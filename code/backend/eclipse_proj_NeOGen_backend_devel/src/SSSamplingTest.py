#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< PACKAGE IMPORTS
#
#------------------< Import python modules
# DEBUG Imports
from logging import getLogger as logging__getLogger
from handler_Debug import Timer
from handler_Debug import Timer2
from handler_Debug import Debug_Location

try:
    from exceptions import WindowsError
except ImportError:
    class WindowsError(OSError): pass
                                            
#from Bio.PopGen.GenePop.EasyController import EasyController as biopython__Easy_Controller
import ctypes
from datetime import datetime, date
import gc
import sys
import os, fnmatch
from subprocess import Popen as subprocess__Popen
from collections import Counter as collections__Counter
from collections import OrderedDict
import csv
import string
import itertools
import copy
import numpy
from copy import deepcopy as copy__deepcopy
import ntpath
import psutil
from os import path as os__path
from os import getcwd as os__getcwd
#from psutil import Process as psutil__Process
from psutil import pid_exists as psutil__pid_exists
from multiprocessing import cpu_count as multiprocessing__cpu_count
from time import sleep as time__sleep
from numpy import random as numpy__random
from random import sample as random__sample
from decimal import Decimal
from operator import gt as operator__gt
from operator import ge as operator__ge
from itertools import starmap as itertools__starmap
from itertools import izip as itertools__izip
                                
#from scipy import stats
# DEBUG Imports
#import objgraph
import pdb
from memory_profiler import profile
#------------------< Import simupop modules
#from simuPOP import *
from simuPOP import utils as simuPOP__utils
import simuPOP as simupop
from simuPOP.sampling import drawRandomSample
#------------------< Import DCB_General modules
from FileHandler import FileHandler
from DatabaseHandler import DatabaseHandler
#------------------< Import SharkSim modules
from AutoVivificationHandler import AutoVivificationHandler
#from SSReplicateHandler import SSReplicateHandler
from SSParameterHandler import SSParameterHandler
from SSErrorHandler import SSErrorOperation
from SSOutputHandler import SSOutputHandler
from SSAnalysisHandler import SSAnalysisHandler
from object_SSConfigSamplingStrategy import object_SSConfigSamplingStrategy
from object_SSReportingCustom_LDNE_1 import object_SSReportingCustom_LDNE_1
from globals_SharkSim import globalsSS
from SSDatabaseHandler import SSDatabaseHandler
from object_SSNe2_Win_DLL import object_SSNe2_Win_DLL
from handler_Biopython import Biopython
from handler_Logging import Logging
#
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< CLASS DEFINITION
gstringModuleName='SSSamplingTest.py'
gstringClassName='SSSamplingOperation'

class SSSamplingTest(object):
    """Handle FileOperation objects"""
    def __enter__(self):
        
        def __init__(self):
            
#             objSSParameters = None
#             
#             return None
            pass
        
        class SSSamplingTestOperation(object):

            str_Current_Col_Index = str(
                                         '0' +
                                         globalsSS.StringDelimiters.static_stringDelimiter_DOT +
                                         '0' +
                                         globalsSS.StringDelimiters.static_stringDelimiter_DOT +
                                         '0' +
                                         globalsSS.StringDelimiters.static_stringDelimiter_DOT +
                                         '0')

            def __init__(self):

                '''
                ------------------
                Initialise class specific variables
                ------------------
                '''                        
                self.objSSParametersLocal = None
                self.objSharkSimOperationLocal = None
                                
                ''' Get all the loggers required for monitoring this object '''
                self.method_Initialise_Monitor_Loggers()

                return None

            def method_Initialise_Monitor_Loggers(self):
                
                ''' 
                ~~~~~~~~~~~~~~~~~~~~~~~~~~
                Get all the loggers required for monitoring this object
                ~~~~~~~~~~~~~~~~~~~~~~~~~~
                '''
                ''' Get Run Display Logger '''
                self.obj_Log_Run_Display = logging__getLogger(globalsSS.Logger_Run_Display.static_Logger_Name__Run_Display)
                           
                ''' Get Default Logger '''
                self.obj_Log_Default_Display = logging__getLogger(globalsSS.Logger_Default_Display.static_Logger_Name__Default_Display)
        
                ''' Get Debug Logger '''
                self.obj_Log_Debug_Display = logging__getLogger(globalsSS.Logger_Debug_Display.static_Logger_Name__Debug_Display)
        
                ''' Get Debug Timer '''
                #self.obj_Log_Debug_Timing = None
                #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                self.obj_Log_Debug_Timing = logging__getLogger(globalsSS.Logger_Debug_Timing.static_Logger_Name__Debug_Timing)
                #pass

                ''' Get Debug AgeNe Logger '''
                self.obj_Log_Debug_AgeNe = None
                if globalsSS.Logger_Debug_AgeNe.bool_Debug_AgeNe:
                    self.obj_Log_Debug_AgeNe = logging__getLogger(globalsSS.Logger_Debug_AgeNe.static_Logger_Name__Debug_AgeNe)
                pass
                                        
                return True
            
            def method_Initialise(self, objSSParameters, objSharkSimOperation=None):
                
                self.objSSParametersLocal = objSSParameters
                self.objSharkSimOperationLocal = objSharkSimOperation
                
                return True

            def method_SplitPopIntoTemporaryVSPs_ByValue_ToUpdateInfoFields(self, pop, intSubPop, boolUpdateInfoField, stringVSPSplitOperator, stringInfoFieldToSplitBy, listVSPSplitValues, listVSPSplitNames, stringInfoFieldToUpdate='', listVSPsToUpdate=[], listUpdateValues=[]):
                
                #Split 
                # 99 is just a dummy number that will not be associated with any individuals
                #this is just to ensure that the final VSPs contain the correct individuals
                if stringVSPSplitOperator == 'cutoff':
                    pop.setVirtualSplitter(simupop.InfoSplitter(stringInfoFieldToSplitBy,
                        cutoff=listVSPSplitValues,
                         names=listVSPSplitNames))
                else:
                    if stringVSPSplitOperator == 'values':
                        pop.setVirtualSplitter(simupop.InfoSplitter(stringInfoFieldToSplitBy,
                            values=listVSPSplitValues,
                             names=listVSPSplitNames))
                
                intUpdateCount = 0
                if boolUpdateInfoField:
                    #Update info fields
                    for intVSP in listVSPsToUpdate:
                        pop.setIndInfo(listUpdateValues[intUpdateCount], stringInfoFieldToUpdate, subPop=(globalsSS.SP_SubPops.static_intSP_SubPop_Primary, intVSP))
                        intUpdateCount += 1
               
                return pop

            def method_SplitLifeStagesInto_AgeInMonths_VSPs_By_AgeInMonths(self, pop, intMaxAge, boolUpdateInfoField):
                 
                pop = self.method_SplitPopIntoTemporaryVSPs_ByValue_ToUpdateInfoFields(pop, globalsSS.SP_SubPops.static_intSP_SubPop_Primary,
                                                                                     boolUpdateInfoField,
                                                                                     stringVSPSplitOperator = 'cutoff',
                                                                                     stringInfoFieldToSplitBy = 'age_in_months',
                                                                                     listVSPSplitValues = [ 
                                                                                                            (intAgeInYears) for intAgeInYears in range(0, intMaxAge*12, 1)
                                                                                                            ],
                                                                                     listVSPSplitNames = [],
                                                                                     stringInfoFieldToUpdate = '',
                                                                                     listVSPsToUpdate = [],
                                                                                     listUpdateValues = [])
                return pop 

            def method_SplitRandomSampleIntoVSP(self, SSpop, listRanges):
                
                
                SSpop.setVirtualSplitter(simupop.RangeSplitter(
                                            ranges=listRanges),
                                                    )

                return SSpop 

            def method_Cohort_Sampling_VSP_And_Sample_Size(self, sspop, odictAgeCohortSampleNumbers):
                
                odictAgeCohortVSPS_And_SampleNumbers = OrderedDict()
                listVSPsToRandomSample = []
                listRandomSampleSizePerVSP = []
                
                #Sample numbers specified are absolute number rather than proportions of each VSP
                for keyAgeInMonths, valueNumToSample in odictAgeCohortSampleNumbers.items():
                    tupVSPToRandomSample = (globalsSS.SP_SubPops.static_intSP_SubPop_Primary, keyAgeInMonths)
                    listVSPsToRandomSample.append(tupVSPToRandomSample)
                    listRandomSampleSizePerVSP.append(int(round(valueNumToSample,0)))
                pass
            
                odictAgeCohortVSPS_And_SampleNumbers[0] = listVSPsToRandomSample
                odictAgeCohortVSPS_And_SampleNumbers[1] = listRandomSampleSizePerVSP

                return odictAgeCohortVSPS_And_SampleNumbers    
                    
            def method_Cohort_Sampling_Specification_Draw_RETIRED(self, pop, objSSParameters, objSharkSimOperation, intRandomSampleNumIndividuals, odictAgeCohortVSPS_And_SampleNumbers):

                listVSPsToRandomSample = []
                listVSPsToRandomSample = odictAgeCohortVSPS_And_SampleNumbers[0]
                listRandomSampleSizePerVSP = []
                listRandomSampleSizePerVSP = odictAgeCohortVSPS_And_SampleNumbers[1]
                #DEBUG_ON
                #simupop.dump(pop)
                #with SSAnalysisHandler() as objSSAnalysisOperation:
                #    strSimupopInfoField = 'age_in_months'
                #    odictCountIndividualsWithInfoField = objSSAnalysisOperation.method_Count_Individuals_By_InfoField(pop, strSimupopInfoField)
                #    print(str(odictCountIndividualsWithInfoField))
                #DEBUG_OFF

                
#                 boolUpdateInfoField = False
#                 intMaxAge = objSSParameters.maxAge
#                 pop_ToSample = self.method_SplitLifeStagesInto_AgeInMonths_VSPs_By_AgeInMonths(pop, intMaxAge, boolUpdateInfoField)
#                 
                #DEBUG_ON
                #simupop.dump(pop_SubSample)
                #intVSPTotal = pop_ToSample.subPopSize()()
                #print('Pop size:' + str(intVSPTotal)) 
                #print('# VSPs:' + str(pop_ToSample.numVirtualSubPop()))
                #boolReportVSPIfEmpty = False
                #with SSAnalysisHandler() as objSSAnalysisOperation:
                #    odictVSPSizes = objSSAnalysisOperation.method_Get_VSP_Sizes(pop_ToSample, boolReportVSPIfEmpty)
                #print('VSPSizes (not inc. 0 size VSPs): ' + str(odictVSPSizes))
                #strSimupopInfoField = 'age_in_months'
                #odictCountIndividualsWithInfoField = objSSAnalysisOperation.method_Count_Individuals_By_InfoField(pop_ToSample, strSimupopInfoField)
                #print('Number per age (Age, Num):' + str(odictCountIndividualsWithInfoField))
                #print('VSPS to sample' + str(listVSPsToRandomSample))
                #print('Sample size per VSP' + str(listRandomSampleSizePerVSP))
                #DEBUG_OFF
                
                #Draw sub sample
                #pop_SubSample = pop_ToSample
                pop_SubSample = drawRandomSample(pop, sizes=listRandomSampleSizePerVSP, subPops=listVSPsToRandomSample)
                pop_SubSample.mergeSubPops()
                listRanges = [[0, intRandomSampleNumIndividuals]]
                
                #Split and report 
                #objSharkSimOperation.method_SplitLifeStagesInto_AgeInMonths_VSPs_By_AgeInMonths(pop_SubSample)
                #pop_SubSample = objSharkSimOperation.pop
                #DEBUG_ON
                #simupop.dump(pop_SubSample)
                #with SSAnalysisHandler() as objSSAnalysisOperation:
                #    odictVSPSizes = objSSAnalysisOperation.method_Get_VSP_Sizes(pop_SubSample, False)
                #print('Pop sub-sample size: ' + str(int(pop_SubSample.subPopSize())))
                #print('Pop sub-sample sizes: ' + str(pop_SubSample.subPopSizes()))
                #print('# VSPs:' + str(pop_SubSample.numVirtualSubPop()))
                #print('#Indivs of each age_in_months: ' + str(odictVSPSizes))
                #DEBUG_OFF
                
                #Create just one VSP from the pop sub-sample
                pop_SubSample = self.method_SplitRandomSampleIntoVSP(pop_SubSample, listRanges)

                #DEBUG_ON
                #simupop.dump(pop_SubSample)
                #with SSAnalysisHandler() as objSSAnalysisOperation:
                #    odictVSPSizes = objSSAnalysisOperation.method_Get_VSP_Sizes(pop_SubSample, False)
                #print('Pop sub-sample size: ' + str(int(pop_SubSample.subPopSize())))
                #print('Pop sub-sample sizes: ' + str(pop_SubSample.subPopSizes()))
                #print('# VSPs:' + str(pop_SubSample.numVirtualSubPop()))
                #print('#Indivs of each age_in_months: ' + str(odictVSPSizes))
                #DEBUG_OFF

                #DEBUG_ON                    
                #simupop.dump(pop_SubSample)
                #DEBUG_OFF
                                
                return pop_SubSample
                
            def method_Cohort_Sampling_Specification_Draw(self, pop_In, intRandomSampleNumIndividuals, odictAgeCohortVSPS_And_SampleNumbers):

                listVSPsToRandomSample = []
                listVSPsToRandomSample = odictAgeCohortVSPS_And_SampleNumbers[0]
                listRandomSampleSizePerVSP = []
                listRandomSampleSizePerVSP = odictAgeCohortVSPS_And_SampleNumbers[1]
                #DEBUG_ON
                #simupop.dump(pop)
                #with SSAnalysisHandler() as objSSAnalysisOperation:
                #    strSimupopInfoField = 'age_in_months'
                #    odictCountIndividualsWithInfoField = objSSAnalysisOperation.method_Count_Individuals_By_InfoField(pop, strSimupopInfoField)
                #    print(str(odictCountIndividualsWithInfoField))
                #DEBUG_OFF

                #DEBUG_ON
                #simupop.dump(pop_SubSample)
                #intVSPTotal = pop_ToSample.subPopSize()()
                #print('Pop size:' + str(intVSPTotal)) 
                #print('# VSPs:' + str(pop_ToSample.numVirtualSubPop()))
                #boolReportVSPIfEmpty = False
                #with SSAnalysisHandler() as objSSAnalysisOperation:
                #    odictVSPSizes = objSSAnalysisOperation.method_Get_VSP_Sizes(pop_ToSample, boolReportVSPIfEmpty)
                #print('VSPSizes (not inc. 0 size VSPs): ' + str(odictVSPSizes))
                #strSimupopInfoField = 'age_in_months'
                #odictCountIndividualsWithInfoField = objSSAnalysisOperation.method_Count_Individuals_By_InfoField(pop_ToSample, strSimupopInfoField)
                #print('Number per age (Age, Num):' + str(odictCountIndividualsWithInfoField))
                #print('VSPS to sample' + str(listVSPsToRandomSample))
                #print('Sample size per VSP' + str(listRandomSampleSizePerVSP))
                #DEBUG_OFF

                bool_No_Strings = False
                for item in listVSPsToRandomSample:
                    bool_No_Strings = not isinstance(item[1], str)
                pass
                if bool_No_Strings:
                    #Draw sub sample
                    pop_SubSample = drawRandomSample(pop_In, sizes=listRandomSampleSizePerVSP, subPops=listVSPsToRandomSample)
                    pop_SubSample.mergeSubPops()
                    listRanges = [[0, intRandomSampleNumIndividuals]]
                else:
                    self.obj_Log_Default_Display.error('simupop.drawRandomSample cannot handle VSP Names only VSP numbers:' + str(listVSPsToRandomSample))
                    raise ValueError('simupop.drawRandomSample cannot handle VSP Names only VSP numbers:' + str(listVSPsToRandomSample))
                pass                         
                #Split and report 
                #objSharkSimOperation.method_SplitLifeStagesInto_AgeInMonths_VSPs_By_AgeInMonths(pop_SubSample)
                #pop_SubSample = objSharkSimOperation.pop
                #DEBUG_ON
                #simupop.dump(pop_SubSample)
                #with SSAnalysisHandler() as objSSAnalysisOperation:
                #    odictVSPSizes = objSSAnalysisOperation.method_Get_VSP_Sizes(pop_SubSample, False)
                #print('Pop sub-sample size: ' + str(int(pop_SubSample.subPopSize())))
                #print('Pop sub-sample sizes: ' + str(pop_SubSample.subPopSizes()))
                #print('# VSPs:' + str(pop_SubSample.numVirtualSubPop()))
                #print('#Indivs of each age_in_months: ' + str(odictVSPSizes))
                #DEBUG_OFF
                
                #Create just one VSP from the pop sub-sample
                pop_SubSample = self.method_SplitRandomSampleIntoVSP(pop_SubSample, listRanges)

                #DEBUG_ON
                #simupop.dump(pop_SubSample)
                #with SSAnalysisHandler() as objSSAnalysisOperation:
                #    odictVSPSizes = objSSAnalysisOperation.method_Get_VSP_Sizes(pop_SubSample, False)
                #print('Pop sub-sample size: ' + str(int(pop_SubSample.subPopSize())))
                #print('Pop sub-sample sizes: ' + str(pop_SubSample.subPopSizes()))
                #print('# VSPs:' + str(pop_SubSample.numVirtualSubPop()))
                #print('#Indivs of each age_in_months: ' + str(odictVSPSizes))
                #DEBUG_OFF

                #DEBUG_ON                    
                #simupop.dump(pop_SubSample)
                #DEBUG_OFF
                                
                return pop_SubSample

            def method_Save_SimuPop_Population(self, pop_In, strSimuPop_Pop_FilePathAndName):

                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass       
            
                bool_Success = False
                strFile_PathAndName = strSimuPop_Pop_FilePathAndName
                
                ''' Prep File system path for save '''
                with FileHandler() as obj_FileOp:
                    bool_Success = obj_FileOp.method_FileSystem_Prep_For_File_Save(strFile_PathAndName, bool_Delete=True)
                pass
            
                if bool_Success:
                    try:
                        pop_In.save(strFile_PathAndName)

                    except (OSError, IOError) as (errno, strerror):
                        bool_Success = False
                        str_Message_Location = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                        self.obj_Log_Default.error(str_Message_Location + "; I/O error({0}): {1}".format(errno, strerror) + '; File: ' + strFile_PathAndName)
                    except:
                        bool_Success = False
                        str_Message_Location = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                        self.obj_Log_Default.error(str_Message_Location + "; Unexpected error: " + str(sys.exc_info()[1]) + '; File: ' + strFile_PathAndName)
                        raise
                    pass 
                pass
            
                #DEBUG_ON
                if globalsSS.Logger_Debug_Display.bool_Debug_Display:
                    str_Message_Location = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                    str_Msg_Prefix = globalsSS.Logger_Debug_Display.static_str_Logger_Message_Prefix
                    self.obj_Log_Debug_Display.debug(str_Msg_Prefix + str_Message_Location)
                    self.obj_Log_Debug_Display.debug(str_Msg_Prefix + 'Simupop Population Saved: ' + strFile_PathAndName)
                    #simupop.dump(pop)
                    #with globalsSS.Pause_Console() as obj_Pause:
                    #    obj_Pause.method_Pause_Console(str_Message_Location)
                pass
                            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    str_Message = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                    t2.Stop(self.obj_Log_Debug_Timing, str_Message, bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass 
                #DEBUG_OFF
               
                return bool_Success
                                
            def method_Load_SimuPop_Population(self, strSimuPop_Pop_FilePathAndName):

                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass    
            
                bool_Success = False
                strFile_PathAndName = strSimuPop_Pop_FilePathAndName
                
                try:
                    pop_Out = None
                    pop_Out = simupop.loadPopulation(strFile_PathAndName)
                    bool_Success = True
                except (OSError, IOError) as (errno, strerror):
                    str_Message_Location = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                    self.obj_Log_Default.error(str_Message_Location + "; I/O error({0}): {1}".format(errno, strerror) + '; File: ' + strFile_PathAndName)
                except:
                    str_Message_Location = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                    self.obj_Log_Default.error(str_Message_Location + "; Unexpected error: " + str(sys.exc_info()[1]) + '; File: ' + strFile_PathAndName)
                    raise
                pass 
                

                #DEBUG_ON
                if globalsSS.Logger_Debug_Display.bool_Debug_Display:
                    str_Message_Location = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                    str_Msg_Prefix = globalsSS.Logger_Debug_Display.static_str_Logger_Message_Prefix
                    self.obj_Log_Debug_Display.debug(str_Msg_Prefix + str_Message_Location)
                    self.obj_Log_Debug_Display.debug(str_Msg_Prefix +'simuPOP Population Imported: ' + strFile_PathAndName)
                    self.obj_Log_Debug_Display.debug(str_Msg_Prefix + 'Imported simuPOP population: ' + str(strSimuPop_Pop_FilePathAndName))
                    self.obj_Log_Debug_Display.debug(str_Msg_Prefix + 'Imported simuPOP population size: ' + str(int(pop_Out.subPopSize())))
                    self.obj_Log_Debug_Display.debug(str_Msg_Prefix + 'Imported simuPOP population VSP sizes: ' + str(int(pop_Out.subPopSize())))
                    #simupop.dump(pop)
                    #with globalsSS.Pause_Console() as obj_Pause:
                    #    obj_Pause.method_Pause_Console(str_Message_Location)
                pass
                            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    str_Message = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                    t2.Stop(self.obj_Log_Debug_Timing, str_Message, bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass 

                
                return pop_Out
                
            def method_Import_Genotypes(self, strFilename_Import):

                pop_genepop = simuPOP__utils.importPopulation(format='GENEPOP', filename=strFilename_Import)
                

                return pop_genepop

            def method_Remove_Loci(self, pop, listLociToRemove):
                
                pop.removeLoci(loci=listLociToRemove)
                
                #DEBUG_ON
                #simupop.dump(pop)
                #DEBUG_OFF
                
                return pop
                
            def method_Export_Genotypes(self, pop, intAlleleAdjust, strFilename_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, tupBoolParams, list_VSPs=[]):

                boolSuccess = False
                
                if bool_Prevent_External_Function_Console_Output:
                    sys.stdout = open(os.devnull, "w")
                
                if len(list_VSPs) > 0:  
                    simuPOP__utils.export(pop, format='GENEPOP', adjust=intAlleleAdjust, output=strFilename_Export, gui=False, subPops=list_VSPs)
                else:   
                    simuPOP__utils.export(pop, format='GENEPOP', adjust=intAlleleAdjust, output=strFilename_Export, gui=False)
                    #simuPOP__utils.export(pop, format='FSTAT', lociNames=list_lociNames, adjust=0, output=strFilename_Export, gui=False)
                pass
            
                if bool_Prevent_External_Function_Console_Output:
                    sys.stdout = sys.__stdout__
                
                if bool_Prevent_Internal_Function_Console_Output == False:
                    with SSOutputHandler() as SSOutputOperation:
                        objOutput=sys.stdout
                        objOutput.write('Exported GP file: ' + strFilename_Export)
                        objOutput.write('\n')
                
                bool_Check_Output_Success = tupBoolParams[0]
                bool_Check_Output_File_Exists = tupBoolParams[1]
                bool_Check_Output_File_Size = tupBoolParams[2]
                
                if bool_Check_Output_Success:
                    if bool_Check_Output_File_Exists:
                        with FileHandler() as objFileOperation:
                            boolSuccess = False
                            boolSuccess = objFileOperation.fileExists(strFilename_Export)
                    if bool_Check_Output_File_Size:
                        with FileHandler() as objFileOperation:
                            boolSuccess = False
                            tupFileStats = objFileOperation.method_Get_File_Stats(strFilename_Export, FileHandler.static_str_FileStat_FileSize_st_size)
                            if tupFileStats[1] > 0:
                                boolSuccess = True
                        pass
                pass
            
                return boolSuccess
                
            def method_Draw_Random_Pop_SubSample(self, pop_In, intSubSample_Size, listVSPsToRandomSample=[]):

                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass  

                bool_Success = False
                
                try:
                    if len(listVSPsToRandomSample) == 0:
                        #Ensure that pop is not sub-divided
                        pop_In.mergeSubPops()
                        #Take the draw
                        pop_SubSample = drawRandomSample(pop_In, sizes=intSubSample_Size)
                    else:
                        #Take the draw
                        bool_No_Strings = False
                        for item in listVSPsToRandomSample:
                            bool_No_Strings = not isinstance(item[1], str)
                        pass
                        if bool_No_Strings:
                            #Draw sub sample
                            pop_SubSample = drawRandomSample(pop_In, sizes=intSubSample_Size, subPops=listVSPsToRandomSample)
                            bool_Success = True 
                        else:
                            self.obj_Log_Default_Display.error('simupop.drawRandomSample cannot handle VSP Names only VSP numbers:' + str(listVSPsToRandomSample))
                            raise ValueError('simupop.drawRandomSample cannot handle VSP Names only VSP numbers:' + str(listVSPsToRandomSample))
                        pass   

                    pass
                except:
                    str_Message_Location = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                    self.obj_Log_Default.error(str_Message_Location + "; Unexpected error: " + str(sys.exc_info()[1]))
                    raise
                pass 
                

                #DEBUG_ON
                if globalsSS.Logger_Debug_Display.bool_Debug_Display:
                    str_Message_Location = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                    str_Msg_Prefix = globalsSS.Logger_Debug_Display.static_str_Logger_Message_Prefix
                    self.obj_Log_Debug_Display.debug(str_Msg_Prefix + str_Message_Location)
                    #simupop.dump(pop)
                    #with globalsSS.Pause_Console() as obj_Pause:
                    #    obj_Pause.method_Pause_Console(str_Message_Location)
                pass
                            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    str_Message = str(self.__class__.__name__) + '.' +  str(sys._getframe().f_code.co_name)
                    t2.Stop(self.obj_Log_Debug_Timing, str_Message, bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass 

                
                return pop_SubSample
            
            def method_SimStat_LDNe_Reporting(self, pop, listVirtualSubPop):
            
                #simupop.stat(pop, effectiveSize=ALL_AVAIL, subPops=ALL_AVAIL, vars=['Ne_LD'])
                simupop.stat(pop, effectiveSize=simupop.ALL_AVAIL, subPops=listVirtualSubPop, vars=['Ne_LD_sp'])
                #pop.dvars()
                return pop

            def method_Pre_Process_External_Program_Ne2Bulk(self, strFilePath_Working):
            
                '''
                Prepares to run an external process
                '''
                
                strFilePath_ProcessUser_Folder = globalsSS.Shared_External_Resources.static_User_Programs_Folder
                strFilePath_ProcessSource_Folder = globalsSS.Shared_External_Resources.static_Win_DOS_Command_Scripts_Ne2Bulk

                strFilePath_ProcessSource = os__path.join(self.objSSParametersLocal.str_App_Run_Path, strFilePath_ProcessUser_Folder, strFilePath_ProcessSource_Folder)
                with FileHandler() as objFileOperation:
                    strFolderPath_Copy_Source = strFilePath_ProcessSource
                    strFolderPath_Copy_Destination = strFilePath_Working
                
                    objFileOperation.method_Copy_Folder_Or_All_Files(strFolderPath_Copy_Source, strFolderPath_Copy_Destination)
                pass
            
                return True

            def func_File_Open_And_Write__Ne_Estimator_Version_To_Use_RETIRE(self, strFilePath_Working):
                
                bool_Success = False
                fileHandle = None
                str_File_Path_And_Name = os__path.join(strFilePath_Working, globalsSS.Shared_External_Resources.static_Win_Parameter_File__Ne_Estimator_Version_Exe)
                
                with FileHandler() as obj_FileOp:
                    
                    ''' Check that files exists - We may need to wait untill it is copied into this location '''
                    
                    fileHandle = obj_FileOp.fileOpen(str_File_Path_And_Name, 'write')
                    
                    if fileHandle != None:
                        bool_Success = True
                    else:
                        with Debug_Location() as obj_DebugLoc:
                            str_Message_Location = obj_DebugLoc.Get_Debug_Location(bool_Short=True)
                        pass
                        str_Message = str_Message_Location + ' >> UNEXPECTED ERROR - File could not be created/opened/written: ' + str(str_File_Path_And_Name)
                        self.obj_Log_Run_Display.error(str_Message)
                        raise ValueError(str_Message)
                    pass 
                
                    if bool_Success:
                        bool_Success = False
                        str_Ne_Estimator_Version = self.objSSParametersLocal.str_Sampling_Strategy_Run_Ne_Estimator_External_Process_Version
                        try:
                            fileHandle.write(str_Ne_Estimator_Version)
                            bool_Success = True
                        except :             
                            with Debug_Location() as obj_DebugLoc:
                                str_Message_Location = obj_DebugLoc.Get_Debug_Location(bool_Short=True)
                            pass
                            str_Message = str_Message_Location + ' >> UNEXPECTED ERROR - File could not be written: ' + str(str_File_Path_And_Name)
                            self.obj_Log_Run_Display.error(str_Message)
                            raise ValueError(str_Message)
                        pass
                    pass
                    
                    ''' Close the file '''
                    bool_Success = obj_FileOp.fileClose(fileHandle)
                    if not bool_Success:
                        with Debug_Location() as obj_DebugLoc:
                            str_Message_Location = obj_DebugLoc.Get_Debug_Location(bool_Short=True)
                        pass
                        str_Message = str_Message_Location + ' >> UNEXPECTED ERROR - File could not be closed: ' + str(str_File_Path_And_Name)
                        self.obj_Log_Run_Display.error(str_Message)
                        raise ValueError(str_Message)
                    pass
                        
                pass
                
                return bool_Success
            
            def func_File_Open_And_Write__Ne_Estimator_Version_To_Use(self):
                
                bool_Success = False
                fileHandle = None
                strFilePath_ProcessUser_Folder = globalsSS.Shared_External_Resources.static_User_Programs_Folder
                strFilePath_ProcessSource_Folder = globalsSS.Shared_External_Resources.static_Win_DOS_Command_Scripts_Ne2Bulk
                strFilePath_ProcessSource = os__path.join(self.objSSParametersLocal.str_App_Run_Path, strFilePath_ProcessUser_Folder, strFilePath_ProcessSource_Folder) 
                
                strFilePath_Working = strFilePath_ProcessSource              
                str_File_Path_And_Name = os__path.join(strFilePath_Working, globalsSS.Shared_External_Resources.static_Win_Parameter_File__Ne_Estimator_Version_Exe)
                
                with FileHandler() as obj_FileOp:
                    
                    ''' Check that files exists - We may need to wait untill it is copied into this location '''

                    if obj_FileOp.fileExists(str_File_Path_And_Name):
                        bool_Success = True
                    else:
                        with SSErrorOperation([]) as obj_SSErrorOp:
                            str_Message_Text = 'Non-existant file: ' + str_File_Path_And_Name
                            int_Stack_Trace_Level = 2
                            obj_SSErrorOp.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text, tup_Args = (self.objSSParametersLocal.str_App_Arg_Output_Base_Path, self.objSSParametersLocal.strUniqueRunID))  
                        pass
                        bool_Success = False 
                        return bool_Success
                    pass

                    if bool_Success:
                        bool_Success = False
                        
                        ''' Write to file '''                    
                        fileHandle = obj_FileOp.fileOpen(str_File_Path_And_Name, 'write')
                    
                        if fileHandle != None:
                            bool_Success = True
                        else:
                            with SSErrorOperation([]) as obj_SSErrorOp:
                                str_Message_Text = 'UNEXPECTED ERROR - File could not be created :'  + str_File_Path_And_Name
                                int_Stack_Trace_Level = 2
                                obj_SSErrorOp.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text, tup_Args = (self.objSSParametersLocal.str_App_Arg_Output_Base_Path, self.objSSParametersLocal.strUniqueRunID))  
                            pass
                            bool_Success = False 
                            return bool_Success
                        pass 
                    pass
                
                    if bool_Success:
                        bool_Success = False
                        str_Ne_Estimator_Version = self.objSSParametersLocal.str_Sampling_Strategy_Run_Ne_Estimator_External_Process_Version
                        try:
                            fileHandle.write(str_Ne_Estimator_Version)
                            bool_Success = True
                        except :             
                            with SSErrorOperation([]) as obj_SSErrorOp:
                                str_Message_Text = 'UNEXPECTED ERROR - File could not be written :'  + str_File_Path_And_Name
                                int_Stack_Trace_Level = 2
                                obj_SSErrorOp.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text, tup_Args = (self.objSSParametersLocal.str_App_Arg_Output_Base_Path, self.objSSParametersLocal.strUniqueRunID))  
                            pass
                            bool_Success = False 
                            return bool_Success
                        pass
                    pass
                    
                    ''' Close the file '''
                    bool_Success = obj_FileOp.fileClose(fileHandle)
                    if not bool_Success:
                        with SSErrorOperation([]) as obj_SSErrorOp:
                            str_Message_Text = 'UNEXPECTED ERROR - File could not be closed :'  + str_File_Path_And_Name
                            int_Stack_Trace_Level = 2
                            obj_SSErrorOp.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text, tup_Args = (self.objSSParametersLocal.str_App_Arg_Output_Base_Path, self.objSSParametersLocal.strUniqueRunID))  
                        pass
                        bool_Success = False 
                        return bool_Success
                    pass
                        
                pass
                
                return bool_Success
                    
            def method_Execute_External_Program_Ne2Bulk(self, strNe2BulkProcessingPCrit, strProcessFilePattern, strFilePath_Working, bool_Prevent_External_Function_Console_Output):
            
                '''
                Runs an external process
                !!!NOTE: Assumes requisite execution and input files are already present
                '''
                if bool_Prevent_External_Function_Console_Output:
                    fh = open(os.devnull, "w")
                else:
                    fh = None
                
                ''' Get original working path '''
                str_Current_Working_Path = os__getcwd()
                
                #Run batch file as subprocess
#                 strFileNameToExecute = 'Get_Filenames_' + strProcessFilePattern +'.bat'
#                 os.chdir(strFilePath_Working)
                strFileNameToExecute = os__path.join(strFilePath_Working, 'Get_Filenames_' + strProcessFilePattern +'.bat')
                os.chdir(strFilePath_Working)
                process_Popen_1 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                #This line ensures that this process completes before proceeding to the next one
                stdout, stderr = process_Popen_1.communicate()

                if strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    
                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PCrit_0_05.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                    
                elif strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:

                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PCrit_0_02.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                    
                elif strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:

                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PCrit_0_01.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                    
                elif strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:

                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PCrit_0_00.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                    
                elif strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:

                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PCrit_NoS.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                    
                elif strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02_PCrit_0_00:

                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PCrit_0_02_PCrit_0_00.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                    
                elif strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02:

                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PCrit_0_05_PCrit_0_02.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                    
                elif strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00:

                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PCrit_0_05_PCrit_0_00.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                    
                elif strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_00:

                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PCrit_0_05_PCrit_0_02_PCrit_0_00.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                elif strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00:

                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                elif strNe2BulkProcessingPCrit == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_10_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00:

                    #Run batch file as subprocess
                    strFileNameToExecute = 'Ne2_common_V3_Bulk_Run_PC_0_10_PC_0_05_PC_0_02_PC_0_01_PC_0_00.bat'
                    strFileNameToExecute = os__path.join(strFilePath_Working, strFileNameToExecute)
                    #os.chdir(strFilePath_Working)
                    process_Popen_2 = subprocess__Popen([strFileNameToExecute], stdout = fh, stderr = fh)
                    #stdout, stderr = process.communicate()
                pass    

                
                ''' Get psutil.Process.  psutil.Popen oject cant be used for as many things '''    
                try:
                    int_Process_PID = process_Popen_2.pid
                    process_Process = psutil.Process(int_Process_PID)
                    obj_Log = self.obj_Log_Debug_Display.debug
                    obj_Log('External process: ' + str(int_Process_PID) + ' is started: ' + str(process_Process.cmdline() if process_Process.is_running() else 0))
                    pass
                except psutil.NoSuchProcess, psutil.AccessDenied:
                    '''process has probably already ended '''
                    pass
                except OSError, exception_Exception:
                    if sys.platform.startswith('win'):
                        if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                            ''' Process has probably finished '''
                        pass
                    pass
                pass


                ''' Change back to previous working folder to close handles on the current one '''
                os.chdir(str_Current_Working_Path)
                
                if bool_Prevent_External_Function_Console_Output:
                    fh.close()
                
                ''' Set the CPU affinity for the process'''
                
                bool_Use_Affinity = True
                if bool_Use_Affinity:
                    int_CPUs = multiprocessing__cpu_count()
                    int_CPUs_To_Keep_Free = 1
                    if int_CPUs > int_CPUs_To_Keep_Free: 
                        int_CPUs_To_Use = int_CPUs - int_CPUs_To_Keep_Free
                        list_CPUs = [x for x in range(0,int_CPUs_To_Use)]                    
                        
                        #psutil_Process = psutil__Process(pidLastSpawnedProcess)    
                        
                        if process_Process.is_running():   
                            try:
                                pidLastSpawnedProcess = process_Process.pid
                                psutil_Process = psutil.Process(psutil__pid_exists(pidLastSpawnedProcess)) 
                                psutil_Process.cpu_affinity(list_CPUs)
                                
                            except psutil.NoSuchProcess, psutil.AccessDenied:
                                '''process has probably already ended '''
                                pass
                            except OSError, exception_Exception:
                                if sys.platform.startswith('win'):
                                    if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                        ''' Process has probably finished '''
                                    pass
                                pass                            
                            pass
                        else:
                            '''process has probably already ended '''
                            pass
                        pass
                    pass
                pass
               
                return process_Process, int_Process_PID

            def method_Execute_External_Program__Ne2Bulk_ReRun_Failed(self, strNe2BulkProcessingPCrit, strProcessFilePattern, strFilePath_Working, bool_Prevent_External_Function_Console_Output):
            
                '''
                Runs an external process
                !!!NOTE: Assumes requisite execution and input files are already present
                '''
                if bool_Prevent_External_Function_Console_Output:
                    fh = open(os.devnull, "w")
                else:
                    fh = None

                strFilePath_ProcessUser_Folder = globalsSS.Shared_External_Resources.static_User_Programs_Folder
                strFilePath_ProcessSource_Folder = globalsSS.Shared_External_Resources.static_Win_DOS_Batch_Program__Ne2Bulk_ReRun_Failed__Path
                #Run batch file as subprocess
                #strPathOfFileToExecute = globalsSS.Shared_External_Resources.static_Win_DOS_Batch_Program__Ne2Bulk_ReRun_Failed__Path
                strPathOfFileToExecute = os__path.join(self.objSSParametersLocal.str_App_Run_Path, strFilePath_ProcessUser_Folder, strFilePath_ProcessSource_Folder)
                strFileNameToExecute = globalsSS.Shared_External_Resources.static_Win_DOS_Batch_Program__Ne2Bulk_ReRun_Failed__Filename
                #strPathAndFileNameToExecute = strPathOfFileToExecute + '\\' + strFileNameToExecute
                strPathAndFileNameToExecute = os__path.join(strPathOfFileToExecute, strFileNameToExecute)
                
                os.chdir(strFilePath_Working)
                process_Popen = subprocess__Popen([strPathAndFileNameToExecute], stdout = fh, stderr = fh)
                #This line ensures that this process completes before proceeding to the next one
                stdout, stderr = process_Popen.communicate()

                ''' Get psutil.Process.  psutil.Popen oject cant be used for as many things '''    
                try:
                    int_Process_PID = process_Popen.pid
                    process_Process = psutil.Process(int_Process_PID)
                except psutil.NoSuchProcess, psutil.AccessDenied:
                    '''process has probably already ended '''
                    pass
                except OSError, exception_Exception:
                    if sys.platform.startswith('win'):
                        if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                            ''' Process has probably finished '''
                        pass
                    pass
                pass

                obj_Log = self.obj_Log_Debug_Display.debug
                obj_Log('External process: ' + str(int_Process_PID) + ' is started: ' + str(process_Process.cmdline() if process_Process.is_running() else 0))
   
                ''' Set the CPU affinity for the process'''
                
                bool_Use_Affinity = True
                if bool_Use_Affinity:
                    int_CPUs = multiprocessing__cpu_count()
                    int_CPUs_To_Keep_Free = 1
                    if int_CPUs > int_CPUs_To_Keep_Free: 
                        int_CPUs_To_Use = int_CPUs - int_CPUs_To_Keep_Free
                        list_CPUs = [x for x in range(0,int_CPUs_To_Use)]                    
                        
                        #psutil_Process = psutil__Process(pidLastSpawnedProcess)    
                        
                        if process_Process.is_running():     
                            try:
                                pidLastSpawnedProcess = process_Process.pid
                                psutil_Process = psutil.Process(psutil__pid_exists(pidLastSpawnedProcess)) 
                                psutil_Process.cpu_affinity(list_CPUs)
                            except psutil.NoSuchProcess, psutil.AccessDenied:
                                '''process has probably already ended '''
                                pass
                            except OSError, exception_Exception:
                                if sys.platform.startswith('win'):
                                    if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                        ''' Process has probably finished '''
                                    pass
                                pass
                            pass
                        else:
                            '''process has probably already ended '''
                            pass 
                        pass
                    pass
                pass
               
                return psutil_Process, int_Process_PID
                                    
            def method_Jackknife_Simulated_Dataset(self, objSSParameters, pop, objSharkSimOperation):
                
                pop_ToSample = pop
                
                bool_Remove_Loci = False
                if bool_Remove_Loci:
                    listLociToRemove = ['42COBS','55CAOB']
                    pop_Locus_Removed = self.method_Remove_Loci(pop_ToSample, listLociToRemove)
                    
                    #Construct loci filename string
                    strLoci = ''
                    for strLocus in listLociToRemove:
                        strLoci += '_' + strLocus[:2]
                    pass   
                 
#                     #Export that pop as a Genepop file
#                     strFilename_Export = strFileName_Import + '_LR_X' + str(strLoci)
#                     strFilenameFull_Export = strFilename_Export + strFileNameSuffix_Import
#                     strFilePathAndNameFull_Export = objSSParameters.outfilePath + strFilenameFull_Export
#                     
#                     bool_Prevent_Internal_Function_Console_Output = False
#                     bool_Prevent_External_Function_Console_Output = False
# 
#                     self.method_Export_Genotypes(pop_Locus_Removed, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output)

#                     with FileHandler() as objFileOperation:
#                         strFolderPath_Copy_Source = strFilePath_Import + 'Ne2_Fresh'
#                         strFolderPath_Copy_Destination = objSSParameters.outfilePath + 'Ne2'
#                         objFileOperation.method_Copy_Folder_Or_All_Files(strFolderPath_Copy_Source, strFolderPath_Copy_Destination)
#                         #Copy input data file to analysis folder
#                         strFilename_Copy = strFilename_Export[:47] + strFileNameSuffix_Import
#                         strFolderPathAndFile_Copy_Destination = strFolderPath_Copy_Destination + '\\' + strFilename_Copy
#                         objFileOperation.method_Copy_Files(strFilePathAndNameFull_Export, strFolderPathAndFile_Copy_Destination)
#                         
#                         #Run batch file as subprocess
#                         strFileNameToExecute = 'Ne2_Standard_Run.bat'
#                         os.chdir(strFolderPath_Copy_Destination)
#                         process = subprocess__Popen([strFileNameToExecute], shell=True)
#                         stdout, stderr = process.communicate()
                pass

                bool_Jackknife_Loci = False
                if bool_Jackknife_Loci:

                    listLoci = ['35COBS','40COBS','48COBS']
                    
#                     with FileHandler() as objFileOperation:
#                         strFolderPath_Copy_Source = strFilePath_Import + 'Ne2Bulk_Fresh'
#                         strFolderPath_Copy_Destination = objSSParameters.outfilePath + 'Ne2Bulk'
#                         objFileOperation.method_Copy_Folder_Or_All_Files(strFolderPath_Copy_Source, strFolderPath_Copy_Destination)
                    
                    for strLocus in listLoci:
                        
                        
                        #Import the same raw data each time
                        #pop_Imported = self.method_Import_Genotypes(strFileNameFull_Import)
                        #pop_Imported = self.method_Import_Genotypes(strFilePathAndNameFull_Export)
                        #Get a pop with the locus removed
                        pop_Locus_Removed = self.method_Remove_Loci(pop_ToSample, [strLocus])
                        #Export that pop as a Genepop file
#                         strFilename_Export = strFileName_Import + '_LR_X_' + '_x_' + str(strLocus[:2])
#                         strFileNameFull_Export = strFolderPath_Copy_Destination + '\\' + strFilename_Export + strFileNameSuffix_Import
#                         
#                         bool_Prevent_Internal_Function_Console_Output = False
#                         bool_Prevent_External_Function_Console_Output = False
# 
#                         self.method_Export_Genotypes(pop_Locus_Removed, strFileNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output)
                        
                    pass

#                     with FileHandler() as objFileOperation:
#                         strFolderPath_Copy_Source = strFilePath_Import + 'Ne2Bulk_Fresh'
#                         strFolderPath_Copy_Destination = objSSParameters.outfilePath + 'Ne2Bulk'
#                         objFileOperation.method_Copy_Folder_Or_All_Files(strFolderPath_Copy_Source, strFolderPath_Copy_Destination)
                        
                    #Run batch file as subprocess
#                     strFileNameToExecute = 'Ne2_Bulk_Run_LR.bat'
#                     os.chdir(strFolderPath_Copy_Destination)
#                     process = subprocess__Popen([strFileNameToExecute], shell=True)
#                     stdout, stderr = process.communicate()

                pass    
                #DEBUG_ON    
                #with SSOutputHandler() as SSOutputOperation:
                #    listOutputDestinations = ['console']
                #    SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'SimTemporalProcessingSummaryInfo', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                #    SSOutputOperation.method_Pause_Console()
                #pass
                #DEBUG_OFF
            
                bool_SubSample_Pop = True
                if bool_SubSample_Pop:
                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', objSSParameters.outputFileNameSummaryLogAllBatches]
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Simulated Jackknife - Random Pop Sampling', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                    #LOGGING
                    
                    '''
                    Split the population into age_in_months VSPs
                    '''
                    boolUpdateInfoField = False
                    intMaxAge = objSSParameters.maxAge
                    pop_ToSample = self.method_SplitLifeStagesInto_AgeInMonths_VSPs_By_AgeInMonths(pop_ToSample, intMaxAge, boolUpdateInfoField)
                    #Get the numbers of individuals per age chort VSP
                    with SSAnalysisHandler() as objSSAnalysisOperation:
                        odictVSPSizes = objSSAnalysisOperation.method_Get_VSP_Sizes(pop_ToSample, False)
                        #LOGGING
                        stringMessage = '>VSP & Sizes (not inc. 0 size VSPs): ' + str(odictVSPSizes) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        listVSPSizes = []
                        for valueTupleVSPSize in odictVSPSizes.items():
                            listVSPSizes.append(int(valueTupleVSPSize[1]))
                        stringMessage = '>VSPSizes (not inc. 0 size VSPs): ' + str(listVSPSizes) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)

                        #LOGGING                    
                    '''
                    Specify the required sampling regime
                    '''
                    #Sampling by PROPRTION applyed per cohort relative to its size across whole population
                    #10% of the population but taking each cohort sample relative to the size of the cohort
                    boolSampleSizeIsCohortAbsoluteRate = False
                    if boolSampleSizeIsCohortAbsoluteRate:                      
                        boolCohortDependentSample = True
                        
                        #floatPopProportionToSample = 0.10
                        #floatPopProportionToSample = 0.05
                        #floatPopProportionToSample = 0.03
                        #floatPopProportionToSample = 0.02
                        floatPopProportionToSample = 0.01
                        #floatPopProportionToSample = 0.005
                        
                        odictAgeCohortSampleNumbers = odictVSPSizes
                        odictAgeCohortSampleNumbers_Adjusted = objSSAnalysisOperation.method_Apply_Absolute_Rate_To_Number_Distribution(floatPopProportionToSample, odictAgeCohortSampleNumbers, True, 0)

                    pass
                
                    #Sampling by absolute number per VSP
                    boolSampleSizeIsCohortAbsoluteNumber = False
                    if boolSampleSizeIsCohortAbsoluteNumber:
                        boolCohortDependentSample = True
                        
                        
                        odictAgeCohortSampleNumbers = OrderedDict([(0,6),(12,16),(24,14),(36,14),(48,6),(60,3),(72,2),(84,0),(96,8),(108,12),(120,17),(132,27),(144,21),(156,47),(168,42),(180,58),(192,38),(204,28),(216,22),(228,14),(240,18),(252,6),(264,5),(276,0),(288,0),(300,2),(312,1),(324,1),(336,0)])
                        
                        #Embryo / Neonate only
#                         odictAgeCohortSampleNumbers = OrderedDict([(0,7),(12,19),(24,17),(36,17),(48,7),(60,4),(72,2),(96,4),(108,11),(120,16),(132,32),(144,25),(156,56),(168,50),(180,67),(192,46),(204,29),(216,22),(228,13),(240,17),(252,7),(264,6),(276,0),(288,0),(300,1),(312,0),(324,1),(336,0),(348,0),(360,0)])
#                         odictAgeCohortSampleNumbers = OrderedDict([(0,1343),(12,0),(24,0),(36,0),(48,0),(60,0),(72,0),(96,0),(108,0),(120,0),(132,0),(144,0),(156,0),(168,0),(180,0),(192,0),(204,0),(216,0),(228,0),(240,0),(252,0),(264,0),(276,0),(288,0),(300,0),(312,0),(324,0),(336,0),(348,0),(360,0)])
#                         odictAgeCohortSampleNumbers = OrderedDict([(0,2686),(12,0),(24,0),(36,0),(48,0),(60,0),(72,0),(96,0),(108,0),(120,0),(132,0),(144,0),(156,0),(168,0),(180,0),(192,0),(204,0),(216,0),(228,0),(240,0),(252,0),(264,0),(276,0),(288,0),(300,0),(312,0),(324,0),(336,0),(348,0),(360,0)])
#                         odictAgeCohortSampleNumbers = OrderedDict([(0,5372),(12,0),(24,0),(36,0),(48,0),(60,0),(72,0),(96,0),(108,0),(120,0),(132,0),(144,0),(156,0),(168,0),(180,0),(192,0),(204,0),(216,0),(228,0),(240,0),(252,0),(264,0),(276,0),(288,0),(300,0),(312,0),(324,0),(336,0),(348,0),(360,0)])
#                         odictAgeCohortSampleNumbers = OrderedDict([(0,10744),(12,0),(24,0),(36,0),(48,0),(60,0),(72,0),(96,0),(108,0),(120,0),(132,0),(144,0),(156,0),(168,0),(180,0),(192,0),(204,0),(216,0),(228,0),(240,0),(252,0),(264,0),(276,0),(288,0),(300,0),(312,0),(324,0),(336,0),(348,0),(360,0)])
                    pass
                
                    #Sampling by PROPRTION per VSP
                    boolSampleSizeIsCohortRateDist = False
                    if boolSampleSizeIsCohortRateDist:
                        boolCohortDependentSample = True

                        boolCAPL_FISHED_cohort_proportions = True
                        if boolCAPL_FISHED_cohort_proportions:
                        
                            #CAPL real catch cohort proportions
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.015267176),(12,0.040712468),(24,0.03562341),(36,0.03562341),(48,0.015267176),(60,0.007633588),(72,0.005089059),(84,0),(96,0.007633588),(108,0.022900763),(120,0.03307888),(132,0.066157761),(144,0.053435115),(156,0.117048346),(168,0.1043257),(180,0.139949109),(192,0.096692112),(204,0.061068702),(216,0.045801527),(228,0.027989822),(240,0.03562341),(252,0.015267176),(264,0.012722646),(276,0),(288,0),(300,0.002544529),(312,0),(324,0.002544529),(336,0),(348,0),(360,0)])
                        pass
                    
                        boolCAPL_random_sampling_MATURE_cohort_proportions = False
                        if boolCAPL_random_sampling_MATURE_cohort_proportions:
    
                            #CAPL random sampling MATURE cohort proportions
                            #Sample from:
                            #minMating age = 16*12 = 192
                            #To:
                            #maxAge = 31*12 = 372
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.0),(12,0.0),(24,0.0),(36,0.0),(48,0.0),(60,0.0),(72,0.0),(84,0.0), (96,0.0),(108,0.0),(120,0.0),(132,0.0),(144,0.0),(156,0.0),(168,0.0),(180,0.0),(192,0.0), \
                                                                       (204,0.0714),(216,0.0714),(228,0.0714),(240,0.0714),(252,0.0714),(264,0.0714),(276,0.0714),(288,0.0714),(300,0.0714),(312,0.0714),(324,0.0714),(324,0.0714),(336,0.0714),(348,0.0714),(360,0.0714)])
                        pass
                    
                        boolCAPL_random_sampling_ALL_cohort_proportions = False
                        if boolCAPL_random_sampling_ALL_cohort_proportions:
                            #CAPL random sampling ALL cohort proportions
                            #Sample from:
                            #embryo age = 0 months
                            #To:
                            #maxAge = 31*12 = 372
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.0323),\
                                                                       (12,0.0323),(24,0.0323),(36,0.0323),(48,0.0323),(60,0.0323),(72,0.0323),(84,0.0323), (96,0.0323),(108,0.0323),(120,0.0323),(132,0.0323),(144,0.0323),(156,0.0323),(168,0.0323),(180,0.0323),(192,0.0323), \
                                                                       (204,0.0323),(216,0.0323),(228,0.0323),(240,0.0323),(252,0.0323),(264,0.0323),(276,0.0323),(288,0.0323),(300,0.0323),(312,0.0323),(324,0.0323),(324,0.0323),(336,0.0323),(348,0.0323),(360,0.0323)])
                        pass

                        boolCAPL_random_sampling_ALL_cohort_proportions_X_NEONATE = False
                        if boolCAPL_random_sampling_ALL_cohort_proportions_X_NEONATE:
                            #CAPL random sampling ALL cohort proportions X NEONATE
                            #Sample from:
                            #Sub-adult age = 12 months
                            #To:
                            #maxAge = 31*12 = 372
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.0),\
                                                                       (12,0.0333),(24,0.0333),(36,0.0333),(48,0.0333),(60,0.0333),(72,0.0333),(84,0.0333), (96,0.0333),(108,0.0333),(120,0.0333),(132,0.0333),(144,0.0333),(156,0.0333),(168,0.0333),(180,0.0333),(192,0.0333), \
                                                                       (204,0.0333),(216,0.0333),(228,0.0333),(240,0.0333),(252,0.0333),(264,0.0333),(276,0.0333),(288,0.0333),(300,0.0333),(312,0.0333),(324,0.0333),(324,0.0333),(336,0.0333),(348,0.0333),(360,0.0333)])
                        pass

                        boolCAPL_random_sampling_NEONATE = False
                        if boolCAPL_random_sampling_NEONATE:
                            #CAPL random sampling NEONATE
                            #Sample from:
                            #embryo age = 0 months
                            odictAgeCohortSampleNumbers = OrderedDict([(0,1.0000),\
                                                                       (12,0.0000),(24,0.0000),(36,0.0000),(48,0.0000),(60,0.0000),(72,0.0000),(84,0.0000), (96,0.0000),(108,0.0000),(120,0.0000),(132,0.0000),(144,0.0000),(156,0.0000),(168,0.0000),(180,0.0000),(192,0.0000), \
                                                                       (204,0.0000),(216,0.0000),(228,0.0000),(240,0.0000),(252,0.0000),(264,0.0000),(276,0.0000),(288,0.0000),(300,0.0000),(312,0.0000),(324,0.0000),(324,0.0000),(336,0.0000),(348,0.0000),(360,0.0000)])
                        pass
                    pass
                 
                    #Get total poulation size
                    intPopSize = pop_ToSample.subPopSize()

                    boolSampleSizeIsNonCohortRandom = True
                    if boolSampleSizeIsNonCohortRandom:
                        boolCohortDependentSample = False
                        
                        #floatPopProportionToSample = 0.10
                        floatPopProportionToSample = 0.05
                        #floatPopProportionToSample = 0.045
                        #floatPopProportionToSample = 0.040
                        #floatPopProportionToSample = 0.035
                        #floatPopProportionToSample = 0.03
                        #floatPopProportionToSample = 0.025
                        #floatPopProportionToSample = 0.02
                        #floatPopProportionToSample = 0.015
                        #floatPopProportionToSample = 0.01
                        #floatPopProportionToSample = 0.005
   
                        intRandomSampleNumIndividuals = int(round(floatPopProportionToSample * intPopSize, 0))
                    pass


                    if boolCohortDependentSample:
                        '''
                        Adjust age_in_month value to match VSP numbers in the population
                        '''                    
                        if boolSampleSizeIsCohortAbsoluteNumber or boolSampleSizeIsCohortRateDist:
                            #Adjust the VSP number to match the current ages in the pop
                            intVSP_ID_Adjustment = 2
                            odictAgeCohortSampleNumbers_Adjusted = OrderedDict()
                            for keyVSP, valueNumToSample in odictAgeCohortSampleNumbers.items():
                                odictAgeCohortSampleNumbers_Adjusted[keyVSP+intVSP_ID_Adjustment] = valueNumToSample
                            pass

                            if boolSampleSizeIsCohortRateDist:  
                                #Convert the rates to actual numbers of individuals
                                odictAgeCohortSampleNumbers_Adjusted = objSSAnalysisOperation.method_Apply_Rate_Distribution_To_Number_Distribution(odictAgeCohortSampleNumbers_Adjusted, odictVSPSizes, True, 0)
                                if odictAgeCohortSampleNumbers_Adjusted == None:
                                    return True
                        '''
                        Prep the sampling specification for processing
                        '''
                        #Get a list of the VSPs to sample and a separate list of the sample size to take per VSP
                        odictAgeCohortVSPS_And_SampleNumbers = self.method_Cohort_Sampling_VSP_And_Sample_Size(pop_ToSample, odictAgeCohortSampleNumbers_Adjusted)

                
                        '''
                        Cohort dependent logging
                        '''
                        #LOGGING
                        listOutputDestinations = ['console', objSSParameters.outputFileNameSummaryLogAllBatches]
                        stringMessage = '>Cohort Age Sample Specification: ' + str(odictAgeCohortSampleNumbers_Adjusted) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        stringMessage = '>Cohort Age Sample Spec Adjusted: ' + str(odictAgeCohortSampleNumbers_Adjusted) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        stringMessage = '>Cohort Age Sampling VSPs : ' + str(odictAgeCohortVSPS_And_SampleNumbers[0]) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        stringMessage = '>Cohort Age Sampling Numbers : ' + str(odictAgeCohortVSPS_And_SampleNumbers[1]) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        intRandomSampleNumIndividuals = sum(odictAgeCohortVSPS_And_SampleNumbers[1])
                        stringMessage = '>Cohort Age Sampling Total : ' + str(intRandomSampleNumIndividuals) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        #LOGGING
                    
                    pass

                    '''
                    Specify the number of random samples
                    '''
                    intRandomSamplesToTake = 1000
                    
                    #LOGGING
                    if boolSampleSizeIsCohortAbsoluteRate == False or boolSampleSizeIsNonCohortRandom == False:
                        floatPopProportionToSample = round(float(intRandomSampleNumIndividuals) / float(intPopSize), 3)
                    pass
                    listOutputDestinations = ['console', objSSParameters.outputFileNameSummaryLogAllBatches]
                    stringMessage = '>Randomly sample: ' + str(intRandomSamplesToTake) + '; Population proportion: ' + str(floatPopProportionToSample) + ' of ' + str(intPopSize) + ' = ' + str(intRandomSampleNumIndividuals) + ' individuals' +'\n'
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                
                    '''
                    Repeatedly sub-sample
                    '''
                    intFileOrder = 0
                    for intRandomLDneSample in  range(0, intRandomSamplesToTake):
                        
                        #LOGGING
                        if boolSampleSizeIsCohortAbsoluteRate == False or boolSampleSizeIsNonCohortRandom == False:
                            floatPopProportionToSample = round(float(intRandomSampleNumIndividuals) / float(intPopSize), 3)
                        pass
                        listOutputDestinations = ['console', objSSParameters.outputFileNameSummaryLogAllBatches]
                        stringMessage = '>Random sample: ' + str(intRandomLDneSample) + ' of ' + str(intRandomSamplesToTake) + '; Population proportion: ' + str(floatPopProportionToSample) + ' of ' + str(intPopSize) + ' = ' + str(intRandomSampleNumIndividuals) + ' individuals' +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #LOGGING
                        '''
                        Take the sample
                        '''
                        if boolCohortDependentSample:
                            pop_SubSample = self.method_Cohort_Sampling_Specification_Draw(pop_ToSample, objSSParameters, objSharkSimOperation, intRandomSampleNumIndividuals, odictAgeCohortVSPS_And_SampleNumbers)
                        else:
                            pop_SubSample = self.method_Draw_Random_Pop_SubSample(pop_ToSample, intRandomSampleNumIndividuals)
                            
                        '''
                        Report LDNe
                        '''
                        bool_Report_Ne = True
                        if bool_Report_Ne:
                            if boolCohortDependentSample:
                                listVSPsToReport = [(0, 0)]
                            else:
                                listVSPsToReport = [0]
                            pass
                        
                            pop_SubSample = self.method_SimStat_LDNe_Reporting(pop_SubSample, listVSPsToReport)
 
                            if boolCohortDependentSample:
                                listVSPsToReport = [0, 0]
                            else:
                                listVSPsToReport = [0]
                            pass
                                                 
                            strPrefixMessage = 'Sub-sample ' + str(intRandomLDneSample) + ' of ' + str(intRandomSamplesToTake) + ' : '
                            listLDNePCritOutput=[0.05]
                            #listLDNePCritOutput=[0.05,0.02,0.01,0]
                            self.method_Calculate_And_Output_LDNE_To_Console(pop_SubSample, listVSPsToReport, listLDNePCritOutput, listOutputDestinations, strPrefixMessage)
                            
                            self.method_Calculate_And_Output_LDNE_To_File(self.objSSParametersLocal, pop_SubSample, listVSPsToReport)

                            boolExportJacknifeGenpopFiles = False
                            if boolExportJacknifeGenpopFiles:
                                strFileNameSuffix_Export = '.gp_gspy'
                                strFileName_Export = 'Sampling_' + str(floatPopProportionToSample) + '_of_N'
                                strFileNameCode_Export = 'SJKS'
                                strFileNameCount_Export = str(intRandomLDneSample)
                                intFileOrder += 1
                                #strFilename_Export = strFileName_Export + '_' + strFileNameCode_Export + '_' + str(intFileOrder)
                                #strFilePathAndNameFull_Export = self.objSSParametersLocal.outfilePath + self.objSSParametersLocal.strFileNameProgramPrefix + strFilename_Export + strFileNameCount_Export + strFileNameSuffix_Export
                                #strFilename_Export = strFileName_Export + '_' + strFileNameCode_Export + '_' + strFileNameCount_Export + 'A' + strFileNameSuffix_Export
                                strFilename_Export = strFileName_Export + '_' + strFileNameCode_Export + '_' + str(intFileOrder) + '_' + strFileNameCount_Export + strFileNameSuffix_Export
                                strFilePathAndNameFull_Export = self.objSSParametersLocal.outfilePath + self.objSSParametersLocal.strFileNameProgramPrefix + strFilename_Export                         

                                '''
                                IMPORTANT - Allele adjust means the difference between an allele and missing data
                                if your data has zeros as missing data - set this to zero
                                if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                                '''
                                intAlleleAdjust = 1
                                bool_Prevent_Internal_Function_Console_Output = True
                                bool_Prevent_External_Function_Console_Output = True
                                
                                self.method_Export_Genotypes(pop_SubSample, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output)
                                intFileOrder += 1
                        '''
                        Jackknife repeatedly on a single LDNe subsample
                        '''
                        bool_Jackknife_Samples = False
                        if bool_Jackknife_Samples:
                            intRandomJackknifeSamplesToTake = 500
                            
                            boolJackknifeProportion = False
                            if boolJackknifeProportion:
                                floatProportionOfIndividualsToExcludeFromJackknifeSample = 0.0100
                                intNumGenotypesToSample = intRandomSampleNumIndividuals - int(round((intRandomSampleNumIndividuals * floatProportionOfIndividualsToExcludeFromJackknifeSample),0))
                            pass
                        
                            boolJackknifeAbsoluteNumber = True
                            if boolJackknifeAbsoluteNumber:
                                intNumberOfIndividualsToExclude = 1
                                intNumGenotypesToSample = intRandomSampleNumIndividuals - intNumberOfIndividualsToExclude
                                floatProportionOfIndividualsToExcludeFromJackknifeSample = round(float(intNumberOfIndividualsToExclude) / float(intRandomSampleNumIndividuals),4) 
                            pass
                            
                            #LOGGING
                            listOutputDestinations = ['console', objSSParameters.outputFileNameSummaryLogAllBatches]
                            stringMessage = '>Randomly Jackknife ' + str(intRandomJackknifeSamplesToTake) + ' times; Excluding : ' + str(floatProportionOfIndividualsToExcludeFromJackknifeSample) + ' of ' + str(intRandomSampleNumIndividuals) + ' = ' + str(intNumGenotypesToSample) + ' individuals' +'\n'
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #LOGGING
                            
                            for intRandomJackknifeLDneSample in  range(0, intRandomJackknifeSamplesToTake):

                                pop_JackknifeSample = self.method_Draw_Random_Pop_SubSample(pop_SubSample, intNumGenotypesToSample)
             
                                #DEBUG_ON                    
                                #simupop.dump(pop_JackknifeSample)
                                #DEBUG_OFF
                                bool_Report_Ne = True
                                if bool_Report_Ne:
                                    if boolCohortDependentSample:
                                        listVSPsToReport = [(0, 0)]
                                    else:
                                        listVSPsToReport = [0]
                                    pass
                                    
                                    pop_JackknifeSample = self.method_SimStat_LDNe_Reporting(pop_JackknifeSample, listVSPsToReport)

                                    if boolCohortDependentSample:
                                        listVSPsToReport = [0, 0]
                                    else:
                                        listVSPsToReport = [0]
                                    pass
                                    
                                    strPrefixMessage = 'Jackknife sample ' + str(intRandomJackknifeLDneSample) + ' of ' + str(intRandomJackknifeSamplesToTake) + ' : '
                                    #listLDNePCritOutput=[0.0,0.05,0.02,0.01]
                                    listLDNePCritOutput=[0.05]
                                    self.method_Calculate_And_Output_LDNE_To_Console(pop_JackknifeSample, listVSPsToReport, listLDNePCritOutput, listOutputDestinations, strPrefixMessage)
                                    
                                    self.method_Calculate_And_Output_LDNE_To_File(self.objSSParametersLocal, pop_JackknifeSample, listVSPsToReport)

                                    boolExportJacknifeGenpopFiles = False
                                    if boolExportJacknifeGenpopFiles:
                                        strFileNameSuffix_Export = '.gp_gspy'
                                        strFileName_Export = 'Sampling_' + str(floatPopProportionToSample) + '_of_N'
                                        strFileNameCode_Export = 'SJKS'
                                        strFileNameCount_Export = str(intRandomJackknifeLDneSample)
                                        strFilename_Export = strFileName_Export + '_' + strFileNameCode_Export + '_' + str(intFileOrder) + '_' + strFileNameCount_Export + strFileNameSuffix_Export
                                        #strFilename_Export = strFileName_Export + '_' + strFileNameCode_Export + '_' + strFileNameCount_Export + 'B' + strFileNameSuffix_Export
                                        strFilePathAndNameFull_Export = self.objSSParametersLocal.outfilePath + self.objSSParametersLocal.strFileNameProgramPrefix + strFilename_Export

                                        '''
                                        IMPORTANT - Allele adjust means the difference between an allele and missing data
                                        if your data has zeros as missing data - set this to zero
                                        if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                                        '''
                                        intAlleleAdjust = 1
                                        bool_Prevent_Internal_Function_Console_Output = True
                                        bool_Prevent_External_Function_Console_Output = True
                                        
                                        self.method_Export_Genotypes(pop_JackknifeSample, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output)
                                pass
                            pass #For loop 2
                        pass
                    pass #For loop 1

                    boolPrepNe2Bulk = False
                    if boolPrepNe2Bulk:
                    
                        #Copy input data file to analysis folder
                        #strFilename_Copy = strFilename_Export[:47] + strFileNameSuffix_Import
                        #strFilename_Copy = strFilename_Export[:47] + strFileNameSuffix_Export
                        strFileNamePattern_Copy = '*' + strFileNameCode_Export + '*' + strFileNameSuffix_Export
                        strFilePath_WorkingFolder = self.objSSParametersLocal.outfilePath + 'Ne2Bulk\\'
                        #strFolderPathAndFile_Copy_Destination = strFilePath_WorkingFolder + strFilename_Copy
                        strFolderPathAndFile_Copy_Destination = strFilePath_WorkingFolder
                        strProcessFilePattern = strFileNameCode_Export
    
                        #Put executable files in place
                        self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_WorkingFolder)
                        
                        #Copy input files to the execution working folder
                        with FileHandler() as objFileOperation:
                            if objFileOperation.method_Path_Exists(strFilePath_WorkingFolder) == False:
                                objFileOperation.method_Create_Path(strFilePath_WorkingFolder)
                            pass
                        
                            objFileOperation.method_Copy_Files_By_Pattern(self.objSSParametersLocal.outfilePath, strFolderPathAndFile_Copy_Destination, strFileNamePattern_Copy)

                    boolExecuteNe2Bulk = False
                    if boolExecuteNe2Bulk:

                        #LOGGING
                        #with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', objSSParameters.outputFileNameSummaryLogAllBatches]
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Simulated Jackknife - Running External Ne2Bulk Process', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        #LOGGING
                    

                        #Execute external program
                        bool_Prevent_External_Function_Console_Output = True
                        self.method_Execute_External_Program_Ne2Bulk(strProcessFilePattern, strFilePath_WorkingFolder, bool_Prevent_External_Function_Console_Output)

                        #LOGGING
                        #with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', objSSParameters.outputFileNameSummaryLogAllBatches]
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Simulated Jackknife - Running External Ne2Bulk Process', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        #LOGGING                    
                pass
                                
                return True

            def method_Output_Pop_Sample_To_GENEPOP_File_Locus_Combo_Jackknife_LCJK(self, pop_In, intAlleleAdjust, strFilenamePrefix, strFilenameSuFfix):

                boolSuccess = False
                
                '''
                Output  pop sample to GENEPOP File
                '''
                strFileName_ExportPrefix = strFilenamePrefix
                strFileNameCode_Export = 'LCJK'
                strFileNameExtension_Export = '.gp_gspy'
                strFileName_ExportSuffix = strFilenameSuFfix
                
                strFilename_Export = strFileName_ExportPrefix + '_' + strFileNameCode_Export + '_' + strFileName_ExportSuffix + strFileNameExtension_Export
                
                strFilePathAndNameFull_Export = self.objSSParametersLocal.outfilePath + self.objSSParametersLocal.strFileNameProgramPrefix + '_'+ strFilename_Export                         
            
                '''
                IMPORTANT - Allele adjust means the difference between an allele and missing data
                if your data has zeros as missing data - set this to zero
                if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                '''
                bool_Prevent_Internal_Function_Console_Output = True
                bool_Prevent_External_Function_Console_Output = True
                
                boolSuccess = self.method_Export_Genotypes(pop_In, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))

                if boolSuccess == False:
                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        #listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        stringMessage = '!!!ERROR - File create failed ERROR!!!; File: ' + strFilename_Export
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        
                        #DEBUG_ON                    
                        simupop.dump(pop_In)
                        #DEBUG_OFF

                        objSSOutputOperation.method_Pause_Console()
                    #LOGGING
                pass    
                    
                    
                #LOGGING
                with SSOutputHandler() as objSSOutputOperation:
                    #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    stringMessage = '>GENEPOP file exported: ' + strFilename_Export
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #objSSOutputOperation.method_Pause_Console()
                #LOGGING

                pass
            
                return boolSuccess

            '''
            Sample simulated population
            '''                        
            def method_SubSample_Simulated_Dataset(self, pop_In, intSamplingMethod, dictSamplingParams, listLociToRemove, intRandomSamplesToTake = 1, intRandomLDneSample = 1, dictResults={}, str_Stats_Category = '', int_Current_Replicate = 1):
                
                pop_ToSample = pop_In
                
                bool_SubSample_Pop = True
                if bool_SubSample_Pop:
                    
                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Random Pop Sampling', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                    #LOGGING
                    
                    int_VSP_Split_Method = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod]
                    if int_VSP_Split_Method == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths:
                        '''
                        Split the population into age_in_months VSPs
                        '''
                        boolUpdateInfoField = False
                        intMaxAge = self.objSSParametersLocal.maxAge
                        pop_ToSample = self.method_SplitLifeStagesInto_AgeInMonths_VSPs_By_AgeInMonths(pop_ToSample, intMaxAge, boolUpdateInfoField)
                        #Get the numbers of individuals per age chort VSP
                        with SSAnalysisHandler() as obj_Analysis:
                            #odictSourceVSPSizes = obj_Analysis.method_Get_VSP_Sizes(pop_ToSample, False)
                            odictSourceVSPSizes = obj_Analysis.method_Get_VSP_Sizes(pop_ToSample, True)
                            #LOGGING
                            stringMessage = '>VSP & Sizes (not inc. 0 size VSPs): ' + str(odictSourceVSPSizes) +'\n'
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
    #                         listVSPSizes = []
    #                         for valueTupleVSPSize in odictSourceVSPSizes.items():
    #                             listVSPSizes.append(int(valueTupleVSPSize[1]))
    #                         stringMessage = '>VSPSizes (not inc. 0 size VSPs): ' + str(listVSPSizes) +'\n'
    #                         objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
    
                            strSourceVSPAgesAndSizes = ''
                            for key, value in odictSourceVSPSizes.items():
                                strSourceVSPAgesAndSizes += str(key) + globalsSS.StringDelimiters.static_stringDelimiter_SPACE + globalsSS.StringDelimiters.static_stringDelimiter_COMMA + globalsSS.StringDelimiters.static_stringDelimiter_SPACE + str(int(value)) + globalsSS.StringDelimiters.static_stringDelimiter_COMMA + globalsSS.StringDelimiters.static_stringDelimiter_SPACE
    
                            #dictResults['Source_VSP_Ages_And_Sizes'] = strSourceVSPAgesAndSizes[:-2]
                            bool_Log_Empty_VSPS = False
                            if bool_Log_Empty_VSPS:
                                odictSourceVSPSizes_For_Log = OrderedDict([(x,y) for x,y in odictSourceVSPSizes.items()])
                            else:
                                odictSourceVSPSizes_For_Log = OrderedDict([(x,y) for x,y in odictSourceVSPSizes.items() if y > 0 ])
                            pass
                            if globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates not in dictResults[str_Stats_Category].keys():
                                #DEBUG_ON
                                #dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates] = OrderedDict([(int_Current_Replicate, OrderedDict([('Source_VSP_Ages_And_Sizes_CSV',strSourceVSPAgesAndSizes[:-2])]))])
                                #DEBUG_OFF
                                dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates] = OrderedDict([(int_Current_Replicate, OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_VSP_Ages_And_Sizes, odictSourceVSPSizes_For_Log)]))])
                            else:
                                #DEBUG_ON
                                #dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][int_Current_Replicate] = OrderedDict([('Source_VSP_Ages_And_Sizes_CSV',strSourceVSPAgesAndSizes[:-2])])
                                #DEBUG_OFF
                                dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][int_Current_Replicate] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_VSP_Ages_And_Sizes, odictSourceVSPSizes_For_Log)])
                            pass
                            #LOGGING 
                    elif int_VSP_Split_Method == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass:
                        with SSAnalysisHandler() as obj_Analysis: 
                            pop_ToSample = obj_Analysis.method_SplitLifeStagesIntoVSPs_By_AgeClass(pop_ToSample)

                            boolUpdateInfoField = False
                            intMaxAge = self.objSSParametersLocal.maxAge
                            pop_ToSample_By_AgeInMonths = pop_ToSample.clone()
                            pop_ToSample_By_AgeInMonths = self.method_SplitLifeStagesInto_AgeInMonths_VSPs_By_AgeInMonths(pop_ToSample_By_AgeInMonths, intMaxAge, boolUpdateInfoField)
                            
                            #odictSourceVSPSizes = obj_Analysis.method_Get_VSP_Sizes(pop_ToSample_By_AgeInMonths, False)
                            odictSourceVSPSizes = obj_Analysis.method_Get_VSP_Sizes(pop_ToSample_By_AgeInMonths, True)
                            #LOGGING
                            stringMessage = '>VSP & Sizes (not inc. 0 size VSPs): ' + str(odictSourceVSPSizes) +'\n'
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                            
                            #dictResults['Source_VSP_Ages_And_Sizes'] = strSourceVSPAgesAndSizes[:-2]
                            bool_Log_Empty_VSPS = False
                            if bool_Log_Empty_VSPS:
                                odictSourceVSPSizes_For_Log = OrderedDict([(x,y) for x,y in odictSourceVSPSizes.items()])
                            else:
                                odictSourceVSPSizes_For_Log = OrderedDict([(x,y) for x,y in odictSourceVSPSizes.items() if y > 0 ])
                            pass
                            if globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates not in dictResults[str_Stats_Category].keys():
                                #DEBUG_ON
                                #dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates] = OrderedDict([(int_Current_Replicate, OrderedDict([('Source_VSP_Ages_And_Sizes_CSV',strSourceVSPAgesAndSizes[:-2])]))])
                                #DEBUG_OFF
                                dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates] = OrderedDict([(int_Current_Replicate, OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_VSP_Ages_And_Sizes, odictSourceVSPSizes_For_Log)]))])
                            else:
                                #DEBUG_ON
                                #dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][int_Current_Replicate] = OrderedDict([('Source_VSP_Ages_And_Sizes_CSV',strSourceVSPAgesAndSizes[:-2])])
                                #DEBUG_OFF
                                dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][int_Current_Replicate] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_VSP_Ages_And_Sizes, odictSourceVSPSizes_For_Log)])
                            pass
                        
                            del(pop_ToSample_By_AgeInMonths)
                        pass
                    pass
                                  
                    '''
                    Specify the required sampling regime
                    '''
        
                    #Cohort Dependent Sample
                    
                    #Non-Cohort Dependent Sample
                       
                        
                        
                    ''' Sampling by PROPRTION applied per cohort relative to its size across whole population
                        10% of the population but taking each cohort sample relative to the size of the cohort '''
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteRate:                      
                        boolCohortDependentSample = True
                        
                        #floatPopProportionToSample = 0.10
                        #floatPopProportionToSample = 0.05
                        #floatPopProportionToSample = 0.03
                        #floatPopProportionToSample = 0.02
                        #floatPopProportionToSample = 0.01
                        #floatPopProportionToSample = 0.005
                        
                        floatPopProportionToSample = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation]
                        
                        odictAgeCohortSampleNumbers = odictSourceVSPSizes
                        odictAgeCohortSampleNumbers_Adjusted = obj_Analysis.method_Apply_Absolute_Rate_To_Number_Distribution(floatPopProportionToSample, odictAgeCohortSampleNumbers, True, 0)

                        self.obj_Log_Debug_Display.debug('Sub-sampling population at: ' + str(dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation]) + '%')
                    

                    pass
                
                    ''' Sampling by absolute number per VSP '''
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteNumber:                      
                        boolCohortDependentSample = True

                        odictAgeCohortSampleNumbers = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort]

                    pass

                    '''Axx - S_STRAT_1_1_USP - Sampling by proportion of TOTAL SAMPLE SIZE requested '''
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByTotalSampleSize:                      
                        boolCohortDependentSample = True

                        odictAgeCohortSampleProportions = OrderedDict()
                        
                        odictAgeCohortSampleProportions = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionScaledByTotalSampleSize]
                        ''' Check if Proportions add up to 1 '''
                        bool_Proportions_Add_To_1 = float(round(sum(odictAgeCohortSampleProportions.values()),5)) == float(1.0)
                        
                        if bool_Proportions_Add_To_1:
                            int_Total_Sample_Size = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize]
                            listAges = [int_Age for int_Age, float_Value in odictAgeCohortSampleProportions.items()]
                            
                            odictAgeCohortSampleSizesUnscaledUnrounded = OrderedDict([(int_Age, float_Value * int_Total_Sample_Size) for int_Age, float_Value in odictAgeCohortSampleProportions.items()])
                            listAgeCohortSampleSizesUnscaledUnrounded = [float_Value for int_Age, float_Value in odictAgeCohortSampleSizesUnscaledUnrounded.items()]
                            odictAgeCohortSampleSizesUnscaledRounded = OrderedDict([(int_Age, int(round(float_Value,0))) for int_Age, float_Value in odictAgeCohortSampleSizesUnscaledUnrounded.items()])
                            listAgeCohortSampleSizesUnscaledRounded = [int_Value for int_Age, int_Value in odictAgeCohortSampleSizesUnscaledRounded.items()]
                            
                            listAgeCohortSampleSizesScaled = listAgeCohortSampleSizesUnscaledUnrounded[:]
                            
                            ''' INITIAL CHECK - Compare the desired total with the ScaledRounded total '''
                            #int_Total_Sample_Size__Scaled = sum(listAgeCohortSampleSizesScaled)
                            listAgeCohortSampleSizesScaledRounded = [int(round(float_Value, 0)) for float_Value in listAgeCohortSampleSizesScaled]
                            int_Total_Sample_Size__ScaledRounded = sum(listAgeCohortSampleSizesScaledRounded)
                            int_Error =  int_Total_Sample_Size__ScaledRounded - int_Total_Sample_Size 
                            if int_Error != 0:
                                ''' If depending on the sign of the error, adjust the value marginally up or down '''
                                if int_Error > 0:
                                    ''' Keep adjusting values until rounded sample size matches desired sample size ''' 
                                    while True:
                                        ''' Too many values round up and give overestimate so marginally adjust DOWN each value rounding up until error is zero'''
                                        for i in range(0, len(listAgeCohortSampleSizesScaled)-1):
                                            float_Value = listAgeCohortSampleSizesScaled[i]
                                            if float_Value != 0:
                                                ''' Check if value will round up or down '''
                                                float_ValueRounded = round(float_Value,0)
                                                if float_ValueRounded > float_Value:
                                                    float_Value_New = float_Value - 0.1
                                                    listAgeCohortSampleSizesScaled[i] = float_Value_New
                                                    ''' REPEATING CHECK - Compare the desired total with the ScaledRounded total to get the Error'''
                                                    listAgeCohortSampleSizesScaledRounded = [int(round(float_Val, 0)) for float_Val in listAgeCohortSampleSizesScaled]
                                                    int_Total_Sample_Size__ScaledRounded = sum(listAgeCohortSampleSizesScaledRounded)
                                                    int_Error = int_Total_Sample_Size__ScaledRounded - int_Total_Sample_Size                                   
                                                    if int_Error == 0:
                                                        break
                                                    pass
                                                pass
                                            pass
                                        pass
                                        ''' Keep adjusting values until rounded sample size matches desired sample size '''
                                        if int_Error == 0:
                                            break
                                        pass
                                    pass
                                pass
                                if int_Error < 0:
                                    ''' Keep adjusting values until rounded sample size matches desired sample size '''
                                    while True:
                                        ''' Too many values round down and give overestimate so marginally adjust UP each value rounding down until error is zero'''
                                        for i in range(0, len(listAgeCohortSampleSizesScaled)-1):
                                            float_Value = listAgeCohortSampleSizesScaled[i]
                                            if float_Value != 0:
                                                ''' Check if value will round up or down '''
                                                float_ValueRounded = round(float_Value,0)
                                                if float_ValueRounded < float_Value:                                    
                                                    float_Value_New = float_Value + 0.1
                                                    listAgeCohortSampleSizesScaled[i] = float_Value_New
                                                    ''' REPEATING CHECK - Compare the desired total with the ScaledRounded total to get the Error'''
                                                    listAgeCohortSampleSizesScaledRounded = [int(round(float_Val, 0)) for float_Val in listAgeCohortSampleSizesScaled]
                                                    int_Total_Sample_Size__ScaledRounded = sum(listAgeCohortSampleSizesScaledRounded)
                                                    int_Error = int_Total_Sample_Size__ScaledRounded - int_Total_Sample_Size                                     
                                                    if int_Error == 0:
                                                        break
                                                    pass
                                                pass
                                            pass
                                        pass
                                        ''' Keep adjusting values until rounded sample size matches desired sample size '''
                                        if int_Error == 0:
                                            break
                                        pass
                                    pass                                
                                pass
                            pass
                        
                            odictAgeCohortSampleNumbers = OrderedDict(zip(listAges, listAgeCohortSampleSizesScaledRounded))
                            pass
                        else:
                            with Debug_Location() as obj_DebugLoc:
                                str_Message_Location = obj_DebugLoc.Get_Debug_Location(bool_Short=True)
                            pass
    
                            ''' Inform the user of this error'''
                            str_Value_Error_Message = '' + '\n'
                            
                            str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                            str_Value_Error_Message += str_Message + '\n' 
                            self.obj_Log_Default_Display.error(str_Message)
                            
                            str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator_WARNING
                            str_Value_Error_Message += str_Message + '\n' 
                            self.obj_Log_Default_Display.error(str_Message)
                            
                            str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                            str_Value_Error_Message += str_Message + '\n\n' 
                            self.obj_Log_Default_Display.error(str_Message)
                            #str_Message = str_Message_Location + ' >> Not enough available indivs: ' + str(int_Age_Cohorts_Available_To_SubSample__Total_Indivs) + ' to satisfy quota of indivs to sample: ' + str(int_SubSamples)
                            #str_Value_Error_Message += str_Message + '\n\n'
                            #self.obj_Log_Default_Display.error(str_Message)
                            
                            str_Message = str_Message_Location + ' << INVALID SAMPLING PROPORTIONS >>'
                            str_Value_Error_Message += str_Message + '\n\n'
                            self.obj_Log_Default_Display.error(str_Message)
                            
                            str_Message = str_Message_Location + ' >> NeOGen has encountered a problem, but we know why, and its easily fixed by editing your Sampling Strategy.'
                            str_Value_Error_Message += str_Message + '\n\n'
                            self.obj_Log_Default_Display.error(str_Message)
                            
                            str_Message = str_Message_Location + ' >> The sampling proportions specified for the age cohorts must add up to 1.0. They currently total: ' + str(sum(odictAgeCohortSampleProportions.values()))
                            #str_Message = str_Message_Location + ' >> The requested MAXIMUM SAMPLE SIZE: ' + str(int_Desired_SubSample_Quota) + ' exceeds the total available individuals: ' + str(int_Actual_SubSample_Quota) + ' for the age cohorts specified by the SAMPLING PLAN'
                            str_Value_Error_Message += str_Message + '\n\n'
                            self.obj_Log_Default_Display.error(str_Message)
                            
                            str_Message = str_Message_Location + ' >> Go back to your Sampling Strategy and adjust your AGE COHORTS SAMPLING PROPORTIONS so that all the proportions total up to 1.0.'
                            str_Value_Error_Message += str_Message + '\n\n'
                            self.obj_Log_Default_Display.error(str_Message)
                            
                            str_Message = str_Message_Location + ' >> Keep this window open as a reference, and read the above carefully. Then edit your Sampling Strategy as per the above recomendation, and run it again.'
                            str_Value_Error_Message += str_Message + '\n\n'
                            self.obj_Log_Default_Display.error(str_Message)
    
                            str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                            str_Value_Error_Message += str_Message + '\n\n' 
                            self.obj_Log_Default_Display.error(str_Message)
                                                                            
                            #str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator_WARNING
                            #str_Value_Error_Message += str_Message + '\n'
                            #self.obj_Log_Default_Display.error(str_Message)
                            ''' ABORT run '''
                            raise ValueError(str_Value_Error_Message)
                                   
                        pass
                        
                    pass
                
                    ''' FAC - 100P_A_COHORTS - Sampling 100% of every user specified Age Cohort '''
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_100_Percent_Of_User_Specified_Age_Cohorts:
                        odictAgeCohortSampleProportions = OrderedDict()                      
                        boolCohortDependentSample = True
                        
                        odictAgeCohortSampleIndicator = OrderedDict(dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort])                    
                        intVSP_ID_Adjustment = 1 #2 
                        odictAgeCohortSampleNumbers_Temp = OrderedDict() 

                        for key_Age, value_Sample_Ind in odictAgeCohortSampleIndicator.items():
                            if value_Sample_Ind > 0:
                                odictAgeCohortSampleNumbers_Temp[key_Age] = int(odictSourceVSPSizes[key_Age + intVSP_ID_Adjustment])
                            else:
                                odictAgeCohortSampleNumbers_Temp[key_Age] = 0
                            pass
                        pass
                        odictAgeCohortSampleNumbers = OrderedDict(odictAgeCohortSampleNumbers_Temp)
                    pass

                    '''PSMP - SCALED_MAX_PROP - Sampling by PROPORTION SCALED BY MAXIMUM PROPORTION per Age Cohort VSP '''
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByMaxPropPerVSPCohort:                      
                        
                        #odictAgeCohortSampleProportions = OrderedDict()
                        odictAgeCohortSampleNumbers = OrderedDict()
                        boolCohortDependentSample = True
                        intVSP_ID_Adjustment = 1
                        
                        odictAgeCohortSampleProportions_Orig = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort]
                        
                        if self.objSSParametersLocal.int_Sampling_Strategy_Sample_Proportions_Source == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_AGE_COHORTS:
                            ''' All cohorts are to be sampled 100% '''
                            ''' Get the sample numbers from the cohort sizes '''
                            for int_Age, float_Proportion in odictAgeCohortSampleProportions_Orig.items():
                                int_Sample_Size = int(round(float_Proportion*odictSourceVSPSizes[int_Age + intVSP_ID_Adjustment],0)) 
                                odictAgeCohortSampleNumbers[int_Age] = int_Sample_Size
                            pass                            
                        elif self.objSSParametersLocal.int_Sampling_Strategy_Sample_Proportions_Source == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_SAMPLE_PROPORTIONS:
                            ''' Sample cohorts by proportion - Scale sample size by max proportion '''
                            '''Get Max Proportion from dist'''
                            int_Max_Sample_Proportion_Key =  max(reversed(odictAgeCohortSampleProportions_Orig.keys()), key=(lambda key: odictAgeCohortSampleProportions_Orig[key])) 
                            float_Max_Sample_Proportion_Value =  odictAgeCohortSampleProportions_Orig[int_Max_Sample_Proportion_Key] 
                            '''Get max percentage'''
                            float_Max_Proportion = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionScaledByMaxAbsPerVSPCohort_MaxProportion]
                            '''Get size of age cohort for the age cohort with the max proportion '''
                            float_Max_Proportion_Cohort_Size = odictSourceVSPSizes[int_Max_Sample_Proportion_Key + intVSP_ID_Adjustment]
                            '''Convert sample numbers to percentages using the Max absolute value as 100% or whatever the float_Max_Percentage is'''
                            float_Scaling_Factor = float(float_Max_Proportion) / float(float_Max_Sample_Proportion_Value)
                            ''' Get largest tptal sample size that this sampling plan can support '''
                            int_Max_Total_Sample_Size = int(round(float_Scaling_Factor*float_Max_Proportion_Cohort_Size,0))
                            
                            while True:
                                
        
                                ''' Get the sample numbers from the cohort sizes '''
                                for int_Age, float_Proportion in odictAgeCohortSampleProportions_Orig.items():
                                    int_Sample_Size = int(round(int_Max_Total_Sample_Size*float_Proportion,0)) 
                                    odictAgeCohortSampleNumbers[int_Age] = int_Sample_Size
                                pass
                                
                                ''' Check if the sample numbers are realistic for the available cohort sizes '''
                                list_Samples = odictAgeCohortSampleNumbers.values()
                                list_Cohort_Sizes = [int(odictSourceVSPSizes[int_Age + intVSP_ID_Adjustment]) for int_Age in odictAgeCohortSampleNumbers.keys()]
                                ''' Check if cohort sizes exceed sample sizes '''
                                
                                bool_Sufficiant = False
                                bool_Sufficiant = all(itertools__starmap(operator__ge, itertools__izip(list_Cohort_Sizes, list_Samples)))
                            
                                if bool_Sufficiant:
                                    break
                                else:
                                    ''' Reduce the total sample size by 1 '''
                                    int_Max_Total_Sample_Size -= 1
                                pass
                            pass
                                                
    #                         for key, value in odictAgeCohortSampleProportions_Orig.items():
    #                             int_New_Sample_Proportion = value*float_Scaling_Factor
    #                             odictAgeCohortSampleProportions[key] = int_New_Sample_Proportion
    #                         pass
                            
    #                         ''' Get the sample numbers from the cohort sizes '''
    #                         for int_Age, float_Propoportion in odictAgeCohortSampleProportions.items():
    #                             int_Sample_Size = int(round(float_Propoportion*odictSourceVSPSizes[int_Age + intVSP_ID_Adjustment],0)) 
    #                             odictAgeCohortSampleNumbers[int_Age] = int_Sample_Size
    #                         pass
                        pass
                    pass
                                
                    ''' Sampling by PROPORTION per VSP determined by COHORT SIZE upto a TOTAL SAMPLE SIZE '''
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples:
                        odictAgeCohortSampleProportions = OrderedDict()                      
                        boolCohortDependentSample = True
                        
                        odictAgeCohortSampleIndicator = OrderedDict(dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort])                    
                        int_SubSample_Quota = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize]
                        #odictAgeCohortSampleNumbers = OrderedDict()
                        
                        ''' If the odictAgeCohortSampleIndicatior = 1 then get age cohort for sampling '''
                        #dict_Ages_To_Sample = OrderedDict()
                        intVSP_ID_Adjustment = 1 #2 
                        list_Ages_To_Sample = []
                        for key_Age, value_Sample_Ind in odictAgeCohortSampleIndicator.items():
                            if value_Sample_Ind >= 1:
                                #dict_Ages_To_Sample[key_Age] = odictSourceVSPSizes[key_Age]
                                list_Ages_To_Sample.append((int(key_Age), int(odictSourceVSPSizes[key_Age + intVSP_ID_Adjustment])))
                                
                            pass
                        pass
                        list_Ages_To_Sample = sorted(list_Ages_To_Sample, key=lambda tup: tup[0])
                        (int_Max_Cohort_Size_Age, int_Max_Cohort_Size) = max(list_Ages_To_Sample, key=lambda tup: tup[1])
                        list_Ages_To_Sample_With_Proportions = [(int_Age, int_Size, float(int_Size)/float(int_Max_Cohort_Size)) for (int_Age, int_Size) in list_Ages_To_Sample]
                        float_Sum_Relative_Proportions = sum(float_Relative_Proportion for (int_Age, int_Size, float_Relative_Proportion) in list_Ages_To_Sample_With_Proportions)
                        float_Max_Sample_Size =  float(int_SubSample_Quota) / float_Sum_Relative_Proportions
                        
                        ''' Use the max sample size to get the sample sizes for the other ages '''
                        list_Ages_To_Sample_With_Proportions_With_Sample_Sizes = [(int_Age, int_Size, float_Relative_Proportion, float_Max_Sample_Size * float_Relative_Proportion) for (int_Age, int_Size, float_Relative_Proportion) in list_Ages_To_Sample_With_Proportions]
                        float_Sum_Proportional_Sample_Sizes = sum(float_Proportional_Sample_Size for (int_Age, int_Size, float_Relative_Proportion, float_Proportional_Sample_Size) in list_Ages_To_Sample_With_Proportions_With_Sample_Sizes)
                        
                        for (int_Age, int_Size, float_Relative_Proportion, float_Proportional_Sample_Size) in list_Ages_To_Sample_With_Proportions_With_Sample_Sizes:
                            odictAgeCohortSampleIndicator[int_Age] = float_Proportional_Sample_Size / odictSourceVSPSizes[int_Age + intVSP_ID_Adjustment] 
                        pass
                    
                        odictAgeCohortSampleProportions = OrderedDict(odictAgeCohortSampleIndicator)
                        #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleProportions  

                    pass

                
                    ''' Sampling by PROPORTION per VSP upto a TOTAL SAMPLE SIZE '''
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples or \
                       intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples: 
                        boolCohortDependentSample = True
                        
                        if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples:
                            odictAgeCohortSamplePercentage = OrderedDict(dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort])
                        elif intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples: 
                            odictAgeCohortSamplePercentage = OrderedDict(odictAgeCohortSampleProportions)
                        pass
                        int_SubSample_Quota = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize]
                        odictAgeCohortSampleNumbers = OrderedDict()
                        odictSourceVSPSizes_Copy = OrderedDict(odictSourceVSPSizes)
                        '''
                        ~~~~~~~~~~~~~~~~~
                        Get sample numbers by cohort
                        ~~~~~~~~~~~~~~~~~
                        '''
                        #Adjust the VSP number to match the current ages in the pop
                        intVSP_ID_Adjustment = 1 #2  
                        bool_Re_Sample = False
                        int_Re_Sample_Count = 0
                        int_Resulting_SubSample_Quota_Prev = 0
                        int_SubSample_Quota__Orig = int_SubSample_Quota
                        while True:
                   
                            odictAgeCohortSampleNumbers, odict_Age_Cohort_Indiv_Count__Post_Sampling = self.method_SubSample_Age_Cohorts__Up_To_QUOTA__Specific_Letftover_Samples_Deplete_Next_Youngest_Cohort(int_SubSample_Quota, odictSourceVSPSizes_Copy, intVSP_ID_Adjustment, odictAgeCohortSamplePercentage, odictAgeCohortSampleNumbers)    
                            
                            ''' Check if the correct number of total sample quota has been take - This is often not the case beacuse rounding per cohort can lower or raise the resulting total sampled'''
                            int_Resulting_SubSample_Quota = int(round(sum(collections__Counter(odictAgeCohortSampleNumbers).values()),2))
                            
                            if bool_Re_Sample:
                                int_Quota_Difference = (int_Resulting_SubSample_Quota - int_Resulting_SubSample_Quota_Prev) - int_SubSample_Quota
                            else:
                                int_Quota_Difference = int_Resulting_SubSample_Quota - int_SubSample_Quota
                            pass
                            
                            #DEBUG_ON
                            #self.obj_Log_Default_Display.info('Sampling Strategy - Quota difference: ' + str(int_Quota_Difference) + ' after sampling int_Resulting_SubSample_Quota: ' + str(int_Resulting_SubSample_Quota) + ' of desired int_SubSample_Quota: ' + str(int_SubSample_Quota))
                            self.obj_Log_Debug_Display.debug('Sampling Strategy - Quota difference: ' + str(int_Quota_Difference) + ' after sampling int_Resulting_SubSample_Quota: ' + str(int_Resulting_SubSample_Quota) + ' of desired int_SubSample_Quota: ' + str(int_SubSample_Quota))
                            self.obj_Log_Debug_Display.debug('Sampling Strategy - int_Re_Sample_Count: ' + str(int_Re_Sample_Count))
                            #DEBUG_OFF
                            
                            if (int_Quota_Difference > -10) or (int_Re_Sample_Count >= 4) or (int_Quota_Difference < -30):
                                break
                            else:
                                bool_Re_Sample = True
                                int_Re_Sample_Count += 1
                                odictSourceVSPSizes_Copy = OrderedDict(odict_Age_Cohort_Indiv_Count__Post_Sampling)
                                int_SubSample_Quota = abs(int_Quota_Difference)
                                int_Resulting_SubSample_Quota_Prev = int_Resulting_SubSample_Quota
                                intVSP_ID_Adjustment = 0
                            pass
                        pass
                    
                        if int_Quota_Difference != 0:
                            ''' Randomly change sub-sampled age cohorts (if not fully depleted) without replacement to ensure the correct total '''
                            #Adjust the VSP number to match the current ages in the pop
                            intVSP_ID_Adjustment = 0
                            odictAgeCohortSampleNumbers, odict_Age_Cohort_Indiv_Count__Post_Sampling = self.method_SubSample_Age_Cohorts__Randomly_Increase_Or_Decrease_Cohorts_By_Sample_Number(int_Resulting_SubSample_Quota, int_SubSample_Quota__Orig, odict_Age_Cohort_Indiv_Count__Post_Sampling, intVSP_ID_Adjustment, odictAgeCohortSamplePercentage, odictAgeCohortSampleNumbers)
                        pass   
                    pass

                
                    ''' Sampling by PROPORTION SCALED BY MAXIMUM ABSOLUTE per Age Cohort VSP '''
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByMaxAbsPerVSPCohort:                      
                        boolCohortDependentSample = True
                        odictAgeCohortSampleNumbers = OrderedDict()
                        
                        odictAgeCohortSampleNumbers_Orig = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort]
                        '''get Max Absolute Number from dist'''
                        int_Max_Sample_Size_Key =  max(odictAgeCohortSampleNumbers_Orig.keys(), key=(lambda key: odictAgeCohortSampleNumbers_Orig[key])) 
                        int_Max_Sample_Size_Value =  odictAgeCohortSampleNumbers_Orig[int_Max_Sample_Size_Key] 
                        '''Get max percentage'''
                        float_Max_Proportion = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionScaledByMaxAbsPerVSPCohort_MaxProportion]
                        '''Convert sample numbers to percentages using the Max absolute vaulue as 100% or whatever the float_Max_Percentage is'''
                        for key, value in odictAgeCohortSampleNumbers_Orig.items():
                            int_New_Sample_Size = (float(value)*float_Max_Proportion) / float(int_Max_Sample_Size_Value)
                            odictAgeCohortSampleNumbers[key] = int_New_Sample_Size
                        pass
                    pass
                
                    ''' Sampling by ABSOLUTE NUMBER SCALED BY MAXIMUM ABSOLUTE per Age Cohort VSP '''
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsAbsScaledByMaxAbsPerVSPCohort:                      
                        boolCohortDependentSample = True
                        odictAgeCohortSampleNumbers = OrderedDict()
                        
                        odictAgeCohortSampleNumbers_Orig = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort]
                        '''get Max Absolute Number from dist'''
                        int_Max_Sample_Size_Key =  max(odictAgeCohortSampleNumbers_Orig.keys(), key=(lambda key: odictAgeCohortSampleNumbers_Orig[key])) 
                        int_Max_Sample_Size_Value =  odictAgeCohortSampleNumbers_Orig[int_Max_Sample_Size_Key] 
                        '''get VSP size for Max Absolute Number'''
                        #Adjust the VSP number to match the current ages in the pop
                        intVSP_ID_Adjustment = 1 #2                        
                        int_VSP_Size_Value =  odictSourceVSPSizes[int_Max_Sample_Size_Key+intVSP_ID_Adjustment] 
                        '''Get max percentage'''
                        float_Max_Proportion = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsScaledByMaxAbsPerVSPCohort_MaxProportion]
                        '''Convert sample numbers to percentages using the Max absolute vaulue as 100% or whatever the float_Max_Percentage is'''
                        for key, value in odictAgeCohortSampleNumbers_Orig.items():
                            int_New_Sample_Size = int(int_VSP_Size_Value*((float(value)*float_Max_Proportion) / float(int_Max_Sample_Size_Value)))
                            odictAgeCohortSampleNumbers[key] = int_New_Sample_Size
                        pass
                    pass
                
                    ''' #Sampling by PROPRTION per VSP '''
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_FISHED_cohort_proportions or \
                       intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_MATURE_cohort_proportions or \
                       intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_ALL_cohort_proportions or \
                       intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_ALL_cohort_proportions_X_NEONATE or \
                       intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_NEONATE:
                        
                        boolCohortDependentSample = True

                        if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_FISHED_cohort_proportions:                      
                        
                            #CAPL real catch cohort proportions
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.015267176),(12,0.040712468),(24,0.03562341),(36,0.03562341),(48,0.015267176),(60,0.007633588),(72,0.005089059),(84,0),(96,0.007633588),(108,0.022900763),(120,0.03307888),(132,0.066157761),(144,0.053435115),(156,0.117048346),(168,0.1043257),(180,0.139949109),(192,0.096692112),(204,0.061068702),(216,0.045801527),(228,0.027989822),(240,0.03562341),(252,0.015267176),(264,0.012722646),(276,0),(288,0),(300,0.002544529),(312,0),(324,0.002544529),(336,0),(348,0),(360,0)])
                        pass
                    
                        if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_MATURE_cohort_proportions:                      
   
                            #CAPL random sampling MATURE cohort proportions
                            #Sample from:
                            #minMating age = 16*12 = 192
                            #To:
                            #maxAge = 31*12 = 372
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.0),(12,0.0),(24,0.0),(36,0.0),(48,0.0),(60,0.0),(72,0.0),(84,0.0), (96,0.0),(108,0.0),(120,0.0),(132,0.0),(144,0.0),(156,0.0),(168,0.0),(180,0.0),(192,0.0), \
                                                                       (204,0.0714),(216,0.0714),(228,0.0714),(240,0.0714),(252,0.0714),(264,0.0714),(276,0.0714),(288,0.0714),(300,0.0714),(312,0.0714),(324,0.0714),(324,0.0714),(336,0.0714),(348,0.0714),(360,0.0714)])
                        pass
                    
                        if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_ALL_cohort_proportions:                      
                            #CAPL random sampling ALL cohort proportions
                            #Sample from:
                            #embryo age = 0 months
                            #To:
                            #maxAge = 31*12 = 372
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.0323),\
                                                                       (12,0.0323),(24,0.0323),(36,0.0323),(48,0.0323),(60,0.0323),(72,0.0323),(84,0.0323), (96,0.0323),(108,0.0323),(120,0.0323),(132,0.0323),(144,0.0323),(156,0.0323),(168,0.0323),(180,0.0323),(192,0.0323), \
                                                                       (204,0.0323),(216,0.0323),(228,0.0323),(240,0.0323),(252,0.0323),(264,0.0323),(276,0.0323),(288,0.0323),(300,0.0323),(312,0.0323),(324,0.0323),(324,0.0323),(336,0.0323),(348,0.0323),(360,0.0323)])
                        pass

                        if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_ALL_cohort_proportions_X_NEONATE:                      
                            #CAPL random sampling ALL cohort proportions X NEONATE
                            #Sample from:
                            #Sub-adult age = 12 months
                            #To:
                            #maxAge = 31*12 = 372
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.0),\
                                                                       (12,0.0333),(24,0.0333),(36,0.0333),(48,0.0333),(60,0.0333),(72,0.0333),(84,0.0333), (96,0.0333),(108,0.0333),(120,0.0333),(132,0.0333),(144,0.0333),(156,0.0333),(168,0.0333),(180,0.0333),(192,0.0333), \
                                                                       (204,0.0333),(216,0.0333),(228,0.0333),(240,0.0333),(252,0.0333),(264,0.0333),(276,0.0333),(288,0.0333),(300,0.0333),(312,0.0333),(324,0.0333),(324,0.0333),(336,0.0333),(348,0.0333),(360,0.0333)])
                        pass

                        if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_NEONATE:                      
                            #CAPL random sampling NEONATE
                            #Sample from:
                            #embryo age = 0 months
                            odictAgeCohortSampleNumbers = OrderedDict([(0,1.0000),\
                                                                       (12,0.0000),(24,0.0000),(36,0.0000),(48,0.0000),(60,0.0000),(72,0.0000),(84,0.0000), (96,0.0000),(108,0.0000),(120,0.0000),(132,0.0000),(144,0.0000),(156,0.0000),(168,0.0000),(180,0.0000),(192,0.0000), \
                                                                       (204,0.0000),(216,0.0000),(228,0.0000),(240,0.0000),(252,0.0000),(264,0.0000),(276,0.0000),(288,0.0000),(300,0.0000),(312,0.0000),(324,0.0000),(324,0.0000),(336,0.0000),(348,0.0000),(360,0.0000)])
                        pass
                    pass
                 
                    #Get total poulation size
                    intPopSize = pop_ToSample.subPopSize()

                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom:                  
                        boolCohortDependentSample = False
                        
                        #floatPopProportionToSample = 0.10
                        #floatPopProportionToSample = 0.05
                        #floatPopProportionToSample = 0.045
                        #floatPopProportionToSample = 0.040
                        #floatPopProportionToSample = 0.035
                        #floatPopProportionToSample = 0.03
                        #floatPopProportionToSample = 0.025
                        #floatPopProportionToSample = 0.02
                        #floatPopProportionToSample = 0.015
                        #floatPopProportionToSample = 0.01
                        #floatPopProportionToSample = 0.005

                        floatPopProportionToSample = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation]
                        
                        if globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample in dictSamplingParams:
                            #Get VSPsize
                            tup_VSP_To_Sample = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample]
                            intPopSize = pop_ToSample.subPopSize(tup_VSP_To_Sample)
                        pass
   
                        intRandomSampleNumIndividuals = int(round(floatPopProportionToSample * intPopSize, 0))
                    pass

                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute:                  
                        boolCohortDependentSample = False

                        if globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample in dictSamplingParams:
                            tup_VSP_To_Sample = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample]
                        pass
                    
                        intAbsoluteNumberOfIndividuals = dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals]
   
                        intRandomSampleNumIndividuals = intAbsoluteNumberOfIndividuals
                    pass


                    if boolCohortDependentSample:
                        '''
                        Adjust age_in_month value to match VSP numbers in the population
                        '''                    
                        if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteNumber or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByTotalSampleSize or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_100_Percent_Of_User_Specified_Age_Cohorts or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByMaxPropPerVSPCohort or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_FISHED_cohort_proportions or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_MATURE_cohort_proportions or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_ALL_cohort_proportions or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_ALL_cohort_proportions_X_NEONATE or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortRateDist_CAPL_random_sampling_NEONATE or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohort or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByMaxAbsPerVSPCohort or \
                           intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsAbsScaledByMaxAbsPerVSPCohort:

                            #if boolSampleSizeIsCohortAbsoluteNumber or boolSampleSizeIsCohortRateDist:
                            #Adjust the VSP number to match the current ages in the pop
                            intVSP_ID_Adjustment = 1 #2
                            odictAgeCohortSampleNumbers_Adjusted = OrderedDict()
                            for keyVSP, valueNumToSample in odictAgeCohortSampleNumbers.items():
                                ''' If UnNatural mortality is turned off then the max age will not exceed maxAge*12  '''
                                if (keyVSP == self.objSSParametersLocal.maxAge * 12) and self.objSSParametersLocal.boolAllowUnNATURALMortality == False:
                                    odictAgeCohortSampleNumbers_Adjusted[keyVSP] = valueNumToSample
                                else:
                                    odictAgeCohortSampleNumbers_Adjusted[keyVSP+intVSP_ID_Adjustment] = valueNumToSample
                                pass
                            pass
                                
                            if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohort or \
                               intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByMaxAbsPerVSPCohort: 
                                #Convert the proportions to actual numbers of individuals
                                odictAgeCohortSampleNumbers_Adjusted = obj_Analysis.method_Apply_Proportion_Distribution_To_Number_Distribution(odictAgeCohortSampleNumbers_Adjusted, odictSourceVSPSizes, True, 0)
                                if odictAgeCohortSampleNumbers_Adjusted == None:
                                    return True
                                pass
                            elif intSamplingMethod != globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsAbsScaledByMaxAbsPerVSPCohort:    
                                if intSamplingMethod != globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteNumber and \
                                   intSamplingMethod != globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByTotalSampleSize and \
                                   intSamplingMethod != globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples and \
                                   intSamplingMethod != globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_100_Percent_Of_User_Specified_Age_Cohorts and \
                                   intSamplingMethod != globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByMaxPropPerVSPCohort and \
                                   intSamplingMethod != globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples:
                                    #Convert the rates to actual numbers of individuals
                                    odictAgeCohortSampleNumbers_Adjusted = obj_Analysis.method_Apply_Rate_Distribution_To_Number_Distribution(odictAgeCohortSampleNumbers_Adjusted, odictSourceVSPSizes, True, 0)
                                    if odictAgeCohortSampleNumbers_Adjusted == None:
                                        return True
                                    pass
                                pass
                            pass
                        '''
                        Prep the sampling specification for processing
                        '''
                        #Get a list of the VSPs to sample and a separate list of the sample size to take per VSP
                        odictAgeCohortVSPS_And_SampleNumbers = self.method_Cohort_Sampling_VSP_And_Sample_Size(pop_ToSample, odictAgeCohortSampleNumbers_Adjusted)

                
                        '''
                        Cohort dependent logging
                        '''
                        #LOGGING
                        listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        stringMessage = '>Cohort Age Sample Specification: ' + str(odictAgeCohortSampleNumbers_Adjusted) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        self.obj_Log_Debug_Display.debug(stringMessage)
                        stringMessage = '>Cohort Age Sample Spec Adjusted: ' + str(odictAgeCohortSampleNumbers_Adjusted) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        self.obj_Log_Debug_Display.debug(stringMessage)
                        stringMessage = '>Cohort Age Sampling VSPs : ' + str(odictAgeCohortVSPS_And_SampleNumbers[0]) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        self.obj_Log_Debug_Display.debug(stringMessage)
                        stringMessage = '>Cohort Age Sampling Numbers : ' + str(odictAgeCohortVSPS_And_SampleNumbers[1]) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        self.obj_Log_Debug_Display.debug(stringMessage)
                        intRandomSampleNumIndividuals = sum(odictAgeCohortVSPS_And_SampleNumbers[1])
                        stringMessage = '>Cohort Age Sampling Total : ' + str(intRandomSampleNumIndividuals) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        self.obj_Log_Debug_Display.debug(stringMessage)
                        #LOGGING
                    
                    pass

                    '''
                    Specify the number of random samples
                    '''
                    #intRandomSamplesToTake = 1
                    
                    #LOGGING
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteRate or \
                       intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom:                  
                        #    if boolSampleSizeIsCohortAbsoluteRate == False or boolSampleSizeIsNonCohortRandom == False:

                        floatPopProportionToSample = round(float(intRandomSampleNumIndividuals) / float(intPopSize), 3)
                    pass
#                     listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
#                     stringMessage = '>Randomly sample: ' + str(intRandomSamplesToTake) + '; Population proportion: ' + str(floatPopProportionToSample) + ' of ' + str(intPopSize) + ' = ' + str(intRandomSampleNumIndividuals) + ' individuals' +'\n'
#                     objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
#                     self.obj_Log_Debug_Display.debug(stringMessage)
                
                    '''
                    Repeatedly sub-sample
                    '''
#                     intFileOrder = 0
#                     for intRandomLDneSample in  range(0, intRandomSamplesToTake):
                        
                    #LOGGING
                    if intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteRate or \
                       intSamplingMethod == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom:                  

                        #if boolSampleSizeIsCohortAbsoluteRate == False or boolSampleSizeIsNonCohortRandom == False:
                        floatPopProportionToSample = round(float(intRandomSampleNumIndividuals) / float(intPopSize), 3)
                        listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        stringMessage = '>Random sample: ' + str(intRandomLDneSample) + ' of ' + str(intRandomSamplesToTake) + '; Population proportion: ' + str(floatPopProportionToSample) + ' of ' + str(intPopSize) + ' = ' + str(intRandomSampleNumIndividuals) + ' individuals' +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        self.obj_Log_Debug_Display.debug(stringMessage)
                    pass

                    #LOGGING
                    '''
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    Check sufficiant individuals exist to satisfy sample 
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    '''
                    bool_Perform_Check = True
                    if bool_Perform_Check:
                        if boolCohortDependentSample:
                            listVSPsToRandomSample = list(odictAgeCohortVSPS_And_SampleNumbers[0])
                            listAgesToRandomSample = list(i[1] for i in listVSPsToRandomSample)
                            listRandomSampleSizePerVSP = list(odictAgeCohortVSPS_And_SampleNumbers[1])
                            odictAgeCohortSampleNumbers = OrderedDict(zip(listAgesToRandomSample, listRandomSampleSizePerVSP))
                            
                            bool_Success = True
                            int_Total_Samples_Requested = sum(odictAgeCohortSampleNumbers.values())
                            for int_Age, int_Sample in odictAgeCohortSampleNumbers.items():
                                int_Individuals = int(odictSourceVSPSizes[int_Age])
                                if int_Sample > int_Individuals:
                                    bool_Success = False

                                    with Debug_Location() as obj_DebugLoc:
                                        str_Message_Location = obj_DebugLoc.Get_Debug_Location(bool_Short=True)
                                    pass
    
                                    ''' Inform the user of this error'''
                                    str_Value_Error_Message = '' + '\n'
                                    
                                    str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                                    str_Value_Error_Message += str_Message + '\n' 
                                    self.obj_Log_Default_Display.error(str_Message)
                                    
                                    str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator_WARNING
                                    str_Value_Error_Message += str_Message
                                    self.obj_Log_Default_Display.error(str_Message)
                                    
                                    str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                                    str_Value_Error_Message += str_Message + '\n\n' 
                                    self.obj_Log_Default_Display.error(str_Message)
    
                                    str_Message = str_Message_Location + ' <<< INVALID SAMPLING PLAN FOR ' + str(int_Total_Samples_Requested) + ' SAMPLES >>> Age ' + str(((int_Age-1)/12)) + ' has too few individuals (' + str(int_Individuals) + ') to satisfy the requested age cohort sample size: ' + str(int_Sample)
                                    str_Value_Error_Message += str_Message + '\n\n'
                                    self.obj_Log_Default_Display.error(str_Message)

                                    str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                                    str_Value_Error_Message += str_Message + '\n\n' 
                                    self.obj_Log_Default_Display.error(str_Message)                                
                                pass
                            pass
                            if not bool_Success:
#                                 stringMessage = '<<< INVALID SAMPLING PLAN >>> Please go back to your Sampling Strategy and adjust your Sampling Plan to select fewer samples from the age(s) listed above.'
#                                 self.obj_Log_Run_Display.info(stringMessage)
#                                 stringMessage = '<<< INVALID SAMPLING PLAN >>> Alternatively, go back to your Sampling Strategy and reduce the total number of samples requested.'
#                                 self.obj_Log_Run_Display.info(stringMessage)

                                with Debug_Location() as obj_DebugLoc:
                                    str_Message_Location = obj_DebugLoc.Get_Debug_Location(bool_Short=True)
                                pass

                                ''' Inform the user of this error'''
                                str_Value_Error_Message = '' + '\n'
                                
                                str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                                str_Value_Error_Message += str_Message + '\n' 
                                self.obj_Log_Default_Display.error(str_Message)
                                
                                str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator_WARNING
                                str_Value_Error_Message += str_Message + '\n' 
                                self.obj_Log_Default_Display.error(str_Message)
                                
                                str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                                str_Value_Error_Message += str_Message + '\n\n' 
                                self.obj_Log_Default_Display.error(str_Message)
                                #str_Message = str_Message_Location + ' >> Not enough available indivs: ' + str(int_Age_Cohorts_Available_To_SubSample__Total_Indivs) + ' to satisfy quota of indivs to sample: ' + str(int_SubSamples)
                                #str_Value_Error_Message += str_Message + '\n\n'
                                #self.obj_Log_Default_Display.error(str_Message)
                                
                                str_Message = str_Message_Location + ' << INVALID SAMPLING PLAN FOR ' + str(int_Total_Samples_Requested) + ' SAMPLES >>'
                                str_Value_Error_Message += str_Message + '\n\n'
                                self.obj_Log_Default_Display.error(str_Message)
                                
                                str_Message = str_Message_Location + ' >> NeOGen has encountered a problem, but we know why, and its easily fixed by editing your Sampling Strategy.'
                                str_Value_Error_Message += str_Message + '\n\n'
                                self.obj_Log_Default_Display.error(str_Message)
                                
                                str_Message = str_Message_Location + ' >> The age cohorts to be sampled have too few individuals. Please scroll up above this message and note which age cohorts are in error'
                                #str_Message = str_Message_Location + ' >> The requested MAXIMUM SAMPLE SIZE: ' + str(int_Desired_SubSample_Quota) + ' exceeds the total available individuals: ' + str(int_Actual_SubSample_Quota) + ' for the age cohorts specified by the SAMPLING PLAN'
                                str_Value_Error_Message += str_Message + '\n\n'
                                self.obj_Log_Default_Display.error(str_Message)
                                
                                str_Message = str_Message_Location + ' >> Then go back to your Sampling Strategy and adjust your SAMPLING PLAN to select fewer samples from the age(s) listed above.'
                                str_Value_Error_Message += str_Message + '\n\n'
                                self.obj_Log_Default_Display.error(str_Message)
                                
                                str_Message = str_Message_Location + ' >> ...or alter the Sampling Strategy SAMPLING PLAN exclude the offending age cohort(s) from sampling'
                                str_Value_Error_Message += str_Message + '\n\n'
                                self.obj_Log_Default_Display.error(str_Message)
        
                                str_Message = str_Message_Location + ' >> Keep this window open as a reference, and read the above carefully. Then edit your Sampling Strategy as per the above recomendation, and run it again.'
                                str_Value_Error_Message += str_Message + '\n\n'
                                self.obj_Log_Default_Display.error(str_Message)
        
                                str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                                str_Value_Error_Message += str_Message + '\n\n' 
                                self.obj_Log_Default_Display.error(str_Message)
                                                                                
                                #str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator_WARNING
                                #str_Value_Error_Message += str_Message + '\n'
                                #self.obj_Log_Default_Display.error(str_Message)
                                ''' ABORT run '''
                                raise ValueError(str_Value_Error_Message)
                            
                            pass
                        pass
                    pass
                
                    '''
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    Take the sample
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    '''
                    if boolCohortDependentSample:
                        pop_SubSample = self.method_Cohort_Sampling_Specification_Draw(pop_ToSample, intRandomSampleNumIndividuals, odictAgeCohortVSPS_And_SampleNumbers)
                    else:
                        listVSPsToSample = []
                        if globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample in dictSamplingParams:
                            listVSPsToSample = [tup_VSP_To_Sample]
                        pass                        
                        pop_SubSample = self.method_Draw_Random_Pop_SubSample(pop_ToSample, intRandomSampleNumIndividuals, listVSPsToSample)
                    pass
                
                    ''' Remove unwanted loci '''
                    if len(listLociToRemove) > 0:
                        pop_SubSample = self.method_Remove_Loci(pop_SubSample, listLociToRemove)
                    pass
#                    pass

                    '''
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    Report sample size per age
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                    '''
                    if int_VSP_Split_Method == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths or \
                       int_VSP_Split_Method == globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass:
                        
                        pop_SubSample = self.method_SplitLifeStagesInto_AgeInMonths_VSPs_By_AgeInMonths(pop_SubSample, intMaxAge, boolUpdateInfoField)
                        #Get the numbers of individuals per age chort VSP
                        with SSAnalysisHandler() as objSSAnalysisOperation:
                            boolReportVSPIfEmpty = False
                            odictSampleVSPSizes = objSSAnalysisOperation.method_Get_VSP_Sizes(pop_SubSample, boolReportVSPIfEmpty)
                            #LOGGING
                            stringMessage = '>SubSample VSP & Sizes (not inc. 0 size VSPs): ' + str(odictSampleVSPSizes) +'\n'
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
    #                         listVSPSizes = []
    #                         for valueTupleVSPSize in odictSampleVSPSizes.items():
    #                             listVSPSizes.append(int(valueTupleVSPSize[1]))
    #                         stringMessage = '>SubSample VSPSizes (not inc. 0 size VSPs): ' + str(listVSPSizes) +'\n'
    #                         objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                            
                            strSampleVSPAgesAndSizes = ''
                            for key, value in odictSampleVSPSizes.items():
                                strSampleVSPAgesAndSizes += str(key) + globalsSS.StringDelimiters.static_stringDelimiter_SPACE + globalsSS.StringDelimiters.static_stringDelimiter_COMMA + globalsSS.StringDelimiters.static_stringDelimiter_SPACE + str(int(value)) + globalsSS.StringDelimiters.static_stringDelimiter_COMMA + globalsSS.StringDelimiters.static_stringDelimiter_SPACE
                            pass
                            #DEBUG_ON
                            #dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][int_Current_Replicate]['Sample_VSP_Ages_And_Sizes_CSV'] = strSampleVSPAgesAndSizes[:-2]
                            #DEBUG_OFF
                            
                            odictSampleVSPSizes_Full = OrderedDict(odictSampleVSPSizes)
                            
                            #for key in odictSourceVSPSizes.keys():
                            for key in odictSourceVSPSizes_For_Log.keys():
                                if key not in odictSampleVSPSizes.keys():
                                    odictSampleVSPSizes_Full[key] = 0
                                pass
                            pass
                            odictSampleVSPSizes_Full = OrderedDict(sorted(odictSampleVSPSizes_Full.iteritems()))
                            dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][int_Current_Replicate][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_VSP_Ages_And_Sizes] = odictSampleVSPSizes_Full
                        
                            ''' Get Sample size per age as Percentage of original cohort '''
                            odictVSPSamplePercentOfSource = OrderedDict()
                            strVSPSamplePercentOfSource = ''
                            for key, value in odictSampleVSPSizes.items():
                                odictVSPSamplePercentOfSource[key] = round((value / odictSourceVSPSizes[key] * 100), 0)
                                strVSPSamplePercentOfSource += str(key) + globalsSS.StringDelimiters.static_stringDelimiter_SPACE + globalsSS.StringDelimiters.static_stringDelimiter_COMMA + globalsSS.StringDelimiters.static_stringDelimiter_SPACE + str(round(odictVSPSamplePercentOfSource[key],2)) + globalsSS.StringDelimiters.static_stringDelimiter_COMMA + globalsSS.StringDelimiters.static_stringDelimiter_SPACE
                            pass
                            #DEBUG_ON
                            #dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][int_Current_Replicate]['Sample_VSP_Ages_And_Percent_Sample_Sizes_CSV'] = strVSPSamplePercentOfSource[:-2]  
                            #DEBUG_OFF
                            odictVSPSamplePercentOfSource_Full = OrderedDict(odictVSPSamplePercentOfSource)
                            
                            #for key in odictSourceVSPSizes.keys():
                            for key in odictSourceVSPSizes_For_Log.keys():
                                if key not in odictSampleVSPSizes.keys():
                                    odictVSPSamplePercentOfSource_Full[key] = 0
                                pass
                            pass
                            odictVSPSamplePercentOfSource_Full = OrderedDict(sorted(odictVSPSamplePercentOfSource_Full.iteritems()))
                            dictResults[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][int_Current_Replicate][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Percent_VSP_Ages_And_Sizes] = odictVSPSamplePercentOfSource_Full
                                                    
                            #LOGGING 
                        pass                   
                    pass
                
                    pop_Out = pop_SubSample
                                
                return pop_Out, dictResults
            

            def method_SubSample_Age_Cohorts__Up_To_QUOTA__Specific_Letftover_Samples_Deplete_Next_Youngest_Cohort(self, int_SubSample_Quota, odict_Age_Cohort_Indiv_Count, intVSP_ID_Adjustment, odictAgeCohortSamplePercentage, odict_Age_Cohort_Indiv_Count__Sampled=OrderedDict()):

                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     
            
                ''' Initialise required variables '''
                #odict_Age_Cohort_Indiv_Count__Sampled = OrderedDict()
                odict_Age_Cohort_Indiv_Count__Post_Sampling = OrderedDict()
                for key, value in odict_Age_Cohort_Indiv_Count.items():
                    if key-intVSP_ID_Adjustment >= 0:
                        if key not in odict_Age_Cohort_Indiv_Count__Sampled.keys():
                            odict_Age_Cohort_Indiv_Count__Sampled[key-intVSP_ID_Adjustment] = 0
                        pass
                        odict_Age_Cohort_Indiv_Count__Post_Sampling[key-intVSP_ID_Adjustment] = int(value)
                    pass
                pass
            
                ''' Sort the age cohorts backwards '''
                ''' Sort Age in DESCENDING order '''
                odictAgeCohortSamplePercentage_Sorted = OrderedDict(sorted(odictAgeCohortSamplePercentage.items(), key=lambda x: x[0], reverse=True))
                
                '''Convert percentages to sample proportions using the Total Sample Size'''
                int_Total_Target_Sample_Size = 0

                for intSampleAge, floatSampleCohortPercentage in odictAgeCohortSamplePercentage_Sorted.items():
                    
                    #DEBUG_ON
                    #if intSampleAge == 324 and int_SubSample_Quota == 400:
                    #    self.obj_Log_Default_Display.info("Debug point - Age is " + str(intSampleAge) + ' and subsample Quota is ' + str(int_SubSample_Quota))
                    #pass
                    self.obj_Log_Debug_Display.debug("Sampling Stratagy - Age is " + str(intSampleAge) + ' and now subsampled ' + str(int_Total_Target_Sample_Size) + ' of Quota ' + str(int_SubSample_Quota))
                    #DEBUG_OFF
                    
                    ''' Ignore the Max age value as it should be zero anyway ADN wont exist in the Age Cohort VSP sizes '''
                    if intSampleAge < (self.objSSParametersLocal.maxAge * 12):
                        
                        ''' Get actual size of cohort to check if this is exceeded by the cohort smaple size '''
                        #Adjust the VSP number to match the current ages in the pop
                        int_VSP_Size = odict_Age_Cohort_Indiv_Count__Post_Sampling[intSampleAge]
                        
                        ''' Get each cohort-specific sample size '''
                        
                        #int_Cohort_Sample_Size = int(round(round(Decimal(floatSampleCohortPercentage)*Decimal(int_SubSample_Quota),1),0)) #round to nearest integer
                        int_Cohort_Sample_Size = int(round(round(Decimal(floatSampleCohortPercentage)*Decimal(int_VSP_Size),1),0)) #round to nearest integer
                        
                        ''' If the current sample will exceed the quota dont...adjust the sample to bring the total sampled to the exact quota desired '''
                        int_Target_Quota_Check = int(int_Total_Target_Sample_Size + int_Cohort_Sample_Size)
                        if int_Target_Quota_Check > int_SubSample_Quota:
                            int_Cohort_Sample_Size = int_SubSample_Quota - int_Total_Target_Sample_Size
                            ''' The outer for loop should exit after this round when checking if the total samples = the desired quota '''
                        pass     
                                         
                        '''If the required cohort samples exceeds the size of the VSP '''
                        if int_Cohort_Sample_Size > int_VSP_Size:
                            int_Leftover_Samples = int_Cohort_Sample_Size - int_VSP_Size
                            ''' Sample the entire cohort '''
                            odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge] = odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge] + int_VSP_Size
                            ''' Reduce the actual cohort number by the number taken... which is all here '''
                            odict_Age_Cohort_Indiv_Count__Post_Sampling[intSampleAge] = 0
                            ''' Add to the total samples taken '''
                            int_Total_Target_Sample_Size += int_VSP_Size
                            
                            ''' The try to take from the next-youngest cohort until the letftovers are sampled '''
                            intSampleAge_NextYoungest = intSampleAge
                            while True:
                                intSampleAge_NextYoungest = intSampleAge_NextYoungest - 12
                                ''' If the next youngest cohort is less than 0 then all cohorts have been sampled withouth achieving the required quota '''
                                if intSampleAge_NextYoungest < 0:
                                    with Debug_Location() as obj_DebugLoc:
                                        str_Message_Location = obj_DebugLoc.Get_Debug_Location(bool_Short=True)
                                    pass
                                    str_Message = str_Message_Location + ' >> Not enough individuals in any age cohort to satisfy quota for Age: ' + str(intSampleAge) + ' Indivs to sample: ' + str(int_Cohort_Sample_Size) + ' at a percent of the VSP of : ' + str(floatSampleCohortPercentage)
                                    self.obj_Log_Default_Display.error(str_Message)
                                    raise ValueError(str_Message)
                                pass
                                int_Younger_Cohort_Size = odict_Age_Cohort_Indiv_Count__Post_Sampling[intSampleAge_NextYoungest]
                                if int_Leftover_Samples > int_Younger_Cohort_Size:
                                    int_Leftover_Samples = int_Leftover_Samples - int_Younger_Cohort_Size
                                    odict_Age_Cohort_Indiv_Count__Post_Sampling[intSampleAge_NextYoungest] = 0
                                    odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge_NextYoungest] = odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge_NextYoungest] + int_Younger_Cohort_Size
                                    ''' Add to the total samples taken '''
                                    int_Total_Target_Sample_Size += int_Younger_Cohort_Size
                                else:
                                    odict_Age_Cohort_Indiv_Count__Post_Sampling[intSampleAge_NextYoungest] = int_Younger_Cohort_Size - int_Leftover_Samples
                                    odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge_NextYoungest] = odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge_NextYoungest] + int_Leftover_Samples
                                    ''' Add to the total samples taken '''
                                    int_Total_Target_Sample_Size += int_Leftover_Samples                                    
                                    int_Leftover_Samples = 0
                                pass
                                                                    
                                if int_Leftover_Samples == 0:
                                    break
                                pass
                            pass
                        else:
#                             ''' Take the required samples from the cohort '''
#                             if intSampleAge in odict_Age_Cohort_Indiv_Count__Sampled.keys():
#                                 int_Older_Cohort_Samples = odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge]
#                                 odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge] = int_Older_Cohort_Samples + int_Cohort_Sample_Size
#                             else:
#                                 odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge] = int_Cohort_Sample_Size
#                             pass
                            ''' Take the required samples from the cohort '''
                            odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge] = odict_Age_Cohort_Indiv_Count__Sampled[intSampleAge] + int_Cohort_Sample_Size
                            ''' Reduce the actual cohort number by the number taken '''
                            odict_Age_Cohort_Indiv_Count__Post_Sampling[intSampleAge] = odict_Age_Cohort_Indiv_Count__Post_Sampling[intSampleAge] - int_Cohort_Sample_Size
                            ''' Add to the total samples taken '''
                            int_Total_Target_Sample_Size += int_Cohort_Sample_Size   
                        pass
                    pass
                    if int(int_Total_Target_Sample_Size) >= int_SubSample_Quota:
                        break
                    pass  
                pass

                #DEBUG_ON
                if globalsSS.Logger_Debug_AgeNe.bool_Debug_AgeNe:
                    ''' ACTUAL Individuals per age cohort BEFORE Sampling'''
                    odict_Logging = odict_Age_Cohort_Indiv_Count
                    odict_Logging = OrderedDict(sorted(odict_Logging.items(), key=lambda x: x[0]))
                    str_Message = '>>> Survival Stat: odict_Age_Cohort_Indiv_Count (with cohorts ADJUSTED by ' + str(intVSP_ID_Adjustment) + ': '
                    self.obj_Log_Debug_AgeNe.debug(str_Message + ' ; Total: ' + str(round(sum(collections__Counter(odict_Logging).values()),2)))
                    str_Message += ':::Age;Num\t'
                    for int_Age, value in odict_Logging.items():
                        str_Message += str(int(int_Age-intVSP_ID_Adjustment)) + ',' + str(value) + '\t'
                    pass 
                    self.obj_Log_Debug_AgeNe.debug(str_Message) 
                    
                    ''' ACTUAL Individuals per age cohort after sampling'''
                    odict_Logging = odict_Age_Cohort_Indiv_Count__Post_Sampling
                    odict_Logging = OrderedDict(sorted(odict_Logging.items(), key=lambda x: x[0]))
                    str_Message = '>>> Survival Stat: odict_Age_Cohort_Indiv_Count__Post_Sampling: '
                    self.obj_Log_Debug_AgeNe.debug(str_Message + ' ; Total: ' + str(round(sum(collections__Counter(odict_Logging).values()),2)))
                    str_Message += ':::Age;Num\t'
                    for int_Age, value in odict_Logging.items():
                        str_Message += str(int(int_Age)) + ',' + str(value) + '\t'
                    pass 
                    self.obj_Log_Debug_AgeNe.debug(str_Message) 

                                       
                    ''' ACTUAL Individuals SAMPLED per age cohort '''
                    odict_Logging = odict_Age_Cohort_Indiv_Count__Sampled
                    odict_Logging = OrderedDict(sorted(odict_Logging.items(), key=lambda x: x[0]))
                    str_Message = '>>> Survival Stat: odict_Age_Cohort_Indiv_Count__Sampled: '
                    self.obj_Log_Debug_AgeNe.debug(str_Message + ' ; Total: ' + str(round(sum(collections__Counter(odict_Logging).values()),2)))
                    str_Message += ':::Age;Num\t'
                    for int_Age, value in odict_Logging.items():
                        str_Message += str(int(int_Age)) + ',' + str(value) + '\t'
                    pass 
                    self.obj_Log_Debug_AgeNe.debug(str_Message) 
                    
                    #with globalsSS.Pause_Console() as obj_Pause:
                    #    obj_Pause.method_Pause_Console()                 
                pass                   
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass 
                
                return odict_Age_Cohort_Indiv_Count__Sampled, odict_Age_Cohort_Indiv_Count__Post_Sampling
            
            def method_SubSample_Age_Cohorts__Randomly_Increase_Or_Decrease_Cohorts_By_Sample_Number(self, int_Actual_SubSample_Quota, int_Desired_SubSample_Quota, odict_Age_Cohort_Indiv_Count, intVSP_ID_Adjustment, odict_Age_Cohort_Indiv_Count__To_Sample, odict_Age_Cohort_Indiv_Count__Sampled):

                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     
            
                ''' Initialise required variables '''
                #odict_Age_Cohort_Indiv_Count__Sampled = OrderedDict()
                odict_Age_Cohort_Indiv_Count__Post_Sampling = OrderedDict()
                for key, value in odict_Age_Cohort_Indiv_Count.items():
                    if key not in odict_Age_Cohort_Indiv_Count__Sampled.keys():
                        odict_Age_Cohort_Indiv_Count__Sampled[key-intVSP_ID_Adjustment] = 0
                    pass
                    odict_Age_Cohort_Indiv_Count__Post_Sampling[key-intVSP_ID_Adjustment] = value
                pass

                if int_Actual_SubSample_Quota > int_Desired_SubSample_Quota:
                    ''' Too many sub-samples were taken so we need to replace some '''
                    ''' Randomly remove the excess samples from the age cohort sub-sample distribution replacing them in the post sampled age cohort distribution'''
                    int_SubSamples = int_Actual_SubSample_Quota - int_Desired_SubSample_Quota
                    
                    ''' Get age cohorts that are to be sub-sampled '''
                    list_Age_Cohorts_To_SubSample = [key for key, value in odict_Age_Cohort_Indiv_Count__To_Sample.items() if value > 0]
                    #list_Age_Cohorts_Available_To_SubSample = [key for key in list_Age_Cohorts_To_SubSample if odict_Age_Cohort_Indiv_Count__Post_Sampling[key] != 0]
                    list_Age_Cohorts_SubSampled = random__sample(list_Age_Cohorts_To_SubSample, int_SubSamples)
                    ''' Decrease the randomly chosen cohort samples by 1 '''
                    for key in list_Age_Cohorts_SubSampled:
                        odict_Age_Cohort_Indiv_Count__Sampled[key] = odict_Age_Cohort_Indiv_Count__Sampled[key] - 1
                        odict_Age_Cohort_Indiv_Count__Post_Sampling[key] = odict_Age_Cohort_Indiv_Count__Post_Sampling[key] + 1
                    pass    
                elif int_Actual_SubSample_Quota < int_Desired_SubSample_Quota:
                    ''' Too few sub-samples were taken so we need to take more '''
                    ''' Randomly increse the samples in the age cohort sub-sample distribution up to the desired quota and remove them from the post sampling age cohort distribution'''
                    int_SubSamples = int_Desired_SubSample_Quota - int_Actual_SubSample_Quota
                    ''' Get age cohorts that are to be sub-sampled '''
                    list_Age_Cohorts_To_SubSample = [key for key, value in odict_Age_Cohort_Indiv_Count__To_Sample.items() if value > 0]
                    ''' MAKE SURE that they were not fully sampled previously and are now empoty in the post sampling age cohort dist'''
                    list_Age_Cohorts_Available_To_SubSample = [key for key in list_Age_Cohorts_To_SubSample if odict_Age_Cohort_Indiv_Count__Post_Sampling[key] > 0]
                    int_Age_Cohorts_Available_To_SubSample__Total_Indivs = 0
                    for key in list_Age_Cohorts_Available_To_SubSample:
                        int_Age_Cohorts_Available_To_SubSample__Total_Indivs += odict_Age_Cohort_Indiv_Count__Post_Sampling[key]
                    pass
                    
                    if int_Age_Cohorts_Available_To_SubSample__Total_Indivs < int_SubSamples:
                        with Debug_Location() as obj_DebugLoc:
                            str_Message_Location = obj_DebugLoc.Get_Debug_Location(bool_Short=True)
                        pass
                    
                        ''' Inform the user of this error'''
                        str_Value_Error_Message = '' + '\n'
                        
                        str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                        str_Value_Error_Message += str_Message
                        self.obj_Log_Default_Display.error(str_Message)
                        str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                        str_Value_Error_Message += str_Message + '\n' 
                        self.obj_Log_Default_Display.error(str_Message)
                        
                        str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator_WARNING
                        str_Value_Error_Message += str_Message
                        self.obj_Log_Default_Display.error(str_Message)
                        str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator_WARNING
                        str_Value_Error_Message += str_Message + '\n' 
                        self.obj_Log_Default_Display.error(str_Message)
                        
                        str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                        str_Value_Error_Message += str_Message 
                        self.obj_Log_Default_Display.error(str_Message)
                        str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                        str_Value_Error_Message += str_Message + '\n\n' 
                        self.obj_Log_Default_Display.error(str_Message)
                        #str_Message = str_Message_Location + ' >> Not enough available indivs: ' + str(int_Age_Cohorts_Available_To_SubSample__Total_Indivs) + ' to satisfy quota of indivs to sample: ' + str(int_SubSamples)
                        #str_Value_Error_Message += str_Message + '\n\n'
                        #self.obj_Log_Default_Display.error(str_Message)
                        
                        str_Message = str_Message_Location + ' >> NeOGen has failed, but we know why, and its easily fixed by editing your Sampling Strategy.'
                        str_Value_Error_Message += str_Message + '\n\n'
                        self.obj_Log_Default_Display.error(str_Message)
                        
                        str_Message = str_Message_Location + ' >> The requested MAXIMUM SAMPLE SIZE: ' + str(int_Desired_SubSample_Quota) + ' exceeds the total available individuals: ' + str(int_Actual_SubSample_Quota) + ' for the age cohorts specified by the SAMPLING PLAN'
                        str_Value_Error_Message += str_Message + '\n\n'
                        self.obj_Log_Default_Display.error(str_Message)
                        
                        str_Message = str_Message_Location + ' >> Please alter the SAMPLING STRATEGY and reduce the MAXIMUM SAMPLES to fewer than ' + str(int_Actual_SubSample_Quota) + ' samples.'
                        str_Value_Error_Message += str_Message + '\n\n'
                        self.obj_Log_Default_Display.error(str_Message)
                        
                        str_Message = str_Message_Location + ' >> ...or alter the Sampling Strategy SAMPLING PLAN to sample more age cohorts, or a larger proportion of each age cohort.'
                        str_Value_Error_Message += str_Message + '\n\n'
                        self.obj_Log_Default_Display.error(str_Message)

                        str_Message = str_Message_Location + ' >> Keep this window open as a reference, and read the above carefully. Then edit your Sampling Strategy as per the above recomendation, and run it again.'
                        str_Value_Error_Message += str_Message + '\n\n'
                        self.obj_Log_Default_Display.error(str_Message)

                        str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                        str_Value_Error_Message += str_Message
                        self.obj_Log_Default_Display.error(str_Message)
                        str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator
                        str_Value_Error_Message += str_Message + '\n\n' 
                        self.obj_Log_Default_Display.error(str_Message)
                                                                        
                        #str_Message = globalsSS.Output_Display_Constants.static_str_Message_Separator_WARNING
                        #str_Value_Error_Message += str_Message + '\n'
                        #self.obj_Log_Default_Display.error(str_Message)
                        ''' ABORT run '''
                        raise ValueError(str_Value_Error_Message)
                    else:
                        ''' Check if the # Subsamples required doesnt exceed the # Avialable Cohorts '''
                        int_Total_Age_Cohorts_Available_To_SubSample = len(list_Age_Cohorts_Available_To_SubSample)
                        if int_Total_Age_Cohorts_Available_To_SubSample <= int_SubSamples:
                            int_SubSamples_Available = int_Total_Age_Cohorts_Available_To_SubSample
                        else:    
                            int_SubSamples_Available = int_SubSamples
                        pass
                        list_Age_Cohorts_SubSampled = random__sample(list_Age_Cohorts_Available_To_SubSample, int_SubSamples_Available)
                        ''' Increase the randomly chosen cohort samples by 1 '''
                        for key in list_Age_Cohorts_SubSampled:
                            odict_Age_Cohort_Indiv_Count__Sampled[key] = odict_Age_Cohort_Indiv_Count__Sampled[key] + 1
                            odict_Age_Cohort_Indiv_Count__Post_Sampling[key] = odict_Age_Cohort_Indiv_Count__Post_Sampling[key] - 1
                        pass    
                    pass
                pass
            
                #DEBUG_ON
                if globalsSS.Logger_Debug_AgeNe.bool_Debug_AgeNe:
                    ''' ACTUAL Individuals per age cohort BEFORE Sampling'''
                    odict_Logging = odict_Age_Cohort_Indiv_Count
                    odict_Logging = OrderedDict(sorted(odict_Logging.items(), key=lambda x: x[0]))
                    str_Message = '>>> Survival Stat: odict_Age_Cohort_Indiv_Count (with cohorts ADJUSTED by ' + str(intVSP_ID_Adjustment) + ': '
                    self.obj_Log_Debug_AgeNe.debug(str_Message + ' ; Total: ' + str(round(sum(collections__Counter(odict_Logging).values()),2)))
                    str_Message += ':::Age;Num\t'
                    for int_Age, value in odict_Logging.items():
                        str_Message += str(int(int_Age-intVSP_ID_Adjustment)) + ',' + str(value) + '\t'
                    pass 
                    self.obj_Log_Debug_AgeNe.debug(str_Message) 
                    
                    ''' ACTUAL Individuals per age cohort after sampling'''
                    odict_Logging = odict_Age_Cohort_Indiv_Count__Post_Sampling
                    odict_Logging = OrderedDict(sorted(odict_Logging.items(), key=lambda x: x[0]))
                    str_Message = '>>> Survival Stat: odict_Age_Cohort_Indiv_Count__Post_Sampling: '
                    self.obj_Log_Debug_AgeNe.debug(str_Message + ' ; Total: ' + str(round(sum(collections__Counter(odict_Logging).values()),2)))
                    str_Message += ':::Age;Num\t'
                    for int_Age, value in odict_Logging.items():
                        str_Message += str(int(int_Age)) + ',' + str(value) + '\t'
                    pass 
                    self.obj_Log_Debug_AgeNe.debug(str_Message) 

                                       
                    ''' ACTUAL Individuals SAMPLED per age cohort '''
                    odict_Logging = odict_Age_Cohort_Indiv_Count__Sampled
                    odict_Logging = OrderedDict(sorted(odict_Logging.items(), key=lambda x: x[0]))
                    str_Message = '>>> Survival Stat: odict_Age_Cohort_Indiv_Count__Sampled: '
                    self.obj_Log_Debug_AgeNe.debug(str_Message + ' ; Total: ' + str(round(sum(collections__Counter(odict_Logging).values()),2)))
                    str_Message += ':::Age;Num\t'
                    for int_Age, value in odict_Logging.items():
                        str_Message += str(int(int_Age)) + ',' + str(value) + '\t'
                    pass 
                    self.obj_Log_Debug_AgeNe.debug(str_Message) 
                    
                    #with globalsSS.Pause_Console() as obj_Pause:
                    #    obj_Pause.method_Pause_Console()                 
                pass                   
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass 
                
                return odict_Age_Cohort_Indiv_Count__Sampled, odict_Age_Cohort_Indiv_Count__Post_Sampling
            
            def method_Sample_Simulated_Dataset(self, pop, objSharkSimOperation):
                
                pop_ToSample = pop
            
                bool_SubSample_Pop = True
                if bool_SubSample_Pop:
                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sample Simulated Population', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                    #LOGGING
                    
                    boolRemoveLoci = True
                    if boolRemoveLoci:
                        #CAPL_PANEL_19_V1
                        #listLoci = ['07CAPL','08CAPL','13CAPL','14CAPL','16CAPL','18CAPL','19CAPL','27CAPL','31CAPL','33CAPL','35CAPL','47CAPL','48CAPL','50CAPL','52CAPL','57CAPL','58CAPL','60CAPL','63CAPL']
                        #CAPL_SIMULATED_PANEL_19_V1
                        #listLoci = ['Locus-1',' Locus-2',' Locus-3',' Locus-4',' Locus-5',' Locus-6',' Locus-7',' Locus-8',' Locus-9',' Locus-10',' Locus-11',' Locus-12',' Locus-13',' Locus-14',' Locus-15',' Locus-16',' Locus-17',' Locus-18',' Locus-19']
                        #REAL CAPL Loci 13,47,60 - Have the least contributions to -LDNE, +LDNe, & even respectively at PCrit 0.05
                        #listLociToExclude = ['Locus-3','Locus-12','Locus-18']
                        #REAL CAPL Loci 14,58 - Have the next least contributions to -LDNE, +LDNe respectively at PCrit 0.05
                        listLociToExclude = ['Locus-3','Locus-4','Locus-12','Locus-17','Locus-18']
                        
                        #Clone the raw data each time
                        pop_Locus_Remove = pop.clone()
                        
                        #Get a pop with the locus removed
                        pop_Locus_Removed = self.method_Remove_Loci(pop_Locus_Remove, listLociToExclude)
                        
                        pop_ToSample = pop_Locus_Removed
                    pass
                    '''
                    Split the population into age_in_months VSPs
                    '''
                    boolUpdateInfoField = False
                    intMaxAge = self.objSSParametersLocal.maxAge
                    pop_ToSample = self.method_SplitLifeStagesInto_AgeInMonths_VSPs_By_AgeInMonths(pop_ToSample, intMaxAge, boolUpdateInfoField)
                    #Get the numbers of individuals per age chort VSP
                    with SSAnalysisHandler() as objSSAnalysisOperation:
                        odictVSPSizes = objSSAnalysisOperation.method_Get_VSP_Sizes(pop_ToSample, False)
                        #LOGGING
                        stringMessage = '>VSP & Sizes (not inc. 0 size VSPs): ' + str(odictVSPSizes) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        listVSPSizes = []
                        for valueTupleVSPSize in odictVSPSizes.items():
                            listVSPSizes.append(int(valueTupleVSPSize[1]))
                        stringMessage = '>VSPSizes (not inc. 0 size VSPs): ' + str(listVSPSizes) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)

                        #LOGGING                    
                    '''
                    Specify the required sampling regime
                    '''
                    #Sampling by PROPRTION applyed per cohort relative to its size across whole population
                    #10% of the population but taking each cohort sample relative to the size of the cohort
                    boolSampleSizeIsCohortAbsoluteRate = False
                    if boolSampleSizeIsCohortAbsoluteRate:                      
                        boolCohortDependentSample = True
                        
                        #floatPopProportionToSample = 0.10
                        #floatPopProportionToSample = 0.05
                        #floatPopProportionToSample = 0.03
                        #floatPopProportionToSample = 0.02
                        floatPopProportionToSample = 0.01
                        #floatPopProportionToSample = 0.005
                        
                        odictAgeCohortSampleNumbers = odictVSPSizes
                        odictAgeCohortSampleNumbers_Adjusted = objSSAnalysisOperation.method_Apply_Absolute_Rate_To_Number_Distribution(floatPopProportionToSample, odictAgeCohortSampleNumbers, True, 0)

                    pass
                
                    #Sampling by absolute number per VSP
                    boolSampleSizeIsCohortAbsoluteNumber = False
                    if boolSampleSizeIsCohortAbsoluteNumber:
                        boolCohortDependentSample = True
                        
                        odictAgeCohortSampleNumbers = OrderedDict([(0,7),(12,19),(24,17),(36,17),(48,7),(60,4),(72,2),(96,4),(108,11),(120,16),(132,32),(144,25),(156,56),(168,50),(180,67),(192,46),(204,29),(216,22),(228,13),(240,17),(252,7),(264,6),(276,0),(288,0),(300,1),(312,0),(324,1),(336,0),(348,0),(360,0)])
                        
                        #Embryo / Neonate only
                        odictAgeCohortSampleNumbers = OrderedDict([(0,1343),(12,0),(24,0),(36,0),(48,0),(60,0),(72,0),(96,0),(108,0),(120,0),(132,0),(144,0),(156,0),(168,0),(180,0),(192,0),(204,0),(216,0),(228,0),(240,0),(252,0),(264,0),(276,0),(288,0),(300,0),(312,0),(324,0),(336,0),(348,0),(360,0)])
                        odictAgeCohortSampleNumbers = OrderedDict([(0,2686),(12,0),(24,0),(36,0),(48,0),(60,0),(72,0),(96,0),(108,0),(120,0),(132,0),(144,0),(156,0),(168,0),(180,0),(192,0),(204,0),(216,0),(228,0),(240,0),(252,0),(264,0),(276,0),(288,0),(300,0),(312,0),(324,0),(336,0),(348,0),(360,0)])
                        odictAgeCohortSampleNumbers = OrderedDict([(0,5372),(12,0),(24,0),(36,0),(48,0),(60,0),(72,0),(96,0),(108,0),(120,0),(132,0),(144,0),(156,0),(168,0),(180,0),(192,0),(204,0),(216,0),(228,0),(240,0),(252,0),(264,0),(276,0),(288,0),(300,0),(312,0),(324,0),(336,0),(348,0),(360,0)])
                        odictAgeCohortSampleNumbers = OrderedDict([(0,10744),(12,0),(24,0),(36,0),(48,0),(60,0),(72,0),(96,0),(108,0),(120,0),(132,0),(144,0),(156,0),(168,0),(180,0),(192,0),(204,0),(216,0),(228,0),(240,0),(252,0),(264,0),(276,0),(288,0),(300,0),(312,0),(324,0),(336,0),(348,0),(360,0)])
                    pass
                
                    #Sampling by PROPRTION per VSP
                    boolSampleSizeIsCohortRateDist = False
                    if boolSampleSizeIsCohortRateDist:
                        boolCohortDependentSample = True

                        boolCAPL_FISHED_cohort_proportions = True
                        if boolCAPL_FISHED_cohort_proportions:
                        
                            #CAPL real catch cohort proportions
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.015267176),(12,0.040712468),(24,0.03562341),(36,0.03562341),(48,0.015267176),(60,0.007633588),(72,0.005089059),(84,0),(96,0.007633588),(108,0.022900763),(120,0.03307888),(132,0.066157761),(144,0.053435115),(156,0.117048346),(168,0.1043257),(180,0.139949109),(192,0.096692112),(204,0.061068702),(216,0.045801527),(228,0.027989822),(240,0.03562341),(252,0.015267176),(264,0.012722646),(276,0),(288,0),(300,0.002544529),(312,0),(324,0.002544529),(336,0),(348,0),(360,0)])
                        pass
                    
                        boolCAPL_random_sampling_MATURE_cohort_proportions = False
                        if boolCAPL_random_sampling_MATURE_cohort_proportions:
    
                            #CAPL random sampling MATURE cohort proportions
                            #Sample from:
                            #minMating age = 16*12 = 192
                            #To:
                            #maxAge = 31*12 = 372
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.0),(12,0.0),(24,0.0),(36,0.0),(48,0.0),(60,0.0),(72,0.0),(84,0.0), (96,0.0),(108,0.0),(120,0.0),(132,0.0),(144,0.0),(156,0.0),(168,0.0),(180,0.0),(192,0.0), \
                                                                       (204,0.0714),(216,0.0714),(228,0.0714),(240,0.0714),(252,0.0714),(264,0.0714),(276,0.0714),(288,0.0714),(300,0.0714),(312,0.0714),(324,0.0714),(324,0.0714),(336,0.0714),(348,0.0714),(360,0.0714)])
                        pass
                    
                        boolCAPL_random_sampling_ALL_cohort_proportions = False
                        if boolCAPL_random_sampling_ALL_cohort_proportions:
                            #CAPL random sampling ALL cohort proportions
                            #Sample from:
                            #embryo age = 0 months
                            #To:
                            #maxAge = 31*12 = 372
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.0323),\
                                                                       (12,0.0323),(24,0.0323),(36,0.0323),(48,0.0323),(60,0.0323),(72,0.0323),(84,0.0323), (96,0.0323),(108,0.0323),(120,0.0323),(132,0.0323),(144,0.0323),(156,0.0323),(168,0.0323),(180,0.0323),(192,0.0323), \
                                                                       (204,0.0323),(216,0.0323),(228,0.0323),(240,0.0323),(252,0.0323),(264,0.0323),(276,0.0323),(288,0.0323),(300,0.0323),(312,0.0323),(324,0.0323),(324,0.0323),(336,0.0323),(348,0.0323),(360,0.0323)])
                        pass

                        boolCAPL_random_sampling_ALL_cohort_proportions_X_NEONATE = False
                        if boolCAPL_random_sampling_ALL_cohort_proportions_X_NEONATE:
                            #CAPL random sampling ALL cohort proportions X NEONATE
                            #Sample from:
                            #Sub-adult age = 12 months
                            #To:
                            #maxAge = 31*12 = 372
                            odictAgeCohortSampleNumbers = OrderedDict([(0,0.0),\
                                                                       (12,0.0333),(24,0.0333),(36,0.0333),(48,0.0333),(60,0.0333),(72,0.0333),(84,0.0333), (96,0.0333),(108,0.0333),(120,0.0333),(132,0.0333),(144,0.0333),(156,0.0333),(168,0.0333),(180,0.0333),(192,0.0333), \
                                                                       (204,0.0333),(216,0.0333),(228,0.0333),(240,0.0333),(252,0.0333),(264,0.0333),(276,0.0333),(288,0.0333),(300,0.0333),(312,0.0333),(324,0.0333),(324,0.0333),(336,0.0333),(348,0.0333),(360,0.0333)])
                        pass

                        boolCAPL_random_sampling_NEONATE = False
                        if boolCAPL_random_sampling_NEONATE:
                            #CAPL random sampling NEONATE
                            #Sample from:
                            #embryo age = 0 months
                            odictAgeCohortSampleNumbers = OrderedDict([(0,1.0000),\
                                                                       (12,0.0000),(24,0.0000),(36,0.0000),(48,0.0000),(60,0.0000),(72,0.0000),(84,0.0000), (96,0.0000),(108,0.0000),(120,0.0000),(132,0.0000),(144,0.0000),(156,0.0000),(168,0.0000),(180,0.0000),(192,0.0000), \
                                                                       (204,0.0000),(216,0.0000),(228,0.0000),(240,0.0000),(252,0.0000),(264,0.0000),(276,0.0000),(288,0.0000),(300,0.0000),(312,0.0000),(324,0.0000),(324,0.0000),(336,0.0000),(348,0.0000),(360,0.0000)])
                        pass
                    pass
                 
                    #Get total poulation size
                    intPopSize = pop_ToSample.subPopSize()

                    boolSampleSizeIsNonCohortRandom = True
                    if boolSampleSizeIsNonCohortRandom:
                        boolCohortDependentSample = False
                        
                        #floatPopProportionToSample = 0.10
                        #floatPopProportionToSample = 0.05
                        #floatPopProportionToSample = 0.045
                        #floatPopProportionToSample = 0.040
                        #floatPopProportionToSample = 0.035
                        floatPopProportionToSample = 0.03
                        #floatPopProportionToSample = 0.025
                        #floatPopProportionToSample = 0.02
                        #floatPopProportionToSample = 0.015
                        #floatPopProportionToSample = 0.01
                        #floatPopProportionToSample = 0.005
   
                        intRandomSampleNumIndividuals = int(round(floatPopProportionToSample * intPopSize, 0))
                    pass


                    if boolCohortDependentSample:
                        '''
                        Adjust age_in_month value to match VSP numbers in the population
                        '''                    
                        if boolSampleSizeIsCohortAbsoluteNumber or boolSampleSizeIsCohortRateDist:
                            #Adjust the VSP number to match the current ages in the pop
                            intVSP_ID_Adjustment = 2
                            odictAgeCohortSampleNumbers_Adjusted = OrderedDict()
                            for keyVSP, valueNumToSample in odictAgeCohortSampleNumbers.items():
                                odictAgeCohortSampleNumbers_Adjusted[keyVSP+intVSP_ID_Adjustment] = valueNumToSample
                            pass

                            if boolSampleSizeIsCohortRateDist:  
                                #Convert the rates to actual numbers of individuals
                                odictAgeCohortSampleNumbers_Adjusted = objSSAnalysisOperation.method_Apply_Rate_Distribution_To_Number_Distribution(odictAgeCohortSampleNumbers_Adjusted, odictVSPSizes, True, 0)
                                if odictAgeCohortSampleNumbers_Adjusted == None:
                                    return True
                        '''
                        Prep the sampling specification for processing
                        '''
                        #Get a list of the VSPs to sample and a separate list of the sample size to take per VSP
                        odictAgeCohortVSPS_And_SampleNumbers = self.method_Cohort_Sampling_VSP_And_Sample_Size(pop_ToSample, odictAgeCohortSampleNumbers_Adjusted)

                
                        '''
                        Cohort dependent logging
                        '''
                        #LOGGING
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        stringMessage = '>Cohort Age Sample Specification: ' + str(odictAgeCohortSampleNumbers_Adjusted) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        stringMessage = '>Cohort Age Sample Spec Adjusted: ' + str(odictAgeCohortSampleNumbers_Adjusted) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        stringMessage = '>Cohort Age Sampling VSPs : ' + str(odictAgeCohortVSPS_And_SampleNumbers[0]) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        stringMessage = '>Cohort Age Sampling Numbers : ' + str(odictAgeCohortVSPS_And_SampleNumbers[1]) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        intRandomSampleNumIndividuals = sum(odictAgeCohortVSPS_And_SampleNumbers[1])
                        stringMessage = '>Cohort Age Sampling Total : ' + str(intRandomSampleNumIndividuals) +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        #LOGGING
                    
                    pass

                    '''
                    Specify the number of random samples
                    '''
                    intRandomSamplesToTake = 300
                    
                    #LOGGING
                    if boolSampleSizeIsCohortAbsoluteRate == False or boolSampleSizeIsNonCohortRandom == False:
                        floatPopProportionToSample = round(float(intRandomSampleNumIndividuals) / float(intPopSize), 3)
                    pass
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                    stringMessage = '>Randomly sample: ' + str(intRandomSamplesToTake) + '; Population proportion: ' + str(floatPopProportionToSample) + ' of ' + str(intPopSize) + ' = ' + str(intRandomSampleNumIndividuals) + ' individuals' +'\n'
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                
                    '''
                    Repeatedly sub-sample
                    '''
                    intFileOrder = 0
                    for intRandomLDneSample in  range(0, intRandomSamplesToTake):
                        
                        #LOGGING
                        if boolSampleSizeIsCohortAbsoluteRate == False or boolSampleSizeIsNonCohortRandom == False:
                            floatPopProportionToSample = round(float(intRandomSampleNumIndividuals) / float(intPopSize), 3)
                        pass
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        stringMessage = '>Random sample: ' + str(intRandomLDneSample) + ' of ' + str(intRandomSamplesToTake) + '; Population proportion: ' + str(floatPopProportionToSample) + ' of ' + str(intPopSize) + ' = ' + str(intRandomSampleNumIndividuals) + ' individuals' +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #LOGGING
                        '''
                        Take the sample
                        '''
                        if boolCohortDependentSample:
                            pop_SubSample = self.method_Cohort_Sampling_Specification_Draw(pop_ToSample, self.objSSParametersLocal, objSharkSimOperation, intRandomSampleNumIndividuals, odictAgeCohortVSPS_And_SampleNumbers)
                        else:
                            pop_SubSample = self.method_Draw_Random_Pop_SubSample(pop_ToSample, intRandomSampleNumIndividuals)
                            
                        '''
                        Report LDNe
                        '''
                        bool_Report_Ne = True
                        if bool_Report_Ne:
                            if boolCohortDependentSample:
                                listVSPsToReport = [(0, 0)]
                            else:
                                listVSPsToReport = [0]
                            pass
                        
                            pop_SubSample = self.method_SimStat_LDNe_Reporting(pop_SubSample, listVSPsToReport)
 
                            if boolCohortDependentSample:
                                listVSPsToReport = [0, 0]
                            else:
                                listVSPsToReport = [0]
                            pass
                                                 
                            strPrefixMessage = 'Sub-sample ' + str(intRandomLDneSample) + ' of ' + str(intRandomSamplesToTake) + ' : '
                            #listLDNePCritOutput=[0.05]
                            listLDNePCritOutput=[0,0.05,0.02,0.01]
                            #listLDNePCritOutput=[0.05,0.02,0.01,0]
                            self.method_Calculate_And_Output_LDNE_To_Console(pop_SubSample, listVSPsToReport, listLDNePCritOutput, listOutputDestinations, strPrefixMessage)
                            
                            self.method_Calculate_And_Output_LDNE_To_File(self.objSSParametersLocal, pop_SubSample, listVSPsToReport)

                        boolExportJacknifeGenpopFiles = True
                        if boolExportJacknifeGenpopFiles:
                            strFileNameSuffix_Export = '.gp_gspy'
                            strFileName_Export = '_S_' + str(floatPopProportionToSample) + 'N'
                            strFileNameCode_Export = 'SJKS'
                            strFileNameCount_Export = str(intRandomLDneSample)
                            intFileOrder += 1
                            #strFilename_Export = strFileName_Export + '_' + strFileNameCode_Export + '_' + str(intFileOrder)
                            #strFilePathAndNameFull_Export = self.objSSParametersLocal.outfilePath + self.objSSParametersLocal.strFileNameProgramPrefix + strFilename_Export + strFileNameCount_Export + strFileNameSuffix_Export
                            #strFilename_Export = strFileName_Export + '_' + strFileNameCode_Export + '_' + strFileNameCount_Export + 'A' + strFileNameSuffix_Export
                            strFilename_Export = strFileName_Export + '_' + strFileNameCode_Export + '_' + str(intFileOrder) + '_' + strFileNameCount_Export + strFileNameSuffix_Export
                            strFilePathAndNameFull_Export = self.objSSParametersLocal.outfilePath + self.objSSParametersLocal.strUniqueRunID + strFilename_Export                         
                        
                            '''
                            Create GENEPOP file
                            IMPORTANT - Allele adjust means the difference between an allele and missing data
                            if your data has zeros as missing data - set this to zero
                            if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                            '''
                            intAlleleAdjust = 1
                            bool_Prevent_Internal_Function_Console_Output = True
                            bool_Prevent_External_Function_Console_Output = True
                            
                            boolSuccess = self.method_Export_Genotypes(pop_SubSample, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))
                            intFileOrder += 1
         
                return True
            
            '''
            Locus Combo Unique combination subset processing
            '''
           
            def method_Generate_Unique_Loci_Combinations(self, listLoci, strLocus_Panel_ID):
                
                '''
                Construct locus combination subsets, create and ID for them, and save to a database table
                '''
                
                #LOGGING
                with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Saving Locus Combo IDs to file', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                #LOGGING
                
                listData = []
                strLocus_Full_Name_List_Ordered_For_Combo_ID = ','.join(str(strLocus) for strLocus in listLoci)
                #strLocus_Panel_ID = 'CAOB'
                strSS_Analysis_Sampling_Locus_Combos_Run_ID = self.objSSParametersLocal.strUniqueRunID
                
                '''
                Systematically construct locus combination IDs
                '''
           
#                import string
                
                
#                 for i, x in enumerate(listLoci):
#                     x.label = string.uppercase[i]       
                
                #Create a numbered list of loci
                listLociEnumerated = list(enumerate(listLoci))
                
                #Create all the locus combinations
#                import itertools
                intLocusComboIDCount = 0
                for L in range(0, len(listLociEnumerated)+1):

                    #DEBUG_ON
                    #if intLocusComboIDCount > 100:
                    #    break
                    #pass
                    #DEBUG_ON

                    for tupSelectedLociSubset in itertools.combinations(listLociEnumerated, L):

                        #DEBUG_ON
                        #if intLocusComboIDCount > 100:
                        #    break
                        #pass
                        #DEBUG_ON
 
                        #DEBUG_ON
                        #print(tupSelectedLociSubset)                
                        #with SSOutputHandler() as objSSOutputOperation:
                        #    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        #    listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        #    stringMessage = '\n' + '>Locus list:' + str(listLociEnumerated)
                        #    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #    stringMessage = '>Locus combo selected:' + str(tupSelectedLociSubset)
                        #    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #   objSSOutputOperation.method_Pause_Console()
                        #DEBUG_OFF
            
                        #Construct locus combo ID
                        #For every locus in a locus combination...
                        #Replace the locus with a 1 indicating that it was selected as part of the combo
                        #Repeat the process and replace all non-selected loci with a 0
                        
                        #Skip combinations that dont make sense
                        if ((len(tupSelectedLociSubset) < 1) or \
                            (len(tupSelectedLociSubset) == len(listLociEnumerated)-1) or \
                            (len(tupSelectedLociSubset) == len(listLociEnumerated))):
                            pass
                        else:
                            
                            #Copy the list so that it can be altered
                            listLociEnumeratedForExclusionID = list(listLociEnumerated)
                            listLociEnumeratedForInclusionID = list(listLociEnumerated)

                            for tupSelectedLocus in tupSelectedLociSubset:
                                for intIndex, tupValue in enumerate(listLociEnumeratedForExclusionID):  
                                    if tupSelectedLocus == tupValue:
                                        listLociEnumeratedForExclusionID[intIndex] = 1
                                        break
                                    else:
                                        listLociEnumeratedForInclusionID[intIndex] = 0
                                    pass
                                pass
                            pass
                            
                            #DEBUG_ON
                            #print(listLociEnumeratedForExclusionID)                
                            #   objSSOutputOperation.method_Pause_Console()
                            #DEBUG_OFF
                            
                            for intIndex, item in enumerate(listLociEnumeratedForExclusionID):
                                if item == 1:
                                    listLociEnumeratedForInclusionID[intIndex] = 0
                                else:
                                    listLociEnumeratedForExclusionID[intIndex] = 0
                                    listLociEnumeratedForInclusionID[intIndex] = 1
                            pass
                            
                            #DEBUG_ON
                            #print(listLociEnumeratedForExclusionID)                
                            #print(listLociEnumeratedForInclusionID)
                                #objSSOutputOperation.method_Pause_Console()
                            #DEBUG_OFF
                            
                            #with SSOutputHandler() as objSSOutputOperation:
                            #    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            #    listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]                            #    #
                            #
                            #    stringMessage = '>LocusComboExclusionID: ' + str(listLociEnumeratedForExclusionID)
                            #    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #    #
                            #    stringMessage = '>LocusComboInclusionID: ' + str(listLociEnumeratedForInclusionID)
                            #    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                #objSSOutputOperation.method_Pause_Console()
                            #DEBUG_OFF
                            
                            strLocus_Exclusion_Combo_Binary_ID = ''.join(str(strID) for strID in listLociEnumeratedForExclusionID)
                            strLocus_Exclusion_Combo_Integer_ID = str(int(strLocus_Exclusion_Combo_Binary_ID, 2))
                            
                            strLocus_Inclusion_Combo_Binary_ID = ''.join(str(strID) for strID in listLociEnumeratedForInclusionID)
                            strLocus_Inclusion_Combo_Integer_ID = str(int(strLocus_Inclusion_Combo_Binary_ID, 2))
                            
                            
#                             for strItem in listLociEnumeratedForExclusionID: 
#                                 strLocus_Exclusion_Combo_Binary_ID += strItem
#                             pass
#                         
#                             strLocus_Inclusion_Combo_Binary_ID = ''
#                             for strItem in listLociEnumeratedForInclusionID: 
#                                 strLocus_Inclusion_Combo_Binary_ID += strItem
#                             pass

                            #DEBUG_ON
                            #with SSOutputHandler() as objSSOutputOperation:
                                #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                #listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]                            #    stringMessage = '>Locus combo Count: ' + str(intLocusComboIDCount)
                            #    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #    #
                            #    stringMessage = '>Locus_Exclusion_Binary_Combo_ID: ' + strLocus_Exclusion_Combo_Binary_ID + '; Locus_Exclusion_Combo_Integer_ID: ' + strLocus_Exclusion_Combo_Integer_ID
                            #    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #    #
                            #    stringMessage = '>Locus_Inclusion_Combo_Binary_ID: ' + strLocus_Inclusion_Combo_Binary_ID + '; Locus_Inclusion_Combo_Integer_ID: ' + strLocus_Inclusion_Combo_Integer_ID + '\n'
                            #    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #    #objSSOutputOperation.method_Pause_Console()
                            #DEBUG_OFF

                            '''
                            Assemble locus combo record
                            '''
                                
                                
                            listData = []       
                            
                            
                            listData.append(str(intLocusComboIDCount)) #Col 0
                            listData.append(strLocus_Inclusion_Combo_Integer_ID) #Col 1
                            listData.append(strLocus_Inclusion_Combo_Binary_ID) #Col 2
                            listData.append(strLocus_Exclusion_Combo_Integer_ID) #Col 3
                            listData.append(strLocus_Exclusion_Combo_Binary_ID) #Col 4
                            listData.append(strLocus_Full_Name_List_Ordered_For_Combo_ID) #Col 5
                            listData.append(strLocus_Panel_ID) #Col 6
                            listData.append(strSS_Analysis_Sampling_Locus_Combos_Run_ID) #Col 7
                            
                            '''
                            Save locus combo record to file for later import
                            '''

                            #LOGGING
                            with SSOutputHandler() as objSSOutputOperation:
                                #listOutputDestinations = ['console', self.objSSParametersLocal.strOutputFileName_LocusCombos]
                                listOutputDestinations = [self.objSSParametersLocal.strOutputFileName_LocusCombos]
                                strPrefixMessage = ''
                                strData = ";".join(listData)
                                objSSOutputOperation.methodOutput_Output_Sampling_Locus_Combo_Info(listOutputDestinations, strPrefixMessage, False, False, strData)
                            #LOGGING
                                           
                            #boolSuccessful = self.method_Database_Unique_Loci_Combinations(objDatabaseOperation, objSSDatabaseOperation, listData)
                        
                            intLocusComboIDCount += 1
                        pass
                pass
                
                #LOGGING
                with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, '>Finished saving ' + str(intLocusComboIDCount) + ' LocusComboIDs', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                #LOGGING
               
                return True

            def method_Load_Locus_Combos_From_File(self, strInputFileName_LocusCombos):

                '''
                Open Locus Combo file
                '''
                
                with FileHandler() as objFileOperation:
                    fileHandle = objFileOperation.fileOpen(strInputFileName_LocusCombos, 'read')
                    readerCSV = csv.reader(fileHandle, delimiter=';', quotechar='|', lineterminator='\r\n')
                
#                 fileHandle.close()
                
#                 tupReturn = (readerCSV, fileHandle )
#                 
#                 return tupReturn
                
                
                return readerCSV, fileHandle
            
            def method_Database_Load_Locus_Combos_From_File_To_Datbase(self, objDatabaseOperation, strInputFileName_LocusCombos):

                '''
                Open Locus Combo file
                '''
                
                with FileHandler() as objFileOperation:
                    fileHandle = objFileOperation.fileOpen(strInputFileName_LocusCombos, 'read')
                    readerCSV = csv.reader(fileHandle, delimiter=';', quotechar='|', lineterminator='\r\n')

                '''
                Initialise database information
                '''
                with SSDatabaseHandler() as objSSDatabaseOperation:
                    objSSDatabaseOperation.property_stringSQLDBName = 'genescape_141029'
                    objSSDatabaseOperation.property_stringSQLTableName = 'ss_analysis_sampling_locus_combinations'
                    objSSDatabaseOperation.property_ListColumns = [0,1,2,3,4]

                '''
                Get each locus combo record from file and load to database
                '''
                                
                intLocusComboIDCount = 0
                for lineCSV in readerCSV:
                    
                    boolSuccessful = self.method_Database_Unique_Loci_Combinations(objDatabaseOperation, objSSDatabaseOperation, lineCSV)
            
                intLocusComboIDCount += 1
                
                return True
            
            def method_Database_Get_Table_Cursor_And_Field_Names(self, objDatabaseOperation, stringSQLDBName, stringSQLTableName):
                
                with SSDatabaseHandler() as objSSDatabaseOperation:
                    
                    '''
                    Specify database and table details
                    '''

                    objSSDatabaseOperation.property_stringSQLDBName = stringSQLDBName
                    objSSDatabaseOperation.property_stringSQLTableName = stringSQLTableName

                    '''
                    Perform a DB operations and return a cursor full of results
                    '''
                    
                    objSSDatabaseOperation.property_SQLStatementType ='SELECT'
                    objSSDatabaseOperation.property_stringSQLSelectLIMITRows = 1 #If 0 them LIMIT will be omitted from SELECT
                    stringSQL = objSSDatabaseOperation.method_GenerateSQLSELECTStatementForFieldNamesInitilization()
                    #eg. "SELECT * FROM Samples LIMIT 1;"
    
                    dbCursor = objDatabaseOperation.method_DBSQLSELECTOperation(objSSDatabaseOperation.property_intConnection, stringSQL)

                    '''
                    Get field names from cursor
                    '''
                    
                    listFieldNames = objDatabaseOperation.method_GetFieldDescriptionInfoListForCursor(dbCursor, 0)

                    tupReturn = (dbCursor, listFieldNames)
                    
                return tupReturn
 
 
            def method_Database_Get_All_Loci_Combos_For_A_Specific_Run(self, objDatabaseOperation, objSSDatabaseOperation, listData):
            
                '''
                Get all locus combo records for this LocusCombo run
                '''

                '''
                Prepare SELECT
                '''
                strSQL_Table_Name = objSSDatabaseOperation.property_stringSQLTableName
                strSS_Analysis_Sampling_Locus_Combos_Run_ID = listData[objSSDatabaseOperation.property_ListColumns[4]]
                
                #stringSQL = 'SELECT Locus_Combo_UID FROM locus_combos WHERE Locus_Combo_Run_ID = ' + strLocusComboRunID + ' AND Locus_Combo = ' + "'" + strLocusCombo + "'" + ';' 
                stringSQL = 'SELECT Locus_Combo_UID FROM ' + strSQL_Table_Name + ' WHERE SS_Analysis_Sampling_Locus_Combos_Run_ID = ' + "'" + strSS_Analysis_Sampling_Locus_Combos_Run_ID + "'" + ';' 
                
                #DEBUG_ON
                print(stringSQL)
                #DEBUG_OFF
                
                #Execute SQL
                dbCursor = objDatabaseOperation.method_DBSQLSELECTOperation(objSSDatabaseOperation.property_intConnection, stringSQL)
                
                #if dbCursor has results:
                rowsLocusComboRecords = dbCursor.fetchall()
                if len(rowsLocusComboRecords) > 0:
                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        #
                        stringMessage = '> SQL; ' + stringSQL
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #
                        stringMessage = '> Records returned' + str(len(rowsLocusComboRecords))
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #LOGGING
                else:
                    #Records dont exist so error
                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        #
                        stringMessage = '> SQL; ' + stringSQL
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #
                        stringMessage = '> ERROR getting records from loci table - records should ALWAYS exist; '
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #LOGGING
                
                return rowsLocusComboRecords
                           
            def method_Database_Unique_Loci_Combinations(self, objDatabaseOperation, objSSDatabaseOperation, listData):
                
                '''
                CREATE TABLE IF NOT EXISTS `genescape_141029`.`ss_analysis_sampling_locus_combinations` (
                  `Locus_Combo_UID` INT(11) NOT NULL,
                  `Locus_Inclusion_Combo_ID` VARCHAR(45) NULL DEFAULT NULL,
                  `Locus_Exclusion_Combo_ID` VARCHAR(45) NULL DEFAULT NULL,
                  `Locus_Full_Name_List_Ordered_For_Combo_ID` VARCHAR(1000) NULL DEFAULT NULL,
                  `Locus_Panel_ID` VARCHAR(45) NULL DEFAULT NULL,
                  `SS_Analysis_Sampling_Locus_Combos_Run_ID` VARCHAR(45) NULL DEFAULT NULL,
                  PRIMARY KEY (`Locus_Combo_UID`))
                '''
                #LOGGING
                with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                    stringMessage = '>INSERTING locus combo record into database:' + str(listData) +'\n'
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                #LOGGING
                
                intProcessingErrorCount = 0
                intSQLSuccessfullINSERTCount = 0
                intSQLFailedINSERTCount = 0
                intSQLTransactionCount = 1
                intSQLTransactionTotal = 2
                intSQLSuccessCount = 0
                intSQLFailedCount = 0
                intSQLSuccessTotal = 0
                intSQLFailedTotal = 0
                
                '''
                Check if LocusCombo already exists for this LocusCombo run
                '''
                
                intLocusFID = 0
                listLocusComboUIDsForRun = []
                
                '''
                Prepare SELECT
                '''
                strSQL_Table_Name = objSSDatabaseOperation.property_stringSQLTableName
                strSS_Analysis_Sampling_Locus_Combos_Run_ID = listData[objSSDatabaseOperation.property_ListColumns[4]]
                strLocus_Inclusion_Combo_ID = listData[objSSDatabaseOperation.property_ListColumns[0]]
                
                #stringSQL = 'SELECT Locus_Combo_UID FROM locus_combos WHERE Locus_Combo_Run_ID = ' + strLocusComboRunID + ' AND Locus_Combo = ' + "'" + strLocusCombo + "'" + ';' 
                stringSQL = 'SELECT Locus_Combo_UID FROM ' + strSQL_Table_Name + ' WHERE SS_Analysis_Sampling_Locus_Combos_Run_ID = ' + "'" + strSS_Analysis_Sampling_Locus_Combos_Run_ID + "'" + ' AND Locus_Inclusion_Combo_ID = ' + "'" + strLocus_Inclusion_Combo_ID + "'" + ';' 
                
                #DEBUG_ON
                print(stringSQL)
                #DEBUG_OFF
                
                #Execute SQL
                dbCursor = objDatabaseOperation.method_DBSQLSELECTOperation(objSSDatabaseOperation.property_intConnection, stringSQL)
                
                #if dbCursor has results:
                rows = dbCursor.fetchall()
                if len(rows) > 0:
                    intProcessingErrorCount += 1
                    #LOGGING
                    #with SSOutputHandler() as objSSOutputOperation:
                    listFields = []
                    listFields.append('Locus_Combo_Run_ID')
                    listFields.append('Locus_Combo')
                    listFieldData = []
                    listFieldData.append(strSS_Analysis_Sampling_Locus_Combos_Run_ID, strLocus_Inclusion_Combo_ID)
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                    #
                    stringMessage = '> SQL; ' + stringSQL
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #
                    stringMessage = '> ERROR getting' + str(listFields) + ' from loci table - record should NEVER exist; ' + str(listFieldData)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #LOGGING
                else:
                    #Record doesnt exist so INSERT it but get the next primary key value first
                    
                    stringSQL = 'SELECT MAX(Locus_Combo_UID) FROM ' + strSQL_Table_Name + ';'

                    #DEBUG_ON
                    print(stringSQL)
                    #DEBUG_OFF
                   
                    dbCursor = objDatabaseOperation.method_DBSQLSELECTOperation(objSSDatabaseOperation.property_intConnection, stringSQL)
                    #if dbCursor has results:
                    rows = dbCursor.fetchall()
                    if rows[0][0] == None:
                        #No Records exist at all in the table 
                        intLocusComboUID = 1
                    else:
                        #Record exists - Generate next UID
                        intLocusComboUID = rows[0][0]+1
                    
                    #Store the UID
                    listLocusComboUIDsForRun.append(intLocusComboUID)
                
                    '''
                    Perform INSERT of locus_combos record
                    '''
                    #Reinitialise dbCursor to get field names for INSERT into table locus_alleles
                    #Perform a DB operations and return a cursor full of results
                    #Return the field names for the table at the same time
                    tupCursorAndListFields = self.method_Database_Get_Table_Cursor_And_Field_Names(objDatabaseOperation, objSSDatabaseOperation.property_stringSQLDBName, objSSDatabaseOperation.property_stringSQLTableName)
                    dbCursor = tupCursorAndListFields[0]
                    listFieldNames = tupCursorAndListFields[1]
                    
                    objSSDatabaseOperation.property_listFieldNames = listFieldNames #If empty list or None SELECT * is assumed
                    objSSDatabaseOperation.property_SQLStatementType ='INSERT'
                    
                    stringSQLInsertPrefix = objSSDatabaseOperation.method_GenerateSQLInsertStatementFieldsPrefix()

                    listColumnData = []
                    stringSQL = ''
                    #for intCSVColumn in GSPYDatabaseOperation.property_ListCSVColumns:
                    #listColumnData= [str(intLocusAlleleNextUID), str(intLocusFID), stringAllele]
                    
                    listColumnData = [str(intLocusComboUID)] + listData    
                    objSSDatabaseOperation.property_listInsertData = listColumnData
                    stringSQL = objSSDatabaseOperation.method_GenerateSQLInsertStatementAddDataSuffixFromList(stringSQLInsertPrefix, False)
                    
                    #DEBUG_ON
                    print(stringSQL)
                    #DEBUG_OFF
                    
                    boolSuccessful = objDatabaseOperation.method_DBSQLINSERTOperation(objSSDatabaseOperation.property_intConnection, stringSQL)
                    if boolSuccessful:
                        intSQLSuccessfullINSERTCount += 1
                        #Perform DB Commit
                        objDatabaseOperation.method_PerformSQLCommitWithCursor(dbCursor) 
                    else:
                        intSQLFailedINSERTCount += 1

                    #with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                    stringMessage = '> # Transaction;' + str(intSQLTransactionCount) + '> INSERT statement success; ' + str(boolSuccessful) +'> with SQL;' + stringSQL
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #END - INSERT locus_combos record

                    '''
                    #Print a header message to encapsulate all the dynamically created and printed SQL statements following          
                    '''
                    #LOGGING
                    #with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                    stringMessage = '> INSERTing records...'
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #LOGGING
                                     
#                     #Print final message footer after all SQL statements have been printed
#                     with SSOutputHandler() as SSOutputOperation:
#                         listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
#                         SSOutputOperation.methodOutput_RunGeneralMessageFooter(listOutputDestinations, '')
                            
                    #Perform DB Commit
                    objDatabaseOperation.method_PerformSQLCommitWithCursor(dbCursor)   
        
                    #LOGGING
                    intSQLSuccessTotal = intSQLSuccessfullINSERTCount
                    intSQLFailedTotal = intSQLFailedINSERTCount
                    #with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                    stringMessage = '> # SQL INSERT Transactions attempted=;' + str(intSQLTransactionTotal-1) + ' > # Succeeded=;' + str(intSQLSuccessTotal) + ' > # Failed=;' + str(intSQLFailedTotal) + ' > See log for detail'
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #LOGGING
                    
                    #Close the cursor
                    dbCursor.close()

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        stringMessage = '>INSERT complete' + '\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #LOGGING
                    
                    return True

            '''
            Ne2_Win_DLL - Genepop File Processing
            '''
                               
            def method_Process_Genepop_File_Using_Ne2_Win_DLL(self, bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_WorkingFolder, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit):

                #LOGGING
                str_Log_Message = 'Processing Genepop File with Ne2_Win_DLL'
                if self.objSSParametersLocal == None: 
                    self.obj_Log_Debug_Display.debug(str_Log_Message)
                else:
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, str_Log_Message, boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                pass
                #LOGGING

                '''
                Perform Ne2_Win_DLL processing
                '''
                bool__Ne2_Win_DLL_Processing = True
                if bool__Ne2_Win_DLL_Processing:
                
                    #LOGGING
                    str_Log_Message_1 = '#################################################################################'
                    str_Log_Message_2 = '>File #: ' + str(intGenepopFileCount) + ' Ne2 processing file: ' + strFilename_Genepop
                    str_Log_Message_3 = '#################################################################################'
                    if self.objSSParametersLocal == None: 
                        self.obj_Log_Debug_Display.debug(str_Log_Message_1)
                        self.obj_Log_Debug_Display.debug(str_Log_Message_2)
                        self.obj_Log_Debug_Display.debug(str_Log_Message_3)
                    else:                    
                        with SSOutputHandler() as objSSOutputOperation:
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            #listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, str_Log_Message_1, True)
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, str_Log_Message_2, True)
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, str_Log_Message_3, True)
                            #objSSOutputOperation.method_Pause_Console()
                        pass
                    pass
                    #LOGGING                    
                    
                    obj_SSNe2_Win_DLL = object_SSNe2_Win_DLL([self.objSSParametersLocal])
                    
                    obj_SSNe2_Win_DLL.bool_Suppress_ALL_LDNe_Console_Output = bool_Suppress_ALL_LDNe_Console_Output
                    
                    obj_SSNe2_Win_DLL.libraryObject = obj_SSNe2_Win_DLL.func_Load_Library__Ne2_Win_DLL(obj_SSNe2_Win_DLL.strDLL_Path_And_File)
                    
                    '''
                    ----------------------------------------
                    Set the General Run parameters for the Ne2 run
                    ----------------------------------------
                    '''    
                    obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.char_Run_ID = strUniqueRunID
                    obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.char_Run_OutputResultsPath = str_OutputResultsPath
                    obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.char_Run_InputDataFilePath = strFilePath_WorkingFolder + '\\'
                    obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.char_Run_InputDataFileName = strFilename_Genepop #+ strFileNameSuffix_Export
                    #obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.char_Run_InputDataFileName = 'test.gp_gspy' #+ strFileNameSuffix_Export
                    
                    obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.int_Run_Count = intGenepopFileCount
                    
                    ''' Set parameters fo the Ne2 LDNe TAB Delim file ''' 
                    if intGenepopFileCount == 0:
                        ''' Use NOT_APPEND to clear file and write headers '''
                        obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.int_Run_OutputResultsFile_NE_AppendResults = object_SSNe2_Win_DLL.struct_t__Ne2_Input_Params.struct_t__Ne2_Input_Params__General_Run.NE2_RESULTS_FILE_NE__NOT_APPEND
                    else:
                        ''' Use APPEND to prevent headers for subsequent runs '''
                        obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.int_Run_OutputResultsFile_NE_AppendResults = object_SSNe2_Win_DLL.struct_t__Ne2_Input_Params.struct_t__Ne2_Input_Params__General_Run.NE2_RESULTS_FILE_NE__APPEND
                    pass
                    
                    obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.bool_Run_Last_Run = False # We dont know how many records there are so no way to set this
                    
                    '''
                    ----------------------------------------
                    Set the LDNe method parameters
                    ----------------------------------------
                    '''
                    #obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__Method_LDNe.list_float_Array_PCrits = [0.02]
                    obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__Method_LDNe.list_float_Array_PCrits = [float_LDNe_PCrit]
                    '''
                    Get the Ne2 results for the GENEPOP file
                    '''
                    
                    boolSuccess = obj_SSNe2_Win_DLL.func_Get_Ne2_Results()
                
                    #obj_SSNe2_Win_DLL.c_struct_t__Ne2_Output_LDNe_LDNe.c_struct_t__Ne2_Output_LDNe_LDNe_Ne_Info.c_floatLDNe
                    #print("c_floatLDNe                      : " + str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_LDNe_Ne_Info.c_floatLDNe))

                pass

                return obj_SSNe2_Win_DLL
            '''
            Ne2_Win_DLL - Locus Combo File Processing
            '''
                               
            def method_Empirical_Dataset_Locus_Combination_Sampling_From_File_Using_Ne2_Win_DLL(self, strFilePathAndName_ImportGenotypes, strInputFileName_LocusCombos):

                #LOGGING
                with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Creating and processing locus combo files', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                #LOGGING

                bool_Get_Locus_Combos_And_Remove_Loci = True
                if bool_Get_Locus_Combos_And_Remove_Loci:
                    
                    '''
                    Import the genotype file from which to remove loci combos
                    '''
                    
                    pop_Imported = self.method_Import_Genotypes(strFilePathAndName_ImportGenotypes)
                    
                    '''
                    Get all locus combos for a specific run from the database
                    '''
                    
                    tupReaderAndFileHandle = self.method_Load_Locus_Combos_From_File(strInputFileName_LocusCombos)
                    fileHandle = tupReaderAndFileHandle[1]
                    readerCSV = tupReaderAndFileHandle[0]
                    
                    '''
                    Remove each locus combo from the empirical data
                    '''
                    intFilesPerFolder = 250
                    intFolderCount = -1
                    intLineCount = -1
                    intFilesPerFolderCount = -1
                    for lineCSV in readerCSV:

                        intLineCount += 1
                        intFilesPerFolderCount += 1
                        
                        #DEBUG_ON
                        if intLineCount == 10:
                            break
                        #DEBUG_OFF

                        '''
                        Create the next working folder
                        '''
                        if (intFilesPerFolderCount == 0) or (intFilesPerFolderCount == intFilesPerFolder):

                            intFilesPerFolderCount = 0
                            intFolderCount += 1
                            
                            strWorkingFolder = str(intFolderCount) + '\\' + 'Ne2Bulk'
                            strFilePath_WorkingFolder = self.objSSParametersLocal.outfilePath + strWorkingFolder
    
                            #Create the folder if it doesnt exist
                            with FileHandler() as objFileOperation:
                                if objFileOperation.method_Path_Exists(strFilePath_WorkingFolder) == False:
                                    objFileOperation.method_Create_Path(strFilePath_WorkingFolder)
                                pass
                            pass

                            #LOGGING
                            with SSOutputHandler() as objSSOutputOperation:
                                listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Created new working folder and continuing processing', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                            #LOGGING
                        
                        '''
                        Get the locus combo information and create the appropriate GENEPOP file
                        '''
                       
                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            stringMessage = '\n' + '>' + str(intLineCount)+ ' Reading Locus Combo record: ' + ",".join(lineCSV)
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #objSSOutputOperation.method_Pause_Console()
                        #LOGGING
                         
                        intLocus_Combo_Count = int(lineCSV[0])
                        intLocus_Inclusion_Combo_Integer_ID = int(lineCSV[1])
                        strLocus_Inclusion_Combo_Binary_ID = lineCSV[2]
                        intLocus_Exclusion_Combo_Integer_ID = int(lineCSV[3])
                        strLocus_Exclusion_Combo_Binary_ID = lineCSV[4]
                        strLocus_Full_Name_List_Ordered_For_Combo_ID = lineCSV[5] 
                        
                        '''
                        Generate a list of named loci to exclude from the strLocusComboExclusionID
                        '''
                        #listLociToExclude = [] 
                        listLoci = strLocus_Full_Name_List_Ordered_For_Combo_ID.split(",")
                        listLociToExclude = []
                        listLociExclusionID = list(strLocus_Exclusion_Combo_Binary_ID)
                        
                        intCount = 0
                        for strExclusionBit in listLociExclusionID:
                            if int(strExclusionBit) == 1:
                                listLociToExclude.append(listLoci[intCount])
                            pass
                            intCount += 1
                        pass
 
                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            #
                            stringMessage = '> Count: ' + str(intLocus_Combo_Count) + '; Locus_Inclusion_Combo_Integer_ID: ' + str(intLocus_Inclusion_Combo_Integer_ID) + '; Locus_Inclusion_Combo_Binary_ID: ' + strLocus_Exclusion_Combo_Binary_ID + '; Removing loci: ' + ",".join(listLociToExclude)
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #
                            stringMessage = '> Count: ' + str(intLocus_Combo_Count) + '; Locus_Exclusion_Combo_Integer_ID: ' + str(intLocus_Exclusion_Combo_Integer_ID) + '; Locus_Exclusion_Binery_Combo_ID: ' + strLocus_Exclusion_Combo_Binary_ID + '; Removing loci: ' + ",".join(listLociToExclude)
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #objSSOutputOperation.method_Pause_Console()
                        #LOGGING
    
                        '''
                        Remove loci combo from genotypes and generate a Genepop file for Ne2 processing
                        '''
        
                        #Clone the raw data each time
                        pop_Locus_Remove = pop_Imported.clone()
                        
                        #Get a pop with the locus removed
                        pop_Locus_Removed = self.method_Remove_Loci(pop_Locus_Remove, listLociToExclude)
                    
                        #Export that pop as a Genepop file
                        with FileHandler() as objFileOperation:
                            tupFilePathNameAndExt = objFileOperation.method_Get_FileNameAndExtension_From_FileName(strFilePathAndName_ImportGenotypes)
                            strPathFileName_ImportWOSuffix = objFileOperation.method_Get_FileName_From_PathAndFileName(tupFilePathNameAndExt[0])
                        
#                         strFileNameSuffix_Export = '.lc'
#                         strFileNameCode_Export = 'EESL'
                        strFileNameSuffix_Export = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__Locus_Jackknifing
                        strFileNameCode_Export = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Name__Locus_Jackknifing

                        #strFileNamePattern_Copy = '*' + strFileNameCode_Export + '*' + strFileNameSuffix_Export
#                         strWorkingFolder = str(intFolderCount) + '\\' + 'Ne2Bulk'
#                         strFilePath_WorkingFolder = self.objSSParametersLocal.outfilePath + strWorkingFolder
                        # strFolderPathAndFile_Copy_Destination = strFilePath_WorkingFolder
                        strProcessFilePattern = strFileNameCode_Export
                        #strFileName_ExportLocusComboIncludedID = str(int(strLocus_Inclusion_Combo_Binary_ID, 2))
                        strFileName_ExportLocusComboIncludedID = str(intLocus_Inclusion_Combo_Integer_ID)
                        strFilename_Export = strPathFileName_ImportWOSuffix[:24] + '_' + strFileNameCode_Export + '_' + str(intLineCount) + '_' + strFileName_ExportLocusComboIncludedID

                        strFilePathAndNameFull_Export = strFilePath_WorkingFolder + '\\' + strFilename_Export + strFileNameSuffix_Export
                        
                        '''
                        Create GENEPOP file
                        IMPORTANT - Allele adjust means the difference between an allele and missing data
                        if your data has zeros as missing data - set this to zero
                        if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                        '''
                        intAlleleAdjust = 0
                        bool_Prevent_Internal_Function_Console_Output = True
                        bool_Prevent_External_Function_Console_Output = True
                        
                        boolSuccess = self.method_Export_Genotypes(pop_Locus_Removed, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))

                        if boolSuccess == False:
                            #LOGGING
                            with SSOutputHandler() as objSSOutputOperation:
                                listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                #listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                                stringMessage = '!!!ERROR - File create failed ERROR!!!; File: ' + strFilename_Export
                                objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                
                                #DEBUG_ON                    
                                simupop.dump(pop_Locus_Removed)
                                #DEBUG_OFF

                                objSSOutputOperation.method_Pause_Console()
                            #LOGGING
                        pass    
                            
                            
                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            stringMessage = '>GENEPOP file exported: ' + strFilename_Export
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #objSSOutputOperation.method_Pause_Console()
                        #LOGGING
                    
                        '''
                        Perform Ne2_Win_DLL processing
                        '''
                        bool__Ne2_Win_DLL_Processing = True
                        if bool__Ne2_Win_DLL_Processing:

                            #LOGGING
                            with SSOutputHandler() as objSSOutputOperation:
                                listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                #listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                stringMessage = '#################################################################################'
                                objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                stringMessage = '>File #: ' + str(intLineCount) + ' Ne2 processing file: ' + strFilename_Export
                                objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                stringMessage = '#################################################################################'
                                objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                #objSSOutputOperation.method_Pause_Console()
                            #LOGGING                    

                            obj_SSNe2_Win_DLL = object_SSNe2_Win_DLL([self.objSSParametersLocal])
                            
                            obj_SSNe2_Win_DLL.libraryObject = obj_SSNe2_Win_DLL.func_Load_Library__Ne2_Win_DLL(obj_SSNe2_Win_DLL.strDLL_Path_And_File)
                            
                            '''
                            Set the parameters for the Ne2 run
                            '''    
                            obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.char_Run_InputDataFilePath = strFilePath_WorkingFolder + '\\'
                            obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.char_Run_InputDataFileName = strFilename_Export + strFileNameSuffix_Export
                            
                            obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.int_Run_Count = intLineCount + 1
                            
                            ''' Set parameters fo the Ne2 LDNe TAB Delim file ''' 
                            if intLineCount == 0:
                                ''' Use NOT_APPEND to clear file and write headers '''
                                obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.int_Run_OutputResultsFile_NE_AppendResults = object_SSNe2_Win_DLL.struct_t__Ne2_Input_Params.struct_t__Ne2_Input_Params__General_Run.NE2_RESULTS_FILE_NE__NOT_APPEND
                            else:
                                ''' Use APPEND to prevent headers for subsequent runs '''
                                obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.int_Run_OutputResultsFile_NE_AppendResults = object_SSNe2_Win_DLL.struct_t__Ne2_Input_Params.struct_t__Ne2_Input_Params__General_Run.NE2_RESULTS_FILE_NE__APPEND
                            pass
                            
                            obj_SSNe2_Win_DLL.obj_Ne2_Input_Params.obj_Ne2_Input_Params__General_Run.bool_Run_Last_Run = False # We dont know how many records there are so no way to set this
                            
                            '''
                            Get the Ne2 results for the GENEPOP file
                            '''
                            boolSuccess = obj_SSNe2_Win_DLL.func_Get_Ne2_Results()

 
                        pass

                        '''
                        EVEN THOUGH WE HAVE PROCESSED WITH NE2 DLL
                        Still create the Ne2Bulk batch file just for after run processing if required
                        JUST PREP the NE2BULK FILES BUT DONT RUN THEM
                        '''
                   
                        '''
                        Check if the file creation limit has been reached
                        If so perform Ne2Bulk processing
                        '''
                        if intFilesPerFolderCount == intFilesPerFolder - 1:
                            
                            '''
                            Subfolder and GENEPOP files have been created
                            Pre-process before executing Ne2Bulk
                            '''
                            
                            boolPrepNe2Bulk = True
                            if boolPrepNe2Bulk:
                            
                                #Put executable files in place
                                self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_WorkingFolder)
                                
                                boolExecuteNe2Bulk = False
                                if boolExecuteNe2Bulk:
            
                                    #LOGGING
                                    with SSOutputHandler() as objSSOutputOperation:
                                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Spawning External Ne2Bulk Process', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                                    #LOGGING
                                
            
                                    #Execute external program
                                    bool_Prevent_External_Function_Console_Output = True
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                                    strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_00
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                                    self.method_Execute_External_Program_Ne2Bulk(strPCritToProcess, strProcessFilePattern, strFilePath_WorkingFolder, bool_Prevent_External_Function_Console_Output)
            
                                    #LOGGING
                                    #with SSOutputHandler() as objSSOutputOperation:
                                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                    objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Spawning External Ne2Bulk Process', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                                    #LOGGING                    
                
                                    pass
                                pass
                            pass
                        pass
                    pass #For end
                    fileHandle.close()
                    
                    '''
                    EVEN THOUGH WE HAVE PROCESSED WITH NE2 DLL
                    Still create the Ne2Bulk batch file just for after run processing if required
                    JUST PREP the NE2BULK FILES BUT DONT RUN THEM
                    '''                   
                    '''
                    After loop final...
                    Subfolder and GENEPOP files have been created
                    Pre-process before executing Ne2Bulk
                    '''
                    
                    boolPrepNe2Bulk = True
                    if boolPrepNe2Bulk:
                    
                        #Put executable files in place
                        self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_WorkingFolder)
                        
                        boolExecuteNe2Bulk = False
                        if boolExecuteNe2Bulk:
    
                            #LOGGING
                            with SSOutputHandler() as objSSOutputOperation:
                                listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Spawning External Ne2Bulk Process', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                            #LOGGING
                        
    
                            #Execute external program
                            bool_Prevent_External_Function_Console_Output = True
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                            strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_00
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                            self.method_Execute_External_Program_Ne2Bulk(strPCritToProcess, strProcessFilePattern, strFilePath_WorkingFolder, bool_Prevent_External_Function_Console_Output)
    
                            #LOGGING
                            #with SSOutputHandler() as objSSOutputOperation:
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Spawning External Ne2Bulk Process', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                            #LOGGING                    
        
                            pass
                        pass
                    pass
                    
                return True

            '''
            Ne2_Bulk - Locus Combo File Processing
            '''
                              
            def method_Empirical_Dataset_Locus_Combination_Sampling_From_File_Using_Ne2Bulk(self, strFilePathAndName_ImportGenotypes, strInputFileName_LocusCombos):

                #LOGGING
                with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Creating and processing locus combo files', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                #LOGGING

                bool_Get_Locus_Combos_And_Remove_Loci = True
                if bool_Get_Locus_Combos_And_Remove_Loci:
                    
                    '''
                    Import the genotype file from which to remove loci combos
                    '''
                    
                    pop_Imported = self.method_Import_Genotypes(strFilePathAndName_ImportGenotypes)
                    
                    '''
                    Get all locus combos for a specific run from the database
                    '''
                    
                    tupReaderAndFileHandle = self.method_Load_Locus_Combos_From_File(strInputFileName_LocusCombos)
                    fileHandle = tupReaderAndFileHandle[1]
                    readerCSV = tupReaderAndFileHandle[0]
                    
                    '''
                    Remove each locus combo from the empirical data
                    '''
                    intFilesPerFolder = 250
                    intFolderCount = -1
                    intLineCount = -1
                    intFilesPerFolderCount = -1
                    for lineCSV in readerCSV:

                        intLineCount += 1
                        intFilesPerFolderCount += 1
                        
                        #DEBUG_ON
                        #if intLineCount == 1000:
                        #    break
                        #DEBUG_OFF

                        '''
                        Create the next working folder
                        '''
                        if (intFilesPerFolderCount == 0) or (intFilesPerFolderCount == intFilesPerFolder):

                            intFilesPerFolderCount = 0
                            intFolderCount += 1
                            
                            strWorkingFolder = str(intFolderCount) + '\\' + 'Ne2Bulk'
                            strFilePath_WorkingFolder = self.objSSParametersLocal.outfilePath + strWorkingFolder
    
                            #Create the folder if it doesnt exist
                            with FileHandler() as objFileOperation:
                                if objFileOperation.method_Path_Exists(strFilePath_WorkingFolder) == False:
                                    objFileOperation.method_Create_Path(strFilePath_WorkingFolder)
                                pass
                            pass

                            #LOGGING
                            with SSOutputHandler() as objSSOutputOperation:
                                listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Created new working folder and continuing processing', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                            #LOGGING
                        
                        '''
                        Get the locus combo information and create the appropriate GENEPOP file
                        '''
                       
                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            stringMessage = '\n' + '>' + str(intLineCount)+ ' Reading Locus Combo record: ' + ",".join(lineCSV)
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #objSSOutputOperation.method_Pause_Console()
                        #LOGGING
                         
                        intLocus_Combo_Count = int(lineCSV[0])
                        intLocus_Inclusion_Combo_Integer_ID = int(lineCSV[1])
                        strLocus_Inclusion_Combo_Binary_ID = lineCSV[2]
                        intLocus_Exclusion_Combo_Integer_ID = int(lineCSV[3])
                        strLocus_Exclusion_Combo_Binary_ID = lineCSV[4]
                        strLocus_Full_Name_List_Ordered_For_Combo_ID = lineCSV[5] 
                        
                        '''
                        Generate a list of named loci to exclude from the strLocusComboExclusionID
                        '''
                        #listLociToExclude = [] 
                        listLoci = strLocus_Full_Name_List_Ordered_For_Combo_ID.split(",")
                        listLociToExclude = []
                        listLociExclusionID = list(strLocus_Exclusion_Combo_Binary_ID)
                        
                        intCount = 0
                        for strExclusionBit in listLociExclusionID:
                            if int(strExclusionBit) == 1:
                                listLociToExclude.append(listLoci[intCount])
                            pass
                            intCount += 1
                        pass
 
                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            #
                            stringMessage = '> Count: ' + str(intLocus_Combo_Count) + '; Locus_Inclusion_Combo_Integer_ID: ' + str(intLocus_Inclusion_Combo_Integer_ID) + '; Locus_Inclusion_Combo_Binary_ID: ' + strLocus_Exclusion_Combo_Binary_ID + '; Removing loci: ' + ",".join(listLociToExclude)
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #
                            stringMessage = '> Count: ' + str(intLocus_Combo_Count) + '; Locus_Exclusion_Combo_Integer_ID: ' + str(intLocus_Exclusion_Combo_Integer_ID) + '; Locus_Exclusion_Binery_Combo_ID: ' + strLocus_Exclusion_Combo_Binary_ID + '; Removing loci: ' + ",".join(listLociToExclude)
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #objSSOutputOperation.method_Pause_Console()
                        #LOGGING
    
                        '''
                        Remove loci combo from genotypes and generate a Genepop file for Ne2 processing
                        '''
        
                        #Clone the raw data each time
                        pop_Locus_Remove = pop_Imported.clone()
                        
                        #Get a pop with the locus removed
                        pop_Locus_Removed = self.method_Remove_Loci(pop_Locus_Remove, listLociToExclude)
                    
                        #Export that pop as a Genepop file
                        with FileHandler() as objFileOperation:
                            tupFilePathNameAndExt = objFileOperation.method_Get_FileNameAndExtension_From_FileName(strFilePathAndName_ImportGenotypes)
                            strPathFileName_ImportWOSuffix = objFileOperation.method_Get_FileName_From_PathAndFileName(tupFilePathNameAndExt[0])
                        
#                         strFileNameSuffix_Export = '.lc'
#                         strFileNameCode_Export = 'EESL'
                        strFileNameSuffix_Export = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__Locus_Jackknifing
                        strFileNameCode_Export = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Name__Locus_Jackknifing
                        
                        #strFileNamePattern_Copy = '*' + strFileNameCode_Export + '*' + strFileNameSuffix_Export
#                         strWorkingFolder = str(intFolderCount) + '\\' + 'Ne2Bulk'
#                         strFilePath_WorkingFolder = self.objSSParametersLocal.outfilePath + strWorkingFolder
                        # strFolderPathAndFile_Copy_Destination = strFilePath_WorkingFolder
                        strProcessFilePattern = strFileNameCode_Export
                        #strFileName_ExportLocusComboIncludedID = str(int(strLocus_Inclusion_Combo_Binary_ID, 2))
                        
                        str_Genepop_File_Count = str(intLineCount)
                        str_Genepop_File_Count_Out = str_Genepop_File_Count.zfill(4)
                        str_Locus_Combo_Integer = str(intLocus_Inclusion_Combo_Integer_ID)
                        str_Locus_Combo_Integer_Out = str_Locus_Combo_Integer.zfill(8)
                        strFilename_Export_Prefix = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Name__Locus_Jackknifing
                        strFilename_Export_Suffix = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__Locus_Jackknifing
                        '''
                        ~~~~~~~~~~~~~~~~~~
                        WARNING:
                        FIlename is really important here as this filename info is extracted and used
                        & is restricted by the number of chars it can have due to Ne2 LDNe TAB file replorting limitations
                        Must be UNDERSCORE delimited (but could be changed here & in the Results processing
                        ONLY 1 UNDERSCORE may be used or the Results processing will screw up the string split into separate pandas df columns
                        Total chars must not exceed (16 - SubSample_Replicate_Number)
                        Filename currently : <Prefix;4>_<Locus_Combo_Integer:8>.l
                        NE2 will only take the LAST (16 - SubSample_Replicate_Number) characters of this filenae. 
                        Most of prefiix will be chopped off by Ne2 but the this is relative so NO UNDERSCORES MAY BE USED IN THE PREFIX.
                        ~~~~~~~~~~~~~~~~~~
                        '''                                                                        
                        strFilename_Export = strFilename_Export_Prefix + '_'
                        #strFilename_Export += str_Genepop_File_Count_Out + '_'
                        strFilename_Export += str_Locus_Combo_Integer_Out
                        strFilename_Export += strFilename_Export_Suffix
                                                                
                        #strFileName_ExportLocusComboIncludedID = str(intLocus_Inclusion_Combo_Integer_ID)
                        #strFilename_Export = strPathFileName_ImportWOSuffix[:24] + '_' + strFileNameCode_Export + '_' + str(intLineCount) + '_' + strFileName_ExportLocusComboIncludedID

                        strFilePathAndNameFull_Export = strFilePath_WorkingFolder + '\\' + strFilename_Export
                        
                        '''
                        Create GENEPOP file
                        IMPORTANT - Allele adjust means the difference between an allele and missing data
                        if your data has zeros as missing data - set this to zero
                        if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                        '''
                        intAlleleAdjust = 0
                        bool_Prevent_Internal_Function_Console_Output = True
                        bool_Prevent_External_Function_Console_Output = True
                        
                        boolSuccess = self.method_Export_Genotypes(pop_Locus_Removed, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))

                        if boolSuccess == False:
                            #LOGGING
                            with SSOutputHandler() as objSSOutputOperation:
                                listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                #listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                                stringMessage = '!!!ERROR - File create failed ERROR!!!; File: ' + strFilename_Export
                                objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                
                                #DEBUG_ON                    
                                simupop.dump(pop_Locus_Removed)
                                #DEBUG_OFF

                                objSSOutputOperation.method_Pause_Console()
                            #LOGGING
                        pass    
                            
                            
                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            stringMessage = '>GENEPOP file exported: ' + strFilename_Export
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            #objSSOutputOperation.method_Pause_Console()
                        #LOGGING
                    
                        '''
                        Check if the file creation limit has been reached
                        If so perform Ne2Bulk processing
                        '''
                        if intFilesPerFolderCount == intFilesPerFolder - 1:
                            
                            '''
                            Subfolder and GENEPOP files have been created
                            Pre-process before executing Ne2Bulk
                            '''
                            
                            boolPrepNe2Bulk = True
                            if boolPrepNe2Bulk:
                            
                                #Put executable files in place
                                self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_WorkingFolder)
                                
                                boolExecuteNe2Bulk = True
                                if boolExecuteNe2Bulk:
            
                                    #LOGGING
                                    with SSOutputHandler() as objSSOutputOperation:
                                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Spawning External Ne2Bulk Process', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                                    #LOGGING
                                
            
                                    #Execute external program
                                    bool_Prevent_External_Function_Console_Output = True
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                                    strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_00
                                    #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                                    self.method_Execute_External_Program_Ne2Bulk(strPCritToProcess, strProcessFilePattern, strFilePath_WorkingFolder, bool_Prevent_External_Function_Console_Output)
            
                                    #LOGGING
                                    #with SSOutputHandler() as objSSOutputOperation:
                                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                    objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Spawning External Ne2Bulk Process', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                                    #LOGGING                    
                
                                    pass
                                pass
                            pass
                        pass
                    pass #For end
                    fileHandle.close()
                    
                    '''
                    After loop final...
                    Subfolder and GENEPOP files have been created
                    Pre-process before executing Ne2Bulk
                    '''
                    
                    boolPrepNe2Bulk = True
                    if boolPrepNe2Bulk:
                    
                        #Put executable files in place
                        self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_WorkingFolder)
                        
                        boolExecuteNe2Bulk = True
                        if boolExecuteNe2Bulk:
    
                            #LOGGING
                            with SSOutputHandler() as objSSOutputOperation:
                                listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Spawning External Ne2Bulk Process', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                            #LOGGING
                        
    
                            #Execute external program
                            bool_Prevent_External_Function_Console_Output = True
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                            strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_00
                            #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                            self.method_Execute_External_Program_Ne2Bulk(strPCritToProcess, strProcessFilePattern, strFilePath_WorkingFolder, bool_Prevent_External_Function_Console_Output)
    
                            #LOGGING
                            #with SSOutputHandler() as objSSOutputOperation:
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Spawning External Ne2Bulk Process', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                            #LOGGING                    
        
                            pass
                        pass
                    pass
    
                    
                return True
            
            def method_Empirical_Dataset_Locus_Combination_Sampling_From_Database(self, objDatabaseOperation, objSSDatabaseOperation, listData, strFilePathAndName_ImportGenotypes):

                '''
                Get all locus combos for a specific run from the database
                '''
                
                rowsLocusComboRecords = self.method_Database_Get_All_Loci_Combos_For_A_Specific_Run(objDatabaseOperation, objSSDatabaseOperation, listData)
                
                '''
                Remove each locus combo from the empirical data
                '''
                
                for rowLocusCombo in rowsLocusComboRecords:
                    
                    intLocus_Combo_UID = int(rowLocusCombo[0])
                    strLocus_Inclusion_Combo_ID = rowLocusCombo[1]
                    strLocus_Exclusion_Combo_ID = rowLocusCombo[2]
                    strLocus_Full_Name_List_Ordered_For_Combo_ID = rowLocusCombo[2] 
                    
                    '''
                    Generate a list of named loci to exclude from the strLocusComboExclusionID
                    '''
                    #listLociToExclude = [] 
                    listLoci = strLocus_Full_Name_List_Ordered_For_Combo_ID.split(",")
                    listLociToExclude = []
                    listLociExclusionID = list(strLocus_Inclusion_Combo_ID)
                    
                    intCount = 0
                    for intExclusionBit in listLociExclusionID:
                        if intExclusionBit == 1:
                            listLociToExclude.append(listLoci[intCount])
                        pass
                        intCount += 1
                    pass
                    
                    
                    
                '''
                Export the genotype data as GENEPOP files
                '''
                
                
                boolPrepNe2Bulk = True
                if boolPrepNe2Bulk:
                
                    #Copy input data file to analysis folder
                    strFileNameSuffix_Export = '.gp_gspy'
                    strFileNameCode_Export = 'EESL'
                    strFileNamePattern_Copy = '*' + strFileNameCode_Export + '*' + strFileNameSuffix_Export
                    strFilePath_WorkingFolder = self.objSSParametersLocal.outfilePath + 'Ne2Bulk\\'
                    strFolderPathAndFile_Copy_Destination = strFilePath_WorkingFolder
                    strProcessFilePattern = strFileNameCode_Export

                    #Put executable files in place
                    self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_WorkingFolder)
                    
                    #Copy input files to the execution working folder
#                     with FileHandler() as objFileOperation:
#                         if objFileOperation.method_Path_Exists(strFilePath_WorkingFolder) == False:
#                             objFileOperation.method_Create_Path(strFilePath_WorkingFolder)
#                         pass
#                     
#                         objFileOperation.method_Copy_Files_By_Pattern(self.objSSParametersLocal.outfilePath, strFolderPathAndFile_Copy_Destination, strFileNamePattern_Copy)

                    
                    '''
                    Randomly sample loci combinations - Remove each locus not included in the selected loci combo
                    and generate a Genepop file for Ne2 processing
                    '''

                    for strLocus in listLoci:
                        
                        #Import the same raw data each time
                        #pop_Imported = self.method_Import_Genotypes(strFileNameFull_Import)
                        pop_Imported = self.method_Import_Genotypes(strFilePathAndName_ImportGenotypes)
                        #Get a pop with the locus removed
                        pop_Locus_Removed = self.method_Remove_Loci(pop_Imported, [strLocus])
                        #Export that pop as a Genepop file
                        #strFilename_Export = strFileName_Import + '_LR_X_' + strLoci + '_x_' + str(strLocus[:2])
                        with FileHandler() as objFileOperation:
                            
                            tupFilePathNameAndExt = objFileOperation.method_Get_FileNameAndExtension_From_FileName(strFilePathAndName_ImportGenotypes)
                            strFileName_ImportSuffix = tupFilePathNameAndExt[1]
                            strPathFileName_ImportWOSuffix = objFileOperation.method_Get_FileName_From_PathAndFileName(tupFilePathNameAndExt[0])
                               
                            strFileName_ExportSuffix = strFileName_ImportSuffix
                            
                        strFilename_Export = strPathFileName_ImportWOSuffix + '_' + strFileNameCode_Export + '_x_' + str(strLocus[:2])
                        #strFileNameFull_Export = objSSParameters.outfilePath + strFilename_Export + strFileNameSuffix_Import
                        strFilePathAndNameFull_Export = strFolderPathAndFile_Copy_Destination + '\\' + strFilename_Export + strFileName_ExportSuffix
                        
                        '''
                        IMPORTANT - Allele adjust means the difference between an allele and missing data
                        if your data has zeros as missing data - set this to zero
                        if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                        '''
                        intAlleleAdjust = 0
                        bool_Prevent_Internal_Function_Console_Output = True
                        bool_Prevent_External_Function_Console_Output = True
                        
                        self.method_Export_Genotypes(pop_Locus_Removed, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output)
                        
                    pass
                    
                    boolExecuteNe2Bulk = True
                    if boolExecuteNe2Bulk:

                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                            objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Running External Ne2Bulk Process', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        #LOGGING
                    

                        #Execute external program
                        bool_Prevent_External_Function_Console_Output = True
                        self.method_Execute_External_Program_Ne2Bulk(strProcessFilePattern, strFilePath_WorkingFolder, bool_Prevent_External_Function_Console_Output)

                        #LOGGING
                        #with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Running External Ne2Bulk Process', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        #LOGGING                    
    
                        pass
                    pass
                pass
            
                return True
            
            def method_Empirical_Dataset_Locus_Sampling(self, strFilePathAndName_ImportGenotypes, listLoci):

                boolPrepNe2Bulk = True
                if boolPrepNe2Bulk:
                
                    #Copy input data file to analysis folder
                    strFileNameSuffix_Export = '.gp_gspy'
                    strFileNameCode_Export = 'EESL'
                    strFileNamePattern_Copy = '*' + strFileNameCode_Export + '*' + strFileNameSuffix_Export
                    strFilePath_WorkingFolder = self.objSSParametersLocal.outfilePath + 'Ne2Bulk\\'
                    strFolderPathAndFile_Copy_Destination = strFilePath_WorkingFolder
                    strProcessFilePattern = strFileNameCode_Export

                    #Put executable files in place
                    self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_WorkingFolder)
                    
                    #Copy input files to the execution working folder
#                     with FileHandler() as objFileOperation:
#                         if objFileOperation.method_Path_Exists(strFilePath_WorkingFolder) == False:
#                             objFileOperation.method_Create_Path(strFilePath_WorkingFolder)
#                         pass
#                     
#                         objFileOperation.method_Copy_Files_By_Pattern(self.objSSParametersLocal.outfilePath, strFolderPathAndFile_Copy_Destination, strFileNamePattern_Copy)

                    
                    '''
                    Randomly sample loci combinations - Remove each locus not included in the selected loci combo
                    and generate a Genepop file for Ne2 processing
                    '''

                    for strLocus in listLoci:
                        
                        #Import the same raw data each time
                        #pop_Imported = self.method_Import_Genotypes(strFileNameFull_Import)
                        pop_Imported = self.method_Import_Genotypes(strFilePathAndName_ImportGenotypes)
                        #Get a pop with the locus removed
                        pop_Locus_Removed = self.method_Remove_Loci(pop_Imported, [strLocus])
                        #Export that pop as a Genepop file
                        #strFilename_Export = strFileName_Import + '_LR_X_' + strLoci + '_x_' + str(strLocus[:2])
                        with FileHandler() as objFileOperation:
                            
                            tupFilePathNameAndExt = objFileOperation.method_Get_FileNameAndExtension_From_FileName(strFilePathAndName_ImportGenotypes)
                            strFileName_ImportSuffix = tupFilePathNameAndExt[1]
                            strPathFileName_ImportWOSuffix = objFileOperation.method_Get_FileName_From_PathAndFileName(tupFilePathNameAndExt[0])
                               
                            strFileName_ExportSuffix = strFileName_ImportSuffix
                            
                        strFilename_Export = strPathFileName_ImportWOSuffix + '_' + strFileNameCode_Export + '_x_' + str(strLocus[:2])
                        #strFileNameFull_Export = objSSParameters.outfilePath + strFilename_Export + strFileNameSuffix_Import
                        strFilePathAndNameFull_Export = strFolderPathAndFile_Copy_Destination + '\\' + strFilename_Export + strFileName_ExportSuffix
                        
                        '''
                        IMPORTANT - Allele adjust means the difference between an allele and missing data
                        if your data has zeros as missing data - set this to zero
                        if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                        '''
                        intAlleleAdjust = 0
                        bool_Prevent_Internal_Function_Console_Output = True
                        bool_Prevent_External_Function_Console_Output = True
                        
                        self.method_Export_Genotypes(pop_Locus_Removed, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output)
                        
                    pass
                    
                    boolExecuteNe2Bulk = True
                    if boolExecuteNe2Bulk:

                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                            objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Running External Ne2Bulk Process', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        #LOGGING
                    

                        #Execute external program
                        bool_Prevent_External_Function_Console_Output = True
                        self.method_Execute_External_Program_Ne2Bulk(strProcessFilePattern, strFilePath_WorkingFolder, bool_Prevent_External_Function_Console_Output)

                        #LOGGING
                        #with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Running External Ne2Bulk Process', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        #LOGGING                    
    
                        pass
                    pass
                pass
            
                return True
            
            def method_Empirical_Dataset_Jackknife_Loci(self, strFilePathAndName_ImportGenotypes, listLoci):

                boolPrepNe2Bulk = True
                if boolPrepNe2Bulk:
                
                    #Copy input data file to analysis folder
                    strFileNameSuffix_Export = '.gp_gspy'
                    strFileNameCode_Export = 'EJKL'
                    strFileNamePattern_Copy = '*' + strFileNameCode_Export + '*' + strFileNameSuffix_Export
                    strFilePath_WorkingFolder = self.objSSParametersLocal.outfilePath + 'Ne2Bulk\\'
                    strFolderPathAndFile_Copy_Destination = strFilePath_WorkingFolder
                    strProcessFilePattern = strFileNameCode_Export

                    #Put executable files in place
                    self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_WorkingFolder)
                    
                    #Copy input files to the execution working folder
#                     with FileHandler() as objFileOperation:
#                         if objFileOperation.method_Path_Exists(strFilePath_WorkingFolder) == False:
#                             objFileOperation.method_Create_Path(strFilePath_WorkingFolder)
#                         pass
#                     
#                         objFileOperation.method_Copy_Files_By_Pattern(self.objSSParametersLocal.outfilePath, strFolderPathAndFile_Copy_Destination, strFileNamePattern_Copy)

                    '''
                    Jackknife Loci - Remove each locus in turn and generate a Genepop file for Ne2 processing
                    '''

                    for strLocus in listLoci:
                        
                        #Import the same raw data each time
                        #pop_Imported = self.method_Import_Genotypes(strFileNameFull_Import)
                        pop_Imported = self.method_Import_Genotypes(strFilePathAndName_ImportGenotypes)
                        #Get a pop with the locus removed
                        pop_Locus_Removed = self.method_Remove_Loci(pop_Imported, [strLocus])
                        #Export that pop as a Genepop file
                        #strFilename_Export = strFileName_Import + '_LR_X_' + strLoci + '_x_' + str(strLocus[:2])
                        with FileHandler() as objFileOperation:
                            
                            tupFilePathNameAndExt = objFileOperation.method_Get_FileNameAndExtension_From_FileName(strFilePathAndName_ImportGenotypes)
                            strFileName_ImportSuffix = tupFilePathNameAndExt[1]
                            strPathFileName_ImportWOSuffix = objFileOperation.method_Get_FileName_From_PathAndFileName(tupFilePathNameAndExt[0])
                               
                            strFileName_ExportSuffix = strFileName_ImportSuffix
                            
                        strFilename_Export = strPathFileName_ImportWOSuffix + '_' + strFileNameCode_Export + '_x_' + str(strLocus[:2])
                        #strFileNameFull_Export = objSSParameters.outfilePath + strFilename_Export + strFileNameSuffix_Import
                        strFilePathAndNameFull_Export = strFolderPathAndFile_Copy_Destination + '\\' + strFilename_Export + strFileName_ExportSuffix
                        
                        '''
                        IMPORTANT - Allele adjust means the difference between an allele and missing data
                        if your data has zeros as missing data - set this to zero
                        if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                        '''
                        intAlleleAdjust = 0
                        bool_Prevent_Internal_Function_Console_Output = True
                        bool_Prevent_External_Function_Console_Output = True
                        
                        self.method_Export_Genotypes(pop_Locus_Removed, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output)
                        
                    pass
                    
                    boolExecuteNe2Bulk = True
                    if boolExecuteNe2Bulk:

                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                            objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Running External Ne2Bulk Process', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        #LOGGING
                    

                        #Execute external program
                        bool_Prevent_External_Function_Console_Output = True
                        self.method_Execute_External_Program_Ne2Bulk(strProcessFilePattern, strFilePath_WorkingFolder, bool_Prevent_External_Function_Console_Output)

                        #LOGGING
                        #with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife Loci - Running External Ne2Bulk Process', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        #LOGGING                    
    
                        pass
                    pass
                pass
            
                return True

            def method_Pop_SubSample_Jackknife_Locus(self, pop_In, listLociNames):

                
                '''
                Jackknife Loci - Remove each locus in turn and generate a Genepop file for Ne2 processing
                '''
                
                for strLocus in listLociNames:
                    
                    #Import the same raw data each time
                    #pop_Imported = self.method_Import_Genotypes(strFileNameFull_Import)
                    strFilePathAndName_ImportGenotypes = ''
                    pop_Imported = self.method_Import_Genotypes(strFilePathAndName_ImportGenotypes)
                    #Get a pop with the locus removed
                    pop_Locus_Removed = self.method_Remove_Loci(pop_In, [strLocus])
           
                return True

            '''
            --------------------------------------------------------------------------------------------------------
            # Sub-Main Processing
            --------------------------------------------------------------------------------------------------------
            '''

            '''
            -----------------------------------
            Saved Pop SubSample Ne2Bulk Processing of EXP and STAT CATEGORY
            -----------------------------------
            '''
                       
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_SubSampling_Experiments(self, list_Experiments, str_Experiment_Label, str_LDNE_Working_Path, str_Search_Path__Saved_SimuPops, str_File_Search_Pattern):

                '''
                ---------------------
                Get general experiment details
                ---------------------
                '''
                bool_Success = False
                
                dictExperiment = self.method_Start_Of_SAMPLING_Reporting__Common_Experiment_Details()
                
                '''
                ---------------------
                Open Sampling Loggers
                ---------------------
                '''
                 
                
                for int_Experiment in list_Experiments:
                    
                    self.method_Open_Log_Files__Sampling(int_Experiment)
                    
                    if int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_Ver_0: 
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment =self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_0(str_Experiment_Label, str_LDNE_Working_Path)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_Ver_1:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_1(str_Experiment_Label, str_LDNE_Working_Path)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_Ver_2:
                        #
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_2(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_Ver_3:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_3(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_CAPL_FISHED_ABSOLUTE_v1_0:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAPL_FISHED_ABSOLUTE_v1_0(str_Experiment_Label, str_LDNE_Working_Path)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_CAPL_FISHED_PROPORTIONS_SCALED_BY_MAX_ABSOLUTE_v1_0:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAPL_FISHED_PROPORTIONS_SCALED_BY_MAX_ABSOLUTE_v1_0(str_Experiment_Label, str_LDNE_Working_Path)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_CAPL_FISHED_ABS_SCALED_BY_MAX_ABSOLUTE_v1_0:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAPL_FISHED_ABSOLUTE_NUMS_SCALED_BY_MAX_ABSOLUTE_v1_0(str_Experiment_Label, str_LDNE_Working_Path)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_CAOB_FISHED_ABSOLUTE_v1_0:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAOB_FISHED_ABSOLUTE_v1_0(str_Experiment_Label, str_LDNE_Working_Path)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_CAPL_FISHED_PROPORTIONS_v1_0:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAPL_FISHED_PROPORTIONS_v1_0(str_Experiment_Label, str_LDNE_Working_Path)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_CAOB_FISHED_PROPORTIONS_v1_0:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAOB_FISHED_PROPORTIONS_v1_0(str_Experiment_Label, str_LDNE_Working_Path)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_CAOB_FISHED_ABS_SCALED_BY_MAX_ABSOLUTE_v1_0:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAOB_FISHED_ABSOLUTE_NUMS_SCALED_BY_MAX_ABSOLUTE_v1_0(str_Experiment_Label, str_LDNE_Working_Path)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_0:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_0(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_AGE_COHORTS:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_1__USER_AGE_COHORTS(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_PROPORTIONS:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_1__USER_PROPORTIONS(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_SAMPLE_NUMBERS:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_1__USER_SAMPLE_NUMBERS(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_SAMPLE_PROPORTIONS:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_1__USER_SAMPLE_PROPORTIONS(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_100_PERCENT_USER_SPECIFIED_AGE_COHORTS_v1_0:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_100_PERCENT_USER_SPECIFED_AGE_COHORTS_1_0(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_EMBRYO_COHORT:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_FULL_EMBRYO_COHORT(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_JUVENILE_COHORTS:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_FULL_JUVENILE_COHORTS(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_ADULT_COHORTS:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_FULL_ADULT_COHORTS(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_SAMPLING_OF_COHORTS:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_FULL_SAMPLING_OF_COHORTS(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION:
                        int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION(str_Experiment_Label, str_LDNE_Working_Path, dictExperiment)
                    pass
                pass
            
                bool_Success, dictExperiment = self.method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_Experiments(int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, str_LDNE_Working_Path, str_Search_Path__Saved_SimuPops, str_File_Search_Pattern, dictExperiment)

                method_End_Of_SAMPLING_Reporting = True
                if bool_Success and method_End_Of_SAMPLING_Reporting:
                    
                    ''' End of Sampling reporting '''
                    if int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_0:
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Strategy(dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_AGE_COHORTS:
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Strategy(dictExperiment)
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_PROPORTIONS:
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Strategy(dictExperiment)                        
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_SAMPLE_NUMBERS:
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Strategy(dictExperiment)                        
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_SAMPLE_PROPORTIONS:
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Strategy(dictExperiment)                        
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_Ver_2: 
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Exp_2_2(dictExperiment)  
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_100_PERCENT_USER_SPECIFIED_AGE_COHORTS_v1_0: 
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Exp_100_PERCENT_USER_SPECIFIED_AGE_COHORTS_1_0(dictExperiment)  
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_EMBRYO_COHORT: 
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Exp_Full_Embryo_Cohort_FEM(dictExperiment)  
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_JUVENILE_COHORTS: 
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Exp_Full_Juvenile_Cohorts_FJV(dictExperiment)  
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_ADULT_COHORTS: 
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Exp_Full_Adult_Cohorts_FMT(dictExperiment)  
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_SAMPLING_OF_COHORTS: 
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Exp_Full_Sampling_Of_Cohorts_FUL(dictExperiment)  
                    elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION: 
                        dictExperiment = self.method_End_Of_SAMPLING_Reporting__Sampling_Exp_Sampling_Proportions_Scaled_By_Max_Proportion_PSMP(dictExperiment)  
                    pass       
                pass
            
                return dictExperiment
           
            
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_0_RETIRE(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()

                #str_Experiment_Label = 'EXP2_0'
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full', 'Large_All', 'Large_Mature','Large_Embryo', 'Small_All', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature','Large_Embryo', 'Small_Mature', 'Small_Embryo']
                list_Stats_Categories = ['Full', 'CAPL_Catch_Prop', 'Large_Mature','Large_Embryo', 'Small_Mature', 'Small_Embryo']

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {'Full':'FUL'
                                                         ,'CAPL_Catch_Prop':'CCP'
                                                         #,'Large_All':1
                                                         ,'Large_Mature':'LMT'
                                                         ,'Large_Embryo':'LEM'
                                                         #,'Small_All':1
                                                         ,'Small_Mature':'SMT'
                                                         ,'Small_Embryo':'SEM'}
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {'Full':1
                                                         ,'CAPL_Catch_Prop':10
                                                         #,'Large_All':1
                                                         ,'Large_Mature':3
                                                         ,'Large_Embryo':3
                                                         #,'Small_All':1
                                                         ,'Small_Mature':10
                                                         ,'Small_Embryo':10}
                
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass

#                 '''
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 Define SubSample Sizes by Stats Category
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 '''            
#                 int_Large_SubSample_Size = self.objSSParametersLocal.popnSize * 0.4
#                 int_Small_SubSample_Size = 500
#                 dict_SubSample_Sizes_By_Category = {'Full':int(int_Full_SubSample_Size)
#                                                     #,'Large_All':int(int_Large_SubSample_Size)
#                                                     ,'Large_Mature':int(int_Large_SubSample_Size)
#                                                     ,'Large_Embryo':int(int_Large_SubSample_Size)
#                                                     #,'Small_All':int(int_Small_SubSample_Size)
#                                                     ,'Small_Mature':int(int_Small_SubSample_Size)
#                                                     ,'Small_Embryo':int(int_Small_SubSample_Size)}

#                 '''
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 Define VSPs to SubSample by Stats Category
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 '''                
#                 dict_VSPs_To_SubSample_By_Category = {'Full':0
#                                                     #,'Large_All':0
#                                                     ,'Large_Mature':(0,2)
#                                                     ,'Large_Embryo':(0,0)
#                                                     #,'Small_All':0
#                                                     ,'Small_Mature':(0,2)
#                                                     ,'Small_Embryo':(0,0)}

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #list_LDNe_PCrits_To_Get = [0.02,0]
                list_LDNe_PCrits_To_Get = [0]
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                
                list_Stats_Categories_For_Sampling_By_Proportion = ['CAPL_Catch_Prop']        
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 

                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohort
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
                    ''' Experiment sampling params '''
                    #dict_SubSampling_Params_By_Category['Proportion_Of_VSP_To_Sample'] = floatProportionOfVSP_Embryo
                    #odictAgeCohortSampleNumbers = OrderedDict([(0,floatProportionOfVSP_Embryo),(12,0),(24,0),(36,0)])
                    odictAgeCohortSampleNumbers = OrderedDict([(0,0.015267176),(12,0.040712468),(24,0.03562341),(36,0.03562341),(48,0.015267176),(60,0.007633588),(72,0.005089059),(84,0),(96,0.007633588),(108,0.022900763),(120,0.03307888),(132,0.066157761),(144,0.053435115),(156,0.117048346),(168,0.1043257),(180,0.139949109),(192,0.096692112),(204,0.061068702),(216,0.045801527),(228,0.027989822),(240,0.03562341),(252,0.015267176),(264,0.012722646),(276,0),(288,0),(300,0.002544529),(312,0),(324,0.002544529),(336,0),(348,0),(360,0)])
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleNumbers

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass

                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full']        
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                

                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    #dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = [0]
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Large_Mature']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.3
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Large_Embryo']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.3
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_Mature']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 500
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_Embryo']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 500
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dictExperiment:
                        dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                    pass

                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment

            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_0(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()

                #str_Experiment_Label = 'EXP2_1'
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full', 'Large_All', 'Large_Mature','Large_Embryo', 'Small_All', 'Small_Mature', 'Small_Embryo']
                list_Stats_Categories = ['Full', 'Large_Mature','Large_Embryo', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'CAPL_Catch_Prop', 'Large_Mature','Large_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature', 'Large_Embryo']
                #list_Stats_Categories = ['Large_Mature', 'Large_Embryo']

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {
                                                         'Full':'FUL'
                                                         #,'CAPL_Catch_Prop':'CCP'
                                                         #,'Large_All':1
                                                         ,'Large_Mature':'LMT'
                                                         ,'Large_Embryo':'LEM'
                                                         #,'Small_All':1
                                                         ,'Small_Mature':'SMT'
                                                         ,'Small_Embryo':'SEM'
                                                        }
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {
                                                         'Full':1
                                                         #,'CAPL_Catch_Prop':10
                                                         #,'Large_All':1
                                                         ,'Large_Mature':1
                                                         ,'Large_Embryo':1
                                                         #,'Small_All':1
                                                         ,'Small_Mature':1
                                                         ,'Small_Embryo':1
                                                         }
                
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass

#                 '''
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 Define SubSample Sizes by Stats Category
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 '''            
#                 int_Large_SubSample_Size = self.objSSParametersLocal.popnSize * 0.4
#                 int_Small_SubSample_Size = 500
#                 dict_SubSample_Sizes_By_Category = {'Full':int(int_Full_SubSample_Size)
#                                                     #,'Large_All':int(int_Large_SubSample_Size)
#                                                     ,'Large_Mature':int(int_Large_SubSample_Size)
#                                                     ,'Large_Embryo':int(int_Large_SubSample_Size)
#                                                     #,'Small_All':int(int_Small_SubSample_Size)
#                                                     ,'Small_Mature':int(int_Small_SubSample_Size)
#                                                     ,'Small_Embryo':int(int_Small_SubSample_Size)}

#                 '''
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 Define VSPs to SubSample by Stats Category
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 '''                
#                 dict_VSPs_To_SubSample_By_Category = {'Full':0
#                                                     #,'Large_All':0
#                                                     ,'Large_Mature':(0,2)
#                                                     ,'Large_Embryo':(0,0)
#                                                     #,'Small_All':0
#                                                     ,'Small_Mature':(0,2)
#                                                     ,'Small_Embryo':(0,0)}

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                list_LDNe_PCrits_To_Get = [0.1,0.05,0.02,0.01,0]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_10_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                #list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                #list_LDNe_PCrits_To_Get = [0.05,0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                           
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()

                 
#                 list_Stats_Categories_For_Sampling_By_Proportion = ['CAPL_Catch_Prop']        
#                 #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
# 
#                 for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
#                     dict_Sampling_Params = OrderedDict()      
#                     ''' Sampling method  '''
#                     dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohort
#                     ''' VSP Split method  '''
#                     dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
#                     ''' Loci to remove from sample '''
#                     #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
#                     listLociToRemove = [] #None assumes keep all
#                     dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
#                     ''' Experiment sampling params '''
#                     #dict_SubSampling_Params_By_Category['Proportion_Of_VSP_To_Sample'] = floatProportionOfVSP_Embryo
#                     #odictAgeCohortSampleNumbers = OrderedDict([(0,floatProportionOfVSP_Embryo),(12,0),(24,0),(36,0)])
#                     odictAgeCohortSampleNumbers = OrderedDict([(0,0.015267176),(12,0.040712468),(24,0.03562341),(36,0.03562341),(48,0.015267176),(60,0.007633588),(72,0.005089059),(84,0),(96,0.007633588),(108,0.022900763),(120,0.03307888),(132,0.066157761),(144,0.053435115),(156,0.117048346),(168,0.1043257),(180,0.139949109),(192,0.096692112),(204,0.061068702),(216,0.045801527),(228,0.027989822),(240,0.03562341),(252,0.015267176),(264,0.012722646),(276,0),(288,0),(300,0.002544529),(312,0),(324,0.002544529),(336,0),(348,0),(360,0)])
#                     dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleNumbers
# 
#                     dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
#                 pass

                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full']        
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                 
 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    #dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = [0]
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Large_Mature']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.4
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Large_Embryo']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.4
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_Mature']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 500
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
             
                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_Embryo']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 500
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dictExperiment:
                        dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                    pass

                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
            
        
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_1(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()

                #str_Experiment_Label = 'EXP2_1'
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full', 'Large_All', 'Large_Mature','Large_Embryo', 'Small_All', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature','Large_Embryo', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'CAPL_Catch_Prop', 'Large_Mature','Large_Embryo']
                list_Stats_Categories = ['Full', 'Large_Mature', 'Large_Embryo']
                #list_Stats_Categories = ['Large_Mature', 'Large_Embryo']

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {
                                                         'Full':'FUL'
                                                         #,'CAPL_Catch_Prop':'CCP'
                                                         #,'Large_All':1
                                                         ,'Large_Mature':'LMT'
                                                         ,'Large_Embryo':'LEM'
                                                         #,'Small_All':1
                                                         #,'Small_Mature':'SMT'
                                                         #,'Small_Embryo':'SEM'
                                                        }
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {
                                                         'Full':1
                                                         #,'CAPL_Catch_Prop':10
                                                         #,'Large_All':1
                                                         ,'Large_Mature':10
                                                         ,'Large_Embryo':10
                                                         #,'Small_All':1
                                                         #,'Small_Mature':10
                                                         #,'Small_Embryo':10
                                                         }
                
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass

#                 '''
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 Define SubSample Sizes by Stats Category
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 '''            
#                 int_Large_SubSample_Size = self.objSSParametersLocal.popnSize * 0.4
#                 int_Small_SubSample_Size = 500
#                 dict_SubSample_Sizes_By_Category = {'Full':int(int_Full_SubSample_Size)
#                                                     #,'Large_All':int(int_Large_SubSample_Size)
#                                                     ,'Large_Mature':int(int_Large_SubSample_Size)
#                                                     ,'Large_Embryo':int(int_Large_SubSample_Size)
#                                                     #,'Small_All':int(int_Small_SubSample_Size)
#                                                     ,'Small_Mature':int(int_Small_SubSample_Size)
#                                                     ,'Small_Embryo':int(int_Small_SubSample_Size)}

#                 '''
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 Define VSPs to SubSample by Stats Category
#                 ~~~~~~~~~~~~~~~~~~~~~~
#                 '''                
#                 dict_VSPs_To_SubSample_By_Category = {'Full':0
#                                                     #,'Large_All':0
#                                                     ,'Large_Mature':(0,2)
#                                                     ,'Large_Embryo':(0,0)
#                                                     #,'Small_All':0
#                                                     ,'Small_Mature':(0,2)
#                                                     ,'Small_Embryo':(0,0)}

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                list_LDNe_PCrits_To_Get = [0.05,0]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                           
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()

                 
#                 list_Stats_Categories_For_Sampling_By_Proportion = ['CAPL_Catch_Prop']        
#                 #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
# 
#                 for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
#                     dict_Sampling_Params = OrderedDict()      
#                     ''' Sampling method  '''
#                     dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohort
#                     ''' VSP Split method  '''
#                     dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
#                     ''' Loci to remove from sample '''
#                     #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
#                     listLociToRemove = [] #None assumes keep all
#                     dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
#                     ''' Experiment sampling params '''
#                     #dict_SubSampling_Params_By_Category['Proportion_Of_VSP_To_Sample'] = floatProportionOfVSP_Embryo
#                     #odictAgeCohortSampleNumbers = OrderedDict([(0,floatProportionOfVSP_Embryo),(12,0),(24,0),(36,0)])
#                     odictAgeCohortSampleNumbers = OrderedDict([(0,0.015267176),(12,0.040712468),(24,0.03562341),(36,0.03562341),(48,0.015267176),(60,0.007633588),(72,0.005089059),(84,0),(96,0.007633588),(108,0.022900763),(120,0.03307888),(132,0.066157761),(144,0.053435115),(156,0.117048346),(168,0.1043257),(180,0.139949109),(192,0.096692112),(204,0.061068702),(216,0.045801527),(228,0.027989822),(240,0.03562341),(252,0.015267176),(264,0.012722646),(276,0),(288,0),(300,0.002544529),(312,0),(324,0.002544529),(336,0),(348,0),(360,0)])
#                     dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleNumbers
# 
#                     dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
#                 pass

                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full']        
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                 
 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    #dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = [0]
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Large_Mature']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.4
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Large_Embryo']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.4
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_Mature']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 500
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
             
                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_Embryo']    
                #list_Stats_Categories_For_Sampling_By_Absolute_Numbers = ['CAPL_Catch_Abs'] 
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 500
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dictExperiment:
                        dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                    pass

                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment

            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_2_RETIRE(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''

                #dictExperiment = OrderedDict()

                #str_Experiment_Label = 'EXP2_1'
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full', 'Large_All', 'Large_Mature','Large_Embryo', 'Small_All', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature','Large_Embryo', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'CAPL_Catch_Prop', 'Large_Mature','Large_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature', 'Large_Embryo']
                list_Stats_Categories = ['Full', 'Full_Mature', 'Full_Juvenile', 'Full_Embryo']
                #list_Stats_Categories = ['Large_Mature', 'Large_Embryo']

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Code_By_Key_Category = {
                                                         'Full':'FUL'
                                                         #,'CAPL_Catch_Prop':'CCP'
                                                         #,'Large_All':1
                                                         ,'Full_Mature':'FMT'
                                                         ,'Full_Juvenile':'FJV'
                                                         ,'Full_Embryo':'FEM'
                                                         #,'Large_Mature':'LMT'
                                                         #,'Large_Embryo':'LEM'
                                                         #,'Small_All':1
                                                         #,'Small_Mature':'SMT'
                                                         #,'Small_Embryo':'SEM'
                                                        }
                
#                 ''' Index the experiment details by Stats Category - For use when assimilating Ne2 results'''
#                 dict_Experiment_Label_By_Key_Category = OrderedDict([str_Stats_Category, str_Experiment_Label] for str_Stats_Category in list_Stats_Categories)
#                 #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
                            
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                for key, value in dict_Stats_Category_Code_By_Key_Category.items():
                    dict_Stats_Category_By_Key_Category_Code[value] = key
                pass
                #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)

                for key, value in dict_Stats_Category_By_Key_Category_Code.items():
                    self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
                pass  

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {
                                                         'Full':1
                                                         #,'CAPL_Catch_Prop':10
                                                         #,'Large_All':1
                                                         ,'Full_Mature':1
                                                         ,'Full_Juvenile':1
                                                         ,'Full_Embryo':1
                                                         #,'Large_Mature':10
                                                         #,'Large_Embryo':10
                                                         #,'Small_All':1
                                                         #,'Small_Mature':10
                                                         #,'Small_Embryo':10
                                                         }
                
                
                ''' Get total population size '''
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass
                
                '''Get total sim locu number '''
                int_Sim_Loci_Total = self.objSSParametersLocal.nLoci
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
           
                #strPCritsToProcess = self.objSSParametersLocal.str_Sampling_EXP_2_2__LDNe_PCrits_To_Get
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                else:
                    list_LDNe_PCrits_To_Get = [0.05]
                pass
#                 #list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
#                 #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
#                 list_LDNe_PCrits_To_Get = [0.05,0]
#                 strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
#                 #list_LDNe_PCrits_To_Get = [0.05]
#                 #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
#                 #list_LDNe_PCrits_To_Get = [0]
#                 #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                           
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full']        
                 
 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    
                    ''' Sample VSP '''
                    #dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = [0]
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full_Mature']    
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full_Juvenile']    
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Juvenile)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full_Embryo']    
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    float_Sample_Size = dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] *int_Full_SubSample_Size
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,float_Sample_Size)]))
                    int_Sampled_Loci_Total = int_Sim_Loci_Total - len(dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove])
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,int_Sampled_Loci_Total)]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
            
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_2(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''

                #dictExperiment = OrderedDict()

                #str_Experiment_Label = 'EXP2_1'
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full', 'Large_All', 'Large_Mature','Large_Embryo', 'Small_All', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature','Large_Embryo', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'CAPL_Catch_Prop', 'Large_Mature','Large_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature', 'Large_Embryo']
                list_Stats_Categories = ['Full', 'Full_Mature', 'Full_Juvenile', 'Full_Embryo']
                #list_Stats_Categories = ['Large_Mature', 'Large_Embryo']

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Code_By_Key_Category = {
                                                         'Full':'FUL'
                                                         #,'CAPL_Catch_Prop':'CCP'
                                                         #,'Large_All':1
                                                         ,'Full_Mature':'FMT'
                                                         ,'Full_Juvenile':'FJV'
                                                         ,'Full_Embryo':'FEM'
                                                         #,'Large_Mature':'LMT'
                                                         #,'Large_Embryo':'LEM'
                                                         #,'Small_All':1
                                                         #,'Small_Mature':'SMT'
                                                         #,'Small_Embryo':'SEM'
                                                        }
                
#                 ''' Index the experiment details by Stats Category - For use when assimilating Ne2 results'''
#                 dict_Experiment_Label_By_Key_Category = OrderedDict([str_Stats_Category, str_Experiment_Label] for str_Stats_Category in list_Stats_Categories)
#                 #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
                            
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                for key, value in dict_Stats_Category_Code_By_Key_Category.items():
                    dict_Stats_Category_By_Key_Category_Code[value] = key
                pass
                #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)

                for key, value in dict_Stats_Category_By_Key_Category_Code.items():
                    self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
                pass  

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_SubSample_Replicates = 1
                dict_SubSample_Replicates_By_Category = {
                                                         'Full':int_SubSample_Replicates
                                                         #,'CAPL_Catch_Prop':10
                                                         #,'Large_All':1
                                                         ,'Full_Mature':int_SubSample_Replicates
                                                         ,'Full_Juvenile':int_SubSample_Replicates
                                                         ,'Full_Embryo':int_SubSample_Replicates
                                                         #,'Large_Mature':10
                                                         #,'Large_Embryo':10
                                                         #,'Small_All':1
                                                         #,'Small_Mature':10
                                                         #,'Small_Embryo':10
                                                         }
                
                
                ''' Get total population size '''
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass
                
                '''
                -----------------------------------
                Define the loci to discard - This is done to balance speed of processing with accuracy
                -----------------------------------
                '''
                '''Get total sim locu number '''
                int_Sim_Loci_Total = self.objSSParametersLocal.nLoci
                
#                 if int_Sim_Loci_Total >= 100:
#                     ''' Work out a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
#                         When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
#                         with 1 pop replicate the Sampling Strat takes ~10 min to run 
#                         When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
#                         with 1 pop replicate the Sampling Strat takes ~25 min to run 
#                     
#                     
#                     '''
#                     #.25%
#                     float_Percentage_Of_Loci_To_Keep = 0.25
#                     int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (0.25),0))
#                 else:
#                     int_Sim_Loci_To_Keep = int_Sim_Loci_Total
#                 pass
            
                float_Percentage_Of_Loci_To_Keep = self.objSSParametersLocal.float_Sampling_EXP_2_2__LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
                if float_Percentage_Of_Loci_To_Keep > 2 and float_Percentage_Of_Loci_To_Keep < 100:
                    ''' Use a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
                        When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~10 min to run 
                        When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~25 min to run 
                    '''
                    int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (float_Percentage_Of_Loci_To_Keep / float(100)),0))
                    
                    list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci_Total)]
                    list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Sim_Loci_To_Keep)
                    list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]
                    listLociToRemove = [ 'Locus-' + str(x+1) for x in list_Sim_Loci_To_Remove]                    
                else:
                    int_Sim_Loci_To_Keep = int_Sim_Loci_Total
                    listLociToRemove = [] 
                pass
            
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
           
                #strPCritsToProcess = self.objSSParametersLocal.str_Sampling_EXP_2_2__LDNe_PCrits_To_Get
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]
#                 else:
#                     list_LDNe_PCrits_To_Get = [0.05]
                pass
#                 #list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
#                 #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
#                 list_LDNe_PCrits_To_Get = [0.05,0]
#                 strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
#                 #list_LDNe_PCrits_To_Get = [0.05]
#                 #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
#                 #list_LDNe_PCrits_To_Get = [0]
#                 #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                           
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full']        
                 
 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    
                    ''' Sample VSP '''
                    #dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = [0]
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    #listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full_Mature']    
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    #listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full_Juvenile']    
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Juvenile)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    #listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full_Embryo']    
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    #listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    float_Sample_Size = dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] *int_Full_SubSample_Size
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,float_Sample_Size)]))
                    int_Sampled_Loci_Total = int_Sim_Loci_Total - len(dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove])
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,int_Sampled_Loci_Total)]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
            
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_3_RETIRE(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()

                #str_Experiment_Label = 'EXP2_1'
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full', 'Large_All', 'Large_Mature','Large_Embryo', 'Small_All', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature','Large_Embryo', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'CAPL_Catch_Prop', 'Large_Mature','Large_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature', 'Large_Embryo']
                #list_Stats_Categories = ['Full', 'Full_Mature', 'Full_Juvenile', 'Full_Embryo']
                list_Stats_Categories = ['Small_All', 'Small_Mature', 'Small_Embryo', 'Small_3_Cohort']

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {
                                                         'Small_All':'SAL'
                                                        ,'Small_Mature':'SMT'
                                                        ,'Small_Embryo':'SEM'
                                                        ,'Small_3_Cohort':'S3C'
                                                        }
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Sample_Replicates = 1
                dict_SubSample_Replicates_By_Category = {
                                                         'Small_All':int_Sample_Replicates
                                                        ,'Small_Mature':int_Sample_Replicates
                                                        ,'Small_Embryo':int_Sample_Replicates
                                                        ,'Small_3_Cohort':int_Sample_Replicates
                                                        }
                
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                #list_LDNe_PCrits_To_Get = [0.05, 0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                list_LDNe_PCrits_To_Get = [0.05]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
                #list_LDNe_PCrits_To_Get = [0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                           
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_All']        
                 
 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 100
                    ''' Sample VSP '''
                    #dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = [0]
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass

                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_Mature']    
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 100
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_Embryo']    
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 100
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass

                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteNumber
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
                    ''' Experiment sampling params '''
                    odictAgeCohortSampleNumbers = OrderedDict([(0,33),(12,33),(24,34)])
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort] = odictAgeCohortSampleNumbers
    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dictExperiment:
                        dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                    pass

                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment

            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_3(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()

                #str_Experiment_Label = 'EXP2_1'
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full', 'Large_All', 'Large_Mature','Large_Embryo', 'Small_All', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature','Large_Embryo', 'Small_Mature', 'Small_Embryo']
                #list_Stats_Categories = ['Full', 'CAPL_Catch_Prop', 'Large_Mature','Large_Embryo']
                #list_Stats_Categories = ['Full', 'Large_Mature', 'Large_Embryo']
                #list_Stats_Categories = ['Full', 'Full_Mature', 'Full_Juvenile', 'Full_Embryo']
                list_Stats_Categories = ['Small_All', 'Small_Mature', 'Small_Embryo', 'Small_3_Cohort']

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Code_By_Key_Category = {
                                                         'Small_All':'SAL'
                                                        ,'Small_Mature':'SMT'
                                                        ,'Small_Embryo':'SEM'
                                                        ,'Small_3_Cohort':'S3C'
                                                        }
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Sample_Replicates = 1
                dict_SubSample_Replicates_By_Category = {
                                                         'Small_All':int_Sample_Replicates
                                                        ,'Small_Mature':int_Sample_Replicates
                                                        ,'Small_Embryo':int_Sample_Replicates
                                                        ,'Small_3_Cohort':int_Sample_Replicates
                                                        }
                
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                #list_LDNe_PCrits_To_Get = [0.05, 0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                list_LDNe_PCrits_To_Get = [0.05]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
                #list_LDNe_PCrits_To_Get = [0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                           
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_All']        
                 
 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 100
                    ''' Sample VSP '''
                    #dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = [0]
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass

                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_Mature']    
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 100
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_Embryo']    
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandomAbsolute
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_AbsoluteNumberOfIndividuals] = 100
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass

                list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteNumber
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
                    ''' Experiment sampling params '''
                    odictAgeCohortSampleNumbers = OrderedDict([(0,33),(12,33),(24,34)])
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort] = odictAgeCohortSampleNumbers
    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment

            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_0_RETIRE(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''
                dictExperiment = OrderedDict()
                list_Stats_Categories = []
                dict_Experiment_Label_By_Key_Category = OrderedDict()
                dict_Stats_Category_Code_By_Key_Category = OrderedDict()
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                dict_SubSample_Size_By_Category = OrderedDict()
                dict_SubSample_Replicates_By_Category = OrderedDict()
                dict_Loci_To_Remove_By_Category = OrderedDict()
                dict_Loci_To_Sample_By_Category = OrderedDict()
                listLociToRemove = [] #None assumes keep all
                list_LDNe_PCrits_To_Get = []
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By

                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''    
                int_Sample_Replicates = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Replicates
                int_Sample_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Min
                int_Sample_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Max
                int_Sample_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Increment
                int_Loci_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Min
                int_Loci_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Max
                int_Loci_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Increment 
                int_Sim_Loci = self.objSSParametersLocal.nLoci
                int_Sim_Loci_To_Remove = int_Sim_Loci - int_Loci_Max
                 
                #list_Sim_Loci_Names = ['Locus-' + str(int_Locus) for int_Locus in range(0, int_Sim_Loci)]
                list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci)]
                
                #list_Sim_Loci_To_Remove =[int_Locus for int_Locus in range(1, int_Sim_Loci + 1)]
                list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Loci_Max)
                list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]

#                 
#                 for int_Locus in range(0, int_Sim_Loci):
#                     
#                 listLociToRemove = [numpy__random.randint(1, int_Sim_Loci) for x in range(int_Sim_Loci_To_Remove)]
                int_Category_Count = 0
                for int_Samples in range(int_Sample_Min, int_Sample_Max+1, int_Sample_Increment):
                    str_Samples = str(int_Samples)
                    
                    for int_Loci_To_Sample in range(int_Loci_Min, int_Loci_Max+1, int_Loci_Increment):

                        list_Sim_Loci_To_Sample = random__sample(list_Sim_Loci_To_Keep, int_Loci_To_Sample)
                        list_Sim_Loci_To_Remove_Additional = [x for x in list_Sim_Loci_To_Keep if x not in list_Sim_Loci_To_Sample]
                        list_Sim_Loci_To_Remove_Additional.extend(list_Sim_Loci_To_Remove)
                        
                        '''  Define SubSampling Stats Categories '''
                        str_Loci_To_Sample = str(int_Loci_To_Sample)
                        str_Stats_Category = 'S' + str_Samples + '_' + 'L' + str_Loci_To_Sample
                        list_Stats_Categories.append(str_Stats_Category)   
                        int_Category_Count += 1
                        str_Stats_Category_Code = str(int_Category_Count).zfill(3)
                        
                        ''' Define Experiment by key Stats Category '''    
                        dict_Experiment_Label_By_Key_Category[str_Stats_Category] = str_Experiment_Label                        
                        ''' Define Stat Category Code by key Stats Category '''    
                        dict_Stats_Category_Code_By_Key_Category[str_Stats_Category] = str_Stats_Category_Code
                        ''' Define Stats category by key Stats Code '''
                        dict_Stats_Category_By_Key_Category_Code[str_Stats_Category_Code] = str_Stats_Category
                        ''' Define SubSample Size by Stats Category '''
                        dict_SubSample_Size_By_Category[str_Stats_Category] = int_Samples     
                        ''' Define SubSample Replicate Number by Stats Category '''
                        dict_SubSample_Replicates_By_Category[str_Stats_Category] = int_Sample_Replicates     
                        ''' Loci to remove from sample '''   
                        dict_Loci_To_Remove_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Remove_Additional)                               
                        ''' Loci to keep for sample '''   
                        dict_Loci_To_Sample_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Sample)                              
                    pass
                
                pass


                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_Codes_By_Key_Category = OrderedDict(dict_Stats_Category_Code_By_Key_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
#                 for key, value in dict_Stats_Category_By_Key_Category_Code.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
#                 pass             
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__SubSample_Replicates_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Loci_To_Sample_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0.05, 0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0.05, 0.02 ,0.01, 0]
                pass

                
#                 if list_LDNe_PCrits_To_Get == [0]:
#                     strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
#                 elif list_LDNe_PCrits_To_Get == [0.05]:
#                     strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
#                 elif list_LDNe_PCrits_To_Get == [0.05, 0]:
#                     strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
#                 elif list_LDNe_PCrits_To_Get == [0.05, 0.02 ,0.01, 0]:
#                     strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
#                 pass
            

                #listLociToRemove = self.objSSParametersLocal.list_Sampling_Strategy_1_0__Loci_To_Remove 
                
                odictAgeCohortSampleProportions = self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Age_Cohort_Sample_Proportions_Of_Total_Sample  
                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                #list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                #for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                for str_Stats_Category in list_Stats_Categories:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = dict_Loci_To_Remove_By_Category[str_Stats_Category] #listLociToRemove
                    ''' Experiment sampling params '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleProportions
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize] = dict_SubSample_Size_By_Category[str_Stats_Category]
                    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dictExperiment:
                        dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                    pass

                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
                        
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_0(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''
                #dictExperiment = OrderedDict()
                list_Stats_Categories = []
                dict_Experiment_Label_By_Key_Category = OrderedDict()
                dict_Stats_Category_Code_By_Key_Category = OrderedDict()
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                dict_SubSample_Size_By_Category = OrderedDict()
                dict_SubSample_Replicates_By_Category = OrderedDict()
                dict_Loci_To_Remove_By_Category = OrderedDict()
                dict_Loci_To_Sample_By_Category = OrderedDict()
                list_LDNe_PCrits_To_Get = []
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By

                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''    
                int_Sample_Replicates = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Replicates
                int_Sample_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Min
                int_Sample_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Max
                int_Sample_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Increment
                int_Loci_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Min
                int_Loci_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Max
                int_Loci_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Increment 
                int_Sim_Loci = self.objSSParametersLocal.nLoci
                int_Sim_Loci_To_Remove = int_Sim_Loci - int_Loci_Max
                 
                #list_Sim_Loci_Names = ['Locus-' + str(int_Locus) for int_Locus in range(0, int_Sim_Loci)]
                list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci)]
                
                #list_Sim_Loci_To_Remove =[int_Locus for int_Locus in range(1, int_Sim_Loci + 1)]
                list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Loci_Max)
                list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]

#                 
#                 for int_Locus in range(0, int_Sim_Loci):
#                     
#                 listLociToRemove = [numpy__random.randint(1, int_Sim_Loci) for x in range(int_Sim_Loci_To_Remove)]
                int_Category_Count = 0
                for int_Samples in range(int_Sample_Min, int_Sample_Max+1, int_Sample_Increment):
                    str_Samples = str(int_Samples)
                    
                    for int_Loci_To_Sample in range(int_Loci_Min, int_Loci_Max+1, int_Loci_Increment):

                        list_Sim_Loci_To_Sample = random__sample(list_Sim_Loci_To_Keep, int_Loci_To_Sample)
                        list_Sim_Loci_To_Remove_Additional = [x for x in list_Sim_Loci_To_Keep if x not in list_Sim_Loci_To_Sample]
                        list_Sim_Loci_To_Remove_Additional.extend(list_Sim_Loci_To_Remove)
                        
                        '''  Define SubSampling Stats Categories '''
                        str_Loci_To_Sample = str(int_Loci_To_Sample)
                        str_Stats_Category = 'S' + str_Samples + '_' + 'L' + str_Loci_To_Sample
                        list_Stats_Categories.append(str_Stats_Category)   
                        int_Category_Count += 1
                        str_Stats_Category_Code = 'A' + str(int_Category_Count).zfill(2)
                        
                        ''' Define Experiment by key Stats Category '''    
                        dict_Experiment_Label_By_Key_Category[str_Stats_Category] = str_Experiment_Label                        
                        ''' Define Stat Category Code by key Stats Category '''    
                        dict_Stats_Category_Code_By_Key_Category[str_Stats_Category] = str_Stats_Category_Code
                        ''' Define Stats category by key Stats Code '''
                        dict_Stats_Category_By_Key_Category_Code[str_Stats_Category_Code] = str_Stats_Category
                        ''' Define SubSample Size by Stats Category '''
                        dict_SubSample_Size_By_Category[str_Stats_Category] = int_Samples     
                        ''' Define SubSample Replicate Number by Stats Category '''
                        dict_SubSample_Replicates_By_Category[str_Stats_Category] = int_Sample_Replicates     
                        ''' Loci to remove from sample '''   
                        dict_Loci_To_Remove_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Remove_Additional)                               
                        ''' Loci to keep for sample '''   
                        dict_Loci_To_Sample_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Sample)                              
                    pass
                
                pass


                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_Codes_By_Key_Category = OrderedDict(dict_Stats_Category_Code_By_Key_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
#                 for key, value in dict_Stats_Category_By_Key_Category_Code.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
#                 pass             
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__SubSample_Replicates_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Loci_To_Sample_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0]
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0.02 ,0.01, 0]
                pass

                
                pass
            

                #listLociToRemove = self.objSSParametersLocal.list_Sampling_Strategy_1_0__Loci_To_Remove 
                
                odictAgeCohortSampleProportions = self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Age_Cohort_Sample_Proportions_Of_Total_Sample  
                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                #list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                #for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                for str_Stats_Category in list_Stats_Categories:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    bool_User_Defined_Sampling_Proportions = False
                    if bool_User_Defined_Sampling_Proportions:
                        dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
                    else:
                        dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples
                    pass
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = dict_Loci_To_Remove_By_Category[str_Stats_Category] #listLociToRemove
                    ''' Experiment sampling params '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleProportions
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize] = dict_SubSample_Size_By_Category[str_Stats_Category]
                    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,dict_SubSample_Size_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,len(dict_Loci_To_Sample_By_Category[str_Stats_Category]))]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
                        
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_1__USER_AGE_COHORTS(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''
                #dictExperiment = OrderedDict()
                list_Stats_Categories = []
                dict_Experiment_Label_By_Key_Category = OrderedDict()
                dict_Stats_Category_Code_By_Key_Category = OrderedDict()
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                dict_SubSample_Size_By_Category = OrderedDict()
                dict_SubSample_Replicates_By_Category = OrderedDict()
                dict_Loci_To_Remove_By_Category = OrderedDict()
                dict_Loci_To_Sample_By_Category = OrderedDict()
                list_LDNe_PCrits_To_Get = []
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By

                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''    
                int_Sample_Replicates = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Replicates
                int_Sample_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Min
                int_Sample_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Max
                int_Sample_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Increment
                int_Loci_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Min
                int_Loci_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Max
                int_Loci_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Increment 
                int_Sim_Loci = self.objSSParametersLocal.nLoci
                int_Sim_Loci_To_Remove = int_Sim_Loci - int_Loci_Max
                 
                #list_Sim_Loci_Names = ['Locus-' + str(int_Locus) for int_Locus in range(0, int_Sim_Loci)]
                list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci)]
                
                #list_Sim_Loci_To_Remove =[int_Locus for int_Locus in range(1, int_Sim_Loci + 1)]
                list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Loci_Max)
                list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]

#                 
#                 for int_Locus in range(0, int_Sim_Loci):
#                     
#                 listLociToRemove = [numpy__random.randint(1, int_Sim_Loci) for x in range(int_Sim_Loci_To_Remove)]
                int_Category_Count = 0
                for int_Samples in range(int_Sample_Min, int_Sample_Max+1, int_Sample_Increment):
                    str_Samples = str(int_Samples)
                    
                    for int_Loci_To_Sample in range(int_Loci_Min, int_Loci_Max+1, int_Loci_Increment):

                        list_Sim_Loci_To_Sample = random__sample(list_Sim_Loci_To_Keep, int_Loci_To_Sample)
                        list_Sim_Loci_To_Remove_Additional = [x for x in list_Sim_Loci_To_Keep if x not in list_Sim_Loci_To_Sample]
                        list_Sim_Loci_To_Remove_Additional.extend(list_Sim_Loci_To_Remove)
                        
                        '''  Define SubSampling Stats Categories '''
                        str_Loci_To_Sample = str(int_Loci_To_Sample)
                        str_Stats_Category = 'S' + str_Samples + '_' + 'L' + str_Loci_To_Sample
                        list_Stats_Categories.append(str_Stats_Category)   
                        int_Category_Count += 1
                        str_Stats_Category_Code = 'A' + str(int_Category_Count).zfill(2)
                        
                        ''' Define Experiment by key Stats Category '''    
                        dict_Experiment_Label_By_Key_Category[str_Stats_Category] = str_Experiment_Label                        
                        ''' Define Stat Category Code by key Stats Category '''    
                        dict_Stats_Category_Code_By_Key_Category[str_Stats_Category] = str_Stats_Category_Code
                        ''' Define Stats category by key Stats Code '''
                        dict_Stats_Category_By_Key_Category_Code[str_Stats_Category_Code] = str_Stats_Category
                        ''' Define SubSample Size by Stats Category '''
                        dict_SubSample_Size_By_Category[str_Stats_Category] = int_Samples     
                        ''' Define SubSample Replicate Number by Stats Category '''
                        dict_SubSample_Replicates_By_Category[str_Stats_Category] = int_Sample_Replicates     
                        ''' Loci to remove from sample '''   
                        dict_Loci_To_Remove_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Remove_Additional)                               
                        ''' Loci to keep for sample '''   
                        dict_Loci_To_Sample_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Sample)                              
                    pass
                
                pass


                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_Codes_By_Key_Category = OrderedDict(dict_Stats_Category_Code_By_Key_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
#                 for key, value in dict_Stats_Category_By_Key_Category_Code.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
#                 pass             
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__SubSample_Replicates_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Loci_To_Sample_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]                  
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0]
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0.02 ,0.01, 0]
                pass

                
                pass
            

                #listLociToRemove = self.objSSParametersLocal.list_Sampling_Strategy_1_0__Loci_To_Remove 
                
                odictAgeCohortSampleProportions = self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Age_Cohort_Sample_Proportions_Of_Total_Sample  
                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                #list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                #for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                for str_Stats_Category in list_Stats_Categories:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    bool_User_Defined_Sampling_Proportions = False
                    if bool_User_Defined_Sampling_Proportions:
                        dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
                    else:
                        dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples
                    pass
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = dict_Loci_To_Remove_By_Category[str_Stats_Category] #listLociToRemove
                    ''' Experiment sampling params '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleProportions
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize] = dict_SubSample_Size_By_Category[str_Stats_Category]
                    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,dict_SubSample_Size_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,len(dict_Loci_To_Sample_By_Category[str_Stats_Category]))]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
                        
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_100_PERCENT_USER_SPECIFED_AGE_COHORTS_1_0(self, str_Experiment_Label, str_Search_Path, dictExperiment):


                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''
                #dictExperiment = OrderedDict()
                list_Stats_Categories = []
                dict_Experiment_Label_By_Key_Category = OrderedDict()
                dict_Stats_Category_Code_By_Key_Category = OrderedDict()
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                dict_SubSample_Size_By_Category = OrderedDict()
                dict_SubSample_Replicates_By_Category = OrderedDict()
                dict_Loci_To_Remove_By_Category = OrderedDict()
                dict_Loci_To_Sample_By_Category = OrderedDict()
                list_LDNe_PCrits_To_Get = []
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By

                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''
                str_Category_Name = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Name_FAC
                list_Stats_Categories = [str_Category_Name]
                    
                #int_Sample_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Min
                #int_Sample_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Max
                #int_Sample_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Increment
                #int_Loci_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Min
                #int_Loci_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Max
                #int_Loci_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Increment 


                '''
                -----------------------------------
                Define the loci to discard - This is done to balance speed of processing with accuracy
                -----------------------------------
                '''   
                int_Sim_Loci_Total = self.objSSParametersLocal.nLoci
                int_Sim_Loci_To_Remove = 0 #int_Sim_Loci - int_Loci_Max
                float_Percentage_Of_Loci_To_Keep = self.objSSParametersLocal.float_Sampling_EXP_2_2__LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
                list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci_Total)]
                
                if float_Percentage_Of_Loci_To_Keep > 2 and float_Percentage_Of_Loci_To_Keep < 100:
                    ''' Use a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
                        When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~10 min to run 
                        When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~25 min to run 
                    '''
                    int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (float_Percentage_Of_Loci_To_Keep / float(100)),0))
                    
                    #list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci_Total)]
                    list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Sim_Loci_To_Keep)
                    list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]
                    listLociToRemove = [ 'Locus-' + str(x+1) for x in list_Sim_Loci_To_Remove]                    
                else:
                    int_Sim_Loci_To_Keep = int_Sim_Loci_Total
                    list_Sim_Loci_To_Keep = list(list_Sim_Loci)
                    listLociToRemove = [] 
                pass
            
                dict_Loci_To_Remove_By_Category[list_Stats_Categories[0]] = list(listLociToRemove)
                dict_Loci_To_Sample_By_Category[list_Stats_Categories[0]] = list(list_Sim_Loci_To_Keep)
                
                #list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci)]
                
                #list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Loci_Max)
                #list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]

#                 int_Category_Count = 0
#                 for int_Samples in range(int_Sample_Min, int_Sample_Max+1, int_Sample_Increment):
#                     str_Samples = str(int_Samples)
#                     
#                     for int_Loci_To_Sample in range(int_Loci_Min, int_Loci_Max+1, int_Loci_Increment):
# 
#                         list_Sim_Loci_To_Sample = random__sample(list_Sim_Loci_To_Keep, int_Loci_To_Sample)
#                         list_Sim_Loci_To_Remove_Additional = [x for x in list_Sim_Loci_To_Keep if x not in list_Sim_Loci_To_Sample]
#                         list_Sim_Loci_To_Remove_Additional.extend(list_Sim_Loci_To_Remove)
#                         
#                         '''  Define SubSampling Stats Categories '''
#                         str_Loci_To_Sample = str(int_Loci_To_Sample)
#                         str_Stats_Category = 'S' + str_Samples + '_' + 'L' + str_Loci_To_Sample
#                         list_Stats_Categories.append(str_Stats_Category)   
#                         int_Category_Count += 1
#                         str_Stats_Category_Code = 'A' + str(int_Category_Count).zfill(2)
#                         
#                         ''' Define Experiment by key Stats Category '''    
#                         dict_Experiment_Label_By_Key_Category[str_Stats_Category] = str_Experiment_Label                        
#                         ''' Define Stat Category Code by key Stats Category '''    
#                         dict_Stats_Category_Code_By_Key_Category[str_Stats_Category] = str_Stats_Category_Code
#                         ''' Define Stats category by key Stats Code '''
#                         dict_Stats_Category_By_Key_Category_Code[str_Stats_Category_Code] = str_Stats_Category
#                         ''' Define SubSample Size by Stats Category '''
#                         dict_SubSample_Size_By_Category[str_Stats_Category] = int_Samples     
#                         ''' Define SubSample Replicate Number by Stats Category '''
#                         dict_SubSample_Replicates_By_Category[str_Stats_Category] = int_Sample_Replicates     
#                         ''' Loci to remove from sample '''   
#                         dict_Loci_To_Remove_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Remove_Additional)                               
#                         ''' Loci to keep for sample '''   
#                         dict_Loci_To_Sample_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Sample)                              
#                     pass
#                 
#                 pass

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''
                str_Category_Code = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Code_FAC                
                dict_Stats_Category_Code_By_Key_Category = {str_Category_Name:str_Category_Code}
                            
                #dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                for key, value in dict_Stats_Category_Code_By_Key_Category.items():
                    dict_Stats_Category_By_Key_Category_Code[value] = key
                pass

                for key, value in dict_Stats_Category_By_Key_Category_Code.items():
                    self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
                pass  

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                '''
                Only 1 replicate is required per pop replicate.
                This is because thes full age cohorts estimates are made from the same samples and therefor will be exactly the same LDNe each time.
                Accuracy cant be increased by more LDNe replicates, only by more pop replicates.
                However, replicates specified by Sampling Strategy
                '''
                if str_Category_Code in self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline.keys()[0]: 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline[str_Category_Code]               
                elif str_Category_Code in self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run.keys(): 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run[str_Category_Code]               
                pass                 
                dict_SubSample_Replicates_By_Category = {str_Category_Name:int_Sample_Replicates}


                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_Codes_By_Key_Category = OrderedDict(dict_Stats_Category_Code_By_Key_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__SubSample_Replicates_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Loci_To_Sample_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]                    
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0]
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0.02 ,0.01, 0]
                pass

                
                pass
            

                #listLociToRemove = self.objSSParametersLocal.list_Sampling_Strategy_1_0__Loci_To_Remove 
                
                odictAgeCohortSampleProportions = self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Age_Cohort_Sample_Proportions_Of_Total_Sample  
                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                
#                 ''' Get total population size '''
#                 if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
#                     int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
#                 else:
#                     int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
#                 pass                
                dict_SubSample_Size_By_Category[list_Stats_Categories[0]] = 1
                            
                #list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                #for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                for str_Stats_Category in list_Stats_Categories:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
#                     bool_User_Defined_Sampling_Proportions = True
#                     if bool_User_Defined_Sampling_Proportions:
#                         dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
#                     else:
#                         dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples
#                     pass
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_100_Percent_Of_User_Specified_Age_Cohorts
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = dict_Loci_To_Remove_By_Category[str_Stats_Category] #listLociToRemove
                    ''' Experiment sampling params '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleProportions
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize] = dict_SubSample_Size_By_Category[str_Stats_Category]
                    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,dict_SubSample_Size_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,len(dict_Loci_To_Sample_By_Category[str_Stats_Category]))]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment

            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION(self, str_Experiment_Label, str_Search_Path, dictExperiment):


                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''
                #dictExperiment = OrderedDict()
                list_Stats_Categories = []
                dict_Experiment_Label_By_Key_Category = OrderedDict()
                dict_Stats_Category_Code_By_Key_Category = OrderedDict()
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                dict_SubSample_Size_By_Category = OrderedDict()
                dict_SubSample_Replicates_By_Category = OrderedDict()
                dict_Loci_To_Remove_By_Category = OrderedDict()
                dict_Loci_To_Sample_By_Category = OrderedDict()
                list_LDNe_PCrits_To_Get = []
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By

                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''
                str_Category_Name = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Name_PSMP
                list_Stats_Categories = [str_Category_Name]
                #list_Stats_Categories = [globalsSS.Colnames_COMMON_STATS.static_str_Colname_Stats_Category__Sampling_Proportions_Scaled_By_Max_Proportion]
                    
                #int_Sample_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Min
                #int_Sample_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Max
                #int_Sample_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Increment
                #int_Loci_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Min
                #int_Loci_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Max
                #int_Loci_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Increment 


                '''
                -----------------------------------
                Define the loci to discard - This is done to balance speed of processing with accuracy
                -----------------------------------
                '''   
                int_Sim_Loci_Total = self.objSSParametersLocal.nLoci
                int_Sim_Loci_To_Remove = 0 #int_Sim_Loci - int_Loci_Max
                float_Percentage_Of_Loci_To_Keep = self.objSSParametersLocal.float_Sampling_EXP_2_2__LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
                list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci_Total)]
                
                if float_Percentage_Of_Loci_To_Keep > 2 and float_Percentage_Of_Loci_To_Keep < 100:
                    ''' Use a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
                        When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~10 min to run 
                        When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~25 min to run 
                    '''
                    int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (float_Percentage_Of_Loci_To_Keep / float(100)),0))
                    
                    #list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci_Total)]
                    list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Sim_Loci_To_Keep)
                    list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]
                    listLociToRemove = [ 'Locus-' + str(x+1) for x in list_Sim_Loci_To_Remove]                    
                else:
                    int_Sim_Loci_To_Keep = int_Sim_Loci_Total
                    list_Sim_Loci_To_Keep = list(list_Sim_Loci)
                    listLociToRemove = [] 
                pass
            
                dict_Loci_To_Remove_By_Category[list_Stats_Categories[0]] = list(listLociToRemove)
                dict_Loci_To_Sample_By_Category[list_Stats_Categories[0]] = list(list_Sim_Loci_To_Keep)
                
                #list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci)]
                
                #list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Loci_Max)
                #list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]

#                 int_Category_Count = 0
#                 for int_Samples in range(int_Sample_Min, int_Sample_Max+1, int_Sample_Increment):
#                     str_Samples = str(int_Samples)
#                     
#                     for int_Loci_To_Sample in range(int_Loci_Min, int_Loci_Max+1, int_Loci_Increment):
# 
#                         list_Sim_Loci_To_Sample = random__sample(list_Sim_Loci_To_Keep, int_Loci_To_Sample)
#                         list_Sim_Loci_To_Remove_Additional = [x for x in list_Sim_Loci_To_Keep if x not in list_Sim_Loci_To_Sample]
#                         list_Sim_Loci_To_Remove_Additional.extend(list_Sim_Loci_To_Remove)
#                         
#                         '''  Define SubSampling Stats Categories '''
#                         str_Loci_To_Sample = str(int_Loci_To_Sample)
#                         str_Stats_Category = 'S' + str_Samples + '_' + 'L' + str_Loci_To_Sample
#                         list_Stats_Categories.append(str_Stats_Category)   
#                         int_Category_Count += 1
#                         str_Stats_Category_Code = 'A' + str(int_Category_Count).zfill(2)
#                         
#                         ''' Define Experiment by key Stats Category '''    
#                         dict_Experiment_Label_By_Key_Category[str_Stats_Category] = str_Experiment_Label                        
#                         ''' Define Stat Category Code by key Stats Category '''    
#                         dict_Stats_Category_Code_By_Key_Category[str_Stats_Category] = str_Stats_Category_Code
#                         ''' Define Stats category by key Stats Code '''
#                         dict_Stats_Category_By_Key_Category_Code[str_Stats_Category_Code] = str_Stats_Category
#                         ''' Define SubSample Size by Stats Category '''
#                         dict_SubSample_Size_By_Category[str_Stats_Category] = int_Samples     
#                         ''' Define SubSample Replicate Number by Stats Category '''
#                         dict_SubSample_Replicates_By_Category[str_Stats_Category] = int_Sample_Replicates     
#                         ''' Loci to remove from sample '''   
#                         dict_Loci_To_Remove_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Remove_Additional)                               
#                         ''' Loci to keep for sample '''   
#                         dict_Loci_To_Sample_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Sample)                              
#                     pass
#                 
#                 pass

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''
                str_Category_Code = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Code_PSMP
                dict_Stats_Category_Code_By_Key_Category = {str_Category_Name:str_Category_Code} 
                            
                #dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                for key, value in dict_Stats_Category_Code_By_Key_Category.items():
                    dict_Stats_Category_By_Key_Category_Code[value] = key
                pass

                for key, value in dict_Stats_Category_By_Key_Category_Code.items():
                    self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
                pass  

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                '''
                Replicates specified by Sampling Strategy
                '''
                if str_Category_Code in self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline.keys()[0]: 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline[str_Category_Code]               
                elif str_Category_Code in self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run.keys(): 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run[str_Category_Code]               
                pass                 
                dict_SubSample_Replicates_By_Category = {str_Category_Name:int_Sample_Replicates}


                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_Codes_By_Key_Category = OrderedDict(dict_Stats_Category_Code_By_Key_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__SubSample_Replicates_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Loci_To_Sample_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]                    
                pass

                
                pass
            

                #listLociToRemove = self.objSSParametersLocal.list_Sampling_Strategy_1_0__Loci_To_Remove 
                
                odictAgeCohortSampleProportions = self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Age_Cohort_Sample_Proportions_Of_Total_Sample  
                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                
#                 ''' Get total population size '''
#                 if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
#                     int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
#                 else:
#                     int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
#                 pass                
                dict_SubSample_Size_By_Category[list_Stats_Categories[0]] = 1
                            
                #list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                #for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                for str_Stats_Category in list_Stats_Categories:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
#                     bool_User_Defined_Sampling_Proportions = True
#                     if bool_User_Defined_Sampling_Proportions:
#                         dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
#                     else:
#                         dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples
#                     pass
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByMaxPropPerVSPCohort
                    ''' Percentage to scale up to. e.g. 1 = 100% of the cohrt with the max propoprtion '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionScaledByMaxAbsPerVSPCohort_MaxProportion] = 1
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = dict_Loci_To_Remove_By_Category[str_Stats_Category] #listLociToRemove
                    ''' Experiment sampling params '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleProportions
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize] = dict_SubSample_Size_By_Category[str_Stats_Category]
                    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,dict_SubSample_Size_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,len(dict_Loci_To_Sample_By_Category[str_Stats_Category]))]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
                        
                        
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_1__USER_SAMPLE_NUMBERS(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''
                #dictExperiment = OrderedDict()
                list_Stats_Categories = []
                dict_Experiment_Label_By_Key_Category = OrderedDict()
                dict_Stats_Category_Code_By_Key_Category = OrderedDict()
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                dict_SubSample_Size_By_Category = OrderedDict()
                dict_SubSample_Replicates_By_Category = OrderedDict()
                dict_Loci_To_Remove_By_Category = OrderedDict()
                dict_Loci_To_Sample_By_Category = OrderedDict()
                list_LDNe_PCrits_To_Get = []
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By

                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''    
                int_Sample_Replicates = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Replicates
                int_Sample_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Min
                int_Sample_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Max
                int_Sample_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Increment
                int_Loci_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Min
                int_Loci_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Max
                int_Loci_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Increment 
                int_Sim_Loci = self.objSSParametersLocal.nLoci
                int_Sim_Loci_To_Remove = int_Sim_Loci - int_Loci_Max
                 
                #list_Sim_Loci_Names = ['Locus-' + str(int_Locus) for int_Locus in range(0, int_Sim_Loci)]
                list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci)]
                
                #list_Sim_Loci_To_Remove =[int_Locus for int_Locus in range(1, int_Sim_Loci + 1)]
                list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Loci_Max)
                list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]

#                 
#                 for int_Locus in range(0, int_Sim_Loci):
#                     
#                 listLociToRemove = [numpy__random.randint(1, int_Sim_Loci) for x in range(int_Sim_Loci_To_Remove)]
                int_Category_Count = 0
                for int_Samples in range(int_Sample_Min, int_Sample_Max+1, int_Sample_Increment):
                    str_Samples = str(int_Samples)
                    
                    for int_Loci_To_Sample in range(int_Loci_Min, int_Loci_Max+1, int_Loci_Increment):

                        list_Sim_Loci_To_Sample = random__sample(list_Sim_Loci_To_Keep, int_Loci_To_Sample)
                        list_Sim_Loci_To_Remove_Additional = [x for x in list_Sim_Loci_To_Keep if x not in list_Sim_Loci_To_Sample]
                        list_Sim_Loci_To_Remove_Additional.extend(list_Sim_Loci_To_Remove)
                        
                        '''  Define SubSampling Stats Categories '''
                        str_Loci_To_Sample = str(int_Loci_To_Sample)
                        str_Stats_Category = 'S' + str_Samples + '_' + 'L' + str_Loci_To_Sample
                        list_Stats_Categories.append(str_Stats_Category)   
                        int_Category_Count += 1
                        str_Stats_Category_Code = 'A' + str(int_Category_Count).zfill(2)
                        
                        ''' Define Experiment by key Stats Category '''    
                        dict_Experiment_Label_By_Key_Category[str_Stats_Category] = str_Experiment_Label                        
                        ''' Define Stat Category Code by key Stats Category '''    
                        dict_Stats_Category_Code_By_Key_Category[str_Stats_Category] = str_Stats_Category_Code
                        ''' Define Stats category by key Stats Code '''
                        dict_Stats_Category_By_Key_Category_Code[str_Stats_Category_Code] = str_Stats_Category
                        ''' Define SubSample Size by Stats Category '''
                        dict_SubSample_Size_By_Category[str_Stats_Category] = int_Samples     
                        ''' Define SubSample Replicate Number by Stats Category '''
                        dict_SubSample_Replicates_By_Category[str_Stats_Category] = int_Sample_Replicates     
                        ''' Loci to remove from sample '''   
                        dict_Loci_To_Remove_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Remove_Additional)                               
                        ''' Loci to keep for sample '''   
                        dict_Loci_To_Sample_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Sample)                              
                    pass
                
                pass


                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_Codes_By_Key_Category = OrderedDict(dict_Stats_Category_Code_By_Key_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
#                 for key, value in dict_Stats_Category_By_Key_Category_Code.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
#                 pass             
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__SubSample_Replicates_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Loci_To_Sample_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]                    
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0]
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0.02 ,0.01, 0]
                pass

                
                pass
            

                #listLociToRemove = self.objSSParametersLocal.list_Sampling_Strategy_1_0__Loci_To_Remove 
                
                odictAgeCohortSampleProportions = self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Age_Cohort_Sample_Proportions_Of_Total_Sample  
                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                #list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                #for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                for str_Stats_Category in list_Stats_Categories:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
#                     bool_User_Defined_Sampling_Proportions = True
#                     if bool_User_Defined_Sampling_Proportions:
#                         dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
#                     else:
#                         dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples
#                     pass
                    
                    #dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteNumber

                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = dict_Loci_To_Remove_By_Category[str_Stats_Category] #listLociToRemove
                    ''' Experiment sampling params '''
                    #dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleProportions
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort] = odictAgeCohortSampleProportions
                    
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize] = dict_SubSample_Size_By_Category[str_Stats_Category]
                    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,dict_SubSample_Size_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,len(dict_Loci_To_Sample_By_Category[str_Stats_Category]))]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
                        
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_1__USER_SAMPLE_PROPORTIONS(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''
                #dictExperiment = OrderedDict()
                list_Stats_Categories = []
                dict_Experiment_Label_By_Key_Category = OrderedDict()
                dict_Stats_Category_Code_By_Key_Category = OrderedDict()
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                dict_SubSample_Size_By_Category = OrderedDict()
                dict_SubSample_Replicates_By_Category = OrderedDict()
                dict_Loci_To_Remove_By_Category = OrderedDict()
                dict_Loci_To_Sample_By_Category = OrderedDict()
                list_LDNe_PCrits_To_Get = []
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By

                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''    
                int_Sample_Replicates = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Replicates
                int_Sample_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Min
                int_Sample_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Max
                int_Sample_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Increment
                int_Loci_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Min
                int_Loci_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Max
                int_Loci_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Increment 
                int_Sim_Loci = self.objSSParametersLocal.nLoci
                int_Sim_Loci_To_Remove = int_Sim_Loci - int_Loci_Max
                 
                #list_Sim_Loci_Names = ['Locus-' + str(int_Locus) for int_Locus in range(0, int_Sim_Loci)]
                list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci)]
                
                #list_Sim_Loci_To_Remove =[int_Locus for int_Locus in range(1, int_Sim_Loci + 1)]
                list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Loci_Max)
                list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]

                int_Category_Count = 0
                for int_Samples in range(int_Sample_Min, int_Sample_Max+1, int_Sample_Increment):
                    str_Samples = str(int_Samples)
                     
                    for int_Loci_To_Sample in range(int_Loci_Min, int_Loci_Max+1, int_Loci_Increment):
 
                        list_Sim_Loci_To_Sample = random__sample(list_Sim_Loci_To_Keep, int_Loci_To_Sample)
                        list_Sim_Loci_To_Remove_Additional = [x for x in list_Sim_Loci_To_Keep if x not in list_Sim_Loci_To_Sample]
                        list_Sim_Loci_To_Remove_Additional.extend(list_Sim_Loci_To_Remove)
                         
                        '''  Define SubSampling Stats Categories '''
                        str_Loci_To_Sample = str(int_Loci_To_Sample)
                        str_Stats_Category = 'S' + str_Samples + '_' + 'L' + str_Loci_To_Sample
                        list_Stats_Categories.append(str_Stats_Category)   
                        int_Category_Count += 1
                        str_Stats_Category_Code = 'A' + str(int_Category_Count).zfill(2)
                         
                        ''' Define Experiment by key Stats Category '''    
                        dict_Experiment_Label_By_Key_Category[str_Stats_Category] = str_Experiment_Label                        
                        ''' Define Stat Category Code by key Stats Category '''    
                        dict_Stats_Category_Code_By_Key_Category[str_Stats_Category] = str_Stats_Category_Code
                        ''' Define Stats category by key Stats Code '''
                        dict_Stats_Category_By_Key_Category_Code[str_Stats_Category_Code] = str_Stats_Category
                        ''' Define SubSample Size by Stats Category '''
                        dict_SubSample_Size_By_Category[str_Stats_Category] = int_Samples     
                        ''' Define SubSample Replicate Number by Stats Category '''
                        dict_SubSample_Replicates_By_Category[str_Stats_Category] = int_Sample_Replicates     
                        ''' Loci to remove from sample '''   
                        dict_Loci_To_Remove_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Remove_Additional)                               
                        ''' Loci to keep for sample '''   
                        dict_Loci_To_Sample_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Sample)                              
                    pass
                 
                pass

#                 int_Category_Count = 0
#                 '''
#                 Reverse the production of the sampling categories so that the largest is attempted first.
#                 This ensures that errors with inadequate individuals to fulfill requested samples are highlighted for the largest samples first
#                 '''                
#                 int_Sample_Decrement = -1 * int_Sample_Increment
#                 int_Loci_Decrement = -1 * int_Loci_Increment
#                 for int_Samples in range(int_Sample_Max, int_Sample_Min-1, int_Sample_Decrement):
#                     str_Samples = str(int_Samples)
#                     
#                     for int_Loci_To_Sample in range(int_Loci_Max, int_Loci_Min-1, int_Loci_Decrement):
# 
#                         list_Sim_Loci_To_Sample = random__sample(list_Sim_Loci_To_Keep, int_Loci_To_Sample)
#                         list_Sim_Loci_To_Remove_Additional = [x for x in list_Sim_Loci_To_Keep if x not in list_Sim_Loci_To_Sample]
#                         list_Sim_Loci_To_Remove_Additional.extend(list_Sim_Loci_To_Remove)
#                         
#                         '''  Define SubSampling Stats Categories '''
#                         str_Loci_To_Sample = str(int_Loci_To_Sample)
#                         str_Stats_Category = 'S' + str_Samples + '_' + 'L' + str_Loci_To_Sample
#                         list_Stats_Categories.append(str_Stats_Category)   
#                         int_Category_Count += 1
#                         str_Stats_Category_Code = 'A' + str(int_Category_Count).zfill(2)
#                         
#                         ''' Define Experiment by key Stats Category '''    
#                         dict_Experiment_Label_By_Key_Category[str_Stats_Category] = str_Experiment_Label                        
#                         ''' Define Stat Category Code by key Stats Category '''    
#                         dict_Stats_Category_Code_By_Key_Category[str_Stats_Category] = str_Stats_Category_Code
#                         ''' Define Stats category by key Stats Code '''
#                         dict_Stats_Category_By_Key_Category_Code[str_Stats_Category_Code] = str_Stats_Category
#                         ''' Define SubSample Size by Stats Category '''
#                         dict_SubSample_Size_By_Category[str_Stats_Category] = int_Samples     
#                         ''' Define SubSample Replicate Number by Stats Category '''
#                         dict_SubSample_Replicates_By_Category[str_Stats_Category] = int_Sample_Replicates     
#                         ''' Loci to remove from sample '''   
#                         dict_Loci_To_Remove_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Remove_Additional)                               
#                         ''' Loci to keep for sample '''   
#                         dict_Loci_To_Sample_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Sample)                              
#                     pass
#                 
#                 pass
           
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_Codes_By_Key_Category = OrderedDict(dict_Stats_Category_Code_By_Key_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
#                 for key, value in dict_Stats_Category_By_Key_Category_Code.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
#                 pass             
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__SubSample_Replicates_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Loci_To_Sample_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]                    
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0]
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0.02 ,0.01, 0]
                pass

                
                pass
            

                #listLociToRemove = self.objSSParametersLocal.list_Sampling_Strategy_1_0__Loci_To_Remove 
                
                odictAgeCohortSampleProportions = self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Age_Cohort_Sample_Proportions_Of_Total_Sample  
                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                #list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                #for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                for str_Stats_Category in list_Stats_Categories:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
#                     bool_User_Defined_Sampling_Proportions = True
#                     if bool_User_Defined_Sampling_Proportions:
#                         dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
#                     else:
#                         dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples
#                     pass
                    
                    #dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByTotalSampleSize

                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = dict_Loci_To_Remove_By_Category[str_Stats_Category] #listLociToRemove
                    ''' Experiment sampling params '''
                    #dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleProportions
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionScaledByTotalSampleSize] = odictAgeCohortSampleProportions
                    
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize] = dict_SubSample_Size_By_Category[str_Stats_Category]
                    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,dict_SubSample_Size_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,len(dict_Loci_To_Sample_By_Category[str_Stats_Category]))]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
                        
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_1__USER_PROPORTIONS(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''
                #dictExperiment = OrderedDict()
                list_Stats_Categories = []
                dict_Experiment_Label_By_Key_Category = OrderedDict()
                dict_Stats_Category_Code_By_Key_Category = OrderedDict()
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                dict_SubSample_Size_By_Category = OrderedDict()
                dict_SubSample_Replicates_By_Category = OrderedDict()
                dict_Loci_To_Remove_By_Category = OrderedDict()
                dict_Loci_To_Sample_By_Category = OrderedDict()
                list_LDNe_PCrits_To_Get = []
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By

                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''    
                int_Sample_Replicates = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Replicates
                int_Sample_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Min
                int_Sample_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Max
                int_Sample_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Increment
                int_Loci_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Min
                int_Loci_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Max
                int_Loci_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Increment 
                int_Sim_Loci = self.objSSParametersLocal.nLoci
                int_Sim_Loci_To_Remove = int_Sim_Loci - int_Loci_Max
                 
                #list_Sim_Loci_Names = ['Locus-' + str(int_Locus) for int_Locus in range(0, int_Sim_Loci)]
                list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci)]
                
                #list_Sim_Loci_To_Remove =[int_Locus for int_Locus in range(1, int_Sim_Loci + 1)]
                list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Loci_Max)
                list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]

#                 
#                 for int_Locus in range(0, int_Sim_Loci):
#                     
#                 listLociToRemove = [numpy__random.randint(1, int_Sim_Loci) for x in range(int_Sim_Loci_To_Remove)]
                int_Category_Count = 0
                for int_Samples in range(int_Sample_Min, int_Sample_Max+1, int_Sample_Increment):
                    str_Samples = str(int_Samples)
                    
                    for int_Loci_To_Sample in range(int_Loci_Min, int_Loci_Max+1, int_Loci_Increment):

                        list_Sim_Loci_To_Sample = random__sample(list_Sim_Loci_To_Keep, int_Loci_To_Sample)
                        list_Sim_Loci_To_Remove_Additional = [x for x in list_Sim_Loci_To_Keep if x not in list_Sim_Loci_To_Sample]
                        list_Sim_Loci_To_Remove_Additional.extend(list_Sim_Loci_To_Remove)
                        
                        '''  Define SubSampling Stats Categories '''
                        str_Loci_To_Sample = str(int_Loci_To_Sample)
                        str_Stats_Category = 'S' + str_Samples + '_' + 'L' + str_Loci_To_Sample
                        list_Stats_Categories.append(str_Stats_Category)   
                        int_Category_Count += 1
                        str_Stats_Category_Code = 'A' + str(int_Category_Count).zfill(2)
                        
                        ''' Define Experiment by key Stats Category '''    
                        dict_Experiment_Label_By_Key_Category[str_Stats_Category] = str_Experiment_Label                        
                        ''' Define Stat Category Code by key Stats Category '''    
                        dict_Stats_Category_Code_By_Key_Category[str_Stats_Category] = str_Stats_Category_Code
                        ''' Define Stats category by key Stats Code '''
                        dict_Stats_Category_By_Key_Category_Code[str_Stats_Category_Code] = str_Stats_Category
                        ''' Define SubSample Size by Stats Category '''
                        dict_SubSample_Size_By_Category[str_Stats_Category] = int_Samples     
                        ''' Define SubSample Replicate Number by Stats Category '''
                        dict_SubSample_Replicates_By_Category[str_Stats_Category] = int_Sample_Replicates     
                        ''' Loci to remove from sample '''   
                        dict_Loci_To_Remove_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Remove_Additional)                               
                        ''' Loci to keep for sample '''   
                        dict_Loci_To_Sample_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Sample)                              
                    pass
                
                pass


                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_Codes_By_Key_Category = OrderedDict(dict_Stats_Category_Code_By_Key_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
#                 for key, value in dict_Stats_Category_By_Key_Category_Code.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
#                 pass             
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__SubSample_Replicates_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Loci_To_Sample_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]                    
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0]
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0.02 ,0.01, 0]
                pass

                
                pass
            

                #listLociToRemove = self.objSSParametersLocal.list_Sampling_Strategy_1_0__Loci_To_Remove 
                
                odictAgeCohortSampleProportions = self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Age_Cohort_Sample_Proportions_Of_Total_Sample  
                #odictAgeCohortSampleProportions = self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Age_Cohort_Sample_Numbers  
                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                #list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                #for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                for str_Stats_Category in list_Stats_Categories:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    bool_User_Defined_Sampling_Proportions = True
                    if bool_User_Defined_Sampling_Proportions:
                        dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
                    else:
                        dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples
                    pass
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = dict_Loci_To_Remove_By_Category[str_Stats_Category] #listLociToRemove
                    ''' Experiment sampling params '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleProportions
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize] = dict_SubSample_Size_By_Category[str_Stats_Category]
                    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,dict_SubSample_Size_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,len(dict_Loci_To_Sample_By_Category[str_Stats_Category]))]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
                        
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_SAMPLING_STRATEGY_1_0__FULL_USER_AGE_COHORTS(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_2 - Define the experiment
                --------------------------
                '''
                #dictExperiment = OrderedDict()
                list_Stats_Categories = []
                dict_Experiment_Label_By_Key_Category = OrderedDict()
                dict_Stats_Category_Code_By_Key_Category = OrderedDict()
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                dict_SubSample_Size_By_Category = OrderedDict()
                dict_SubSample_Replicates_By_Category = OrderedDict()
                dict_Loci_To_Remove_By_Category = OrderedDict()
                dict_Loci_To_Sample_By_Category = OrderedDict()
                list_LDNe_PCrits_To_Get = []
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By

                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''    
                int_Sample_Replicates = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Replicates
                int_Sample_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Min
                int_Sample_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Max
                int_Sample_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Sample_Increment
                int_Loci_Min = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Min
                int_Loci_Max = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Max
                int_Loci_Increment = self.objSSParametersLocal.int_Sampling_Strategy_1_0__Loci_Increment 
                int_Sim_Loci = self.objSSParametersLocal.nLoci
                int_Sim_Loci_To_Remove = int_Sim_Loci - int_Loci_Max
                 
                #list_Sim_Loci_Names = ['Locus-' + str(int_Locus) for int_Locus in range(0, int_Sim_Loci)]
                list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci)]
                
                #list_Sim_Loci_To_Remove =[int_Locus for int_Locus in range(1, int_Sim_Loci + 1)]
                list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Loci_Max)
                list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]

#                 
#                 for int_Locus in range(0, int_Sim_Loci):
#                     
#                 listLociToRemove = [numpy__random.randint(1, int_Sim_Loci) for x in range(int_Sim_Loci_To_Remove)]
                int_Category_Count = 0
                for int_Samples in range(int_Sample_Min, int_Sample_Max+1, int_Sample_Increment):
                    str_Samples = str(int_Samples)
                    
                    for int_Loci_To_Sample in range(int_Loci_Min, int_Loci_Max+1, int_Loci_Increment):

                        list_Sim_Loci_To_Sample = random__sample(list_Sim_Loci_To_Keep, int_Loci_To_Sample)
                        list_Sim_Loci_To_Remove_Additional = [x for x in list_Sim_Loci_To_Keep if x not in list_Sim_Loci_To_Sample]
                        list_Sim_Loci_To_Remove_Additional.extend(list_Sim_Loci_To_Remove)
                        
                        '''  Define SubSampling Stats Categories '''
                        str_Loci_To_Sample = str(int_Loci_To_Sample)
                        str_Stats_Category = 'S' + str_Samples + '_' + 'L' + str_Loci_To_Sample
                        list_Stats_Categories.append(str_Stats_Category)   
                        int_Category_Count += 1
                        str_Stats_Category_Code = 'A' + str(int_Category_Count).zfill(2)
                        
                        ''' Define Experiment by key Stats Category '''    
                        dict_Experiment_Label_By_Key_Category[str_Stats_Category] = str_Experiment_Label                        
                        ''' Define Stat Category Code by key Stats Category '''    
                        dict_Stats_Category_Code_By_Key_Category[str_Stats_Category] = str_Stats_Category_Code
                        ''' Define Stats category by key Stats Code '''
                        dict_Stats_Category_By_Key_Category_Code[str_Stats_Category_Code] = str_Stats_Category
                        ''' Define SubSample Size by Stats Category '''
                        dict_SubSample_Size_By_Category[str_Stats_Category] = int_Samples     
                        ''' Define SubSample Replicate Number by Stats Category '''
                        dict_SubSample_Replicates_By_Category[str_Stats_Category] = int_Sample_Replicates     
                        ''' Loci to remove from sample '''   
                        dict_Loci_To_Remove_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Remove_Additional)                               
                        ''' Loci to keep for sample '''   
                        dict_Loci_To_Sample_By_Category[str_Stats_Category] = list(list_Sim_Loci_To_Sample)                              
                    pass
                
                pass


                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_Codes_By_Key_Category = OrderedDict(dict_Stats_Category_Code_By_Key_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Stats_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
#                 for key, value in dict_Stats_Category_By_Key_Category_Code.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
#                 pass             
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)
                
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__SubSample_Replicates_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)
                self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Loci_To_Sample_By_Category = OrderedDict(dict_SubSample_Replicates_By_Category)


                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]                  
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0]
#                 elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00:
#                     list_LDNe_PCrits_To_Get = [0.05, 0.02 ,0.01, 0]
                pass

                
                pass
            

                #listLociToRemove = self.objSSParametersLocal.list_Sampling_Strategy_1_0__Loci_To_Remove 
                
                odictAgeCohortSampleProportions = self.objSSParametersLocal.dict_Sampling_Strategy_1_0__Age_Cohort_Sample_Proportions_Of_Total_Sample  
                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                #list_Stats_Categories_For_Sampling_By_Proportion = ['Small_3_Cohort']    
                 
                #for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                for str_Stats_Category in list_Stats_Categories:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    bool_User_Defined_Sampling_Proportions = False
                    if bool_User_Defined_Sampling_Proportions:
                        dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohortOfTotalSamples
                    else:
                        dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIs_A_Cohort_Size_Dependent_ProportionPerVSPCohortOfTotalSamples
                    pass
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                    ''' Loci to remove from sample '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = dict_Loci_To_Remove_By_Category[str_Stats_Category] #listLociToRemove
                    ''' Experiment sampling params '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleProportions
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_TotalSampleSize] = dict_SubSample_Size_By_Category[str_Stats_Category]
                    
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,dict_SubSample_Size_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,len(dict_Loci_To_Sample_By_Category[str_Stats_Category]))]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
                        
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_FULL_EMBRYO_COHORT(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_FEM - Define the experiment
                --------------------------
                '''

                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full_Embryo']
                str_Category_Name = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Name_FEM
                list_Stats_Categories = [str_Category_Name]
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #dict_Stats_Category_Code_By_Key_Category = {'Full_Embryo':'FEM'}
                str_Category_Code = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Code_FEM
                dict_Stats_Category_Code_By_Key_Category = {str_Category_Name:str_Category_Code}                                                         
                
#                 ''' Index the experiment details by Stats Category - For use when assimilating Ne2 results'''
#                 dict_Experiment_Label_By_Key_Category = OrderedDict([str_Stats_Category, str_Experiment_Label] for str_Stats_Category in list_Stats_Categories)
#                 #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
                            
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                for key, value in dict_Stats_Category_Code_By_Key_Category.items():
                    dict_Stats_Category_By_Key_Category_Code[value] = key
                pass
                #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)

                for key, value in dict_Stats_Category_By_Key_Category_Code.items():
                    self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
                pass  

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                '''
                Only 1 replicate is required per pop replicate.
                This is because thes full age cohorts estimates are made from the same samples and therefor will be exactly the same LDNe each time.
                Accuracy cant be increased by more LDNe replicates, only by more pop replicates.
                However, replicates specified by Sampling Strategy
                '''
                if str_Category_Code in self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline.keys()[0]: 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline[str_Category_Code]               
                elif str_Category_Code in self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run.keys(): 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run[str_Category_Code]               
                pass                 
                dict_SubSample_Replicates_By_Category = {str_Category_Name:int_Sample_Replicates}
                
                
                ''' Get total population size '''
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass
                
                '''
                -----------------------------------
                Define the loci to discard - This is done to balance speed of processing with accuracy
                -----------------------------------
                '''
                '''Get total sim locu number '''
                int_Sim_Loci_Total = self.objSSParametersLocal.nLoci
                
#                 if int_Sim_Loci_Total >= 100:
#                     ''' Work out a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
#                         When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
#                         with 1 pop replicate the Sampling Strat takes ~10 min to run 
#                         When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
#                         with 1 pop replicate the Sampling Strat takes ~25 min to run 
#                     
#                     
#                     '''
#                     #.25%
#                     float_Percentage_Of_Loci_To_Keep = 0.25
#                     int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (0.25),0))
#                 else:
#                     int_Sim_Loci_To_Keep = int_Sim_Loci_Total
#                 pass
            
                float_Percentage_Of_Loci_To_Keep = self.objSSParametersLocal.float_Sampling_EXP_2_2__LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
                if float_Percentage_Of_Loci_To_Keep > 2 and float_Percentage_Of_Loci_To_Keep < 100:
                    ''' Use a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
                        When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~10 min to run 
                        When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~25 min to run 
                    '''
                    int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (float_Percentage_Of_Loci_To_Keep / float(100)),0))
                    
                    list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci_Total)]
                    list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Sim_Loci_To_Keep)
                    list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]
                    listLociToRemove = [ 'Locus-' + str(x+1) for x in list_Sim_Loci_To_Remove]                    
                else:
                    int_Sim_Loci_To_Keep = int_Sim_Loci_Total
                    listLociToRemove = [] 
                pass
            
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
           
                #strPCritsToProcess = self.objSSParametersLocal.str_Sampling_EXP_2_2__LDNe_PCrits_To_Get
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]
                pass
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                           
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full_Embryo']    
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Embryo)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    #listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    float_Sample_Size = dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] *int_Full_SubSample_Size
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,float_Sample_Size)]))
                    int_Sampled_Loci_Total = int_Sim_Loci_Total - len(dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove])
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,int_Sampled_Loci_Total)]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
            
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_FULL_JUVENILE_COHORTS(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_FJV - Define the experiment
                --------------------------
                '''
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full_Juvenile']
                str_Category_Name = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Name_FJV
                list_Stats_Categories = [str_Category_Name]                

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #dict_Stats_Category_Code_By_Key_Category = {'Full_Juvenile':'FJV'}
                str_Category_Code = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Code_FJV
                dict_Stats_Category_Code_By_Key_Category = {str_Category_Name:str_Category_Code} 
                                
#                 ''' Index the experiment details by Stats Category - For use when assimilating Ne2 results'''
#                 dict_Experiment_Label_By_Key_Category = OrderedDict([str_Stats_Category, str_Experiment_Label] for str_Stats_Category in list_Stats_Categories)
#                 #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
                            
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                for key, value in dict_Stats_Category_Code_By_Key_Category.items():
                    dict_Stats_Category_By_Key_Category_Code[value] = key
                pass
                #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)

                for key, value in dict_Stats_Category_By_Key_Category_Code.items():
                    self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
                pass  

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                '''
                Only 1 replicate is required per pop replicate.
                This is because thes full age cohorts estimates are made from the same samples and therefor will be exactly the same LDNe each time.
                Accuracy cant be increased by more LDNe replicates, only by more pop replicates.
                However, replicates specified by Sampling Strategy
                '''
                if str_Category_Code in self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline.keys()[0]: 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline[str_Category_Code]               
                elif str_Category_Code in self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run.keys(): 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run[str_Category_Code]               
                pass                 
                dict_SubSample_Replicates_By_Category = {str_Category_Name:int_Sample_Replicates}
                
                ''' Get total population size '''
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass
                
                '''
                -----------------------------------
                Define the loci to discard - This is done to balance speed of processing with accuracy
                -----------------------------------
                '''
                '''Get total sim locu number '''
                int_Sim_Loci_Total = self.objSSParametersLocal.nLoci
                
#                 if int_Sim_Loci_Total >= 100:
#                     ''' Work out a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
#                         When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
#                         with 1 pop replicate the Sampling Strat takes ~10 min to run 
#                         When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
#                         with 1 pop replicate the Sampling Strat takes ~25 min to run 
#                     
#                     
#                     '''
#                     #.25%
#                     float_Percentage_Of_Loci_To_Keep = 0.25
#                     int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (0.25),0))
#                 else:
#                     int_Sim_Loci_To_Keep = int_Sim_Loci_Total
#                 pass
            
                float_Percentage_Of_Loci_To_Keep = self.objSSParametersLocal.float_Sampling_EXP_2_2__LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
                if float_Percentage_Of_Loci_To_Keep > 2 and float_Percentage_Of_Loci_To_Keep < 100:
                    ''' Use a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
                        When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~10 min to run 
                        When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~25 min to run 
                    '''
                    int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (float_Percentage_Of_Loci_To_Keep / float(100)),0))
                    
                    list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci_Total)]
                    list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Sim_Loci_To_Keep)
                    list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]
                    listLociToRemove = [ 'Locus-' + str(x+1) for x in list_Sim_Loci_To_Remove]                    
                else:
                    int_Sim_Loci_To_Keep = int_Sim_Loci_Total
                    listLociToRemove = [] 
                pass
            
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
           
                #strPCritsToProcess = self.objSSParametersLocal.str_Sampling_EXP_2_2__LDNe_PCrits_To_Get
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]
                pass
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                           
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full_Juvenile']    
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Juvenile)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    #listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    float_Sample_Size = dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] *int_Full_SubSample_Size
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,float_Sample_Size)]))
                    int_Sampled_Loci_Total = int_Sim_Loci_Total - len(dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove])
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,int_Sampled_Loci_Total)]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
            
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_FULL_ADULT_COHORTS(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_FMT - Define the experiment
                --------------------------
                '''
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full_Mature']
                str_Category_Name = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Name_FMT
                list_Stats_Categories = [str_Category_Name]                 

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #dict_Stats_Category_Code_By_Key_Category = {'Full_Mature':'FMT'}
                str_Category_Code = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Code_FMT
                dict_Stats_Category_Code_By_Key_Category = {str_Category_Name:str_Category_Code} 
                                
#                 ''' Index the experiment details by Stats Category - For use when assimilating Ne2 results'''
#                 dict_Experiment_Label_By_Key_Category = OrderedDict([str_Stats_Category, str_Experiment_Label] for str_Stats_Category in list_Stats_Categories)
#                 #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
                            
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                for key, value in dict_Stats_Category_Code_By_Key_Category.items():
                    dict_Stats_Category_By_Key_Category_Code[value] = key
                pass
                #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)

                for key, value in dict_Stats_Category_By_Key_Category_Code.items():
                    self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
                pass  

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                '''
                Only 1 replicate is required per pop replicate.
                This is because thes full age cohorts estimates are made from the same samples and therefor will be exactly the same LDNe each time.
                Accuracy cant be increased by more LDNe replicates, only by more pop replicates.
                However, replicates specified by Sampling Strategy
                '''
                if str_Category_Code in self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline.keys()[0]: 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline[str_Category_Code]               
                elif str_Category_Code in self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run.keys(): 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run[str_Category_Code]               
                pass                 
                dict_SubSample_Replicates_By_Category = {str_Category_Name:int_Sample_Replicates}
                
                
                ''' Get total population size '''
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass
                
                '''
                -----------------------------------
                Define the loci to discard - This is done to balance speed of processing with accuracy
                -----------------------------------
                '''
                '''Get total sim locu number '''
                int_Sim_Loci_Total = self.objSSParametersLocal.nLoci
                
#                 if int_Sim_Loci_Total >= 100:
#                     ''' Work out a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
#                         When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
#                         with 1 pop replicate the Sampling Strat takes ~10 min to run 
#                         When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
#                         with 1 pop replicate the Sampling Strat takes ~25 min to run 
#                     
#                     
#                     '''
#                     #.25%
#                     float_Percentage_Of_Loci_To_Keep = 0.25
#                     int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (0.25),0))
#                 else:
#                     int_Sim_Loci_To_Keep = int_Sim_Loci_Total
#                 pass
            
                float_Percentage_Of_Loci_To_Keep = self.objSSParametersLocal.float_Sampling_EXP_2_2__LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
                if float_Percentage_Of_Loci_To_Keep > 2 and float_Percentage_Of_Loci_To_Keep < 100:
                    ''' Use a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
                        When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~10 min to run 
                        When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~25 min to run 
                    '''
                    int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (float_Percentage_Of_Loci_To_Keep / float(100)),0))
                    
                    list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci_Total)]
                    list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Sim_Loci_To_Keep)
                    list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]
                    listLociToRemove = [ 'Locus-' + str(x+1) for x in list_Sim_Loci_To_Remove]                    
                else:
                    int_Sim_Loci_To_Keep = int_Sim_Loci_Total
                    listLociToRemove = [] 
                pass
            
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
           
                #strPCritsToProcess = self.objSSParametersLocal.str_Sampling_EXP_2_2__LDNe_PCrits_To_Get
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]
                pass
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                           
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full_Mature']    
                
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    ''' Sample VSP '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = (0,globalsSS.VSP_AgeClass.static_intVSP_AgeClass_Reproductivly_available_adult)
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    #listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove

                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass
            
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    float_Sample_Size = dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] *int_Full_SubSample_Size
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,float_Sample_Size)]))
                    int_Sampled_Loci_Total = int_Sim_Loci_Total - len(dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove])
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,int_Sampled_Loci_Total)]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment

            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_FULL_SAMPLING_OF_COHORTS(self, str_Experiment_Label, str_Search_Path, dictExperiment):

                '''
                --------------------------
                EXPERIMENT_FUL - Define the experiment
                --------------------------
                '''
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_Stats_Categories = ['Full']
                str_Category_Name = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Name_FUL
                list_Stats_Categories = [str_Category_Name] 
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #dict_Stats_Category_Code_By_Key_Category = {'Full':'FUL'}
                str_Category_Code = object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Code_FUL
                dict_Stats_Category_Code_By_Key_Category = {str_Category_Name:str_Category_Code} 
                                
#                 ''' Index the experiment details by Stats Category - For use when assimilating Ne2 results'''
#                 dict_Experiment_Label_By_Key_Category = OrderedDict([str_Stats_Category, str_Experiment_Label] for str_Stats_Category in list_Stats_Categories)
#                 #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category = OrderedDict(dict_Experiment_Label_By_Key_Category)
#                 for key, value in dict_Experiment_Label_By_Key_Category.items():
#                     self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Label_By_Key_Category[key] = value
#                 pass 
                            
                dict_Stats_Category_By_Key_Category_Code = OrderedDict()
                for key, value in dict_Stats_Category_Code_By_Key_Category.items():
                    dict_Stats_Category_By_Key_Category_Code[value] = key
                pass
                #self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code = OrderedDict(dict_Stats_Category_By_Key_Category_Code)

                for key, value in dict_Stats_Category_By_Key_Category_Code.items():
                    self.objSSParametersLocal.dict_Ne2_Sampling_Experiment_Category_By_Key_Category_Code[key] = value
                pass  

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                '''
                Only 1 replicate is required per pop replicate.
                This is because thes full age cohorts estimates are made from the same samples and therefor will be exactly the same LDNe each time.
                Accuracy cant be increased by more LDNe replicates, only by more pop replicates.
                However, replicates specified by Sampling Strategy
                '''
                if str_Category_Code in self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline.keys()[0]: 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Sampling_Plan_To_Use_For_Accuracy_Guideline[str_Category_Code]               
                elif str_Category_Code in self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run.keys(): 
                    int_Sample_Replicates = self.objSSParametersLocal.dict_Other_Sampling_Plans_To_Run[str_Category_Code]               
                pass                 
                dict_SubSample_Replicates_By_Category = {str_Category_Name:int_Sample_Replicates}
                
                
                ''' Get total population size '''
                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Full_SubSample_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass
                
                '''
                -----------------------------------
                Define the loci to discard - This is done to balance speed of processing with accuracy
                -----------------------------------
                '''
                '''Get total sim locu number '''
                int_Sim_Loci_Total = self.objSSParametersLocal.nLoci
                
#                 if int_Sim_Loci_Total >= 100:
#                     ''' Work out a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
#                         When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
#                         with 1 pop replicate the Sampling Strat takes ~10 min to run 
#                         When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
#                         with 1 pop replicate the Sampling Strat takes ~25 min to run 
#                     
#                     
#                     '''
#                     #.25%
#                     float_Percentage_Of_Loci_To_Keep = 0.25
#                     int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (0.25),0))
#                 else:
#                     int_Sim_Loci_To_Keep = int_Sim_Loci_Total
#                 pass
            
                float_Percentage_Of_Loci_To_Keep = self.objSSParametersLocal.float_Sampling_EXP_2_2__LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
                if float_Percentage_Of_Loci_To_Keep > 2 and float_Percentage_Of_Loci_To_Keep < 100:
                    ''' Use a % of loci to keep relative to the pop size that gives reasonable accuracy for FUL LDNe...
                        When N = 20,000 & L = 100, the LDNe JK Upper CI is ~ 15 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~10 min to run 
                        When N = 50,000 & L = 100, the LDNe JK Upper CI is ~ 35 > than the point est. LDNe 
                        with 1 pop replicate the Sampling Strat takes ~25 min to run 
                    '''
                    int_Sim_Loci_To_Keep = int(round(float(int_Sim_Loci_Total) * (float_Percentage_Of_Loci_To_Keep / float(100)),0))
                    
                    list_Sim_Loci =[int_Locus for int_Locus in range(0, int_Sim_Loci_Total)]
                    list_Sim_Loci_To_Keep = random__sample(list_Sim_Loci, int_Sim_Loci_To_Keep)
                    list_Sim_Loci_To_Remove = [x for x in list_Sim_Loci if x not in list_Sim_Loci_To_Keep]
                    listLociToRemove = [ 'Locus-' + str(x+1) for x in list_Sim_Loci_To_Remove]                    
                else:
                    int_Sim_Loci_To_Keep = int_Sim_Loci_Total
                    listLociToRemove = [] 
                pass
            
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
           
                #strPCritsToProcess = self.objSSParametersLocal.str_Sampling_EXP_2_2__LDNe_PCrits_To_Get
                strPCritsToProcess = self.objSSParametersLocal.str_Sampling_Strategy_1_0__LDNe_PCrits_To_Get

                if strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00:
                    list_LDNe_PCrits_To_Get = [0]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01:
                    list_LDNe_PCrits_To_Get = [0.01]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02:
                    list_LDNe_PCrits_To_Get = [0.02]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05:
                    list_LDNe_PCrits_To_Get = [0.05]
                elif strPCritsToProcess == globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_NoS:
                    list_LDNe_PCrits_To_Get = [globalsSS.LDNe_PCrit__Float.static_float_LDNe_PCrit_NoS]
                pass
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                           
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                            
                list_Stats_Categories_For_Sampling_By_Proportion = ['Full']        
                 
                for str_Stats_Category in list_Stats_Categories_For_Sampling_By_Proportion:
                    dict_Sampling_Params = OrderedDict()      
                    ''' Sampling method  '''
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    ''' VSP Split method  '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeClass
                    ''' Sample Percentage of Pop '''
                    dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 1
                    
                    ''' Sample VSP '''
                    #dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_tup_VSP_To_Sample] = [0]
                    ''' Loci to remove from sample '''
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                    #listLociToRemove = [] #None assumes keep all
                    dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
 
                    dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                pass

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                dict_Stats_Categories = OrderedDict()
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Stats_Categories:
                        dict_Stats_Categories[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]) 
                    else:
                        dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Code_By_Key_Category[str_Stats_Category])]))
                    pass
                    float_Sample_Size = dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] *int_Full_SubSample_Size
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Indiv_Number,float_Sample_Size)]))
                    int_Sampled_Loci_Total = int_Sim_Loci_Total - len(dict_SubSampling_Params_By_Category[str_Stats_Category][globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove])
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Loci_Number,int_Sampled_Loci_Total)]))
                
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    #dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))

                    dict_Stats_Categories[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

                    pass
                pass

                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label] = str_Experiment_Label
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories] = list_Stats_Categories
                dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories] = dict_Stats_Categories
                
            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
            
           
           
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAPL_FISHED_PROPORTIONS_v1_0(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                str_Stats_Category = 'CAPL_Catch_Prop'
                list_Stats_Categories = [str_Stats_Category]
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {str_Stats_Category:'CCP'}
                                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {str_Stats_Category:10}

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                #list_LDNe_PCrits_To_Get = [0.1, 0.05,0.02,0.01,0.005,0]
                list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #list_LDNe_PCrits_To_Get = [0.02,0]
                #list_LDNe_PCrits_To_Get = [0]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                
                dict_Sampling_Params = OrderedDict()      
                ''' Sampling method  '''
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohort
                ''' VSP Split method  '''
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                ''' Loci to remove from sample '''
                #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                listLociToRemove = [] #None assumes keep all
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
                ''' Experiment sampling params '''
                odictAgeCohortSampleNumbers = OrderedDict([(0,0.015267176),(12,0.040712468),(24,0.03562341),(36,0.03562341),(48,0.015267176),(60,0.007633588),(72,0.005089059),(84,0),(96,0.007633588),(108,0.022900763),(120,0.03307888),(132,0.066157761),(144,0.053435115),(156,0.117048346),(168,0.1043257),(180,0.139949109),(192,0.096692112),(204,0.061068702),(216,0.045801527),(228,0.027989822),(240,0.03562341),(252,0.015267176),(264,0.012722646),(276,0),(288,0),(300,0.002544529),(312,0),(324,0.002544529),(336,0),(348,0),(360,0)])
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleNumbers

                dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                           

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                if str_Stats_Category not in dictExperiment:
                    dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                pass

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Pop_Starts_When_Mating_Count_Is,int_Pop_Starts_When_Mating_Count_Is)]))

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
            
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAPL_FISHED_ABSOLUTE_v1_0(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                str_Stats_Category = 'CAPL_Catch_Abs'
                list_Stats_Categories = [str_Stats_Category]
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {str_Stats_Category:'CCA'}
                                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {str_Stats_Category:100}

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                #list_LDNe_PCrits_To_Get = [0.1, 0.05,0.02,0.01,0.005,0]               
                list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #list_LDNe_PCrits_To_Get = [0.02,0]
                #list_LDNe_PCrits_To_Get = [0]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                
                dict_Sampling_Params = OrderedDict()      
                ''' Sampling method  '''
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteNumber
                ''' VSP Split method  '''
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                ''' Loci to remove from sample '''
                #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                listLociToRemove = [] #None assumes keep all
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
                ''' Experiment sampling params '''
                odictAgeCohortSampleNumbers = OrderedDict([(0,6),(12,16),(24,14),(36,14),(48,6),(60,3),(72,2),(84,0),(96,8),(108,12),(120,17),(132,27),(144,21),(156,47),(168,42),(180,58),(192,38),(204,28),(216,22),(228,14),(240,18),(252,6),(264,5),(276,0),(288,0),(300,2),(312,1),(324,1),(336,0)])
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort] = odictAgeCohortSampleNumbers

                dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                           

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                if str_Stats_Category not in dictExperiment:
                    dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                pass

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Pop_Starts_When_Mating_Count_Is,int_Pop_Starts_When_Mating_Count_Is)]))

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment

            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAPL_FISHED_PROPORTIONS_SCALED_BY_MAX_ABSOLUTE_v1_0(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                str_Stats_Category = 'CAPL_Catch_Prop_SMA'
                list_Stats_Categories = [str_Stats_Category]
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {str_Stats_Category:'CCA'}
                                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {str_Stats_Category:10}

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                #list_LDNe_PCrits_To_Get = [0.1, 0.05,0.02,0.01,0.005,0]               
                list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #list_LDNe_PCrits_To_Get = [0.02,0]
                #list_LDNe_PCrits_To_Get = [0]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                
                dict_Sampling_Params = OrderedDict()      
                ''' Sampling method  '''
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionScaledByMaxAbsPerVSPCohort
                ''' VSP Split method  '''
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                ''' Loci to remove from sample '''
                #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                listLociToRemove = [] #None assumes keep all
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
                ''' Experiment sampling params '''
                odictAgeCohortSampleNumbers = OrderedDict([(0,6),(12,16),(24,14),(36,14),(48,6),(60,3),(72,2),(84,0),(96,8),(108,12),(120,17),(132,27),(144,21),(156,47),(168,42),(180,58),(192,38),(204,28),(216,22),(228,14),(240,18),(252,6),(264,5),(276,0),(288,0),(300,2),(312,1),(324,1),(336,0)])
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort] = odictAgeCohortSampleNumbers
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionScaledByMaxAbsPerVSPCohort_MaxProportion] = 1

                dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                           

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                if str_Stats_Category not in dictExperiment:
                    dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                pass

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Pop_Starts_When_Mating_Count_Is,int_Pop_Starts_When_Mating_Count_Is)]))

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
            
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAPL_FISHED_ABSOLUTE_NUMS_SCALED_BY_MAX_ABSOLUTE_v1_0(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                str_Stats_Category = 'CAPL_Catch_Abs_SMA'
                list_Stats_Categories = [str_Stats_Category]
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {str_Stats_Category:'CAS'}
                                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {str_Stats_Category:500}

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                #list_LDNe_PCrits_To_Get = [0.1, 0.05,0.02,0.01,0.005,0]               
                #list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                #list_LDNe_PCrits_To_Get = [0.05,0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                list_LDNe_PCrits_To_Get = [0.05]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
                #list_LDNe_PCrits_To_Get = [0]
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                
                dict_Sampling_Params = OrderedDict()      
                ''' Sampling method  '''
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsAbsScaledByMaxAbsPerVSPCohort
                ''' VSP Split method  '''
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                ''' Loci to remove from sample '''
                #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                listLociToRemove = [] #None assumes keep all
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
                ''' Experiment sampling params '''
                odictAgeCohortSampleNumbers = OrderedDict([(0,6),(12,16),(24,14),(36,14),(48,6),(60,3),(72,2),(84,0),(96,8),(108,12),(120,17),(132,27),(144,21),(156,47),(168,42),(180,58),(192,38),(204,28),(216,22),(228,14),(240,18),(252,6),(264,5),(276,0),(288,0),(300,2),(312,2),(324,0),(336,0)])
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort] = odictAgeCohortSampleNumbers
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsScaledByMaxAbsPerVSPCohort_MaxProportion] = 0.8

                dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                           

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                if str_Stats_Category not in dictExperiment:
                    dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                pass

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Pop_Starts_When_Mating_Count_Is,int_Pop_Starts_When_Mating_Count_Is)]))

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
            
            
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAOB_FISHED_PROPORTIONS_v1_0(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                str_Stats_Category = 'CAOB_Catch_Prop'
                list_Stats_Categories = [str_Stats_Category]
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {str_Stats_Category:'CBP'}
                                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {str_Stats_Category:10}

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #list_LDNe_PCrits_To_Get = [0.02,0]
                #list_LDNe_PCrits_To_Get = [0]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                
                dict_Sampling_Params = OrderedDict()      
                ''' Sampling method  '''
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohort
                ''' VSP Split method  '''
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                ''' Loci to remove from sample '''
                #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                listLociToRemove = [] #None assumes keep all
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
                ''' Experiment sampling params '''
                odictAgeCohortSampleNumbers = OrderedDict([(0,0.085),(12,0.043),(24,0.072),(36,0.036),(48,0.052),(60,0.043),(72,0.043),(84,0.051),(96,0.037),(108,0.007),(120,0.014),(132,0.022),(144,0.007),(156,0.022),(168,0.000),(180,0.007),(192,0.007),(204,0.050),(216,0.064),(228,0.071),(240,0.050),(252,0.092),(264,0.120),(276,0.126),(288,0.193),(300,0.133),(312,0.201),(324,0.093),(336,0.071),(348,0.043),(360,0.022),(372,0.022),(384,0.036),(396,0.015),(408,0.000)])
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleNumbers

                dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                           

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                if str_Stats_Category not in dictExperiment:
                    dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                pass

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Pop_Starts_When_Mating_Count_Is,int_Pop_Starts_When_Mating_Count_Is)]))

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment

            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAOB_FISHED_ABSOLUTE_v1_0(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                str_Stats_Category = 'CAOB_Catch_Abs'
                list_Stats_Categories = [str_Stats_Category]
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {str_Stats_Category:'CBA'}
                                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {str_Stats_Category:10}

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #list_LDNe_PCrits_To_Get = [0.02,0]
                #list_LDNe_PCrits_To_Get = [0]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                
                dict_Sampling_Params = OrderedDict()      
                ''' Sampling method  '''
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsCohortAbsoluteNumber
                ''' VSP Split method  '''
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                ''' Loci to remove from sample '''
                #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                listLociToRemove = [] #None assumes keep all
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
                ''' Experiment sampling params '''
                odictAgeCohortSampleNumbers = OrderedDict([(0,12),(12,6),(24,10),(36,5),(48,7),(60,6),(72,6),(84,7),(96,5),(108,1),(120,2),(132,3),(144,1),(156,3),(168,0),(180,1),(192,1),(204,7),(216,9),(228,10),(240,7),(252,13),(264,17),(276,18),(288,28),(300,19),(312,29),(324,13),(336,10),(348,6),(360,3),(372,3),(384,5),(396,2),(408,0)])
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort] = odictAgeCohortSampleNumbers

                dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                           

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                if str_Stats_Category not in dictExperiment:
                    dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                pass

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Pop_Starts_When_Mating_Count_Is,int_Pop_Starts_When_Mating_Count_Is)]))

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment

            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_EXPERIMENT_2_CAOB_FISHED_ABSOLUTE_NUMS_SCALED_BY_MAX_ABSOLUTE_v1_0(self, str_Experiment_Label, str_Search_Path):

                '''
                --------------------------
                Define the experiment
                --------------------------
                '''

                dictExperiment = OrderedDict()
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Stats Categories
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                str_Stats_Category = 'CAOB_Catch_Abs_SMA'
                list_Stats_Categories = [str_Stats_Category]
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define Stst Category Code by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_Stats_Category_Codes_By_Category = {str_Stats_Category:'CAS'}
                                                         
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSample Replicate Number by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                dict_SubSample_Replicates_By_Category = {str_Stats_Category:500}

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define LDNe PCrits to generate
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                #list_LDNe_PCrits_To_Get = [0.1, 0.05,0.02,0.01,0.005,0]               
                #list_LDNe_PCrits_To_Get = [0.05,0.02,0.01,0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                #list_LDNe_PCrits_To_Get = [0.05,0]
                #strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                list_LDNe_PCrits_To_Get = [0.05]
                strPCritsToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
                #list_LDNe_PCrits_To_Get = [0]
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define the saved populations to sample
                ~~~~~~~~~~~~~~~~~~~~~~
                '''                
                int_Pop_Starts_When_Mating_Count_Is = self.objSSParametersLocal.int_Post_Sim_Pop_Sampling_Starts_When_Mating_Count_Is
                int_Sample_Pop_When_Mating_Count_Divisible_By = self.objSSParametersLocal.int_Sample_Pop_When_Mating_Count_Divisible_By
                
                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Define SubSampling Params by Stats Category
                ~~~~~~~~~~~~~~~~~~~~~~
                '''

                dict_SubSampling_Params_By_Category = OrderedDict()
                
                dict_Sampling_Params = OrderedDict()      
                ''' Sampling method  '''
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsAbsScaledByMaxAbsPerVSPCohort
                ''' VSP Split method  '''
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_VSPSplitMethod] = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_VSPSplit_AgeInMonths
                ''' Loci to remove from sample '''
                #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                listLociToRemove = [] #None assumes keep all
                dict_Sampling_Params[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove] = listLociToRemove
                ''' Experiment sampling params '''
                odictAgeCohortSampleNumbers = OrderedDict([(0,12),(12,6),(24,10),(36,5),(48,7),(60,6),(72,6),(84,7),(96,5),(108,1),(120,2),(132,3),(144,1),(156,3),(168,0),(180,1),(192,1),(204,7),(216,9),(228,10),(240,7),(252,13),(264,17),(276,18),(288,28),(300,19),(312,29),(324,13),(336,10),(348,6),(360,3),(372,3),(384,7),(396,0),(408,0)])
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsoluteNumberPerVSPCohort] = odictAgeCohortSampleNumbers
                dict_Sampling_Params[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsAbsScaledByMaxAbsPerVSPCohort_MaxProportion] = 0.8

                dict_SubSampling_Params_By_Category[str_Stats_Category] = dict_Sampling_Params
                           

                '''
                ~~~~~~~~~~~~~~~~~~~~~~
                Combine all the Experiment Specs
                ~~~~~~~~~~~~~~~~~~~~~~
                ''' 
                if str_Stats_Category not in dictExperiment:
                    dictExperiment[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment_Label)])
                pass

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code,dict_Stats_Category_Codes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Sizes_By_Category,dict_SubSample_Sizes_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                #dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_VSPs_To_SubSample_By_Category,dict_VSPs_To_SubSample_By_Category[str_Stats_Category])]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess,strPCritsToProcess)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path,str_Search_Path)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By,int_Sample_Pop_When_Mating_Count_Divisible_By)]))
                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Pop_Starts_When_Mating_Count_Is,int_Pop_Starts_When_Mating_Count_Is)]))

                dictExperiment[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params,dict_SubSampling_Params_By_Category[str_Stats_Category])]))

            
                return int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, dictExperiment
            
        
            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_Experiments_RETIRE(self, int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, str_LDNE_Working_Path, str_Search_Path__Saved_SimuPops, str_File_Search_Pattern, dictExperiment):

                '''
                --------------------------
                Run the experiment
                --------------------------
                '''

                '''
                -------------------------------
                Get & Process simuPOP Pop Input files
                -------------------------------
                '''                
                list_Process_PIDs = []
#                 ''' Search file pattern '''
#                 str_File_Search_Pattern = '*' + globalsSS.SS_Per_Fert_PF_File_Output_Details.static_Output_File_Suffix__SimuPOP_Pop_PF
                
                str_Genepop_File_Suffix = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__PF_Pop_SubSample
         
                '''
                Import each SimuPop Pop file
                '''
                str_Search_Path = str_Search_Path__Saved_SimuPops
                self.obj_Log_Debug_Display.debug('Importing simuPOP Pop file of search pattern: ' + str_File_Search_Pattern + ' in search path: ' + str_Search_Path) 
        
                ''' Locate simuPOP Pop input files '''
                bool_File_Located = False
                with FileHandler() as obj_FileOp:
                    bool_File_Located, list_Path_And_Files = obj_FileOp.func_Locate_Files(str_Search_Path, str_File_Search_Pattern)
                pass
                if bool_File_Located:
                    
                    '''Process each file in turn'''
                    for str_simuPOP_Path_And_File in list_Path_And_Files:
                        
                        strFilePath, strFileName = obj_FileOp.method_Separate_Path_And_FileName_From_PathAndFileName(str_simuPOP_Path_And_File)
                        str_simuPOP_FileName = strFileName
                        ''' Get original run details from filename '''
                        str_Run_UID = str_simuPOP_FileName[:31]
                        ''' Get Sim Mating Count from simuPOP pop filename '''
                        str_Sim_Mating_Count = str_simuPOP_FileName.split('_SM', 1)[1]
                        str_Sim_Mating_Count = str_Sim_Mating_Count.split('_', 1)[0]
                        int_Sim_Mating_Count = int(str_Sim_Mating_Count)
                        str_Rep_Mating_Count = str_simuPOP_FileName.split('_M', 1)[1]
                        str_Rep_Mating_Count = str_Rep_Mating_Count.split('.', 1)[0]
                        int_Rep_Mating_Count = int(str_Rep_Mating_Count)
                                               
                        ''' Check if we want to sample this pop '''
                        #int_Sample_Pop_When_Mating_Count_Divisible_By = dictExperiment[str_Any_Stats_Cat][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By]
                        ''' Do we want to this pop file? '''
                        if int_Rep_Mating_Count >= int_Pop_Starts_When_Mating_Count_Is: 
                            bool_PreProcess_Check_1 = True
                        else:
                            bool_PreProcess_Check_1 = False
                        pass
                        ''' Only load pop at every mating interval as specified by int_Sample_Pop_When_Mating_Count_Divisible_By '''
                        int_Replicate_Mating_Count_Div = float(int_Sim_Mating_Count) / float(int_Sample_Pop_When_Mating_Count_Divisible_By) 
                        bool_PreProcess_Check_2 = (int_Replicate_Mating_Count_Div).is_integer()
                        if bool_PreProcess_Check_1 and bool_PreProcess_Check_2:
#                             ''' Record the Sim Mating group being subsampled here '''
#                             dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_Last_Mating_In_Replicate] = int_Sim_Mating_Count
                            
                            ''' Load simuPOP pop '''
                            self.obj_Log_Debug_Display.debug('Importing simuPOP Pop file: ' + str_simuPOP_Path_And_File)
                            
                            self.obj_Log_Run_Display.info('Importing simuPOP Pop file: ' + strFileName)
                            
                            pop_Imported = self.method_Load_SimuPop_Population(str_simuPOP_Path_And_File)
    
    
                            '''
                            ~~~~~~~~~~~~~~~~~~~~~~
                            SubSample Imported Pop By Stats Category Details
                            ~~~~~~~~~~~~~~~~~~~~~~
                            '''
                            #str_Any_Stats_Cat = dictExperiment.keys()[0]
                            #list_Stats_Cats = dictExperiment[str_Any_Stats_Cat][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories]
                            list_Stats_Cats = dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories]
                            str_Experiment_Label = dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label]
                            dict_Stats_Categories = OrderedDict(dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories])
                            for str_Stats_Category in list_Stats_Cats:
                                
                                self.obj_Log_Run_Display.info('Exporting sub-samples for Experiment: ' + str_Experiment_Label + ' ; Stats Category: ' + str_Stats_Category)
    
                                        
                                #DEBUG_ON
                                #if str_Stats_Category == 'Full':
                                #    self.obj_Log_Debug_Display.debug('Here')
                                #pass  
                                #DEDBUG_OFF
                                
                                ''' SubSample pop '''
                                bool_SubSample_SS_Pop = True
                                if bool_SubSample_SS_Pop:    
                                    '''
                                    -----------------------------------
                                    Sub-sample loaded population
                                    -----------------------------------
                                    '''
                                    intFilesPerFolder = 250
                                    intFilesPerFolderCount = 0
                                    dictSamplingParams = {}
        
                                    intNumberOfReplicates = dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category]
                                    for intReplicate in range(1, intNumberOfReplicates+1):
                                        
                                        self.obj_Log_Debug_Display.debug('Creating SubSample Replicate: ' + str(intReplicate) + ' of ' + str(intNumberOfReplicates))
                                        
                                        intGenepopFileCount = intReplicate
                                        intFilesPerFolderCount += 1
    
                                        #DEBUG_ON
                                        #if intReplicate == 10:
                                        #    break
                                        #DEBUG_OFF    
                                        dictSamplingParams = dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params]                             
                                        listLociToRemove = dictSamplingParams[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove]
                                        intSamplingMethod = dictSamplingParams[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method]
                                        '''
                                        SubSample the pop
                                        '''
                                        #pop_SubSample_Orig, dict_Stats_Categories = self.method_SubSample_Simulated_Dataset(pop_Imported, intSamplingMethod, dictSamplingParams, listLociToRemove, intNumberOfReplicates , intGenepopFileCount, dict_Stats_Categories)
                                        pop_SubSample_Orig, dict_Stats_Categories = self.method_SubSample_Simulated_Dataset(pop_Imported, intSamplingMethod, dictSamplingParams, listLociToRemove, intNumberOfReplicates , intGenepopFileCount, dict_Stats_Categories, str_Stats_Category, intReplicate)
                                        intSubSampleSize = pop_SubSample_Orig.subPopSize() 
    
                                        '''
                                        Export the sampled pop as a Genepop file
                                        '''
    #                                     with FileHandler() as objFileOperation:
    #                                         tupFilePathNameAndExt = objFileOperation.method_Get_FileNameAndExtension_From_FileName(str_Pop_Source_File_Path_And_Name)
    #                                         strPathFileName_ImportWOSuffix = objFileOperation.method_Get_FileName_From_PathAndFileName(tupFilePathNameAndExt[0])
    #                                     
                                        str_Stats_Cat_Code = dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code]

#                                         strFilePath_Export = dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path] + '\\'
#                                         strFilePath_Export += self.objSSParametersLocal.strUniqueRunID + '\\'
                                        #strFilePath_Export = self.objSSParametersLocal.str_Current_Run_Path + '\\'
                                        strFilePath_Export = str_LDNE_Working_Path + '\\'
                                        #strFilePath_Export += dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label]
                                        strFilePath_Export += str_Experiment_Label
                                        #strFilePath_Export += '\\' + str_Stats_Category
                                        strFilePath_Export += '\\' + str_Stats_Cat_Code
                                        strFilePath_Export += '\\SM_' + str_Sim_Mating_Count
                                        
                                        strFilename_Export_Suffix = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__PF_Pop_SubSample
                                        str_Genepop_File_Count = str(intReplicate)
                                        str_Genepop_File_Count_Out = str_Genepop_File_Count.zfill(len(str(intNumberOfReplicates)))
                                                                                      
                                        '''
                                        ~~~~~~~~~~~~~~~~~~
                                        WARNING:
                                        FIlename is really important here as this info is used to match with other datsets on the Sim Mating Count key
                                        & is restricted by the number of chars it can have due to Ne2 LDNe TAB file replorting limitations
                                        Must be UNDERSCORE delimited (but could be changed here & in the Results processing
                                        ONLY 3 UNDERSCORES may be used or the Results processing will screw up the string split into separate pandas df columns
                                        Total chars must not exceed (16 - SubSample_Replicate_Number)
                                        Filename currently : <Prefix>_<Stats_Cat_Code:3>_<Sim_Mating_Count:4>_<SubSample_Replicate:2>.a
                                        NE2 will only take the LAST (16 - SubSample_Replicate_Number) characters of this filenae. 
                                        Most of prefiix will be chopped off by Ne2 but the this is relative so NO UNDERSCORES MAY BE USED IN THE PREFIX.
                                        ~~~~~~~~~~~~~~~~~~
                                        '''                                                                        
                                        strFilename_Export = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Name__PF_Pop_SubSample + '_'
                                        strFilename_Export += str_Stats_Cat_Code + '_'
                                        strFilename_Export += str_Sim_Mating_Count + '_'
                                        strFilename_Export += str_Genepop_File_Count_Out
                                        strFilename_Export += strFilename_Export_Suffix
                                                                            
                                        strFilePathAndNameFull_Export = strFilePath_Export + '\\' + strFilename_Export 
                                        
                                        ''' Prep File system path for save '''
                                        with FileHandler() as obj_FileOp:
                                            bool_Success = obj_FileOp.method_FileSystem_Prep_For_File_Save(strFilePathAndNameFull_Export, bool_Delete=True)
                                        pass
                                        '''
                                        Create GENEPOP file
                                        IMPORTANT - Allele adjust means the difference between an allele and missing data
                                        if your data has zeros as missing data - set this to zero
                                        if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                                        '''
                                        intAlleleAdjust = 1
                                        bool_Prevent_Internal_Function_Console_Output = True
                                        bool_Prevent_External_Function_Console_Output = True
                
                                        boolSuccess = self.method_Export_Genotypes(pop_SubSample_Orig, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))
                    
                                        if boolSuccess == False:
                                            self.obj_Log_Default_Display.error('!!!ERROR - File create failed ERROR!!!; File: ' + strFilename_Export)
                                            #DEBUG_ON                    
                                            simupop.dump(pop_SubSample_Orig)
                                            with globalsSS.Pause_Console() as obj_Pause:
                                                obj_Pause.method_Pause_Console
                                            pass
                                            #DEBUG_OFF
                                        else:
                                            ''' Record the Sim Mating group being subsampled here '''
                                            dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][intReplicate][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_Last_Mating_In_Replicate] = int_Sim_Mating_Count
                                            ''' Save the filename to the dictExperiment Sampling Replicate '''
                                            dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][intReplicate][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicate_Filename] = strFilename_Export 
                                                
                                            self.obj_Log_Debug_Display.debug('GENEPOP file exported: ' + strFilename_Export)
                                        pass
                                    pass
                                pass
                                '''
                                Check if the file creation limit has been reached
                                If so perform Ne2Bulk processing
                                '''
                                #if intFilesPerFolderCount == intFilesPerFolder - 1:
                                     
                                '''
                                Subfolder and GENEPOP files have been created
                                Pre-process before executing Ne2Bulk
                                '''
                                 
                                boolPrepNe2Bulk = True
                                if boolPrepNe2Bulk:
                                 
                                    #Put executable files in place
                                    self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_Export)
                                     
                                    boolExecuteNe2Bulk = True
                                    if boolExecuteNe2Bulk:
                                
                                        self.obj_Log_Debug_Display.debug('Spawning External Ne2Bulk Process')
                                
                                        #Execute external program
                                        bool_Prevent_External_Function_Console_Output = True
                                        strProcessFilePattern =  globalsSS.Genepop_Results_File_Details.static_Genepop_File_Name__PF_Pop_SubSample
                                        strFilePath_Working = strFilePath_Export
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02_PCrit_0_00
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_00
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                                        strPCritToProcess =  dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess]
                                        process, int_Process_PID = self.method_Execute_External_Program_Ne2Bulk(strPCritToProcess, strProcessFilePattern, strFilePath_Working, bool_Prevent_External_Function_Console_Output)
                                        list_Process_PIDs.append(process.pid)
                                        self.obj_Log_Debug_Display.debug('Spawned External Ne2Bulk Process PID: ' + str(process.pid))
                                        
                                        #self.obj_Log_Run_Display.info('External Processes now running: ' + str(len(list_Process_PIDs)))
                                        
                                        bool_Restrict_Number_Of_Processes_Running = True
                                        if bool_Restrict_Number_Of_Processes_Running:
                                            ''' Keep checking if allowed number of processes ar still running '''
                                            #int_Processes_Allowed = 20
                                            int_Processes_Allowed = self.objSSParametersLocal.int_Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed
                                            int_Processes_Still_Running = len(list_Process_PIDs)
                                            while int_Processes_Still_Running >= int_Processes_Allowed:
                                                for pid in list_Process_PIDs:
                                                    if not psutil__pid_exists(pid):
                                                        list_Process_PIDs.remove(pid)
                                                    pass
                                                pass
                                                int_Processes_Still_Running = len(list_Process_PIDs)
                                                self.obj_Log_Run_Display.info('Waiting on processes to finish...Process Allowed: ' + str(int_Processes_Allowed) + ' ; Still Running Processes: ' + str(int_Processes_Still_Running) + ' ; (PIDs: ' + str(list_Process_PIDs) + ')...')
                                                time__sleep(1) # delays for 1 seconds
                                            pass                                       
                                        pass
                                    pass
                                pass

                    pass
                pass
            
                ''' Keep checking if last spawned process is still running '''
                
                bool_Process_Still_Running = True
                while bool_Process_Still_Running:
                    for pid in list_Process_PIDs:
                        if not psutil__pid_exists(pid):
                            list_Process_PIDs.remove(pid)
                        pass
                    pass
                    if len(list_Process_PIDs) == 0:
                        bool_Process_Still_Running = False
                    else:
                        self.obj_Log_Run_Display.info('Waiting on...External Processes (n = ' + str(len(list_Process_PIDs)) + ') still running (PIDs: ' + str(list_Process_PIDs) + ')...')
                    pass
                    time__sleep(5) # delays for 5 seconds
                pass
            
                return dictExperiment

            def method_Saved_Pop_SubSample_Ne2Bulk_Processing_of_Experiments(self, int_Sample_Pop_When_Mating_Count_Divisible_By, int_Pop_Starts_When_Mating_Count_Is, str_LDNE_Working_Path, str_Search_Path__Saved_SimuPops, str_File_Search_Pattern, dictExperiment):

                '''
                --------------------------
                Run the experiment
                --------------------------
                '''
                
                bool_Success = False
                
                '''
                -------------------------------
                Get & Process simuPOP Pop Input files
                -------------------------------
                '''                
                #list_Processes = []
                odict_Process_History = OrderedDict()
                
#                 ''' Search file pattern '''
#                 str_File_Search_Pattern = '*' + globalsSS.SS_Per_Fert_PF_File_Output_Details.static_Output_File_Suffix__SimuPOP_Pop_PF
                
                str_Genepop_File_Suffix = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__PF_Pop_SubSample
         
                '''
                Import each SimuPop Pop file
                '''
                str_Search_Path = str_Search_Path__Saved_SimuPops
                self.obj_Log_Debug_Display.debug('Importing simuPOP Pop file of search pattern: ' + str_File_Search_Pattern + ' in search path: ' + str_Search_Path) 
        
                ''' Locate simuPOP Pop input files '''
                bool_File_Located = False
                with FileHandler() as obj_FileOp:
                    bool_File_Located, list_Path_And_Files = obj_FileOp.func_Locate_Files(str_Search_Path, str_File_Search_Pattern)
                pass
                if not bool_File_Located:
                    ''' Display meaningfull error message '''
                    with SSErrorOperation([]) as obj_SSErrorOp:
                        str_Message_Text = 'ERROR: No simuPOP Pop files of search pattern: ' + str_File_Search_Pattern + ' found in search path: ' + str_Search_Path + '\n'
                        int_Stack_Trace_Level = 2
                        obj_SSErrorOp.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text, tup_Args = (self.objSSParametersLocal.str_App_Arg_Output_Base_Path, self.objSSParametersLocal.strUniqueRunID))  
                    pass
                
                    bool_Success = False
                    return bool_Success, dictExperiment
                else:    
                    '''Process each file in turn'''
                    dictSimReplicate = OrderedDict()
                    int_Sim_Replicate = 0
                    for str_simuPOP_Path_And_File in list_Path_And_Files:
                        
                        strFilePath, strFileName = obj_FileOp.method_Separate_Path_And_FileName_From_PathAndFileName(str_simuPOP_Path_And_File)
                        str_simuPOP_FileName = strFileName
                        ''' Get original run details from filename '''
                        str_Run_UID = str_simuPOP_FileName[:31]
                        ''' Get Sim Mating Count from simuPOP pop filename '''
                        str_Sim_Mating_Count = str_simuPOP_FileName.split('_SM', 1)[1]
                        str_Sim_Mating_Count = str_Sim_Mating_Count.split('_', 1)[0]
                        int_Sim_Mating_Count = int(str_Sim_Mating_Count)
                        str_Rep_Mating_Count = str_simuPOP_FileName.split('_M', 1)[1]
                        str_Rep_Mating_Count = str_Rep_Mating_Count.split('.', 1)[0]
                        int_Rep_Mating_Count = int(str_Rep_Mating_Count)
                                               
                        ''' Check if we want to sample this pop '''
                        #int_Sample_Pop_When_Mating_Count_Divisible_By = dictExperiment[str_Any_Stats_Cat][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Each_Mating_Count_Divisible_By]
                        ''' Do we want to this pop file? '''
                        if int_Rep_Mating_Count >= int_Pop_Starts_When_Mating_Count_Is: 
                            bool_PreProcess_Check_1 = True
                        else:
                            bool_PreProcess_Check_1 = False
                        pass
                        ''' Only load pop at every mating interval as specified by int_Sample_Pop_When_Mating_Count_Divisible_By '''
                        int_Replicate_Mating_Count_Div = float(int_Sim_Mating_Count) / float(int_Sample_Pop_When_Mating_Count_Divisible_By) 
                        bool_PreProcess_Check_2 = (int_Replicate_Mating_Count_Div).is_integer()
                        if bool_PreProcess_Check_1 and bool_PreProcess_Check_2:
                            
                            int_Sim_Replicate += 1
                            
                            
                            ''' Load simuPOP pop '''
                            self.obj_Log_Debug_Display.debug('Importing simuPOP Pop file: ' + str_simuPOP_Path_And_File)
                            
                            self.obj_Log_Run_Display.info('Importing simuPOP Pop file: ' + strFileName)
                            
                            pop_Imported = self.method_Load_SimuPop_Population(str_simuPOP_Path_And_File)
    
    
                            '''
                            ~~~~~~~~~~~~~~~~~~~~~~
                            SubSample Imported Pop By Stats Category Details
                            ~~~~~~~~~~~~~~~~~~~~~~
                            '''
                            #str_Any_Stats_Cat = dictExperiment.keys()[0]
                            #list_Stats_Cats = dictExperiment[str_Any_Stats_Cat][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories]
                            list_Stats_Cats = dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories]
                            str_Experiment_Label = dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label]
                            #dict_Stats_Categories = OrderedDict(dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories])
                            dict_Stats_Categories = copy__deepcopy(dictExperiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories])
                            
                            for str_Stats_Category in list_Stats_Cats:
                                
                                self.obj_Log_Run_Display.info('Exporting sub-samples for Experiment: ' + str_Experiment_Label + ' ; Stats Category: ' + str_Stats_Category)
    
                                        
                                #DEBUG_ON
                                #if str_Stats_Category == 'Full':
                                #    self.obj_Log_Debug_Display.debug('Here')
                                #pass  
                                #DEDBUG_OFF
                                
                                ''' SubSample pop '''
                                bool_SubSample_SS_Pop = True
                                if bool_SubSample_SS_Pop:    
                                    '''
                                    -----------------------------------
                                    Sub-sample loaded population
                                    -----------------------------------
                                    '''
                                    intFilesPerFolder = 250
                                    intFilesPerFolderCount = 0
                                    dictSamplingParams = {}
        
                                    intNumberOfReplicates = dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category]
                                    for intReplicate in range(1, intNumberOfReplicates+1):
                                        
                                        self.obj_Log_Debug_Display.debug('Creating SubSample Replicate: ' + str(intReplicate) + ' of ' + str(intNumberOfReplicates))
                                        
                                        intGenepopFileCount = intReplicate
                                        intFilesPerFolderCount += 1
    
                                        #DEBUG_ON
                                        #if intReplicate == 10:
                                        #    break
                                        #DEBUG_OFF    
                                        dictSamplingParams = dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Params]                             
                                        listLociToRemove = dictSamplingParams[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sample_Loci_To_Remove]
                                        intSamplingMethod = dictSamplingParams[globalsSS.Colnames_Pop_Sampling.static_Str_Colname_Sampling_Method]
                                        '''
                                        SubSample the pop
                                        '''
                                        #pop_SubSample_Orig, dict_Stats_Categories = self.method_SubSample_Simulated_Dataset(pop_Imported, intSamplingMethod, dictSamplingParams, listLociToRemove, intNumberOfReplicates , intGenepopFileCount, dict_Stats_Categories)
                                        pop_SubSample_Orig, dict_Stats_Categories = self.method_SubSample_Simulated_Dataset(pop_Imported, intSamplingMethod, dictSamplingParams, listLociToRemove, intNumberOfReplicates , intGenepopFileCount, dict_Stats_Categories, str_Stats_Category, intReplicate)
                                        intSubSampleSize = pop_SubSample_Orig.subPopSize() 
    
                                        '''
                                        Export the sampled pop as a Genepop file
                                        '''
    #                                     with FileHandler() as objFileOperation:
    #                                         tupFilePathNameAndExt = objFileOperation.method_Get_FileNameAndExtension_From_FileName(str_Pop_Source_File_Path_And_Name)
    #                                         strPathFileName_ImportWOSuffix = objFileOperation.method_Get_FileName_From_PathAndFileName(tupFilePathNameAndExt[0])
    #                                     
                                        str_Stats_Cat_Code = dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category_Code]

#                                         strFilePath_Export = dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Search_Path] + '\\'
#                                         strFilePath_Export += self.objSSParametersLocal.strUniqueRunID + '\\'
                                        #strFilePath_Export = self.objSSParametersLocal.str_Current_Run_Path + '\\'
                                        strFilePath_Export = str_LDNE_Working_Path + '\\'
                                        #strFilePath_Export += dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label]
                                        strFilePath_Export += str_Experiment_Label
                                        #strFilePath_Export += '\\' + str_Stats_Category
                                        strFilePath_Export += '\\' + str_Stats_Cat_Code
                                        strFilePath_Export += '\\SM_' + str_Sim_Mating_Count
                                        
                                        strFilename_Export_Suffix = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__PF_Pop_SubSample
                                        str_Genepop_File_Count = str(intReplicate)
                                        str_Genepop_File_Count_Out = str_Genepop_File_Count.zfill(len(str(intNumberOfReplicates)))
                                                                                      
                                        '''
                                        ~~~~~~~~~~~~~~~~~~
                                        WARNING:
                                        FIlename is really important here as this info is used to match with other datsets on the Sim Mating Count key
                                        & is restricted by the number of chars it can have due to Ne2 LDNe TAB file replorting limitations
                                        Must be UNDERSCORE delimited (but could be changed here & in the Results processing
                                        ONLY 3 UNDERSCORES may be used or the Results processing will screw up the string split into separate pandas df columns
                                        Total chars must not exceed (16 - SubSample_Replicate_Number)
                                        Filename currently : <Prefix>_<Stats_Cat_Code:3>_<Sim_Mating_Count:4>_<SubSample_Replicate:2>.a
                                        NE2 will only take the LAST (16 - SubSample_Replicate_Number) characters of this filenae. 
                                        Most of prefiix will be chopped off by Ne2 but the this is relative so NO UNDERSCORES MAY BE USED IN THE PREFIX.
                                        ~~~~~~~~~~~~~~~~~~
                                        '''                                                                        
                                        strFilename_Export = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Name__PF_Pop_SubSample + '_'
                                        strFilename_Export += str_Stats_Cat_Code + '_'
                                        strFilename_Export += str_Sim_Mating_Count + '_'
                                        strFilename_Export += str_Genepop_File_Count_Out
                                        strFilename_Export += strFilename_Export_Suffix
                                                                            
                                        strFilePathAndNameFull_Export = strFilePath_Export + '\\' + strFilename_Export 
                                        
                                        ''' Prep File system path for save '''
                                        with FileHandler() as obj_FileOp:
                                            bool_Success = obj_FileOp.method_FileSystem_Prep_For_File_Save(strFilePathAndNameFull_Export, bool_Delete=True)
                                        pass
                                        '''
                                        Create GENEPOP file
                                        IMPORTANT - Allele adjust means the difference between an allele and missing data
                                        if your data has zeros as missing data - set this to zero
                                        if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                                        '''
                                        intAlleleAdjust = 1
                                        bool_Prevent_Internal_Function_Console_Output = True
                                        bool_Prevent_External_Function_Console_Output = True
                
                                        boolSuccess = self.method_Export_Genotypes(pop_SubSample_Orig, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))
                    
                                        if boolSuccess == False:
                                            self.obj_Log_Default_Display.error('!!!ERROR - File create failed ERROR!!!; File: ' + strFilename_Export)
                                            #DEBUG_ON                    
                                            simupop.dump(pop_SubSample_Orig)
                                            with globalsSS.Pause_Console() as obj_Pause:
                                                obj_Pause.method_Pause_Console
                                            pass
                                            #DEBUG_OFF
                                        else:
                                            ''' Save the filename to the dictExperiment Sampling Replicate '''
                                            dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates][intReplicate][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicate_Filename] = strFilename_Export 
                                                
                                            self.obj_Log_Debug_Display.debug('GENEPOP file exported: ' + strFilename_Export)
                                        pass
                                    pass
                                pass
                                '''
                                Check if the file creation limit has been reached
                                If so perform Ne2Bulk processing
                                '''
                                #if intFilesPerFolderCount == intFilesPerFolder - 1:
                                     
                                '''
                                Subfolder and GENEPOP files have been created
                                Pre-process before executing Ne2Bulk
                                '''
                                 
                                boolPrepNe2Bulk = True
                                if boolPrepNe2Bulk:
                                 
                                    ''' Write Ne Estimator Version to Ne2Bulk_Fresh version parameter file '''
                                    bool_Success = self.func_File_Open_And_Write__Ne_Estimator_Version_To_Use()
                                    
                                    #Put executable files in place
                                    self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_Export)
                                     
                                    boolExecuteNe2Bulk = True
                                    if boolExecuteNe2Bulk:
                                
                                        self.obj_Log_Debug_Display.debug('Spawning External Ne2Bulk Process')
                                
                                        #Execute external program
                                        bool_Prevent_External_Function_Console_Output = True
                                        strProcessFilePattern =  globalsSS.Genepop_Results_File_Details.static_Genepop_File_Name__PF_Pop_SubSample
                                        strFilePath_Working = strFilePath_Export
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_00
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_01
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_02_PCrit_0_00
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_00
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_00
                                        #strPCritToProcess = globalsSS.Ne2Bulk_Processing.static_stringNe2Bulk_PCrit_To_Process_PCrit_0_05_PCrit_0_02_PCrit_0_01_PCrit_0_00
                                        strPCritToProcess =  dict_Stats_Categories[str_Stats_Category][globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_strPCritsToProcess]

                                        process_Process, int_Process_PID = self.method_Execute_External_Program_Ne2Bulk(strPCritToProcess, strProcessFilePattern, strFilePath_Working, bool_Prevent_External_Function_Console_Output)

                                        #DEBUG_ON
                                        obj_Log = self.obj_Log_Debug_Display.debug
                                        obj_Log('External process executed: ' + str(int_Process_PID))
                                        #DEBUG_OFF 
                                                        
                                        ''' Wait to see if process finishes rapidly '''
                                        int_Tries = 12
                                        for int_Try in range(int_Tries):
                                            try:
                                                #DEBUG_ON
                                                #obj_Log = self.obj_Log_Debug_Display.debug
                                                #obj_Log('Try: ' + str(int_Try) + ' of ' + str(int_Tries))
                                                #DEBUG_OFF                                                
                                                bool_Running = process_Process.is_running()
                                                if bool_Running:
                                                    time__sleep(.25)
                                                else:
                                                    break
                                                pass                                                
                                            except psutil.NoSuchProcess, psutil.AccessDenied:
                                                ''' Process has probably finished '''
                                                bool_Running = False
                                                break
                                                pass                                            
                                            except OSError, exception_Exception:
                                                if sys.platform.startswith('win'):
                                                    if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                                        ''' Process has probably finished '''
                                                        bool_Running = False
                                                        break
                                                    pass
                                                pass
                                            pass                                            
                                        pass
                                    
                                        if bool_Running:     
                                            try:
                                                odict_Process = OrderedDict([('Process_PID', process_Process.pid), ('Process_Object', process_Process), ('Process_Cmdline', process_Process.cmdline()), ('Child_Process_Odict', None)])
                                                odict_Process_History[process_Process.pid] = odict_Process
                                            except psutil.NoSuchProcess, psutil.AccessDenied:
                                                ''' Process has probably finished '''
                                                pass
                                            except OSError, exception_Exception:
                                                if sys.platform.startswith('win'):
                                                    if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                                        ''' Process has probably finished '''
                                                    pass
                                                pass
                                            pass
                                        pass
                                    
                                        bool_Restrict_Number_Of_Processes_Running = True
                                        if bool_Restrict_Number_Of_Processes_Running:
                                            ''' Keep checking if allowed number of processes are still running '''
                                            #int_Processes_Allowed = 20
                                            int_Processes_Allowed = self.objSSParametersLocal.int_Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed
                                            int_Processes_Still_Running = len(odict_Process_History)
                                            
                                            while int_Processes_Still_Running >= int_Processes_Allowed:
                                                
                                                odict_Process_History = self.func_Check_List_Of_Subprocess_Running_Status_And_Terminate_Zombie_Processes(odict_Process_History)
                                                
                                                int_Processes_Still_Running = len(odict_Process_History)
                                                self.obj_Log_Run_Display.info('Waiting on processes to finish...Process Allowed: ' + str(int_Processes_Allowed) + ' ; Still Running Processes: ' + str(int_Processes_Still_Running) + ' ; (PIDs: ' + str([int_PID for int_PID in odict_Process_History.keys()]) + ')...')
                                                time__sleep(3)
                                            pass                                       
                                        pass
                                    pass
                                pass
                            pass
                            
                            dictSimReplicate[int_Sim_Replicate] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories, dict_Stats_Categories)])
                            ''' Record the Sim Replicate Details '''
                            dictSimReplicate[int_Sim_Replicate][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_Data_Sim_Current_Replicate] = int_Sim_Replicate
                            dictSimReplicate[int_Sim_Replicate][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_Last_Mating_In_Replicate] = int_Sim_Mating_Count
                            dictSimReplicate[int_Sim_Replicate][globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_Data_Sim_Current_File] = strFileName
                            
                        pass
                    pass
                
                    dictExperiment['Sim_Replicate_Details'] = dictSimReplicate
                    bool_Success = True
                pass
                
                ''' Keep checking if last spawned process is still running '''
                
                bool_Process_Still_Running = True
                while bool_Process_Still_Running:

                    odict_Process_History = self.func_Check_List_Of_Subprocess_Running_Status_And_Terminate_Zombie_Processes(odict_Process_History)
                                                              
                    if len(odict_Process_History) == 0:
                        bool_Process_Still_Running = False
                    else:
                        self.obj_Log_Run_Display.info('Waiting on...External Processes (n = ' + str(len(odict_Process_History)) + ') still running (PIDs: ' + str([int_PID for int_PID in odict_Process_History.keys()]) + ')...')
                    pass
                    time__sleep(3)
                pass
            
                return bool_Success, dictExperiment


            def func_Check_List_Of_Subprocess_Running_Status_And_Terminate_If_No_IO_RETIRE(self, odict_Process_History):


                '''
                -------------------------------
                Take a list of subprocesses and check if still running.
                If the process has stopped using IO since the last check, terminate it.
                Otherwise remove it from the list of processes still running
                -------------------------------
                ''' 
                
                ''' Get a static copy of the process list '''                 
                odict_Processes_Temp = OrderedDict(odict_Process_History)
                
                #DEBUG_ON
                #obj_Log = self.obj_Log_Debug_Display.debug 
                #for int_Process_Parent__PID, odict_Process in odict_Processes_Temp.items():
                #    for key, value in odict_Process.items():
                #        if type(value) is OrderedDict:
                #            for key2, value2 in value.items():
                #                obj_Log('Process PID: ' + str(int_Process_Parent__PID) + ' ; Key: ' + str(key) + ' ; Key2: ' + str(key2) + ' ; Value2: ' + str(value2))
                #            pass
                #        else:
                #            obj_Log('Process PID: ' + str(int_Process_Parent__PID) + ' ; Key: ' + str(key) + ' ; Value: ' + str(value))
                #        pass
                #    pass
                #pass
                #DEBUG_OFF
                                    
                for int_Process_Parent__PID, odict_Process in odict_Processes_Temp.items():
                    
                    process_Process = odict_Process['Process_Object']
                    
                    #DEBUG_ON
                    #obj_Log = self.obj_Log_Debug_Display.debug 
                    #obj_Log('Process: ' + str(int_Process_Parent__PID) + ' ; Is running: ' + str(process_Process.is_running()))
                    #DEBUG_OFF
                    
                    ''' Chek if the process is still running '''
                    if process_Process.is_running():
                        
                        #DEBUG_ON
                        #''' Check what the process status is '''
                        #try:
                        #    str_Process__Status = str(process_Process.status() if process_Process.is_running() else 'process finished')
                        #    obj_Log = self.obj_Log_Debug_Display.debug 
                        #    obj_Log('Process: ' + str(int_Process_Parent__PID) + ' ; Status: ' + str_Process__Status)
                        #except psutil.NoSuchProcess, psutil.AccessDenied:
                        #    ''' Process has probably finished '''
                        #    pass
                        #except OSError, exception_Exception:
                        #    if sys.platform.startswith('win'):
                        #        if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                        #            ''' Process has probably finished '''
                        #        pass
                        #    pass
                        #pass
                        #DEBUG_OFF
                        
                        '''
                        Get the child of the process as these processes consist of a Parent and 1 Child process
                        Ne2 processing is started from a DOS batch script so the Parent = Script and Child = Ne2
                        We need to monitor the Ne2 process to ensure it doesnt turn into a Zombie process which has no IO (but has CPU)
                        '''
                        
                        ''' Get the children of the parent process '''
                        try:
                            process_Process_Children = process_Process.children(recursive=True) if process_Process.is_running() else []
                        except psutil.NoSuchProcess, psutil.AccessDenied:
                            ''' Process has probably finished '''
                            pass
                        except OSError, exception_Exception:
                            if sys.platform.startswith('win'):
                                if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                    ''' Process has probably finished '''
                                pass
                            pass
                        pass
                        
                        ''' We assume only one child process '''
                        if len(process_Process_Children) > 0:
                            if len(process_Process_Children) == 1:
                                
                                ''' Get the child process '''
                                process_Process_Child__Current = process_Process_Children[0]
                                str_Process_Prefix = 'Child_'
                                
                                odict_Process_Child__Current = self.func_External_Process__Add_Details_To_ODict(process_Process_Child__Current, str_Process_Prefix)

                                if not odict_Process_Child__Current is None:
                
                                    '''
                                    Maintain a dictionary of process history.
                                    Check if IO has ceased since last checked.
                                    Check if process has run for too long.
                                    '''
                                    odict_Process_Child__Previous = None
                                    
                                    ''' Is the Parent Process still in the dictionary? '''
                                    if  int_Process_Parent__PID in odict_Process_History.keys():
                                        '''' Get the Child Process ''' 
                                        odict_Process_Child__Previous = odict_Process_History[int_Process_Parent__PID]['Child_Process_Odict']
                                    else:
                                        ''' Parent Process is probably finished '''
                                        pass
                                    pass
                                        
                                    ''' Check if the previous child process dict exists. If not, create it '''
                                    if odict_Process_Child__Previous is None:
                                        
                                        ''' Add the current child process to the process history dict '''
                                        odict_Process_History[int_Process_Parent__PID]['Child_Process_Odict'] = odict_Process_Child__Current

                                        #DEBUG_ON
                                        #obj_Log = self.obj_Log_Debug_Display.debug 
                                        #obj_Log('ODICT Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' NOT in ODICT so ADDED ')
                                        #DEBUG_OFF
                                        
                                    else:
#                                         '''
#                                         ONLY IMPLEMENT THIS WHEN int_Process__Max_Run_Seconds is a CONFIG FILE (Batch_Settings) parameter
#                                         '''
#                                         
#                                         '''If Child Process Dict exists, check how long the process has been running '''
#                                         
#                                         datetime_Process_Child__Previous__Time_Check = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Start_Time']
#                                         datetime_Current__Time_Check = datetime.now()
#                                         
#                                         int_Time_Diff__Seconds = int(datetime_Current__Time_Check.seconds()) - int(datetime_Process_Child__Previous__Time_Check.seconds())
#                                         int_Process__Max_Run_Seconds = 360
#                                         
#
#                                         #DEBUG_ON
#                                         obj_Log = self.obj_Log_Run_Display.info 
#                                         obj_Log('ODICT Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' in ODICT so CHECKING RUN TIME')
#                                         obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev Check time: ' + str(datetime_Process_Child__Previous__Time_Check))
#                                         obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Has been running: ' + str(int_Time_Diff__Seconds) + ' seconds')
#                                         obj_Log('int_Process__Max_Run_Seconds: ' + str(int_Process__Max_Run_Seconds))
#                                         #DEBUG_OFF
#                                         
#                                         if int_Time_Diff__Seconds > int_Process__Max_Run_Seconds:
#                                             '''
#                                             Process is running too long.
#                                             Terminate it.
#                                             We dont remove terminated processes from the process dictionary or list, but allow that to happen automatically at the next check.
# 
#                                             '''
#                                             obj_Log = self.obj_Log_Run_Display.info 
#                                             obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Has been running too long: ' + str(int_Time_Diff__Seconds) + ' seconds ; TERMINATE IT')
# 
#                                             list_Process_Parent__Cmdline = odict_Process['Process_Cmdline']
#                                             bool_Success = self.func_Terminate_Ne2_And_Prep_For_Rerun(odict_Process_Child__Current, str_Process_Prefix, int_Process_Parent__PID, list_Process_Parent__Cmdline)
#                                         
#                                         pass
                                    
                                        ''' If Child Process Dict exists, check current IO against previous IO to see if changed '''
                                        
                                        int_Process_Child__Previous__Check_Count = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Check_Count']
                                        str_Process_Child__Previous__Mem_Info = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Last_Memory_Check']
                                        str_Process_Child__Previous__IO_Counters = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Last_IO_Check']
                                        int_Process_Child__Previous__IO_Zombie_Check_Count = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Zombie_Found_Count']
                                        int_Process_Child__Current__Check_Count = odict_Process_Child__Current[str_Process_Prefix + 'Process_Check_Count']
                                        str_Process_Child__Current__Mem_Info = odict_Process_Child__Current[str_Process_Prefix + 'Process_Last_Memory_Check']
                                        str_Process_Child__Current__IO_Counters = odict_Process_Child__Current[str_Process_Prefix + 'Process_Last_IO_Check']
                                        int_Process_Child__Current__IO_Zombie_Check_Count = odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Count']

                                        #DEBUG_ON
                                        obj_Log = self.obj_Log_Debug_Display.debug 
                                        obj_Log('ODICT Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' in ODICT so CHECKING IO')
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev IO Check Count: ' + str(int_Process_Child__Previous__Check_Count)  + ' ; Prev IO Zombie Check Count: ' + str(int_Process_Child__Previous__IO_Zombie_Check_Count) + ' ; Prev IO: ' + str_Process_Child__Previous__IO_Counters)
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr IO Check Count: ' + str(int_Process_Child__Current__Check_Count) + ' ; Curr IO Zombie Check Count: ' + str(int_Process_Child__Current__IO_Zombie_Check_Count) + ' ; Curr IO: ' + str_Process_Child__Current__IO_Counters)
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev IO: ' + str_Process_Child__Previous__IO_Counters)
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr IO: ' + str_Process_Child__Current__IO_Counters)
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev Mem Info: ' + str_Process_Child__Previous__Mem_Info)
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr Mem Info: ' + str_Process_Child__Current__Mem_Info)
                                        #DEBUG_OFF
                                        
                                        if str_Process_Child__Current__IO_Counters == str_Process_Child__Previous__IO_Counters:
                                            '''
                                            IO counter hav not changed since the last check.
                                            Process is a Zombie with no IO.
                                            If the number of check counts has been exceeded...
                                            Approx 5min (300sec). 3sec between checks over 300sec = 100 checks
                                            Allows a zombie process to continue for 5 minutes, to elimate Ne2 processes that are just taking a long time to process (CPU), before we... 
                                            Terminate it.
                                            We dont remove terminated processes from the process dictionary or list, but allow that to happen automatically at the next check.
                                            '''
                                            if int_Process_Child__Previous__IO_Zombie_Check_Count > 100: #Approx 5min (300sec). 3sec between checks over 300sec = 100 checks 
                                                list_Process_Parent__Cmdline = odict_Process['Process_Cmdline']
                                                #bool_Success = self.func_Terminate_Ne2_And_Prep_For_Rerun(odict_Process_Child__Current, str_Process_Prefix, int_Process_Parent__PID, list_Process_Parent__Cmdline)
                                            else:
                                                odict_Process_Child__Previous[str_Process_Prefix + 'Process_Zombie_Found_Count'] += 1
                                            pass
                                        else:
                                            '''
                                            IO does not match previous IO.
                                            Process is alive.
                                            Allow it to continue.
                                            Update its stats.
                                            '''
                                            odict_Process_Child__Previous[str_Process_Prefix + 'Process_Last_Status_Check'] = odict_Process_Child__Current[str_Process_Prefix + 'Process_Last_Status_Check']
                                            odict_Process_Child__Previous[str_Process_Prefix + 'Process_Last_IO_Check'] = odict_Process_Child__Current[str_Process_Prefix + 'Process_Last_IO_Check']
                                            odict_Process_Child__Previous[str_Process_Prefix + 'Process_Check_Count'] += 1
                                            odict_Process_Child__Previous[str_Process_Prefix + 'Process_Start_Time'] = odict_Process_Child__Current[str_Process_Prefix + 'Process_Start_Time']
                                          
                                            #DEBUG_ON
                                            #obj_Log = self.obj_Log_Debug_Display.debug 
                                            #obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; IO not MATCHED ; IO OCCURING ; Continue')
                                            #DEBUG_OFF
                                        pass
                                    pass
                                else:
                                    '''
                                    Process has probably finshed.
                                    
                                    The OS recycles IO.
                                    Remove PIDs of finshed processes from the process history.
                                    We dont remove terminated processes from the process dictionary or list, but allow that to happen automatically at the next check.
                                    '''

                                    if not process_Process.is_running():
                                        
                                        del  odict_Process_History[int_Process_Parent__PID]
                                    
                                        #DEBUG_ON
                                        #obj_Log = self.obj_Log_Debug_Display.debug 
                                        #obj_Log('ODICT Process: ' + str(int_Process_Parent__PID) + ' NOT RUNNING so deleted from ODICT')
                                        #DEBUG_OFF
                                    pass
                                pass
                            else:
                                '''
                                ERROR:
                                More than one child process found but only one expected
                                '''
                                
                                '''
                                Wait for a while to ensure that this process doesnt complete and dissappear.
                                E.g. When a process fails Win OS creates a WER FAULT Child process to report the error.
                                But this finishes quicly an the process ends in error but gracefully.
                                We want to ignore those instances so we wait
                                '''
                                
                                bool_Error = True
                                int_Sleep_Timeout = 1 
                                int_Repeats = 3
                                
                                for int_Repeat in range(int_Repeats):
                                    
                                    time__sleep(int_Sleep_Timeout)
                                    
                                    ''' If all child processes have finished its not an error '''
                                    for process_Process_Child in process_Process_Children:
                                        if not process_Process_Child.is_running():
                                            bool_Error = False
                                        pass
                                    pass
                                    if not bool_Error:
                                        break
                                    pass
                                pass
                                
                                if bool_Error:
                                    with SSErrorOperation([]) as obj_SSErrorOp:
                                    
                                        str_Message_Text = 'More than one child process found but only one expected. #Children: ' + str(len(process_Process_Children)) + '\n'
                                        
                                        try:
                                            for process_Process_Child in process_Process_Children:
                                                str_Message_Text += 'PID: ' + str(process_Process_Child.pid if process_Process_Child.is_running() else 'process finished') + '\n'
                                                str_Message_Text += 'Name: ' + str(process_Process_Child.name() if process_Process_Child.is_running() else 'process finished') + '\n'
                                                str_Message_Text += 'EXE Path: ' + str(process_Process_Child.exe() if process_Process_Child.is_running() else 'process finished') + '\n'
                                            pass
                                        except psutil.NoSuchProcess, psutil.AccessDenied:
                                            ''' Process has probably finished '''
                                            str_Message_Text += 'process finished' + '\n'
                                            pass
                                        except OSError, exception_Exception:
                                            if sys.platform.startswith('win'):
                                                if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                                    ''' Process has probably finished '''
                                                    str_Message_Text += 'process finished' + '\n'
                                                pass
                                            pass                                    
                                        int_Stack_Trace_Level = 2
                                        obj_SSErrorOp.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text, tup_Args = (self.objSSParametersLocal.str_App_Arg_Output_Base_Path, self.objSSParametersLocal.strUniqueRunID))  
                                    pass
                                pass                            
                            pass
                        else:
                            ''' Process has no children.  Probably finished '''
                            pass
                        pass
                    else:
                        '''
                        Process is finished.
                        Remove it from the list of running processes.
                        We dont remove terminated processes from the process dictionary or list, but allow that to happen automatically at the next check.
                        '''
                        #DEBUG_ON
                        #obj_Log = self.obj_Log_Debug_Display.debug 
                        #obj_Log.info('Process: ' + str(process_Process.pid) + ' ; Status: COMPLETE')
                        #DEBUG_OFF

                        del  odict_Process_History[int_Process_Parent__PID] 
                                               
                        pass
                    pass
                pass  
            
                return odict_Process_History

            def func_Check_List_Of_Subprocess_Running_Status_And_Terminate_Zombie_Processes(self, odict_Process_History):


                '''
                -------------------------------
                Take a list of subprocesses and check if still running.
                If the process has stopped using IO since the last check, terminate it.
                Otherwise remove it from the list of processes still running
                -------------------------------
                ''' 
                
                ''' Get a static copy of the process list '''                 
                odict_Processes_Temp = OrderedDict(odict_Process_History)
                
                #DEBUG_ON
                #obj_Log = self.obj_Log_Debug_Display.debug 
                #for int_Process_Parent__PID, odict_Process in odict_Processes_Temp.items():
                #    for key, value in odict_Process.items():
                #        if type(value) is OrderedDict:
                #            for key2, value2 in value.items():
                #                obj_Log('Process PID: ' + str(int_Process_Parent__PID) + ' ; Key: ' + str(key) + ' ; Key2: ' + str(key2) + ' ; Value2: ' + str(value2))
                #            pass
                #        else:
                #            obj_Log('Process PID: ' + str(int_Process_Parent__PID) + ' ; Key: ' + str(key) + ' ; Value: ' + str(value))
                #        pass
                #    pass
                #pass
                #DEBUG_OFF
                                    
                for int_Process_Parent__PID, odict_Process in odict_Processes_Temp.items():
                    
                    process_Process = odict_Process['Process_Object']
                    
                    #DEBUG_ON
                    #obj_Log = self.obj_Log_Debug_Display.debug 
                    #obj_Log('Process: ' + str(int_Process_Parent__PID) + ' ; Is running: ' + str(process_Process.is_running()))
                    #DEBUG_OFF
                    
                    ''' Chek if the process is still running '''
                    if process_Process.is_running():
                        
                        #DEBUG_ON
                        #''' Check what the process status is '''
                        #try:
                        #    str_Process__Status = str(process_Process.status() if process_Process.is_running() else 'process finished')
                        #    obj_Log = self.obj_Log_Debug_Display.debug 
                        #    obj_Log('Process: ' + str(int_Process_Parent__PID) + ' ; Status: ' + str_Process__Status)
                        #except psutil.NoSuchProcess, psutil.AccessDenied:
                        #    ''' Process has probably finished '''
                        #    pass
                        #except OSError, exception_Exception:
                        #    if sys.platform.startswith('win'):
                        #        if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                        #            ''' Process has probably finished '''
                        #        pass
                        #    pass
                        #pass
                        #DEBUG_OFF
                        
                        '''
                        Get the child of the process as these processes consist of a Parent and 1 Child process
                        Ne2 processing is started from a DOS batch script so the Parent = Script and Child = Ne2
                        We need to monitor the Ne2 process to ensure it doesnt turn into a Zombie process which has no IO (but has CPU)
                        '''
                        
                        ''' Get the children of the parent process '''
                        try:
                            process_Process_Children = process_Process.children(recursive=True) if process_Process.is_running() else []
                        except psutil.NoSuchProcess, psutil.AccessDenied:
                            ''' Process has probably finished '''
                            pass
                        except OSError, exception_Exception:
                            if sys.platform.startswith('win'):
                                if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                    ''' Process has probably finished '''
                                pass
                            pass
                        pass
                        
                        ''' We assume only one child process '''
                        if len(process_Process_Children) > 0:
                            if len(process_Process_Children) == 1:
                                
                                ''' Get the child process '''
                                process_Process_Child__Current = process_Process_Children[0]
                                str_Process_Prefix = 'Child_'
                                
                                odict_Process_Child__Current = self.func_External_Process__Add_Details_To_ODict(process_Process_Child__Current, str_Process_Prefix)

                                if not odict_Process_Child__Current is None:
                
                                    '''
                                    Maintain a dictionary of process history.
                                    Check if IO has ceased since last checked.
                                    Check if process has run for too long.
                                    '''
                                    odict_Process_Child__Previous = None
                                    
                                    ''' Is the Parent Process still in the dictionary? '''
                                    if  int_Process_Parent__PID in odict_Process_History.keys():
                                        '''' Get the Child Process ''' 
                                        odict_Process_Child__Previous = odict_Process_History[int_Process_Parent__PID]['Child_Process_Odict']
                                    else:
                                        ''' Parent Process is probably finished '''
                                        pass
                                    pass
                                        
                                    ''' Check if the previous child process dict exists. If not, create it '''
                                    if odict_Process_Child__Previous is None:
                                        
                                        ''' Add the current child process to the process history dict '''
                                        odict_Process_History[int_Process_Parent__PID]['Child_Process_Odict'] = odict_Process_Child__Current

                                        #DEBUG_ON
                                        #obj_Log = self.obj_Log_Debug_Display.debug 
                                        #obj_Log('ODICT Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' NOT in ODICT so ADDED ')
                                        #DEBUG_OFF
                                        
                                    else:
                                        '''
                                        If Child Process Dict exists, it is still running since the last check
                                        check if it is a ZOMBIE
                                        If all the zombie checks are true terminate the process
                                        '''
                                        
                                        '''
                                        PRE CHECK - Update CURRENT from PREVIOUS process history - ODICT item PREVIOUS is the master copy that get updated
                                        '''
                                        odict_Process_Child__Current[str_Process_Prefix + 'Process_Check_Count'] = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Check_Count']
                                        odict_Process_Child__Current[str_Process_Prefix + 'Process_Check_Count'] += 1
                                        odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Count'] = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Zombie_Found_Count']
                                        odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count'] = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count']
                                        
                                        '''
                                        GET CURRENT INFO - and display if required
                                        '''                                        
                                        ''' Get the time the process has been running ''' 
                                        datetime_Process_Child__Previous__Process_Start_Time = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Start_Time']
                                        datetime_Current__Time_Check = datetime.now()
                                        int_Time_Diff__Seconds = int((datetime_Current__Time_Check - datetime_Process_Child__Previous__Process_Start_Time).total_seconds())
                                        int_Process__Max_Run_Seconds = self.objSSParametersLocal.int_Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds
                                        
                                        ''' Get the current and previous IO usage '''
                                        str_Process_Child__Previous__IO_Counters = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Last_IO_Check']
                                        str_Process_Child__Current__IO_Counters = odict_Process_Child__Current[str_Process_Prefix + 'Process_Last_IO_Check']

                                        ''' Get the current and previous IO Read Count '''
#                                         import re
#                                         str_Process_Child__Previous__IO_Read_Count = re.split('=|,', str_Process_Child__Previous__IO_Counters)
#                                         str_Process_Child__Current__IO_Read_Count = re.split('=|,', str_Process_Child__Current__IO_Counters)
                                        #import re
                                        str_Process_Child__Previous__IO_Read_Count = str_Process_Child__Previous__IO_Counters.split(',')[0]
                                        str_Process_Child__Current__IO_Read_Count = str_Process_Child__Current__IO_Counters.split(',')[0]
                                        #DEBUG_ON
                                        #obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info 
                                        #obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev IO: ' + str_Process_Child__Previous__IO_Read_Count)
                                        #obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr IO: ' + str_Process_Child__Current__IO_Read_Count)
                                        #DEBUG_OFF
                                        
                                        ''' Get the current and previous IO Write Count '''
                                        str_Process_Child__Previous__IO_Write_Count = str_Process_Child__Previous__IO_Counters.split(',')[1]
                                        str_Process_Child__Current__IO_Write_Count = str_Process_Child__Current__IO_Counters.split(',')[1]

                                        #DEBUG_ON
                                        #obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info 
                                        #obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev IO: ' + str_Process_Child__Previous__IO_Write_Count)
                                        #obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr IO: ' + str_Process_Child__Current__IO_Write_Count)
                                        #DEBUG_OFF
                                        
                                        ''' Get the current and previous memory usage '''
                                        str_Process_Child__Previous__Mem_Info = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Last_Memory_Check']
                                        str_Process_Child__Current__Mem_Info = odict_Process_Child__Current[str_Process_Prefix + 'Process_Last_Memory_Check']
                                        
                                        #''' Get the current and previous memory usage RSS '''
                                        #str_Process_Child__Previous__Mem_Info_RSS = str_Process_Child__Previous__Mem_Info.split(',')[0]
                                        #str_Process_Child__Current__Mem_Info_RSS = str_Process_Child__Current__Mem_Info.split(',')[0]
                                        #DEBUG_ON
                                        #obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info
                                        #obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev Mem Info RSS: ' + str_Process_Child__Previous__Mem_Info_RSS)
                                        #obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr Mem Info_RSS: ' + str_Process_Child__Current__Mem_Info_RSS)
                                        #DEBUG_OFF
                                        
                                        ''' Get the current and previous memory usage WSET '''
                                        str_Process_Child__Previous__Mem_Info_WSET = str_Process_Child__Previous__Mem_Info.split(',')[4]
                                        str_Process_Child__Current__Mem_Info_WSET = str_Process_Child__Current__Mem_Info.split(',')[4]
                                        #DEBUG_ON
                                        #obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info
                                        #obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev Mem Info WSET: ' + str_Process_Child__Previous__Mem_Info_WSET)
                                        #obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr Mem Info_WSET: ' + str_Process_Child__Current__Mem_Info_WSET)
                                        #DEBUG_OFF
                                                                                
                                        ''' Get the total number of times this process has been checked '''
                                        int_Process_Child__Previous__Check_Count = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Check_Count']
                                        int_Process_Child__Current__Check_Count = odict_Process_Child__Current[str_Process_Prefix + 'Process_Check_Count']
                                        
                                        ''' Get the total number of times this process has been found to be a zombie '''
                                        int_Process_Child__Previous__Zombie_Found_Count = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Zombie_Found_Count']
                                        int_Process_Child__Current__Zombie_Found_Count = odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Count']
                                        
                                        ''' Get the total number of times this process has been found to be a zombie CONSECUTIVELY'''
                                        int_Process_Child__Previous__Zombie_Found_Serially_Count = odict_Process_Child__Previous[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count']
                                        int_Process_Child__Current__Zombie_Found_Serially_Count = odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count']
                                         
                                        #DEBUG_ON
                                        obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info  
                                        obj_Log('ODICT Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' still running so checking if it is a ZOMBIE')
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Prev check count: ' + str(int_Process_Child__Previous__Check_Count))
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr check count: ' + str(int_Process_Child__Current__Check_Count))
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Prev zombie found count: ' + str(int_Process_Child__Previous__Zombie_Found_Count))
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr zombie found count: ' + str(int_Process_Child__Current__Zombie_Found_Count))
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Prev zombie found SERIALLY count: ' + str(int_Process_Child__Previous__Zombie_Found_Serially_Count))
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr zombie found SERIALLY count: ' + str(int_Process_Child__Current__Zombie_Found_Serially_Count))
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Start time: ' + str(datetime_Process_Child__Previous__Process_Start_Time))
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Has been running: ' + str(int_Time_Diff__Seconds) + ' seconds of allowed run time:' + str(int_Process__Max_Run_Seconds))
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev IO: ' + str_Process_Child__Previous__IO_Counters)
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr IO: ' + str_Process_Child__Current__IO_Counters)
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev Mem Info: ' + str_Process_Child__Previous__Mem_Info)
                                        obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr Mem Info: ' + str_Process_Child__Current__Mem_Info)
                                        #DEBUG_OFF
                                        
                                        '''
                                        INITIALISE the termination flags
                                        '''
                                        bool_Terminate_Check__Process_Has_Not_Changed_IO_Usage = False
                                        bool_Terminate_Check__Process_Has_Not_Changed_Memory_Usage = False
                                        bool_Terminate_Check__Zombie_Check_Count_Exceeded = False
                                        bool_Terminate_Check__Zombie_Check_Serial_Count_Exceeded = False
                                        bool_Terminate_Check__Process_Running_Too_Long = False
                                        
                                        '''
                                        CHECK if process is a ZOMBIE
                                        '''
                                        
                                        '''
                                        ZOMBIE Check 1 of 5 - Process has been running too long:
                                        Terminate zombie processes after a specified amount of elapsed time.
                                        However, if int_Process__Max_Run_Seconds = 0, never terminate.
                                        ''' 
                                        if (int_Process__Max_Run_Seconds > 0) and (int_Time_Diff__Seconds > int_Process__Max_Run_Seconds):

                                            bool_Terminate_Check__Process_Running_Too_Long = True
                                            
                                            obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info 
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Has been running too long: ' + str(int_Time_Diff__Seconds) + ' seconds of allowed run time:' + str(int_Process__Max_Run_Seconds) + '; TERMINATE IT!')
                                         
                                        pass

                                        '''
                                        ZOMBIE Check 2 of 5 - Process has been not been using IO:
                                        IO counters have not changed since the last check.
                                        Process may be Zombie.
                                        ''' 
                                        
                                        if str_Process_Child__Current__IO_Read_Count == str_Process_Child__Previous__IO_Read_Count and \
                                           str_Process_Child__Current__IO_Write_Count == str_Process_Child__Previous__IO_Write_Count:
                                        #if str_Process_Child__Current__IO_Counters == str_Process_Child__Previous__IO_Counters:    
                                            bool_Terminate_Check__Process_Has_Not_Changed_IO_Usage = True

                                            obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info 
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Possible IO ZOMBIE! Process IO has not changed.')
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev IO: ' + str_Process_Child__Previous__IO_Read_Count)
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr IO: ' + str_Process_Child__Current__IO_Read_Count)
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev IO: ' + str_Process_Child__Previous__IO_Write_Count)
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr IO: ' + str_Process_Child__Current__IO_Write_Count)
                                            #obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev IO: ' + str_Process_Child__Previous__IO_Counters)
                                            #obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr IO: ' + str_Process_Child__Current__IO_Counters)
                                    
                                        pass

                                        '''
                                        ZOMBIE Check 3 of 5 - Process has been not been using Memory:
                                        Memory counters have not changed since the last check.
                                        Process may be Zombie.
                                        '''
                                        #if str_Process_Child__Current__Mem_Info == str_Process_Child__Previous__Mem_Info:
                                        #if str_Process_Child__Current__Mem_Info_RSS == str_Process_Child__Previous__Mem_Info_RSS or \
                                        #   str_Process_Child__Current__Mem_Info_WSET == str_Process_Child__Previous__Mem_Info_WSET:
                                        if str_Process_Child__Current__Mem_Info_WSET == str_Process_Child__Previous__Mem_Info_WSET:
                                           
                                        
                                            bool_Terminate_Check__Process_Has_Not_Changed_Memory_Usage = True

                                            obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Possible MEMORY ZOMBIE! Process Memory usage has not changed.')
                                            #obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev Mem Info RSS: ' + str_Process_Child__Previous__Mem_Info_RSS)
                                            #obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr Mem Info_RSS: ' + str_Process_Child__Current__Mem_Info_RSS)
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev Mem Info WSET: ' + str_Process_Child__Previous__Mem_Info_WSET)
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr Mem Info_WSET: ' + str_Process_Child__Current__Mem_Info_WSET)
                                            #obj_Log('Child Process: ' + str(odict_Process_Child__Previous[str_Process_Prefix + 'Process_PID']) + ' ; Prev Mem Info: ' + str_Process_Child__Previous__Mem_Info)
                                            #obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Curr Mem Info: ' + str_Process_Child__Current__Mem_Info)
                                    
                                        pass
                                     
                                        '''
                                        ZOMBIE Check 4 of 5 - The number of Zombie checks for the process has been exceeded:
                                        '''
                                        ''' Process flagged as a zombie. Update the zombie found counter '''
                                         
                                        if bool_Terminate_Check__Process_Has_Not_Changed_IO_Usage and bool_Terminate_Check__Process_Has_Not_Changed_Memory_Usage:
                                             
                                            odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Count'] += 1
                                            int_Process_Child__Current__Zombie_Found_Count = odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Count']
 
                                            obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Process has been found to be a zombie THIS TIME AROUND. Zombie count updated to: ' + str(int_Process_Child__Current__Zombie_Found_Count))
                                             
                                        pass
#                                     
#                                         ''' Check if the number of allowed checks has been exceeded. If so, flag the the process as a zombie for termination '''
#                                         int_Process_Zombie_Found_Count_Allowed = 100
#                                         if int_Process_Child__Current__Zombie_Found_Count > int_Process_Zombie_Found_Count_Allowed:
#                                             bool_Terminate_Check__Zombie_Check_Count_Exceeded = True
# 
#                                             obj_Log = self.obj_Log_Run_Display.info 
#                                             obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Process has been found to be a zombie: ' + str(int_Process_Child__Current__Zombie_Found_Count) + ' times out of checks:' + str(int_Process_Zombie_Found_Count_Allowed) +' ; TERMINATE IT')
#                                         pass

                                    
                                        '''
                                        ZOMBIE Check 5 of 5 - The number of SERIAL Zombie checks for the process has been exceeded:
                                        '''
                                        ''' Process flagged as a zombie. Update the zombie found counter '''
                                        
                                        if bool_Terminate_Check__Process_Has_Not_Changed_IO_Usage and bool_Terminate_Check__Process_Has_Not_Changed_Memory_Usage:
                                            
                                            if odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count'] > 0:
                                                ''' Process WAS a zombie at the last check so ADD to the counter '''
                                                odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count'] += 1
                                                int_Process_Child__Current__Zombie_Found_Serially_Count = odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count']
    
                                                obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info
                                                obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Process has been found to be a SERIAL ZOMBIE AGAIN. Serial Zombie count updated to: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count']))
                                            else:
                                                ''' Process was NOT a zombie at the last check so RESET the counter '''
                                                odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count'] = 1

                                                obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info
                                                obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Serial zombie count max: ' + str(self.objSSParametersLocal.int_Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed) + ' ; Process was A ZOMBIE THIS TIME AROUND, but not last time. Serial Zombie count reset to: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count']))

                                            pass
                                        else:
                                            ''' Process was NOT a zombie at the last check so RESET the counter '''
                                            odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count'] = 0

                                            obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Serial zombie count max: ' + str(self.objSSParametersLocal.int_Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed) + ' ; Process was NOT a zombie this time around. Serial Zombie count reset to: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count']))
                                        pass
                                    
                                        ''' Check if the number of allowed checks has been exceeded. If so, flag the the process as a zombie for termination '''
                                        #int_Process_Zombie_Found_Serially_Count_Allowed = 20
                                        int_Process_Zombie_Found_Serially_Count_Allowed = self.objSSParametersLocal.int_Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed
                                        if int_Process_Child__Current__Zombie_Found_Serially_Count > int_Process_Zombie_Found_Serially_Count_Allowed:
                                            
                                            bool_Terminate_Check__Zombie_Check_Serial_Count_Exceeded = True

                                            obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Process has been found to be a SERIAL ZOMBIE: ' + str(int_Process_Child__Current__Zombie_Found_Serially_Count) + ' times out of checks:' + str(int_Process_Zombie_Found_Serially_Count_Allowed) +' ; TERMINATE IT')
                                        pass
                                                                        
                                        '''
                                        POST CHECK - Update PREVIOUS from CURRENT process history - ODICT item PREVIOUS is the master copy that get updated
                                        '''
                                   
                                        odict_Process_Child__Previous[str_Process_Prefix + 'Process_Zombie_Found_Count'] = odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Count']
                                        odict_Process_Child__Previous[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count'] = odict_Process_Child__Current[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count']
                                        odict_Process_Child__Previous[str_Process_Prefix + 'Process_Check_Count'] = odict_Process_Child__Current[str_Process_Prefix + 'Process_Check_Count']
                                        odict_Process_Child__Previous[str_Process_Prefix + 'Process_Last_Status_Check'] = odict_Process_Child__Current[str_Process_Prefix + 'Process_Last_Status_Check']
                                        odict_Process_Child__Previous[str_Process_Prefix + 'Process_Last_IO_Check'] = odict_Process_Child__Current[str_Process_Prefix + 'Process_Last_IO_Check']
                                        odict_Process_Child__Previous[str_Process_Prefix + 'Process_Last_Memory_Check'] = odict_Process_Child__Current[str_Process_Prefix + 'Process_Last_Memory_Check']
                                        
                                        '''
                                        Check if the Zombie Termination Check have been reached
                                        if so, TERMINATE THE PROCESS
                                        '''
                                        if bool_Terminate_Check__Process_Running_Too_Long or bool_Terminate_Check__Zombie_Check_Serial_Count_Exceeded: #or bool_Terminate_Check__Zombie_Check_Count_Exceeded:
                                            '''
                                            Zombie Termination Checks find that this process is a zombie
                                            Terminate it.
                                            We dont remove terminated processes from the process dictionary or list, but allow that to happen automatically at the next check.
                                            '''
                                            
                                            obj_Log = self.obj_Log_Run_Display.info 
                                            obj_Log('Child Process: ' + str(odict_Process_Child__Current[str_Process_Prefix + 'Process_PID']) + ' ; Termination check find this process is a ZOMBIE ; TERMINATE IT!')
 
                                            list_Process_Parent__Cmdline = odict_Process['Process_Cmdline']
                                            bool_Success = self.func_Terminate_Ne2_And_Prep_For_Rerun(odict_Process_Child__Current, str_Process_Prefix, int_Process_Parent__PID, list_Process_Parent__Cmdline)
                                         
                                        pass
                                    
                                    pass
                                else:
                                    '''
                                    Process has probably finshed.
                                    
                                    The OS recycles IO.
                                    Remove PIDs of finshed processes from the process history.
                                    We dont remove terminated processes from the process dictionary or list, but allow that to happen automatically at the next check.
                                    '''

                                    if not process_Process.is_running():
                                        
                                        del  odict_Process_History[int_Process_Parent__PID]
                                    
                                        #DEBUG_ON
                                        #obj_Log = self.obj_Log_Debug_Display.debug 
                                        #obj_Log('ODICT Process: ' + str(int_Process_Parent__PID) + ' NOT RUNNING so deleted from ODICT')
                                        #DEBUG_OFF
                                    pass
                                pass
                            else:
                                '''
                                ERROR:
                                More than one child process found but only one expected
                                '''
                                
                                '''
                                Wait for a while to ensure that this process doesnt complete and dissappear.
                                E.g. When a process fails Win OS creates a WER FAULT Child process to report the error.
                                But this finishes quicly an the process ends in error but gracefully.
                                We want to ignore those instances so we wait
                                '''
                            
                                bool_Error = False
                                int_Sleep_Timeout = 3 
                                int_Repeats = 20 #20 x 3 = 60 secs 
                                
                                for int_Repeat in range(int_Repeats):

                                    #DEBUG_ON
                                    obj_Log = self.obj_Log_Debug_Display.debug 
                                    obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' ; Number of children processes check: ' + str(int_Repeat) + ' of ' + str(int_Repeats) + ' ; each with a sleep timeout of:' + str(int_Sleep_Timeout))
                                    #DEBUG_OFF 
                                                                        
                                    ''' Set the error flag to False for each repeat '''
                                    bool_Error = False
                                    
                                    ''' Sleep to allow processes to finish '''
                                    time__sleep(int_Sleep_Timeout)

                                    '''
                                    Get the children of the parent process
                                    '''
                                    try:
                                        process_Process_Children = []
                                        
                                        if process_Process.is_running():
                                            process_Process_Children = process_Process.children(recursive=True)
                                        else:
                                            #bool_Error = False
                                            ''' Process has probably finished '''
                                            #DEBUG_ON
                                            obj_Log = self.obj_Log_Debug_Display.debug 
                                            obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' Process no longer running. ; bool_Error: ' + str(bool_Error))
                                            #DEBUG_OFF                                        
                                            break
                                        pass                                            
                                    except psutil.NoSuchProcess, psutil.AccessDenied:
                                        ''' Process has probably finished '''
                                        #DEBUG_ON
                                        obj_Log = self.obj_Log_Debug_Display.debug 
                                        obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' psutil.NoSuchProcess, psutil.AccessDenied. Process finished? ; bool_Error: ' + str(bool_Error))
                                        #DEBUG_OFF                                        
                                        pass
                                    except OSError, exception_Exception:
                                        if sys.platform.startswith('win'):
                                            if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                                ''' Process has probably finished '''
                                                #DEBUG_ON
                                                obj_Log = self.obj_Log_Debug_Display.debug 
                                                obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' exception_Exception.winerror == 299. Process finished? ; bool_Error: ' + str(bool_Error))
                                                #DEBUG_OFF                                        
                                            pass
                                        pass
                                    except Exception as exceptn:
                                        #DEBUG_ON
                                        obj_Log = self.obj_Log_Debug_Display.debug 
                                        obj_Log("UNCAUGHT EXCEPTION 1: Getting number of children from parent process. EXCEPTION - %s"%str(type(exceptn)))
                                        #DEBUG_OFF                                      
                                    pass
                                                                    
                                    '''
                                    Check if there are still more than one children - If so report them
                                    '''
                                    if len(process_Process_Children) > 1:
                                        #DEBUG_ON
                                        obj_Log = self.obj_Log_Debug_Display.debug 
                                        obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' ; Process has x children: ' + str(len(process_Process_Children)))
                                        #DEBUG_OFF                                          
                                        ''' If all child processes have finished its not an error '''
                                        for process_Process_Child in process_Process_Children:
                                            if process_Process_Child.is_running():
                                                bool_Error = True
                                                #DEBUG_ON
                                                obj_Log = self.obj_Log_Debug_Display.debug 
                                                obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' ; Process child still running ; bool_Error: ' + str(bool_Error))
                                                try:
                                                    str_Message_Text = 'Parent Process: ' + str(int_Process_Parent__PID) + ' ; Child Process still running: ' + '\n'
                                                    str_Message_Text = 'PID: ' + str(process_Process_Child.pid if process_Process_Child.is_running() else 'process finished') + '\n'
                                                    str_Message_Text += 'Name: ' + str(process_Process_Child.name() if process_Process_Child.is_running() else 'process finished') + '\n'
                                                    str_Message_Text += 'EXE Path: ' + str(process_Process_Child.exe() if process_Process_Child.is_running() else 'process finished') + '\n'
                                                    pass
                                                except psutil.NoSuchProcess, psutil.AccessDenied:
                                                    ''' Process has probably finished '''
                                                    str_Message_Text += 'psutil.NoSuchProcess, psutil.AccessDenied. process finished?' + '\n'
                                                    obj_Log(str_Message_Text)
                                                    pass
                                                except OSError, exception_Exception:
                                                    if sys.platform.startswith('win'):
                                                        if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                                            ''' Process has probably finished '''
                                                            str_Message_Text += 'exception_Exception.winerror == 299. process finished?' + '\n'
                                                            obj_Log(str_Message_Text)
                                                        pass
                                                    pass 
                                                except Exception as exceptn:
                                                    #DEBUG_ON
                                                    obj_Log = self.obj_Log_Debug_Display.debug 
                                                    obj_Log("UNCAUGHT EXCEPTION 2: Getting child process information. EXCEPTION - %s"%str(type(exceptn)))
                                                    #DEBUG_OFF                           
                                                    #break         
                                                pass                                   
                                                obj_Log(str_Message_Text)
                                                #DEBUG_OFF                                                
                                            pass
                                            
#                                             if len(process_Process_Children) > 1:
#                                                 #DEBUG_ON
#                                                 obj_Log = self.obj_Log_Debug_Display.debug 
#                                                 obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' ; Still more than 1 child running ; bool_Error: ' + str(bool_Error))
#                                                 #DEBUG_OFF                                        
#                                                 pass
#                                             else:
#                                                 bool_Error = False
#                                                 #DEBUG_ON
#                                                 obj_Log = self.obj_Log_Debug_Display.debug 
#                                                 obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' ; Now only 1 child running ; bool_Error: ' + str(bool_Error))
#                                                 #DEBUG_OFF                                        
#                                                 break
#                                             pass
                                        pass
#                                         ''' If no children are running then they have finished, there is no error, and we can stop checking '''
#                                         if not bool_Error:
#                                             #DEBUG_ON
#                                             obj_Log = self.obj_Log_Debug_Display.debug 
#                                             obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' ; No children are running ; bool_Error: ' + str(bool_Error))
#                                             #DEBUG_OFF                                                
#                                             break
#                                         pass                                    
                                    else:
                                        ''' If only one child is running, there is no error, and we can stop checking '''
                                        bool_Error = False
                                        #DEBUG_ON
                                        obj_Log = self.obj_Log_Debug_Display.debug 
                                        obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' ; Only 1 child running ; bool_Error: ' + str(bool_Error))
                                        #DEBUG_OFF                                        
                                        break
                                    pass
                                pass
                                
                                '''
                                Weve checked heap of times and there are still an unexpected number of children - report the error
                                '''
                                if bool_Error:
                                    #DEBUG_ON
                                    obj_Log = self.obj_Log_Debug_Display.debug 
                                    obj_Log('Parent Process: ' + str(int_Process_Parent__PID) + ' ; found to have too many children ; bool_Error: ' + str(bool_Error))
                                    #DEBUG_OFF                                    
                                    with SSErrorOperation([]) as obj_SSErrorOp:
                                    
                                        str_Message_Text = 'More than one child process found but only one expected. #Children: ' + str(len(process_Process_Children)) + '\n'
                                        
                                        for process_Process_Child in process_Process_Children:
                                            try:
                                                str_Message_Text += 'PID: ' + str(process_Process_Child.pid if process_Process_Child.is_running() else 'process finished') + '\n'
                                                str_Message_Text += 'Name: ' + str(process_Process_Child.name() if process_Process_Child.is_running() else 'process finished') + '\n'
                                                str_Message_Text += 'EXE Path: ' + str(process_Process_Child.exe() if process_Process_Child.is_running() else 'process finished') + '\n'
                                                pass
                                            except psutil.NoSuchProcess, psutil.AccessDenied:
                                                ''' Process has probably finished '''
                                                str_Message_Text += 'process finished' + '\n'
                                                pass
                                            except OSError, exception_Exception:
                                                if sys.platform.startswith('win'):
                                                    if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                                        ''' Process has probably finished '''
                                                        str_Message_Text += 'process finished' + '\n'
                                                    pass
                                                pass 
                                            except Exception as exceptn:
                                                #DEBUG_ON
                                                obj_Log = self.obj_Log_Debug_Display.debug 
                                                obj_Log("EXCEPTION TYPE - %s"%str(type(exceptn)))
                                                #DEBUG_OFF                                    
                                            pass                                   
                                        pass
                                        int_Stack_Trace_Level = 2
                                        obj_SSErrorOp.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text, tup_Args = (self.objSSParametersLocal.str_App_Arg_Output_Base_Path, self.objSSParametersLocal.strUniqueRunID))  
                                    pass
                                pass                            
                            pass
                        else:
                            ''' Process has no children.  Probably finished '''
                            pass
                        pass
                    else:
                        '''
                        Process is finished.
                        Remove it from the list of running processes.
                        We dont remove terminated processes from the process dictionary or list, but allow that to happen automatically at the next check.
                        '''
                        #DEBUG_ON
                        #obj_Log = self.obj_Log_Debug_Display.debug 
                        #obj_Log.info('Process: ' + str(process_Process.pid) + ' ; Status: COMPLETE')
                        #DEBUG_OFF

                        del  odict_Process_History[int_Process_Parent__PID] 
                                               
                        pass
                    pass
                pass  
            
                return odict_Process_History

            def func_External_Process__Add_Details_To_ODict(self, process_Process, str_Process_Prefix):
                
                odict_Process = None
                
                ''' Check if still running '''
                if process_Process.is_running():

                    odict_Process = OrderedDict()
                    
                    ''' Put the process details into a dict '''
                    
                    try:
                        ''' Get the PID of the process '''
                        int_Process__Current__PID = str(process_Process.pid if process_Process.is_running() else 0)
                        ''' Get the Name of the process ''' 
                        str_Process__Current__Name = str(process_Process.name() if process_Process.is_running() else 'process finished' )
                        ''' Get the EXE path of the process ''' 
                        str_Process__Current__EXE_Path = str(process_Process.exe() if process_Process.is_running() else 'process finished' )
                        ''' Get the Status of the process '''
                        str_Process__Current__Status = str(process_Process.status() if process_Process.is_running() else 'process finished')
                        ''' Get the Memory history of the process '''
                        str_Process__Current__Mem_Info = str(process_Process.memory_info() if process_Process.is_running() else 'process finished' )
                        ''' Get the IO history of the process '''
                        str_Process__Current__IO_Counters = str(process_Process.io_counters() if process_Process.is_running() else 'process finished' )
                        ''' Set the Zombie Counter to Zero '''
                        int_Process__Current__Zombie_Check_Count = 0
                        ''' Set the SERIAL Zombie Counter to Zero '''
                        int_Process__Current__Zombie_Check_Serial_Count = 0                        
                        ''' Set the Check Counter to Zero '''
                        int_Process__Current__Check_Count = 0
                        ''' Get the Last Check Time of the process '''
                        datetime_Process__Current__Last_Time_Check = datetime.now()
                        
                    except psutil.NoSuchProcess, psutil.AccessDenied:
                        ''' process has finished '''
                        odict_Process = None
                    except OSError, exception_Exception:
                        if sys.platform.startswith('win'):
                            if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                ''' Process has probably finished '''
                                odict_Process = None
                            pass
                        pass
                    finally:
                        odict_Process = OrderedDict([(str_Process_Prefix + 'Process_PID', int_Process__Current__PID)
                                                     , (str_Process_Prefix + 'Process_Object', process_Process)
                                                     , (str_Process_Prefix + 'Process_Name', str_Process__Current__Name)
                                                     , (str_Process_Prefix + 'Process_EXE_Path', str_Process__Current__EXE_Path)
                                                     , (str_Process_Prefix + 'Process_Last_Status_Check', str_Process__Current__Status)
                                                     , (str_Process_Prefix + 'Process_Last_Memory_Check', str_Process__Current__Mem_Info)
                                                     , (str_Process_Prefix + 'Process_Last_IO_Check', str_Process__Current__IO_Counters)
                                                     , (str_Process_Prefix + 'Process_Zombie_Found_Count', int_Process__Current__Zombie_Check_Count)
                                                     , (str_Process_Prefix + 'Process_Zombie_Found_Serially_Count', int_Process__Current__Zombie_Check_Serial_Count)
                                                     , (str_Process_Prefix + 'Process_Check_Count', int_Process__Current__Check_Count)
                                                     , (str_Process_Prefix + 'Process_Start_Time', datetime_Process__Current__Last_Time_Check)])                                    
                    pass
                
                    #DEBUG_ON
                    obj_Log = self.obj_Log_Debug_Display.debug #self.obj_Log_Run_Display.info 
                    obj_Log(str_Process_Prefix + 'Process_PID: ' + str(odict_Process[str_Process_Prefix + 'Process_PID']) + ' ; ODICT Process CREATED.')
                    obj_Log(str_Process_Prefix + 'Process_Object: ' + str(odict_Process[str_Process_Prefix + 'Process_Object']))
                    obj_Log(str_Process_Prefix + 'Process_Name: ' + str(odict_Process[str_Process_Prefix + 'Process_Name']))
                    obj_Log(str_Process_Prefix + 'Process_EXE_Path: ' + str(odict_Process[str_Process_Prefix + 'Process_EXE_Path']))
                    obj_Log(str_Process_Prefix + 'Process_Last_Status_Check: ' + str(odict_Process[str_Process_Prefix + 'Process_Last_Status_Check']))
                    obj_Log(str_Process_Prefix + 'Process_Last_Memory_Check: ' + str(odict_Process[str_Process_Prefix + 'Process_Last_Memory_Check']))
                    obj_Log(str_Process_Prefix + 'Process_Last_IO_Check: ' + str(odict_Process[str_Process_Prefix + 'Process_Last_IO_Check']))
                    obj_Log(str_Process_Prefix + 'Process_Zombie_Found_Count: ' + str(odict_Process[str_Process_Prefix + 'Process_Zombie_Found_Count']))
                    obj_Log(str_Process_Prefix + 'Process_Zombie_Found_Serially_Count: ' + str(odict_Process[str_Process_Prefix + 'Process_Zombie_Found_Serially_Count']))
                    obj_Log(str_Process_Prefix + 'Process_Check_Count: ' + str(odict_Process[str_Process_Prefix + 'Process_Check_Count']))
                    obj_Log(str_Process_Prefix + 'Process_Start_Time: ' + str(odict_Process[str_Process_Prefix + 'Process_Start_Time']))
                    #DEBUG_OFF
                else:
                    odict_Process = None
                pass
            
                return odict_Process
                
            def func_Terminate_Ne2_And_Prep_For_Rerun(self, odict_Process, str_Process_Prefix, int_Process_Parent__PID = 0, list_Process_Parent__Cmdline = None):
                
                bool_Success = False
                
                '''
                For NeOGen we start the child Ne2 process from a DOS batch script .
                That script will create a .FAILED file when the Ne2 child process is termintated, and thus will be rerun later on
                '''
                
                #DEBUG_ON
                obj_Log = self.obj_Log_Debug_Display.debug
                obj_Log('odict_Process: ' + str(odict_Process))
                obj_Log('str_Process_Prefix: ' + str_Process_Prefix)
                obj_Log('Parent PID: ' + str(int_Process_Parent__PID))
                obj_Log('Parent Cmd Line: ' + str(list_Process_Parent__Cmdline))
                obj_Log('Child PID: ' + str(odict_Process[str_Process_Prefix + 'Process_PID']))
                obj_Log('Child Name: ' + str(odict_Process[str_Process_Prefix + 'Process_Name']))
                obj_Log('Child EXE Path: ' + str(odict_Process[str_Process_Prefix + 'Process_EXE_Path']))
                #DEBUG_OFF
                
                ''' Terminate process '''
                def on_terminate(process):
                    obj_Log = self.obj_Log_Debug_Display.debug
                    obj_Log('Process TERMINATED: ' + str(odict_Process[str_Process_Prefix + 'Process_PID']) + ' ; Exit Code: ' + str(process.returncode))
                    pass
                
                process_Process = odict_Process[str_Process_Prefix + 'Process_Object']      
                list_Processes = [process_Process]
                 
                try:
                    for process in list_Processes:
                        process.terminate()
                        bool_Success = True
                    pass
                 
                    gone, alive = psutil.wait_procs(list_Processes, timeout=3, callback=on_terminate)
                     
                    for process in alive:
                        process.kill()
                        bool_Success = True
                    pass
                except psutil.NoSuchProcess, psutil.AccessDenied:
                    ''' Process has probably finished '''
                    bool_Success = True
                    pass
                except OSError, exception_Exception:
                    if sys.platform.startswith('win'):
                        if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                            ''' Process has probably finished '''
                            bool_Success = True
                            pass
                        pass
                    pass
                pass
             
                time__sleep(3)
                                                 
                '''
                Write .FAILED file to path so that rerun occurs
                '''
                bool_Success = False
                
                #DEBUG_ON
                #obj_Log = self.obj_Log_Debug_Display.debug 
                #obj_Log('Process Process_Cmdline: ' + str(list_Process_Parent__Cmdline[2]))
                #DEBUG_OFF
                 
                str_CMD_Line = list_Process_Parent__Cmdline[2]
                str_CMD_Path, str_CMD_EXE = os__path.split(str_CMD_Line)
                str_CMD_EXE_Name, str_CMD_EXE_Extension = os__path.splitext(str_CMD_EXE)
                 
                with FileHandler() as obj_File_Op:
                    str_Path__FAILED = str_CMD_Path
                    str_Path_And_File__FAILED = os__path.join(str_Path__FAILED, str_CMD_EXE_Name + '.FAILED')
                      
                    handle_File = obj_File_Op.fileOpen(str_Path_And_File__FAILED, 'write')
                    bool_Success = obj_File_Op.fileClose(handle_File)
                      
                    if bool_Success:
                        obj_Log = self.obj_Log_Debug_Display.debug
                        obj_Log('Created .FAILED file: ' + str_Path_And_File__FAILED)
                    else:
                        with SSErrorOperation([]) as obj_SSErrorOp:
                            str_Message_Text = 'Could NOT create .FAILED file :'  + str_Path_And_File__FAILED
                            int_Stack_Trace_Level = 2
                            obj_SSErrorOp.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text, tup_Args = (self.objSSParametersLocal.str_App_Arg_Output_Base_Path, self.objSSParametersLocal.strUniqueRunID))  
                        pass
                    pass
                      
                    ''' Delete any .COMPLETE files '''
                    bool_Files_Located = False
                    str_File_Search_Pattern = '*.COMPLETE'
                      
                    bool_Files_Located, list_Path_And_Files = obj_File_Op.func_Locate_Files(str_Path__FAILED, str_File_Search_Pattern, bool_Print_Search_Result = False, bool_Search_Sub_Folders = False)
                      
                    if bool_Files_Located:
                        for str_Path_And_File__COMPLETE in list_Path_And_Files:
                              
                            bool_Success = False
                            bool_Success = obj_File_Op.fileDelete(str_Path_And_File__COMPLETE)
                              
                            if not bool_Success:
                                with SSErrorOperation([]) as obj_SSErrorOp:
                                    str_Message_Text = 'Could NOT delete .COMPLETE file :'  + str_Path_And_File__COMPLETE
                                    int_Stack_Trace_Level = 2
                                    obj_SSErrorOp.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text, tup_Args = (self.objSSParametersLocal.str_App_Arg_Output_Base_Path, self.objSSParametersLocal.strUniqueRunID))  
                                pass
                            pass
                        pass
                    else:
                        obj_Log = self.obj_Log_Debug_Display.debug
                        obj_Log('No .COMPLETE files located: ' + str_Path__FAILED)
                        bool_Success = True
                    pass
                pass
            
                return bool_Success
                
            def method_Saved_Pop_SubSample_Ne2Bulk_Rerunning_of_FAILED_Ne2(self, str_Search_Path):

                '''
                -------------------------------
                Find the folders the have .FAILED files and re-run the process untill all are successful
                -------------------------------
                '''                
                ''' Repeat for x tries or until no .FAILED files are found
                
                FIX_REQUIRED: Put the retries value into the Batch Setting file. Temoprarily increased the retries to 100 from 5.
                
                When LDNe is hard to evaluate i.e. with empirical genetics.
                Many retries are required for all LDNe to COMPLETE and if the retries are too few  .FAILED files are not cleared
                and the Bulk Ne estimate files e.g. Ne2_common_V3_PC2xLD.txt do not have the required number of estimates leading to "out of index" error.
                
                Such as:
                2017-12-08 12:47:02,618 log_Default_Display INFO   SSResultsHandler : Processing file: R:\WORK\NOG\v1_3_0_6_a1\test\usr\var\backend\work\BS_20171208100023\SS_20171208100024\NG_1_3_0_6_a1_Run_2017_12_08_12_23_27\sst\S_STRAT_1_1_UAC\A01\SM_1568\Ne2_common_V3_PC2xLD.txt

                ---------------------------------------------- NeOGen 1.3.0.6.a1 Command Line ----------------------------------------------
                >>>> End program.
                ----------------------------------------------------------------------------------------------------------------------------
                Traceback (most recent call last):
                  File "NeOGen.py", line 855, in <module>
                  File "NeOGen.py", line 821, in func_Main
                  File "SSRunHandler.pyo", line 461, in func_Run_Start
                  File "SSRunHandler.pyo", line 473, in method_Run_Initiation
                  File "SSRunHandler.pyo", line 611, in method_Run_Processing
                  File "SSBatchHandler.pyo", line 126, in method_Batch_Processing
                  File "SSReplicateHandler.pyo", line 532, in method_Replicate_Processing
                  File "SSResultsHandler.pyo", line 4330, in func_EXPERIMENT_Parent_Offspring_Ne_2__Ne2_PS_PF_Results__Aggregate_Results
                  File "SSResultsHandler.pyo", line 4397, in func__EXPERIMENT_Parent_Offspring_Ne_2__Ne2_PS_PF_Results__Aggregate__Process
                  File "SSResultsHandler.pyo", line 4497, in func__EXPERIMENT_Parent_Offspring_Ne_2__Ne2_PS_PF_Results__Aggregate_Input_File_To_Dataframe
                  File "pandas\core\series.pyo", line 583, in __getitem__
                  File "pandas\indexes\base.pyo", line 1986, in get_value
                  File "pandas\tslib.pyx", line 777, in pandas.tslib.get_value_box (pandas\tslib.c:17017)
                  File "pandas\tslib.pyx", line 793, in pandas.tslib.get_value_box (pandas\tslib.c:16774)
                IndexError: index out of bounds
                
                R:\WORK\NOG\v1_3_0_6_a1\test\usr\var\backend\work\BS_20171208100023>pause
                
                '''
                int_Repeats = self.objSSParametersLocal.int_Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count
                int_Repeats_Total = int_Repeats
                
                while True:
                
                    odict_Process_History = OrderedDict()
                    
                    #DEBUG_ON
                    obj_Log = self.obj_Log_Debug_Display.debug
                    obj_Log('Rerun repeat: ' + str(int_Repeats_Total - int_Repeats) + ' of ' + str(int_Repeats_Total))
                    #DEBUG_OFF
                    
                    ''' Search for files with a .FAILED extension '''
                    str_File_Search_Pattern = '*' + globalsSS.Shared_External_Resources.static_Win_DOS_Batch_Program__Ne2Bulk_ReRun_Failed__FAILED_Process_File_Flag_Extension
                    
                    '''
                    Find each .FAILED file
                    '''
                    self.obj_Log_Debug_Display.debug('Finding Ne2 failed processes by search pattern: ' + str_File_Search_Pattern + ' in search path: ' + str_Search_Path) 
            
                    bool_File_Located = False
                    with FileHandler() as obj_FileOp:
                        bool_File_Located, list_Path_And_Files = obj_FileOp.func_Locate_Files(str_Search_Path, str_File_Search_Pattern)
                    pass
                
                    if bool_File_Located:
                        
                        '''Process each file in turn'''
                        for str_Path_And_File__FAILED_file in list_Path_And_Files:
                            
                            strFilePath_Of_Failed_Process, strFileName = obj_FileOp.method_Separate_Path_And_FileName_From_PathAndFileName(str_Path_And_File__FAILED_file)
                            ''' Get the Ne2 process tha failed from the failed filename '''
                            str_Ne2Bulk_Batch_Process_FileName, str_File_Extension = os.path.splitext(str_Path_And_File__FAILED_file)
                            str_Path, str_Ne2Bulk_Batch_Process_FileName = ntpath.split(str_Ne2Bulk_Batch_Process_FileName)
                            
                            obj_Log = self.obj_Log_Debug_Display.info
                            obj_Log('Processing .FAILED File: ' + str_Path_And_File__FAILED_file)
                                                        
                            str_Ne2Bulk_Batch_Process_To_ReRun = str_Ne2Bulk_Batch_Process_FileName.split('Ne2_common_V3_Bulk_Run_', 1)[1].upper()

                            obj_Log = self.obj_Log_Debug_Display.info
                            obj_Log('str_Ne2Bulk_Batch_Process_To_ReRun: ' + str_Ne2Bulk_Batch_Process_To_ReRun)
                            
                            '''
                            Subfolder and files have been created
                            NO NEED to Pre-process before executing Ne2Bulk
                            '''
                                 
                            boolPrepNe2Bulk = False
                            if boolPrepNe2Bulk:
                             
                                #Put executable files in place
                                self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_Of_Failed_Process)
                            pass
                             
                            boolExecuteNe2Bulk = True
                            if boolExecuteNe2Bulk:
                        
                                self.obj_Log_Debug_Display.debug('Spawning External Ne2Bulk Process')
                        
                                #Execute external program
                                bool_Prevent_External_Function_Console_Output = True
                                strProcessFilePattern =  globalsSS.Genepop_Results_File_Details.static_Genepop_File_Name__PF_Pop_SubSample
                                strFilePath_Working = strFilePath_Of_Failed_Process
                                
                                strPCritToProcess =  str_Ne2Bulk_Batch_Process_To_ReRun
                                process_Process, int_Process_PID = self.method_Execute_External_Program_Ne2Bulk(strPCritToProcess, strProcessFilePattern, strFilePath_Working, bool_Prevent_External_Function_Console_Output)

                                ''' Display so that user can see progress is occuring '''
                                obj_Log = self.obj_Log_Run_Display.info
                                obj_Log('External process executed: ' + str(int_Process_PID))
                                                        
                                ''' Wait to see if process finishes rapidly '''
                                int_Tries = 12
                                for int_Try in range(int_Tries):
                                    try:
                                        #DEBUG_ON
                                        #obj_Log = self.obj_Log_Debugun_Display.debug
                                        #obj_Log('Try: ' + str(int_Try) + ' of ' + str(int_Tries))
                                        #DEUG_OFF                                                
                                        bool_Running = process_Process.is_running()
                                        if bool_Running:
                                            time__sleep(.25)
                                        else:
                                            break
                                        pass
                                    except psutil.NoSuchProcess, psutil.AccessDenied:
                                        ''' Process has probably finished '''
                                        bool_Running = False
                                        break
                                        pass                                            
                                    except OSError, exception_Exception:
                                        if sys.platform.startswith('win'):
                                            if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                                ''' Process has probably finished '''
                                                bool_Running = False
                                                break
                                            pass
                                        pass
                                    pass                                            
                                pass
                            
                                if bool_Running:
                                    '''If still going, get the process details '''
                                    try:
                                        odict_Process = OrderedDict([('Process_PID', process_Process.pid), ('Process_Object', process_Process), ('Process_Cmdline', process_Process.cmdline()), ('Child_Process_Odict', None)])
                                        odict_Process_History[process_Process.pid] = odict_Process
                                    except psutil.NoSuchProcess, psutil.AccessDenied:
                                        ''' Process has probably finished '''
                                        pass
                                    except OSError, exception_Exception:
                                        if sys.platform.startswith('win'):
                                            if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                                ''' Process has probably finished '''
                                            pass
                                        pass
                                    pass
                                pass
                            
                                #DEBUG_ON
                                #self.obj_Log_Run_Display.info('External Processes started: ' + str(len(odict_Process_History)))
                                #DEBUG_OFF
                                
                                bool_Restrict_Number_Of_Processes_Running = True
                                if bool_Restrict_Number_Of_Processes_Running:
                                    ''' Keep checking if allowed number of processes ar still running '''
                                    #int_Processes_Allowed = 20
                                    int_Processes_Allowed = self.objSSParametersLocal.int_Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed
                                    int_Processes_Still_Running = len(odict_Process_History)
                                    while int_Processes_Still_Running >= int_Processes_Allowed:

                                        odict_Process_History = self.func_Check_List_Of_Subprocess_Running_Status_And_Terminate_Zombie_Processes(odict_Process_History)

                                        int_Processes_Still_Running = len(odict_Process_History)
                                        self.obj_Log_Run_Display.info('Waiting on processes to finish...Process Allowed: ' + str(int_Processes_Allowed) + ' ; Still Running Processes: ' + str(int_Processes_Still_Running) + ' ; (PIDs: ' + str([int_PID for int_PID in odict_Process_History.keys()]) + ')...')
                                        time__sleep(3)
                                    pass                                       
                                pass
                            pass
                        pass
                
                        ''' Keep checking if last spawned process is still running '''

                        bool_Process_Still_Running = True
                        while bool_Process_Still_Running:

                            odict_Process_History = self.func_Check_List_Of_Subprocess_Running_Status_And_Terminate_Zombie_Processes(odict_Process_History)

                            if len(odict_Process_History) == 0:
                                bool_Process_Still_Running = False
                            else:
                                self.obj_Log_Run_Display.info('Waiting on...External Processes (n = ' + str(len(odict_Process_History)) + ') still running (PIDs: ' + str([int_PID for int_PID in odict_Process_History.keys()]) + ')...')
                            pass
                            time__sleep(3)
                        pass
                    else:
                        '''No more .FAILED files found '''
                        break
                    pass
                
                    '''Check if the max number of repeats has been executed '''
                    int_Repeats -= 1
                    
                    if int_Repeats <= 0:
                        break
                    pass                    
                pass
            
                return True
 
 
            '''
            -----------------------------------
            Repetative Ne2PCRIT estimates
            -----------------------------------
            '''

            def method_Repetative_Ne2_LDNe_PCRIT_Sampling_EXPERIMENT_1(self, strFilePath_Import, strFileName_Import):

                dict_Results = OrderedDict()
                
                ''' Get logger - Categorised Ne2 Stats '''
                bool_LogToConsole = False
                str_Logger_Path = self.objSSParametersLocal.str_Current_Run_Path__Logs
                str_Logger_Name = globalsSS.Logger_Results_File_Details.static_Logger_Name__Ne2_LDNe_Pcrit_Exp1
                str_Logger_FileName_Suffix = globalsSS.Logger_Results_File_Details.static_Logger_File_Suffix__Ne2_LDNe_Pcrit_Exp1
                strFileName_Experiment_Label = ''
                str_Experiment = ''
                self.obj_Logging__NE2_PCRIT_SAMP_1, self.obj_Results_Log__NE2_PCRIT_SAMP_1 = self.method_Get_Results_Logger(bool_LogToConsole, str_Logger_Path, str_Logger_Name, str_Logger_FileName_Suffix, strFileName_Experiment_Label, str_Experiment)


                '''
                --------------------------
                EXPERIMENT_1 - Define the experiment
                --------------------------
                '''

                list_Stats_Categories = ['Full']
                
                dict_SubSample_Replicates_By_Category = {
                                                         'Full':1
                                                         }

                float_Pcrit_Increment = 0.0001
                float_Pcrit_Min = 0
                float_Pcrit_Max = 0.2 + float_Pcrit_Increment 
#                 float_Pcrit_Increment = 0.0001
#                 float_Pcrit_Min = 0.0012
#                 float_Pcrit_Max = 0.1 + float_Pcrit_Increment 
                list_LDNe_PCrits_To_Get = []
                list_LDNe_PCrits_To_Get = numpy.arange(float_Pcrit_Min,float_Pcrit_Max,float_Pcrit_Increment).tolist()
                
                str_Experiment = 'LDNe_PCRIT_Sampling_1'
                str_Experiment_Path = self.objSSParametersLocal.outfilePath
                
                strFilename_Genepop = strFileName_Import
                                     
                for str_Stats_Category in list_Stats_Categories:
                    #if bool_Initialise_Stats:
                    if str_Stats_Category not in dict_Results:
                        dict_Results[str_Stats_Category] = OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Stats_Category)])
                    pass

                    dict_Results[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder,self.objSSParametersLocal.strRunSpecificUserDefinedFolder)]))
                    dict_Results[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_list_Stats_Categories,list_Stats_Categories)]))
                    dict_Results[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_SubSample_Replicates_By_Category,dict_SubSample_Replicates_By_Category[str_Stats_Category])]))
                    dict_Results[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get,list_LDNe_PCrits_To_Get)]))
                    dict_Results[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Experiment_Label,str_Experiment)]))

                    str_OutputResultsPath = str_Experiment_Path + 'Ne2' + '\\' + str_Experiment + '\\' + str_Stats_Category + '\\'
                    strFilePath_Working_Ne2 = strFilePath_Import
                    
                    dict_Results[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Emprical_Ne2_Processing.static_str_FilePath_Working_Ne2,strFilePath_Working_Ne2)]))
                    dict_Results[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Emprical_Ne2_Processing.static_str_Filename_Genepop,strFilename_Genepop)]))
                    dict_Results[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_Emprical_Ne2_Processing.static_str_OutputResultsPath,str_OutputResultsPath)]))                
                    
                    dict_Results[str_Stats_Category].update(OrderedDict([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category,str_Stats_Category)]))

                    pass
                pass

                '''
                --------------------------
                Get the stats
                --------------------------
                '''
                
                with SSSamplingTest() as obj_SSSampling:
                    obj_SSSampling.method_Initialise(self.objSSParametersLocal)
                    bool_Use_Simupop_LDNe = False
                    bool_Use_Ne2_LDNe = True
                    for str_SubSampling_Category in dict_Results.keys():
                        dict_Results = obj_SSSampling.method_Emprirical_Repetative_PCRIT_Sampling_Ne2_Results(str_SubSampling_Category, bool_Use_Simupop_LDNe, bool_Use_Ne2_LDNe, dict_Results)
                    pass


                '''
                --------------------------
                Flatten the dict for logging
                --------------------------
                '''
                dict_To_Flatten = dict_Results

                ''' First - determine how many levels down the nested dict goes '''

                with SSAnalysisHandler() as obj_SSAnalysis:
                    dict_Non_Dict_Key_Count_Per_Level = OrderedDict()
                    dict_Non_Dict_Key_Count_Per_Level = obj_SSAnalysis.method_Get_Nested_Dict__Non_Dict_Key_Count_Per_Nested_Level(dict_To_Flatten, 0, dict_Non_Dict_Key_Count_Per_Level)
                    #int_Lowest_Level = max(dict_Non_Dict_Key_Count_Per_Level, key=dict_Non_Dict_Key_Count_Per_Level.get) - 1
                    int_Lowest_Level = max(dict_Non_Dict_Key_Count_Per_Level.keys(), key=int) - 1
                
                ''' Second - Get the number fd dicts at that lowest level (-1)'''    
                int_Lowest_Level_Dict_Num_Keys = len(list_LDNe_PCrits_To_Get)
               
                ''' Third - Flattern the dict into a dcb multiline dict '''
                dict_To_Flatten = dict_Results
                dict_Final = OrderedDict()
                dict_MultiLine_Results = OrderedDict()
                int_Line_Initial = 0
                int_Line = 0
                int_Level = 0
                #int_Lowest_Level = 3
                #int_Lowest_Level_Dict_Num_Keys = 5
                
                with SSAnalysisHandler() as obj_SSAnalysis:
                    dict_MultiLine_Results = obj_SSAnalysis.method_Flatten_Nested_Dict_Into_Multiline_Dict__LDNe_Results(True, int_Line_Initial, int_Line, int_Level, int_Lowest_Level, int_Lowest_Level_Dict_Num_Keys, dict_To_Flatten, dict_Final)
                pass
                

                '''
                --------------------------
                Log the results
                --------------------------
                '''
                str_Results_1 = self.objSSParametersLocal.strUniqueRunID
                str_Heading_1 = globalsSS.Logger_Results_File_Details.static_Logger_Label_Gen_UniqueID
                str_Heading_Prefix_1 = globalsSS.Logger_Results_File_Details.static_Logger_Colname_Prefix__Ne2_LDNe_Pcrit_Exp1
                self.obj_Logging__NE2_PCRIT_SAMP_1.func_Log_MultiLine_Results_Header(self.obj_Results_Log__NE2_PCRIT_SAMP_1, str_Heading_1, str_Heading_Prefix_1, dict_MultiLine_Results)
                self.obj_Logging__NE2_PCRIT_SAMP_1.func_Log_MultiLine_Results_Detail(str_Results_1, self.obj_Results_Log__NE2_PCRIT_SAMP_1, dict_MultiLine_Results)
                
                ''' Clear the log handlers'''
                self.obj_Results_Log__NE2_PCRIT_SAMP_1.handlers = []
                
                return True

            
            def method_Emprirical_Repetative_PCRIT_Sampling_Ne2_Results(self, str_SubSampling_Category, bool_Use_Simupop_LDNe, bool_Use_Ne2_LDNe, dict_Results):
            
                str_Stats_Category = str_SubSampling_Category
                list_LDNe_PCrits_To_Get = dict_Results[str_Stats_Category]['list_LDNe_PCrits_To_Get']

                '''
                -------------
                Get Ne2 Results
                -------------
                '''            
                strFilePath_Working_Ne2 = dict_Results[str_Stats_Category][globalsSS.Colnames_Emprical_Ne2_Processing.static_str_FilePath_Working_Ne2]
                strFilename_Genepop = dict_Results[str_Stats_Category][globalsSS.Colnames_Emprical_Ne2_Processing.static_str_Filename_Genepop]
                str_OutputResultsPath = dict_Results[str_Stats_Category][globalsSS.Colnames_Emprical_Ne2_Processing.static_str_OutputResultsPath]
                
                dict_Results_By_PCrit = OrderedDict()
                
                for float_LDNe_PCrit in list_LDNe_PCrits_To_Get:
                    '''
                    -------------
                    Get Ne2 Results
                    -------------
                    '''
                    str_OutputResultsPath_Pcrit = str_OutputResultsPath + str(float_LDNe_PCrit)
                    with FileHandler() as obj_FileHandler:
                        boolPathCreated = obj_FileHandler.method_Create_Path(str_OutputResultsPath)
                    pass
                            
                    bool_Suppress_ALL_LDNe_Console_Output = True
                    strUniqueRunID = self.objSSParametersLocal.strUniqueRunID
                    intGenepopFileCount = 0
                    dict_Results_By_PCrit = self.method_Use_Ne2_Win_DLL_To_Produce_Estimates_From_Genepop_File(bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath_Pcrit, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit, dict_Results_By_PCrit)
                pass
                
                dict_Ne2_Results_By_PCrit_Copy = OrderedDict()
                for key_Outer, value_Dict in dict_Results_By_PCrit.iteritems():
                    if key_Outer in dict_Results[str_Stats_Category]:
                        dict_Ne2_Results_By_PCrit_Copy[key_Outer].update(OrderedDict([(key,valuelist) for key,valuelist in value_Dict.iteritems()]))
                    else:
                        dict_Ne2_Results_By_PCrit_Copy[key_Outer] = OrderedDict([(key,valuelist) for key,valuelist in value_Dict.iteritems()])
                    pass
                pass
            
                dict_Results[str_Stats_Category].update(OrderedDict([('dict_Ne2_Results_By_PCrit',dict_Ne2_Results_By_PCrit_Copy)]))

                return dict_Results            
                   
            '''
            -----------------------------------
            Population Ne2 Sub-sample stats
            -----------------------------------
            '''
            def method_Population_SubSample_Ne2_Results(self, pop_In, str_SubSampling_Category, bool_Use_Simupop_LDNe, bool_Use_Ne2_LDNe, dict_Results):
            
                str_SubSampling_Name_Prefix = str_SubSampling_Category
                str_Stats_Category = str_SubSampling_Category
 
                str_Experiment = dict_Results[str_Stats_Category]['Experiment_Label']
               
                int_Sim_Current_Batch = dict_Results[str_Stats_Category]['Sim_Current_Batch']
                int_Sim_Current_Replicate = dict_Results[str_Stats_Category]['Sim_Current_Replicate']

                str_Sim_Current_Batch = str(int_Sim_Current_Batch)
                str_Sim_Current_Batch_Out = str_Sim_Current_Batch.zfill(len(str_Sim_Current_Batch))
                
                str_Sim_Current_Replicate = str(int_Sim_Current_Replicate)
                str_Sim_Current_Replicate_Out = str_Sim_Current_Batch.zfill(len(str_Sim_Current_Replicate))
                
                str_SubSampling_Name_Suffix = 'b' + str_Sim_Current_Batch_Out + '_r' + str_Sim_Current_Replicate_Out
                
                str_SubSampling_Name = str_SubSampling_Name_Prefix + str_SubSampling_Name_Suffix
            
                intSubSample_Size = dict_Results[str_Stats_Category]['SubSample_Sizes_By_Category']
                int_Random_SubSamples = dict_Results[str_Stats_Category]['SubSample_Replicates_By_Category']
                tup_VSP_To_Sample = dict_Results[str_Stats_Category]['VSPs_To_SubSample_By_Category']
                listVSPsToRandomSample = [tup_VSP_To_Sample]
                
                list_LDNe_PCrits_To_Get = dict_Results[str_Stats_Category]['list_LDNe_PCrits_To_Get']

                dict_Pop_SubSample_LDNeStats = OrderedDict()
                
                for int_SubSample in range(1, int_Random_SubSamples+1):
                    #print('int_SubSample: ' + str(int_SubSample))
                    
                    bool_No_Strings = False
                    for item in listVSPsToRandomSample:
                        if isinstance(item, tuple):
                            bool_No_Strings = not isinstance(item[1], str)
                        elif not isinstance(item, str):
                            bool_No_Strings = True
                        pass
                    pass
                    if bool_No_Strings:
                        pop_SubSample = drawRandomSample(pop_In, sizes=intSubSample_Size, subPops=listVSPsToRandomSample)
                    else:
                        self.obj_Log_Default_Display.error('simupop.drawRandomSample cannot handle VSP Names only VSP numbers:' + str(listVSPsToRandomSample))
                        raise ValueError('simupop.drawRandomSample cannot handle VSP Names only VSP numbers:' + str(listVSPsToRandomSample))
                    pass
                
                    if bool_Use_Simupop_LDNe:
                        '''
                        -------------
                        Get simupop LDNe Results
                        -------------
                        '''    
                        simupop.stat(pop_SubSample, effectiveSize=simupop.ALL_AVAIL, vars=['Ne_LD'])
                        dict_Pop_SubSample_LDNeStats[int_SubSample] = pop_SubSample.dvars().Ne_LD
                        #print('dict_Pop_SubSample_Small_LDNeStats: ' + str(dict_Pop_SubSample_Small_LDNeStats))
                    if bool_Use_Ne2_LDNe:
                        '''
                        -------------
                        Get Ne2 Results
                        -------------
                        '''            
                        str_SubSample_Replicate = str(int_SubSample)
                        str_SubSample_Replicate_Out = str_SubSample_Replicate.zfill(len(str_SubSample_Replicate))
                        str_SubSampling_Name_Suffix = '_' + str_SubSampling_Name_Suffix
                        str_SubSampling_Name = str_SubSampling_Name_Prefix + str_SubSampling_Name_Suffix
                        str_Experiment_Path = self.objSSParametersLocal .outfilePath                   
                        str_Output_Path = str_Experiment_Path + 'Ne2Bulk' + '\\' + str_Experiment + '\\' + str_SubSampling_Name_Prefix + '\\'
                        str_GP_Output_FileName = 'genepop_SP_0_SLDNESR_' + str_SubSampling_Name + '_SR_' + str_SubSample_Replicate_Out + '.txt'
                        str_GP_Output_Path_And_File = str_Output_Path + str_GP_Output_FileName
                        intGenepopFileCount = int_SubSample
                        dict_Ne2_Results_By_PCrit = self.method_Get_Ne2_Results(pop_SubSample, self.objSSParametersLocal.strUniqueRunID, str_Output_Path, str_GP_Output_FileName, intGenepopFileCount, str_GP_Output_Path_And_File, list_LDNe_PCrits_To_Get)
                        #print('dict_Results_By_PCrit: ' + str(dict_Results_By_PCrit))
                        
                        #dict_Ne2_Results_By_PCrit_Copy = copy__deepcopy(dict_Ne2_Results_By_PCrit)
                        #dict_Results[str_Stats_Category].update({'dict_Ne2_Results_By_PCrit':dict_Ne2_Results_By_PCrit_Copy})
                        
                        dict_Ne2_Results_By_PCrit_Copy = OrderedDict()
                        for key_Outer, value_Dict in dict_Ne2_Results_By_PCrit.iteritems():
                            if key_Outer in dict_Results[str_Stats_Category]:
                                dict_Ne2_Results_By_PCrit_Copy[key_Outer].update(OrderedDict([(key,valuelist) for key,valuelist in value_Dict.iteritems()]))
                            else:
                                dict_Ne2_Results_By_PCrit_Copy[key_Outer] = OrderedDict([(key,valuelist) for key,valuelist in value_Dict.iteritems()])
                            pass
                        pass
                    
                        dict_Results[str_Stats_Category].update(OrderedDict([('dict_Ne2_Results_By_PCrit',dict_Ne2_Results_By_PCrit_Copy)]))

                    pass
                
                return dict_Results            

            def method_Get_Ne2_Results(self, pop_SubSample, strUniqueRunID, str_Output_Path, str_GP_Output_FileName, intGenepopFileCount, str_GP_Output_Path_And_File, list_LDNe_PCrits_To_Get):
                
                int_Len_str_GP_Output_Path_And_File = len(str_GP_Output_Path_And_File)
                int_MaxLength = 259
                if int_Len_str_GP_Output_Path_And_File > int_MaxLength:
                    print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
                    print('str_GP_Output_Path_And_File : ' + str_GP_Output_Path_And_File)
                    print('IS TOO LONG: ' + str(int_Len_str_GP_Output_Path_And_File))
                    print('BY: ' + str(int_Len_str_GP_Output_Path_And_File - int_MaxLength) + ' CHARACTERS')
                    print('File write will fail')
                    print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
                pass
                with FileHandler() as obj_FileHandler:
                    boolPathCreated = obj_FileHandler.method_Create_Path(str_Output_Path)
                pass
 
                strFilePathAndNameFull_Export = str_GP_Output_Path_And_File
                '''
                Create GENEPOP file
                IMPORTANT - Allele adjust means the difference between an allele and missing data
                if your data has zeros as missing data - set this to zero
                if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                '''
                intAlleleAdjust = 1
                bool_Prevent_Internal_Function_Console_Output = True
                bool_Prevent_External_Function_Console_Output = True
                
                boolSuccess = self.method_Export_Genotypes(pop_SubSample, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))
               
                #simuPOP__utils.export(pop_ToExport, format='GENEPOP', adjust=1, output=str_GP_Output_Path_And_File, gui=False)
                dict_Results_By_PCrit = OrderedDict()
                
                for float_LDNe_PCrit in list_LDNe_PCrits_To_Get:
                    '''
                    -------------
                    Get Ne2 Results
                    -------------
                    '''
                
                    strFilePath_Working_Ne2 = str_Output_Path
                    strFilename_Genepop = str_GP_Output_FileName
                    str_OutputResultsPath = str_Output_Path
                    #dict_Results = method_Get_Ne2_WinDLL_Results(strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit, dict_Results)
        
                    bool_Suppress_ALL_LDNe_Console_Output = True
                    
                    dict_Results_By_PCrit = self.method_Use_Ne2_Win_DLL_To_Produce_Estimates_From_Genepop_File(bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit, dict_Results_By_PCrit)
                pass
                
                return dict_Results_By_PCrit     
                   
            '''
            -----------------------------------
            GENEPOP stats
            -----------------------------------
            '''
            def method_Genepop_Statistics(self, str_Search_Path, str_File_Suffix_Search_Pattern):

                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass           
                        
                '''
                For all the genpop files in a given folder
                process each with biopython genpop and log the results to a single file
                '''

                dict_Results = OrderedDict()

                if self.objSSParametersLocal.bool_Overlapping_Gens_Simulation:
                    int_Sim_Pop_Size = self.objSSParametersLocal.popnSize
                else:
                    int_Sim_Pop_Size = self.objSSParametersLocal.popnSize / 2 #For Discrete gens only
                pass
      
                dict_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Unique_Run_ID] = self.objSSParametersLocal.strUniqueRunID 
                dict_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder] = self.objSSParametersLocal.strRunSpecificUserDefinedFolder

                str_Path_GP_Input = str_Search_Path

                boolSuccessful = False

                intCount = 0
                
                str_File_Search_Pattern = '*' + str_File_Suffix_Search_Pattern

                '''Locate all files in a search path with a search pattern'''
                bool_File_Located = False
                with FileHandler() as obj_FileHandler:
                    bool_File_Located, list_Path_And_Files = obj_FileHandler.func_Locate_Files(str_Search_Path, str_File_Search_Pattern)
               
                if bool_File_Located:
                    
                    '''Process All files located'''
                    for str_Path_And_File in list_Path_And_Files:

                
                        #DEBUG_ON
                        #if intCount == 1:
                        #    break
                        #pass
                        #DEBUG_OFF
                        
                        self.obj_Log_Debug_Display.debug('GP File: ' + str_Path_And_File)
                
                        ''' Get path from Path and Filename '''
                        str_FilePath_Import, strFileName_Import = obj_FileHandler.method_Separate_Path_And_FileName_From_PathAndFileName(str_Path_And_File)

                        ''' Get original run details from filename '''
                        str_Run_UID = strFileName_Import[:31]
                        ''' Get Batch '''
                        str_Batch = strFileName_Import.split('_B', 1)[1]
                        str_Batch = str_Batch.split('_', 1)[0]
                        ''' Get Replicate '''
                        str_Replicate = strFileName_Import.split('_R')[2]
                        str_Replicate = str_Replicate.split('_', 1)[0]
                        ''' Get Mating '''
                        str_Mating = strFileName_Import.split('_M', 1)[1]
                        str_Mating = str_Mating.split('_', 1)[0]
                        
                        dict_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_Data_Unique_Run_ID] = str_Run_UID
                        dict_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_Data_Sim_Current_Batch] = str_Batch
                        dict_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_Data_Sim_Current_Replicate] = str_Replicate
                        dict_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_Data_Sim_Current_Replicate_Mating] = str_Mating

                        ''' Determine Population Cohort that the file relates to '''
                        if str_File_Suffix_Search_Pattern == globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__Embryo_VSP_Post_Fertilization:
                            dict_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Population_Sampled] = globalsSS.VSP_AgeClass.static_string_Age_Class_VSP_Name_Embryo
                            pass
                        elif str_File_Suffix_Search_Pattern == globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__Mature_VSP_Post_Fertilization:
                            dict_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Population_Sampled] = globalsSS.VSP_AgeClass.static_string_Age_Class_VSP_Name_Reproductivly_available_adult
                            pass
                        elif str_File_Suffix_Search_Pattern == globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__Full_SP_Post_Fertilization:
                            dict_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Population_Sampled] = 'SP_0_Full'
                            pass
                        else:
                            dict_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Population_Sampled] = 'Unknown'
                            pass
                        pass
                    
                        str_GP_Data_File = strFileName_Import 
                        str_GP_Data_Path = str_FilePath_Import
                        str_Log_Output_Path = str_FilePath_Import
                        
                        str_GP_EXE_Path = str_Path_GP_Input
                        #DEBUG_ON
                        #str_GP_EXE_Path_And_File = 'ssafM:\\software\\Genepop\\'  #ERRONEOUS message to make Genepop fail but display it run parameter command line
                        #DEBUG_OFF
                        
                        obj_BioP = Biopython(self.objSSParametersLocal, str_Log_Output_Path, str_GP_Data_Path, str_GP_Data_File, str_GP_EXE_Path)
                        obj_BioP.bool_Allow_Log_Debug_Console_Output = False
                        #obj_BioP = Biopython(str_GP_Data_Path_And_File)
                        #obj_BioP.Get_Basic_Info()
                        #obj_BioP.Get_Alleles()
                        
                        bool_LD_Test = False
                        if bool_LD_Test:
                            bool_Get_Test_LD_All_Pair = True
                            if bool_Get_Test_LD_All_Pair:
                                obj_BioP.Get_Test_LD_All_Pair()
                            pass
                        pass
                    
                        bool_Get_HWE_Pop = False
                        if bool_Get_HWE_Pop:
                            #str_Param = 'excess'
                            #obj_BioP.Get_HWE_Pop(str_Param)
                            str_Param = 'probability'
                            obj_BioP.Get_HWE_Pop(str_Param)
                            #str_Param = 'deficiency'
                            #obj_BioP.Get_HWE_Pop(str_Param)
                        pass

                        bool_Get_Allele_Frequency_All_Loci = True
                        if bool_Get_Allele_Frequency_All_Loci:
                            obj_BioP.Get_Allele_Frequency_All_Loci(dict_Results)
                        pass
                        
                        bool_Get_Heterozygosity_All_Loci = True
                        if bool_Get_Heterozygosity_All_Loci:
                            obj_BioP.Get_Heterozygosity_All_Loci()
                        pass
                        

                        #with SSOutputHandler() as obj_SSOutput:
                            #obj_SSOutput.method_Pause_Console()   
 
 #                         bool_Get_HWE_Global = False
#                         if bool_Get_HWE_Global:                            
#                             str_Param = 'excess'
#                             obj_BioP.Get_HWE_Global(str_Param)
#                             str_Param = 'deficiency'
#                             obj_BioP.Get_HWE_Global(str_Param)                            
#                         
#                         bool_Get_Genotype_Frequency = False
#                         if bool_Get_Genotype_Frequency:
#                             #obj_BioP.Get_Genotype_Frequency() doesnt exist in biopython
#                             pass
#                         
#                         bool_Get_Allele_Frequency = False
#                         if bool_Get_Allele_Frequency:
#                             obj_BioP.Get_Allele_Frequency()
 #                             
#                         bool_Get_Heterozygosity = False
#                         if bool_Get_Heterozygosity:
#                             obj_BioP.Get_Heterozygosity()
                                                  
                        intCount += 1
 
                    pass
                pass

                #DEBUG_ON
                if globalsSS.Logger_Debug_AgeNe.bool_Debug_AgeNe:
#                     self.obj_Log_Debug_AgeNe.debug('>>> Survival Stat: odictAgeNe_Sim_Age_Values_Survival_Rates')
#                     for str_Sex, value in self.odictAgeNe_Sim_Age_Values_Survival_Rates.iteritems():
#                         self.obj_Log_Debug_AgeNe.debug('Sex: ' + str_Sex + ' ; Total: ' + str(round(sum(collections__Counter(value).values()),2)) + ' ; Values: ' + str(value)) 
                    pass                     
                    #with globalsSS.Pause_Console() as obj_Pause:
                    #    obj_Pause.method_Pause_Console()
                pass
                            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, str_Message='', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass 
                #DEBUG_OFF
                                        
                return True
         
        
            '''
            -----------------------------------
            Locus Combination Selective Jackknife
            -----------------------------------
            '''
           
            def method_Selective_Locus_Jackknife(self):
 
                listOutput = []
                
                with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Locus Combination Selective Jackknife - Main processing', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
               
                '''
                Load the population to analyse
                '''
                boolSelectiveLocusJacknife = True
                if boolSelectiveLocusJacknife:
                    
                    strFileNameSuffix_Import = '.r_pf_ssimupop.pop'
                    strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
                    #SCAPL 95,000 Nat Mort Only
                    #strFileName_Import = 'SS_2.37_pop_full_2014_10_05_10_53_58_{1_19_1_0_32.8_95046_1_1_31_30_15_45990}_rep_001'  #CAPL Simulated
                    
                    #SCAPL 90,000 Nat Mort Only
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.37_Py27\\Prod\\14_LDNE_VS_NED_RA_V1\\SS_2.37_Run_2014_10_04_22_01_14\\'
                    #strFileName_Import = 'SS_2.37_pop_full_2014_10_04_22_01_14_{1_19_1_0_32.8_90024_1_1_31_30_15_43560}_rep_001'  #CAPL Simulated
                    
                    #SCAPL 85,000 Nat Mort Only
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.37_Py27\\Prod\\13_LDNE_VS_NED_RA_V1\\SS_2.37_Run_2014_10_04_19_07_51\\'
                    #strFileName_Import = 'SS_2.37_pop_full_2014_10_04_19_07_51_{1_19_1_0_32.8_85002_1_1_31_30_15_41130}_rep_001'  #CAPL Simulated

                    #SCAPL 80,000 Nat Mort Only.  #LDNe PCrit 0.05 ~12,5000
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.37_Py27\\Prod\\13_LDNE_VS_NED_RA_V1\\SS_2.37_Run_2014_10_04_19_07_51\\'
                    #strFileName_Import = 'SS_2.37_pop_full_2014_10_04_19_07_51_{1_19_1_0_32.8_80042_1_1_31_30_15_38730}_rep_001'  #CAPL Simulated

                    #SCAPL 75,000 Nat Mort Only
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.37_Py27\\Prod\\13_LDNE_VS_NED_RA_V1\\SS_2.37_Run_2014_10_04_19_07_51\\'
                    #strFileName_Import = 'SS_2.37_pop_full_2014_10_04_19_07_51_{1_19_1_0_32.8_75020_1_1_31_30_15_36300}_rep_001'  #CAPL Simulated
                    
                    #SCAPL 70,000 Nat Mort Only.  LDNe PCrit 0.05 = ~10,500
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.35_Py27\\Prod\\12_LDNE_VS_NED_V1\\SS_2.35_Run_2014_10_03_23_10_45\\'
                    #strFileName_Import = 'SS_2.35_pop_full_2014_10_03_23_10_45_{1_20_11_0_32.8_70060_0_1_31_30_15_33900}_rep_001'  #CAPL Simulated
 
                    #SCAPL 60,000 Nat Mort Only
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.35_Py27\\Prod\\12_LDNE_VS_NED_V1\\SS_2.35_Run_2014_10_03_23_10_45\\'
                    #strFileName_Import = 'SS_2.35_pop_full_2014_10_03_23_10_45_{1_20_11_0_32.8_60016_0_1_31_30_15_29040}_rep_001'  #CAPL Simulated
 
                    #SCAPL 50,000 Nat Mort Only.  LDNe PCrit 0.05 = ~7000
                    strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.35_Py27\\Prod\\12_LDNE_VS_NED_V1\\SS_2.35_Run_2014_10_03_23_10_45\\'
                    strFileName_Import = 'SS_2.35_pop_full_2014_10_03_23_10_45_{1_20_11_0_32.8_50034_0_1_31_30_15_24210}_rep_001'  #CAPL Simulated
 
                    #SCAPL 40,000 Nat Mort Only
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.35_Py27\\Prod\\12_LDNE_VS_NED_V1\\SS_2.35_Run_2014_10_03_23_10_45\\'
                    #strFileName_Import = 'SS_2.35_pop_full_2014_10_03_23_10_45_{1_20_11_0_32.8_40052_0_1_31_30_15_19380}_rep_001'  #CAPL Simulated
 
                    #SCAPL 30,000 Nat Mort Only
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.35_Py27\\Prod\\12_LDNE_VS_NED_V1\\SS_2.35_Run_2014_10_03_23_10_45\\'
                    #strFileName_Import = 'SS_2.35_pop_full_2014_10_03_23_10_45_{1_20_11_0_32.8_30008_0_1_31_30_15_14520}_rep_001'  #CAPL Simulated
 
                    #SCAPL 20,000 Nat Mort Only
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.35_Py27\\Prod\\12_LDNE_VS_NED_V1\\SS_2.35_Run_2014_10_03_23_10_45\\'
                    #strFileName_Import = 'SS_2.35_pop_full_2014_10_03_23_10_45_{1_20_11_0_32.8_20026_0_1_31_30_15_9690}_rep_001'  #CAPL Simulated
 
                    #SCAPL 10,000 Nat Mort Only
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2.35_Py27\\Prod\\12_LDNE_VS_NED_V1\\SS_2.35_Run_2014_10_03_23_10_45\\'
                    #strFileName_Import = 'SS_2.35_pop_full_2014_10_03_23_10_45_{1_20_11_0_32.8_10044_0_1_31_30_15_4860}_rep_001'  #CAPL Simulated
 
                    #Load pop
                    strSimuPop_Pop_FilePathAndName = strFilePath_Import + strFileName_Import + strFileNameSuffix_Import
                    objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - Main processing - Simulated Jackknife', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                    
                    '''
                    Load the enite pop to sub-sample
                    Only the sub-sample will be analysed and optimized to get close to the True LDNe
                    '''
                    pop_Imported = self.method_Load_SimuPop_Population(strSimuPop_Pop_FilePathAndName)
                    intPopSize = pop_Imported.subPopSize() 
                    #Take a copy of imported pop each time to ensure that operations on a sub-pop dont propagate to the source pop
                    pop_In = pop_Imported.clone()


                    intRuns = 250
                    for intRun in range(1, intRuns+1):
                        
                        #LOGGING
                        stringMessage = '\n' + '------------------ ' + 'RUN ' + str(intRun) + ' OF ' + str(intRuns) + ' -------------------------------------------------------------' + '\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        #LOGGING

                        '''
                        Sub-sample the population to get a LDNe estimate
                        '''
                        boolCohortDependentSample = False
                        if boolCohortDependentSample:
                            pass
                        else:
                            intSamplingMethod = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                        pass
                        dictSamplingParams = {}

                        '''
                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                        SLECTIVE LOCUS JACKKNIFE
                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                        !!! ----> Set Locus Selection parameters here
                        '''
                        #CAPL_EMP_PANEL_19_V1
                        listLoci = ['07CAPL','08CAPL','13CAPL','14CAPL','16CAPL','18CAPL','19CAPL','27CAPL','31CAPL','33CAPL','35CAPL','47CAPL','48CAPL','50CAPL','52CAPL','57CAPL','58CAPL','60CAPL','63CAPL']
                        strLocus_Panel_ID = 'CAPL_EMP_PANEL_19_V1'
                        listLoci = ['Locus-1','Locus-2','Locus-3','Locus-4','Locus-5','Locus-6','Locus-7','Locus-8','Locus-9','Locus-10','Locus-11','Locus-12','Locus-13','Locus-14','Locus-15','Locus-16','Locus-17','Locus-18','Locus-19']
                        #listLoci = ['Locus-1','Locus-2','Locus-3','Locus-4','Locus-5','Locus-6']
                        listLociInclude = listLoci 
                        intTotalLoci = len(listLociInclude)
                        intMaximumLociToExclude = 3
                        intTrueLDNe = 7000
                        boolStopWhenRecommended = False
                        #listLocus_ExclusionLDNe_Deltas_Method = [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2] #Must equal numer of loci
                        listLocus_ExclusionLDNe_Deltas_Method = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] #Must equal numer of loci
                        dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.005
                        
                        pop_SubSample_Orig = self.method_SubSample_Simulated_Dataset(pop_In, intSamplingMethod, dictSamplingParams)
                        intSubSampleSize = pop_SubSample_Orig.subPopSize()
                             
                        boolOutputAnalysisSpreadsheet = True
                        if boolOutputAnalysisSpreadsheet:
                            #LOGGING
                            listSLJ_Sheet_Output0 = []
                            listSLJ_Sheet_Output0.append('RUN' + globalsSS.StringDelimiters.static_stringDelimiterTAB)
                            listSLJ_Sheet_Output0.append(str(dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation]))
                            listSLJ_Sheet_Output0.append(str(intRun))
                            listSLJ_Sheet_Output0.append(str(intRuns))
                            listSLJ_Sheet_Output0.append('\n')
                            stringMessage = globalsSS.StringDelimiters.static_stringDelimiter.join(listSLJ_Sheet_Output0)
                            #objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife, stringMessage, False)
                            
                            #LOGGING
    
                        
                        pop_SubSample_LocusExclusion = None
                        dictLocusExclusion_Cumulative_LDNes_ByPCrit = OrderedDict()
                        intSLJ_Level = 0
                        
                        #Loop unti the minimum loci have been evaluated  = THAs all this loop does
                        for intLocusExclusionCount in range(1, intTotalLoci):
                            
                            listSLJ_Sheet_Output3 = []
                            intSLJ_Level = intLocusExclusionCount
                            dictSpreadsheet = OrderedDict()

                            #Take a copy of imported pop each time to ensure that operations on a sub-pop dont propagate to the source pop
                            if intLocusExclusionCount == 1: 
                                pop_SubSample_LocusExclusion = pop_SubSample_Orig.clone()
                            
    #                         '''
    #                         Sub-sample the populations
    #                         '''
    #                         boolCohortDependentSample = False
    #                         if boolCohortDependentSample:
    #                             pass
    #                         else:
    #                             intSamplingMethod = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
    #                         pass
    #                         dictSamplingParams = {}
    #                         dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.03
    #                         
    #                         pop_SubSample = self.method_SubSample_Simulated_Dataset(pop_In, intSamplingMethod, dictSamplingParams)
    #                         
                            '''
                            Generate Simupop Ne statistics
                            '''
                            if boolCohortDependentSample:
                                listVSPsToReport = [(0, 0)]
                            else:
                                listVSPsToReport = [0]
                            pass
    
                            pop_SubSample_LocusExclusion = self.method_SimStat_LDNe_Reporting(pop_SubSample_LocusExclusion, listVSPsToReport)
                            
                            #simupop.stat(pop_SubSample_LocusExclusion, effectiveSize=ALL_AVAIL, subPops=listVSPsToReport, vars=['Ne_LD_sp'])
                            
                            '''
                            Get LDNe for primary exclusion comparison
                            '''
                            dictLDNeForComparison_Temp = self.method_Get_LDNe_Statistics(pop_SubSample_LocusExclusion, listVSPsToReport)
                            ''' IMPORTANT: Without a copy() the dict will update next time a simupop.stat() is used '''
                            dictLDNeForComparison = copy.copy(dictLDNeForComparison_Temp)
                            dictLDNeForPosterity = copy.copy(dictLDNeForComparison_Temp)
                            dictLocusExclusion_Cumulative_LDNes_ByPCrit['ALL_LOCI'] = copy.copy(dictLDNeForComparison_Temp)
                            '''
                            Log processing status & Report LDNe (COMPLETE SAMPLE) to media
                            '''
                            #LOGGING
                            stringMessage = '\n' + '-------------------------------------------------------------------------------' + '\n'
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                            strPrefixMessage = 'Locus selection/exclusion round: ' + str(intLocusExclusionCount) + ' of ' + str(intTotalLoci) + ' : '
                            listLDNePCritsToEvaluate=[0.05]
                            #listLDNePCritOutput=[0.05,0.02,0.01,0]
                            self.method_Output_LDNE_Summary(dictLDNeForComparison, listLDNePCritsToEvaluate, listOutputDestinations, strPrefixMessage)
                            stringMessage = '\n' + '-------------------------------------------------------------------------------' + '\n'
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                            self.method_Output_LDNE_To_Spreadsheet(pop_SubSample_LocusExclusion, listVSPsToReport, listOutputDestinations)
                            #LOGGING
    
                            boolOutputAnalysisSpreadsheet = True
                            if boolOutputAnalysisSpreadsheet:
                                #LOGGING
                                listSLJ_Sheet_Output1 = []
                                #listSLJ_Sheet_Output1 += listSLJ_Sheet_Output0
                                listSLJ_Sheet_Output1.append('LOCUS_EXCLUSION_ROUND' + globalsSS.StringDelimiters.static_stringDelimiterTAB)
                                listSLJ_Sheet_Output1.append(str(intLocusExclusionCount))
                                listSLJ_Sheet_Output1.append(str(intTotalLoci))
                                listSLJ_Sheet_Output1.append(self.method_Output_Format_LDNe_Estimates_From_Dict_As_Delimited_String(dictLDNeForComparison, listLDNePCritsToEvaluate))
                                listSLJ_Sheet_Output1.append('\n')
                                stringMessage = globalsSS.StringDelimiters.static_stringDelimiter.join(listSLJ_Sheet_Output1)
                                #objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife, stringMessage, False)
                                #LOGGING
                            
                            boolOutputGenepop = False
                            if boolOutputGenepop:
                                '''
                                Output GENPOP file
                                IMPORTANT - Allele adjust means the difference between an allele and missing data
                                if your data has zeros as missing data - set this to zero
                                if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                                '''
                                strFilenamePrefix = 'TEST'
                                strFilenameSuFfix = str(intLocusExclusionCount)
                                intAlleleAdjust = 0
                                boolSuccess = self.method_Output_Pop_Sample_To_GENEPOP_File_Locus_Combo_Jackknife_LCJK(pop_SubSample_LocusExclusion, intAlleleAdjust, strFilenamePrefix, strFilenameSuFfix)
                            pass
                            #LOGGING
                            
                            '''
                            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                            JACKKNIFE LOCI
                            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                            Remove each locus in turn and generate a Genepop file for Ne2 processing
                            '''
                            dictLocusExclusion_Total_Cumulative_LDNeDeltas_ByPCrit = OrderedDict()
                            dictLocusExclusion_Jackknife_Cumulative_LDNeDeltas_ByPCrit = OrderedDict()
                            intLocusCount = 1
                            intLocusTotal = len(listLoci)
                            
                            for strLocus in listLociInclude:
    
                                pop_SubSample_LocusJackknife = pop_SubSample_LocusExclusion.clone()
                                '''
                                Log processing status
                                '''
                                #LOGGING
                                stringMessage = '> Run ' + str(intRun) + ' of ' + str(intRuns) + ' >> Locus Jackknife round: ' + str(intLocusExclusionCount) + '; Jackknife locus: ' + strLocus + '; Jackknife ' + str(intLocusCount) + ' of ' + str(intLocusTotal) + ' : '
                                objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                #LOGGING
                                
                                '''
                                Remove a locus from poulation sub-sample
                                '''
                                pop_SubSample_LocusJackknife = self.method_Remove_Loci(pop_SubSample_LocusJackknife, [strLocus])
    
                                '''
                                Get LDNe for primary exclusion comparison
                                Generate Simupop Ne statistics
                                '''
                                if boolCohortDependentSample:
                                    listVSPsToReport = [(0, 0)]
                                else:
                                    listVSPsToReport = [0]
                                pass
        
                                pop_SubSample_LocusJackknife = self.method_SimStat_LDNe_Reporting(pop_SubSample_LocusJackknife, listVSPsToReport)
                                #simupop.stat(pop_SubSample_LocusJackknife, effectiveSize=ALL_AVAIL, subPops=listVSPsToReport, vars=['Ne_LD_sp'])
                                '''
                                Get LDNe for Jackknife
                                '''
                                dictLDNeForJackknife = self.method_Get_LDNe_Statistics(pop_SubSample_LocusJackknife, listVSPsToReport)
                                dictLocusExclusion_Cumulative_LDNes_ByPCrit[strLocus] = copy.copy(dictLDNeForJackknife)
                                '''
                                Report LDNe (LOCUS JACKKNIFE SAMPLE) to media
                                '''
                                #LOGGING
                                strPrefixMessage = 'Locus exclusion: '
                                self.method_Output_LDNE_Summary(dictLDNeForComparison, listLDNePCritsToEvaluate, listOutputDestinations, strPrefixMessage)
                                strPrefixMessage = 'Locus jackknife after removing locus: ' + strLocus + ' : '
                                self.method_Output_LDNE_Summary(dictLDNeForJackknife, listLDNePCritsToEvaluate, listOutputDestinations, strPrefixMessage)
                                self.method_Output_LDNE_To_Spreadsheet(pop_SubSample_LocusJackknife, listVSPsToReport, listOutputDestinations)
    
                                boolOutputAnalysisSpreadsheet = True
                                if boolOutputAnalysisSpreadsheet:
                                    #LOGGING
                                    listSLJ_Sheet_Output2 = []
                                    #listSLJ_Sheet_Output2 += listSLJ_Sheet_Output1
                                    #listSLJ_Sheet_Output2.append('')
                                    listSLJ_Sheet_Output2.append('LOCUS_JACKKNIFE_ROUND' + globalsSS.StringDelimiters.static_stringDelimiterTAB)
                                    listSLJ_Sheet_Output2.append(str(intLocusCount))
                                    listSLJ_Sheet_Output2.append(str(intLocusTotal))
                                    listSLJ_Sheet_Output2.append(strLocus)
                                    #listSLJ_Sheet_Output2.append(str(intLocusExclusionCount))
                                    listSLJ_Sheet_Output2.append(self.method_Output_Format_LDNe_Estimates_From_Dict_As_Delimited_String(dictLDNeForJackknife, listLDNePCritsToEvaluate))
                                    listSLJ_Sheet_Output2.append('\n')
                                    stringMessage = globalsSS.StringDelimiters.static_stringDelimiter.join(listSLJ_Sheet_Output2)
                                    #objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife, stringMessage, False)
                                    #LOGGING
                                    
                                    intCol = 0
                                    dictSpreadsheet.setdefault(intCol, []).append('RUN'); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append(intPopSize); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append(dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation]); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append(intSubSampleSize); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append(intTrueLDNe); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append(intRun); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append(intRuns); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append('LOCUS_EXCLUSION_ROUND'); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append(intLocusExclusionCount); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append(intTotalLoci); intCol +=1
                                    for listItem in listLDNePCritsToEvaluate:
                                        dictSpreadsheet.setdefault(intCol, []).append(listItem); intCol +=1
                                        for i in range(0,3):
                                            dictSpreadsheet.setdefault(intCol, []).append(round(dictLDNeForPosterity[listItem][i],0)); intCol +=1
                                        pass
                                    pass
                                    for listItem in listLDNePCritsToEvaluate:
                                        dictSpreadsheet.setdefault(intCol, []).append(listItem); intCol +=1
                                        for i in range(0,3):
                                            dictSpreadsheet.setdefault(intCol, []).append(round(dictLDNeForComparison[listItem][i],0)); intCol +=1
                                        pass
                                    pass
                                    dictSpreadsheet.setdefault(intCol, []).append(intLocusTotal); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append(intLocusCount); intCol +=1
                                    #dictSpreadsheet.setdefault(intCol, []).append(intLocusTotal); intCol +=1
                                    dictSpreadsheet.setdefault(intCol, []).append(strLocus); intCol +=1
                                    #dictSpreadsheet.setdefault(intCol, []).append(intLocusExclusionCount); intCol +=1
                                    for listItem in listLDNePCritsToEvaluate:
                                        dictSpreadsheet.setdefault(intCol, []).append(listItem); intCol +=1
                                        for i in range(0,3):
                                            dictSpreadsheet.setdefault(intCol, []).append(round(dictLDNeForJackknife[listItem][i],0)); intCol +=1
                                        pass
                                    pass

                                    
                                boolOutputGenepop = False
                                if boolOutputGenepop:
                                    '''
                                    Output GENPOP file
                                    IMPORTANT - Allele adjust means the difference between an allele and missing data
                                    if your data has zeros as missing data - set this to zero
                                    if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                                    '''
                                    strFilenamePrefix = 'TEST'
                                    strFilenameSuFfix = str(intLocusExclusionCount)
                                    intAlleleAdjust = 0
                                    boolSuccess = self.method_Output_Pop_Sample_To_GENEPOP_File_Locus_Combo_Jackknife_LCJK(pop_SubSample_LocusJackknife, intAlleleAdjust, strFilenamePrefix, strFilenameSuFfix)
                                #LOGGING
    
                                '''
                                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                EVALUATE LDNe DELTA
                                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                                Evaluate the magnitude of -LDNe influence of each locus
                                '''
    
                                '''
                                Calculate LDNe delta in comparision to previous LDNe with locus included
                                ''' 
                                listLDNePCritsToEvaluate=[0.05]
                                #dictLDNe_Delta = self.method_Calculate_DELTA_LDNe(pop_In, listVSPsToReport, listLDNePCritsToEvaluate, dictLDNeForComparison, listOutputDestinations, strPrefixMessage)
                                dictLDNe_Delta = self.method_Calculate_DELTA_LDNe(listLDNePCritsToEvaluate, dictLDNeForJackknife, dictLDNeForComparison, listOutputDestinations, strPrefixMessage)
                                #Append LDNe Delta to previous deltas
                                dictLocusExclusion_Jackknife_Cumulative_LDNeDeltas_ByPCrit[strLocus] = dictLDNe_Delta
    
                                '''
                                Log the cumulative deltas
                                '''
                                
                                
                                intLocusCount += 1
                            pass #for end - jackknife locus list
                        
                            '''
                            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                            SELECT - LOCUS BASED
                            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                            Evaluate each LDNe deta, rank loci for -LDne influence, Select locus based on cumulative delat criteria, Remove the selected locus
                            
                            !!!!THE MAGNITUDE OF THE DELTA IS THE BEST THROTTLE FOR DETERMINING IF ANOTHER LOCUS SHOUDL BE REMIVED !!!
                            
                            '''
                       
                            '''
                            Accumulate LDNe deltas from previuos Jackknifing round
                            '''
                            dictWithListsOf_Current_Locus_IndexedLDNeDeltas_ByPCrit = OrderedDict()
                            listLDNePCritsToEvaluate=[0.05]
                            #Accumulate LDNe deltas by PCrit
                            dictWithListsOf_Current_Locus_IndexedLDNeDeltas_ByPCrit = self.method_Accumulate_Locus_Exclusion_LDNe_Deltas(dictLocusExclusion_Jackknife_Cumulative_LDNeDeltas_ByPCrit, listLDNePCritsToEvaluate)

                            '''
                            Evaluate cumulative LDNe deltas and if the delta LDNe is large enough, select locus for exclusion
                            '''
                            floatPCritForEvaluationMethod = 0.05
                            intLDNeDeltaEvaluationMethod = listLocus_ExclusionLDNe_Deltas_Method[intLocusExclusionCount-1]
                            #Evaluate, decide and select locus for exclusion
                            #tupLocusCandidateSelectedForExclusionByLDNeDeltas = self.method_Select_Exclusion_Locus_By_LDNe_Deltas(dictWithListsOf_Current_Locus_IndexedLDNeDeltas_ByPCrit, floatPCritForEvaluationMethod, intLDNeDeltaEvaluationMethod)
                            listLocusCandidateSelectedForExclusionByLDNeDeltas = self.method_Select_Exclusion_Locus_By_LDNe_Deltas(dictWithListsOf_Current_Locus_IndexedLDNeDeltas_ByPCrit, floatPCritForEvaluationMethod, intLDNeDeltaEvaluationMethod)
                            listLocusCandidateSelectedForExclusion = self.method_Select_Exclusion_Locus_By_LDNe_Statistics(listLocusCandidateSelectedForExclusionByLDNeDeltas, dictLocusExclusion_Cumulative_LDNes_ByPCrit, listLDNePCritsToEvaluate)
    
                            boolExcludeLocus = listLocusCandidateSelectedForExclusion[0]
                            strLocusSelectedForExclusion = listLocusCandidateSelectedForExclusion[1]
                            listSLJ_Sheet_Output3 = listLocusCandidateSelectedForExclusion[2]
                            
                            '''
                            Spreadsheet logging
                            '''
                            boolOutputAnalysisSpreadsheet = True
                            if boolOutputAnalysisSpreadsheet:
                                #LOGGING
                                listSLJ_Sheet_Output4 = []
                                #listSLJ_Sheet_Output4 += listSLJ_Sheet_Output2
                                #listSLJ_Sheet_Output4.append('')
                                listSLJ_Sheet_Output4.append('SELECT_LOCUS_EXCLUSION' + globalsSS.StringDelimiters.static_stringDelimiterTAB)
                                listSLJ_Sheet_Output4.append(strLocusSelectedForExclusion)
                                listSLJ_Sheet_Output4 += listSLJ_Sheet_Output3 
#                                 listSLJ_Sheet_Output4.append(str(intLocusCount))
#                                 listSLJ_Sheet_Output4.append(str(intLocusTotal))
#                                 listSLJ_Sheet_Output4.append(strLocus)
#                                 listSLJ_Sheet_Output4.append(str(intLocusExclusionCount))
                                #listSLJ_Sheet_Output4.append(self.method_Output_Format_LDNe_Estimates_From_Dict_As_Delimited_String(dictWithListsOf_Current_Locus_IndexedLDNeDeltas_ByPCrit, listLDNePCritsToEvaluate))
                                listSLJ_Sheet_Output4.append(self.method_Output_Format_LDNe_Delta_Estimates_From_Dict_As_Delimited_String(dictWithListsOf_Current_Locus_IndexedLDNeDeltas_ByPCrit, listLDNePCritsToEvaluate))
                                listSLJ_Sheet_Output4.append('\n')
                                stringMessage = globalsSS.StringDelimiters.static_stringDelimiter.join(listSLJ_Sheet_Output4)
                                #objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife, stringMessage, False)
                                #LOGGING
                                
                                if intRun == 1:
                                    dictSpreadsheetHeadings = OrderedDict()
                                    intHeadingCol = 0
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LEVEL1'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('Tot_N'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('Samp_%_Tot_N'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('Samp_n'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('True LDNe'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('Run_Count'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('Runs_Total'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LEVEL2'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LocusExclusionCount'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('TotalLoci'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeOrig_PCrit'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeOrig_Ne'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeOrig_LwrJKCI'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeOrig_UprJKCI'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeForComparison_PCrit'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeForComparison_Ne'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeForComparison_LwrJKCI'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeForComparison_UprJKCI'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LocusTotal'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LocusCount'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('Locus'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeForJackknife_PCrit'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeForJackknife_Ne'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeForJackknife_LwrJKCI'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeForJackknife_UprJKCI'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_PCrit'); intHeadingCol +=1
                                    for listItem in listLDNePCritsToEvaluate:
                                        for intCount in range(0, len(dictWithListsOf_Current_Locus_IndexedLDNeDeltas_ByPCrit[listItem])):
                                            dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LEVEL3'); intHeadingCol +=1
                                            dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('Locus_Exclusion_Candidate'); intHeadingCol +=1
                                            dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('Locus_Delta'); intHeadingCol +=1
                                            dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta'); intHeadingCol +=1
                                    pass
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_Select_Crit'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_Select_Score'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_Select_Cutoff'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_Median'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_Median_Value'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_Mean'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_Mean_Value'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_StdDev'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_StdDev_Value'); intHeadingCol +=1
                                    dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_Variance'); intHeadingCol +=1
                                    for intDecideHeadingCount in range(0, len(listSLJ_Sheet_Output3)):
                                        dictSpreadsheetHeadings.setdefault(intHeadingCol, []).append('LDNeDelta_Decide_' + str(intDecideHeadingCount)); intHeadingCol +=1
                                    pass

                                #dictSpreadsheet[intCol] = 'SELECT_LOCUS_EXCLUSION'
                                #intCol +=1
                                #dictSpreadsheet[intCol] = strLocusSelectedForExclusion
                                #intCol +=1
#                                 for item in listSLJ_Sheet_Output3:
#                                     dictSpreadsheet[intCol]
#                                 pass
                                #####for intLocusCount in range(0, len(listLoci)):
                                #for listItem in listLDNePCritsToEvaluate:
                                for intRow in range(0, len(listLociInclude)):
                                #for intRow in range(0, len(dictSpreadsheet[0])):
                                    dictSpreadsheet.setdefault(intCol, []).append(listItem)
                                pass
                                intCol +=1
                                
                                for x,y in dictWithListsOf_Current_Locus_IndexedLDNeDeltas_ByPCrit[listItem]:
                                    
                                    
                                    for intRow in range(0, len(listLociInclude)):
                                    #for intRow in range(0, len(dictSpreadsheet[0])):
                                        dictSpreadsheet.setdefault(intCol, []).append('SELECT_LOCUS_EXCLUSION')
                                    intCol +=1
                                    for intRow in range(0, len(listLociInclude)):
                                    #for intRow in range(0, len(dictSpreadsheet[0])):
                                        dictSpreadsheet.setdefault(intCol, []).append(strLocusSelectedForExclusion)
                                    intCol +=1
                                    for intRow in range(0, len(listLociInclude)):
                                    #for intRow in range(0, len(dictSpreadsheet[0])):
                                        dictSpreadsheet.setdefault(intCol, []).append(x)
                                    intCol +=1
                                    for intRow in range(0, len(listLociInclude)):
                                    #for intRow in range(0, len(dictSpreadsheet[0])):
                                        dictSpreadsheet.setdefault(intCol, []).append(round(y,0))
                                    intCol +=1
                                pass
                                pass
                            
                                for intRow in range(0, len(listLociInclude)):
                                #for intRow in range(0, len(dictSpreadsheet[0])):
                                    dictSpreadsheet.setdefault(intCol, []).append(globalsSS.StringDelimiters.static_stringDelimiter.join(listSLJ_Sheet_Output3))
                                intCol +=1
                                
                                '''
                                Write headings first
                                '''
                                if intRun == 1:
                                    stringMessage = ''
                                    
                                    for intRow in range(0, len(dictSpreadsheetHeadings[0])):
                                        for intCol in range(0, len(dictSpreadsheetHeadings)):
                                        
                                            stringMessage += str(dictSpreadsheetHeadings[intCol][intRow]) + globalsSS.StringDelimiters.static_stringDelimiter
                                        pass
                                        stringMessage += '\n'
    
                                        if intSLJ_Level == 1:
                                            listSLJOutputDestinations = self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife_L1
                                        if intSLJ_Level == 2:
                                            listSLJOutputDestinations = self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife_L2
                                        if intSLJ_Level == 3:
                                            listSLJOutputDestinations = self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife_L3
                                        if intSLJ_Level == 4:
                                            listSLJOutputDestinations = self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife_L4
                                            
                                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listSLJOutputDestinations, stringMessage, False)
                                    pass
                                
                                '''
                                Write detail
                                '''
                                stringMessage = ''
                                
                                for intRow in range(0, len(dictSpreadsheet[0])):
                                    stringMessage = '' 
                                    for intCol in range(0, len(dictSpreadsheet)):
                                     
                                        stringMessage += str(dictSpreadsheet[intCol][intRow]) + globalsSS.StringDelimiters.static_stringDelimiter
                                    pass
                                    stringMessage += '\n'
                                    
                                    if intSLJ_Level == 1:
                                        listSLJOutputDestinations = self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife_L1
                                    if intSLJ_Level == 2:
                                        listSLJOutputDestinations = self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife_L2
                                    if intSLJ_Level == 3:
                                        listSLJOutputDestinations = self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife_L3
                                    if intSLJ_Level == 4:
                                        listSLJOutputDestinations = self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife_L4
                                        
                                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listSLJOutputDestinations, stringMessage, False)
                                
                                pass
                            
                               
                                
#                                 for key, listValues in dictSpreadsheet.items():
#                                     for item in listValues:
#                                         stringMessage += str(value) + globalsSS.StringDelimiters.static_stringDelimiter
#                                 pass
#                                 stringMessage += '\n'
#                                 objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_Reporting_SelectiveLocusJackknife, stringMessage, False)
                                
                            '''
                            Perform end of Locus exclusion round processing
                            ''' 
                            
                            if boolStopWhenRecommended:
                                if  boolExcludeLocus == False:
                                    '''
                                    Conclude processing if the decision has been made not to remove any more loci
                                    '''
                                    break
                               
                            if intLocusExclusionCount == intMaximumLociToExclude:
                                '''
                                Conclude processing if the max loci to be excluded is reached 
                                '''
                                break
                            else:
                                if boolExcludeLocus == True or boolStopWhenRecommended == False:
                                    '''
                                    Remove the locus from the working population and from the list of loci to include in next jackknife
                                    '''
                                    #Remove the selected locus from pop sub-sample
                                    pop_SubSample_LocusExclusion = self.method_Remove_Loci(pop_SubSample_LocusExclusion, [strLocusSelectedForExclusion])
                                    
                                    #Remove the selected locus from the list of loci to include in next jackknife
                                    if strLocusSelectedForExclusion in listLociInclude:
                                        listLociInclude.remove(strLocusSelectedForExclusion)
                                    else:
                                        #LOGGING
                                        with SSOutputHandler() as objSSOutputOperation:
                                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                            stringMessage = '!!!ERROR - Locus to be excluded could not be found in list - ERROR!!!; Locus: ' + strLocusSelectedForExclusion + '; list: ' + str(listLociInclude)
                                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                            objSSOutputOperation.method_Pause_Console()
                                        #LOGGING
                                pass
    
                                dictLocusExclusion_Total_Cumulative_LDNeDeltas_ByPCrit[intLocusExclusionCount] = dictWithListsOf_Current_Locus_IndexedLDNeDeltas_ByPCrit
                                intLocusExclusionCount += 1
                            pass
                        
                        pass #for end - all loci have been evaluated
                        #Repeat
                        
                    
                return True
            
            '''
            -----------------------------------
            Empirical Locus Jackknife
            -----------------------------------
            '''
                       
            def method_Jackknife_Empirical_Dataset(self):

                strFileNameSuffix_Import = '.gp_gspy'
                strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_AS_V1_No_Pops'  #CAOB
                #strFileName_Import = 'GsPy_GP_2015_03_12_15_28_AGL_B2_CAOB_2015_03_12_All_Loci_No_Pops'  #CAOB
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_No_Pops'  #CAOB
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_NSW'  #CAOB
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_No_Pops_X_WA'  #CAOB
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_All_Pops_WA_Only'  #CAOB
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_No_Pops_X_WA_LR_X_32COBS_42COBS_55CAOB'  #CAOB
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_No_Pops_X_WA_LR_X_32COBS_42COBS_55CAOB_LR_X_37COBS'  #CAOB
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_No_Pops_X_WA_LR_X_32COBS_42COBS_55CAOB_LR_X_37COBS_LR_X_07COBS'  #CAOB
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_No_Pops_X_WA_LR_X_32_42_55_LR_X_37_LR_X_07_LR_X_54'  #CAOB
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_No_Pops_X_WA_LR_X_32_42_55_LR_X_37_LR_X_07_LR_X_54_LR_X_59'  #CAOB
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_No_Pops_X_WA_LR_X_32_42_55_LR_X_37_LR_X_07_LR_X_54_LR_X_59_LR_X_22'  #CAOB
                #strFileName_Import = 'SS_2.41_Sampling_0.02_of_N_SSSS_0'  #CAOB
                #strFileName_Import = 'GSc__GP_2014_08_02_14_32_CAPL_ALL_LOCI_Region_Wo_SNPs_NSW_ONLY'  ##CAPL X WA WITH MISSING DATA
                strFileName_Import = 'GSc__GP_2014_08_02_14_32_CAPL_ALL_LOCI_Region_Wo_SNPs_AS_NSW'  ##CAPL NSW ONLY AFTER SHAZA WITH MISSING DATA
                
                #Locus Jacknife
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_No_Pops_X_WA_EJKL_x_55'
                #strFileName_Import = 'GsPy_GP_2014_11_08_17_14_AGL_B2_CAOB_X_14_43_49_Clean_V1_No_Pops_X_WA_EJKL_x_42'
                
                #Locus combo - Simulated pop
                #strFileName_Import = 'SS_2.42_Sampling_0.05_of_N_SJKS_1_0'
                #strFileName_Import = 'SS_2.43_Run_2014_12_13_12_07_46_Sampling_0.05_of_N_SJKS_1_0_DCB' #CAPL Allele Freqs, 0.05 Sample of 95,000, STELLAR FILE, CAPL_SIMULATED_PANEL_14_V1 - 5 loci removed 
                #strFileName_Import = 'SS_2.43_Run_2014_12_13_15_02_25_Sampling_0.03_of_N_SJKS_69_34_DCB' #CAPL Allele Freqs, 0.03 Sample of 95,000, GOOD FILE, CAPL_SIMULATED_PANEL_14_V1 - 5 loci removed
                #strFileName_Import = 'SS_2.43_Run_2014_12_13_15_02_25_Sampling_0.03_of_N_SJKS_5_2_DCB' #CAPL Allele Freqs, 0.03 Sample of 95,000, POOR FILE, CAPL_SIMULATED_PANEL_14_V1 - 5 loci removed 
                #strFileName_Import = 'SS_2.43_Run_2014_12_13_15_02_25_Sampling_0.03_of_N_SJKS_97_48_DCB' #CAPL Allele Freqs, 0.03 Sample of 95,000, AWEFUL FILE, CAPL_SIMULATED_PANEL_14_V1 - 5 loci removed 
                
                 
                strFilePathAndName_ImportGenotypes = strFilePath_Import + strFileName_Import + strFileNameSuffix_Import
                 
                pop_Imported = self.method_Import_Genotypes(strFilePathAndName_ImportGenotypes)
 
                #LOGGING
                with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Jackknife Empirical Dataset - Imported GENEPOP: ' + strFilePathAndName_ImportGenotypes, boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                #LOGGING
 
 
                bool_Systematic_Locus_Sampling = True
                if bool_Systematic_Locus_Sampling:


                    bool_Generate_And_Save_Locus_Combos = False
                    if bool_Generate_And_Save_Locus_Combos:
                        
                        '''
                        Generate unique combinations of loci for sampling
                        '''
                        #CAOB_PANEL_19_V1            
                        #listLoci = ['07COBS','11COBS','16COBS','17COBS','22COBS','32COBS','35COBS','37COBS','40COBS','42COBS','43COBS','48COBS','52CAOB','54CAOB','55CAOB','58CAOB','59CAOB','61CAOB','65CAOB']
                        #strLocus_Panel_ID = 'CAOB_EMP_PANEL_19_V1'
                        
                        #CAOB_PANEL_18_V1 
                        #listLoci = ['07COBS','11COBS','16COBS','17COBS','22COBS','32COBS','35COBS','37COBS','40COBS','42COBS','48COBS','52CAOB','54CAOB','55CAOB','58CAOB','59CAOB','61CAOB','65CAOB']
                        #strLocus_Panel_ID = 'CAOB_EMP_PANEL_18_V1'
                        
                        #CAPL_EMP_PANEL_19_V1
                        listLoci = ['07CAPL','08CAPL','13CAPL','14CAPL','16CAPL','18CAPL','19CAPL','27CAPL','31CAPL','33CAPL','35CAPL','47CAPL','48CAPL','50CAPL','52CAPL','57CAPL','58CAPL','60CAPL','63CAPL']
                        strLocus_Panel_ID = 'CAPL_EMP_PANEL_19_V1'
                        
                        #CAPL_SIMULATED_PANEL_19_V1
                        #listLoci = ['Locus-1',' Locus-2',' Locus-3',' Locus-4',' Locus-5',' Locus-6',' Locus-7',' Locus-8',' Locus-9',' Locus-10',' Locus-11',' Locus-12',' Locus-13',' Locus-14',' Locus-15',' Locus-16',' Locus-17',' Locus-18',' Locus-19']

                        #CAPL_SIMULATED_PANEL_14_V1
                        #listLoci = ['07CAPL','08CAPL','16CAPL','18CAPL','19CAPL','27CAPL','31CAPL','33CAPL','35CAPL','48CAPL','50CAPL','52CAPL','57CAPL','63CAPL']
                        #REAL CAPL Loci 13,47,60 - Have the least contributions to -LDNE, +LDNe, & even respectively at PCrit 0.05
                        #REAL CAPL Loci 14,58 - Have the next least contributions to -LDNE, +LDNe respectively at PCrit 0.05
                        #listLociToExclude = ['Locus-3','Locus-4','Locus-12','Locus-17','Locus-18']
                        #listLociToExclude = ['13CAPL','14CAPL','47CAPL','58CAPL','60CAPL']
                        #strLocus_Panel_ID = 'CAPL_SIM_PANEL_14_V1'
                        
                        self.method_Generate_Unique_Loci_Combinations(listLoci, strLocus_Panel_ID)
                       
                    pass
                
                    bool_Load_Locus_Combos_From_Database = False
                    if bool_Load_Locus_Combos_From_Database:
                  
                        '''
                        Prepare database for processing
                        '''
                        boolSuccessfull = False
                        with DatabaseHandler() as objDatabaseOperation:
                            #Get the JSON database info
                            boolSuccessfull = objDatabaseOperation.method_DBGetJSONDatabaseInfo()
                            if boolSuccessfull:
                                #Open the DBs specified in the databases.json file
                                objDatabaseOperation.method_DBOpenConections()
                            else:
                                #LOGGING
                                with SSOutputHandler() as objSSOutputOperation:
                                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                    objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, '!!!ERROR - Cannot get JSON Database information - ERROR!!!', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                                #LOGGING
                            pass
                        pass
                        
                        '''
                        Load locus combos from file to the database
                        '''
                        strFileNameSuffix_Import = '.r_st_lc_ssim'
                        strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
                        strFileName_Import = 'SS_2.41_locus_combo_log_TEST'
                        strFilePathAndName_ImportLocusCombos = strFilePath_Import + strFileName_Import + strFileNameSuffix_Import
                        
                        self.method_Database_Load_Locus_Combos_From_Database(objDatabaseOperation, strFilePathAndName_ImportLocusCombos)

                    bool_Load_Locus_Combos_From_File = True
                    if bool_Load_Locus_Combos_From_File:
                  
                       
                        '''
                        Load locus combos from file, generate genepop files containing the locus combos, export as genepop, and process Ne2
                        '''
                        strFileNameSuffix_Import = '.r_st_lc_ssim'
                        
                        strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
                        #CAPL_PANEL_19_V1
                        #strFileName_Import = 'SS_2.42_CAPL_PANEL_19_V1_locus_combo_log_2014_12_09_13_07_29_{1_19_1_10_32.8_10044_1_1_31_30_15_4860}_rep_001_DCB'
                        #CAPL_SIMULATED_PANEL_19_V1
                        #strFileName_Import = 'SS_2.42_CAPL_SIMULATED_PANEL_19_V1_locus_combo_log_2014_12_12_15_57_45_{1_19_1_10_32.8_10044_1_1_31_30_15_4860}_rep_001'
                        #CAOB_PANEL_18_V1
                        #strFileName_Import = 'SS_2.42_locus_combo_log_2014_12_06_13_13_18_{1_19_1_10_32.8_10044_1_1_31_30_15_4860}_rep_001'
                        #CAPL_SIMULATED_PANEL_14_V1
                        #strFileName_Import = 'SS_2.43_locus_combo_log_2014_12_13_13_00_40_{1_19_1_10_32.8_10044_1_1_31_30_15_4860}_rep_001'
                        #CAPL_SIM_PANEL_14_V1
                        #strFileName_Import = 'SS_2.43_CAPL_SIM_PANEL_14_V1_locus_combo_log_2014_12_14_17_15_17_{1_19_1_10_32.8_10044_1_1_31_30_15_4860}_rep_001'
                        #CAOB_EMP_PANEL_19_V1
                        #strFileName_Import = 'SS_2_57_CAOB_EMP_PANEL_19_V1_locus_combo_log_2015_03_12_15_38_28_{1_20_10_10_19.8_10000_0_1_4_3_2_2500}_rep_001'
                        #CAOB_EMP_PANEL_18_V1
                        #strFileName_Import = 'SS_2.43_CAOB_EMP_PANEL_18_V1_locus_combo_log_2014_12_14_17_28_34_{1_19_1_10_32.8_10044_1_1_31_30_15_4860}_rep_001'
                        #CAOB_EMP_PANEL_18_V1
                        #strFileName_Import = 'SS_2_59_CAOB_EMP_PANEL_18_V1_locus_combo_log_2015_03_31_14_14_37_{1_20_10_0_4.8_1000_1_1_3_2_1_333}_rep_001'
                        #CAPL_EMP_PANEL_19_V1
                        strFileName_Import = 'SS_2.43_CAPL_EMP_PANEL_19_V1_locus_combo_log_2014_12_14_22_32_37_{1_19_1_10_32.8_10044_1_1_31_30_15_4860}_rep_001'
                        
                        strFilePathAndName_ImportLocusCombos = strFilePath_Import + strFileName_Import + strFileNameSuffix_Import

                        bool_Generate_Locus_Combo_Genotype_Files = True
                        if bool_Generate_Locus_Combo_Genotype_Files:
                            
                            bool_Use_Ne2_Win_DLL = False
                            if bool_Use_Ne2_Win_DLL:
                                self.method_Empirical_Dataset_Locus_Combination_Sampling_From_File_Using_Ne2_Win_DLL(strFilePathAndName_ImportGenotypes, strFilePathAndName_ImportLocusCombos)
                            else:
                                self.method_Empirical_Dataset_Locus_Combination_Sampling_From_File_Using_Ne2Bulk(strFilePathAndName_ImportGenotypes, strFilePathAndName_ImportLocusCombos)
                            pass
                        pass
                   
                pass
            
                           
                bool_Remove_Loci = False
                if bool_Remove_Loci:
                    listLociToRemove = ['55CAOB']
                    #listLociToRemove = ['42COBS','55CAOB']
                    #listLociToRemove = ['32COBS','42COBS','55CAOB']
                    #listLociToRemove = ['37COBS']
                    #listLociToRemove = ['07COBS']
                    #listLociToRemove = ['54CAOB']
                    #listLociToRemove = ['59CAOB']
                    #listLociToRemove = ['22COBS']
                    #listLociToRemove = ['17COBS']
                    #listLociToRemove = ['32COBS','42COBS','55CAOB','37COBS','07COBS','54CAOB','59CAOB','22COBS']
                    #listLociToRemove = ['32COBS','42COBS','55CAOB','37COBS','07COBS','54CAOB','59CAOB','22COBS','17COBS']
                    #listLociToRemove = ['32COBS','42COBS','55CAOB','37COBS','07COBS','54CAOB','59CAOB','22COBS','17COBS','65CAOB']
                    #listLociToRemove = ['32COBS','42COBS','55CAOB','37COBS','07COBS','54CAOB','59CAOB','22COBS','17COBS','65CAOB','61CAOB','16COBS']
                    #listLociToRemove = ['32COBS','42COBS','55CAOB','37COBS','07COBS','54CAOB','59CAOB','22COBS','17COBS','65CAOB','61CAOB','16COBS','52CAOB','58CAOB','11COBS','35COBS']
                    pop_Locus_Removed = self.method_Remove_Loci(pop_Imported, listLociToRemove)
                    #Export that pop as a Genepop file
                    
                    #Construct loci filename string
                    strLoci = ''
                    for strLocus in listLociToRemove:
                        strLoci += '_' + strLocus[:2]
                    pass   
                 
                    strFilename_Export = strFileName_Import + '_LR_X' + str(strLoci)
                    strFilenameFull_Export = strFilename_Export + strFileNameSuffix_Import
                    strFilePathAndNameFull_Export = self.objSSParametersLocal.outfilePath + strFilenameFull_Export
                    
                    bool_Prevent_Internal_Function_Console_Output = False
                    bool_Prevent_External_Function_Console_Output = False

                    self.method_Export_Genotypes(pop_Locus_Removed, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output)

                    with FileHandler() as objFileOperation:
                        strFolderPath_Copy_Source = strFilePath_Import + 'Ne2_Fresh'
                        strFolderPath_Copy_Destination = self.objSSParametersLocal.outfilePath + 'Ne2'
                        objFileOperation.method_Copy_Folder_Or_All_Files(strFolderPath_Copy_Source, strFolderPath_Copy_Destination)
                        #Copy input data file to analysis folder
                        strFilename_Copy = strFilename_Export[:47] + strFileNameSuffix_Import
                        strFolderPathAndFile_Copy_Destination = strFolderPath_Copy_Destination + '\\' + strFilename_Copy
                        objFileOperation.method_Copy_Files(strFilePathAndNameFull_Export, strFolderPathAndFile_Copy_Destination)
                        
                        #Run batch file as subprocess
                        strFileNameToExecute = 'Ne2_Standard_Run.bat'
                        os.chdir(strFolderPath_Copy_Destination)
                        process = subprocess__Popen([strFileNameToExecute], shell=True)
                        stdout, stderr = process.communicate()
                pass

                bool_Jackknife_Loci = False
                if bool_Jackknife_Loci:

                    listLoci = ['07COBS','11COBS','16COBS','17COBS','22COBS','32COBS','35COBS','37COBS','40COBS','42COBS','48COBS','52CAOB','54CAOB','55CAOB','58CAOB','59CAOB','61CAOB','65CAOB']
                    #listLoci = ['07COBS','11COBS','16COBS','17COBS','22COBS','35COBS','40COBS','48COBS','52CAOB','54CAOB','58CAOB','59CAOB','61CAOB','65CAOB']
                    #listLoci = ['11COBS','16COBS','17COBS','22COBS','35COBS','40COBS','48COBS','52CAOB','58CAOB','61CAOB','65CAOB']
                    #listLoci = ['11COBS','16COBS','17COBS','35COBS','40COBS','48COBS','52CAOB','58CAOB','61CAOB','65CAOB']
                    #listLoci = ['11COBS','16COBS','35COBS','40COBS','48COBS','52CAOB','58CAOB','61CAOB','65CAOB']
                    #listLoci = ['11COBS','16COBS','35COBS','40COBS','48COBS','52CAOB','58CAOB','61CAOB']
                    #listLoci = ['11COBS','16COBS','35COBS','40COBS','48COBS','52CAOB','58CAOB']
                    #listLoci = ['11COBS','35COBS','40COBS','48COBS','52CAOB','58CAOB']
                    #listLoci = ['11COBS','35COBS','40COBS','48COBS','58CAOB']
                    #listLoci = ['11COBS','35COBS','40COBS','48COBS']
                    #listLoci = ['35COBS','40COBS','48COBS']
                    #listLoci = ['40COBS','48COBS']
                    
                    self.method_Empirical_Dataset_Jackknife_Loci(strFilePathAndName_ImportGenotypes, listLoci)

                    pass
                pass    

                '''
                Jackknife repeatedly on a single LDNe subsample
                '''
                
                intSampleNumIndividuals = pop_Imported.subPopSize() 
                
                bool_Jackknife_Samples = False
                if bool_Jackknife_Samples:
                    
                    '''
                    Specify if initial Ne point estimate of whole sample set is required
                    '''
                    
                    boolInitialLDNePointEstimate = True
                    if boolInitialLDNePointEstimate:
                        intExraSamples = 1
                    else:
                        intExraSamples = 0
                    '''
                    Specify the type of Jackknife sampling to do
                    '''
                    
                    intRandomJackknifeSamplesToTake = 500
                    
                    boolJackknifeProportion = False
                    if boolJackknifeProportion:
                        floatProportionOfIndividualsToExcludeFromJackknifeSample = 0.0100
                        intNumGenotypesToSample = intSampleNumIndividuals - int(round((intSampleNumIndividuals * floatProportionOfIndividualsToExcludeFromJackknifeSample),0))
                        floatPopProportionToSample = round(float(intNumGenotypesToSample) / float(intSampleNumIndividuals),4)  
                    pass
                
                    boolJackknifeAbsoluteNumber = True
                    if boolJackknifeAbsoluteNumber:
                        
                        intNumberOfIndividualsToExclude = 1
                        #intNumberOfIndividualsToExclude = 2
                        #intNumberOfIndividualsToExclude = 3
                        #intNumberOfIndividualsToExclude = 4
                        #intNumberOfIndividualsToExclude = 5
                        
                        intNumGenotypesToSample = intSampleNumIndividuals - intNumberOfIndividualsToExclude
                        floatProportionOfIndividualsToExcludeFromJackknifeSample = round(float(intNumberOfIndividualsToExclude) / float(intSampleNumIndividuals),4) 
                        floatPopProportionToSample = round(float(intNumGenotypesToSample) / float(intSampleNumIndividuals),4)
                    pass
                    
                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                        stringMessage = '>Randomly Jackknife ' + str(intRandomJackknifeSamplesToTake + intExraSamples) + ' times; Excluding : ' + str(floatProportionOfIndividualsToExcludeFromJackknifeSample) + ' of ' + str(intSampleNumIndividuals) + ' = ' + str(intNumGenotypesToSample) + ' individuals' +'\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #LOGGING
                    
                    
                    for intRandomJackknifeLDneSample in  range(1, intRandomJackknifeSamplesToTake + intExraSamples + 1):

                        if boolInitialLDNePointEstimate:
                            pop_JackknifeSample = self.method_Draw_Random_Pop_SubSample(pop_Imported, intSampleNumIndividuals)
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                            stringMessage = '>Initial LDNe point estimate:' #+'\n'
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            boolInitialLDNePointEstimate = False
                        else:    
                            pop_JackknifeSample = self.method_Draw_Random_Pop_SubSample(pop_Imported, intNumGenotypesToSample)
     
                        #DEBUG_ON                    
                        #simupop.dump(pop_JackknifeSample)
                        #DEBUG_OFF
                        intFileOrder = 0
                        boolCohortDependentSample = False
                        bool_Report_Ne = True
                        if bool_Report_Ne:
                            if boolCohortDependentSample:
                                listVSPsToReport = [(0, 0)]
                            else:
                                listVSPsToReport = [0]
                            pass
                            
                            pop_JackknifeSample = self.method_SimStat_LDNe_Reporting(pop_JackknifeSample, listVSPsToReport)

                            if boolCohortDependentSample:
                                listVSPsToReport = [0, 0]
                            else:
                                listVSPsToReport = [0]
                            pass
                            
                            
                            
                            listLDNePCritOutput=[0.05,0.02,0.01,0.0]
                            #listLDNePCritOutput=[0.05]
                            strPrefixMessage = 'Jackknife sample ' + str(intRandomJackknifeLDneSample) + ' of ' + str(intRandomJackknifeSamplesToTake + intExraSamples) + ' : '
                            self.method_Calculate_And_Output_LDNE_To_Console(pop_JackknifeSample, listVSPsToReport, listLDNePCritOutput, listOutputDestinations, strPrefixMessage)
                            
                            self.method_Calculate_And_Output_LDNE_To_File(self.objSSParametersLocal, pop_JackknifeSample, listVSPsToReport)

                        boolExportJacknifeGenpopFiles = True
                        if boolExportJacknifeGenpopFiles:
                            strFileNameSuffix_Export = '.gp_gspy'
                            strFileName_Export = 'Sampling_' + str(floatPopProportionToSample) + '_of_N'
                            strFileNameCode_Export = 'EJKS'
                            strFileNameCount_Export = str(intRandomJackknifeLDneSample)
                            strFilename_Export = strFileName_Export + '_' + strFileNameCode_Export + '_' + str(intFileOrder) + '_' + strFileNameCount_Export + strFileNameSuffix_Export
                            #strFilename_Export = strFileName_Export + '_' + strFileNameCode_Export + '_' + strFileNameCount_Export + 'B' + strFileNameSuffix_Export
                            strFilePathAndNameFull_Export = self.objSSParametersLocal.outfilePath + self.objSSParametersLocal.strFileNameProgramPrefix + strFilename_Export
                            intFileOrder += 1
                            '''
                            IMPORTANT - Allele adjust means the difference between an allele and missing data
                            if your data has zeros as missing data - set this to zero
                            if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                            '''
                        
                            intAlleleAdjust = 0
                            bool_Prevent_Internal_Function_Console_Output = True
                            bool_Prevent_External_Function_Console_Output = True
                            
                            boolSuccess = self.method_Export_Genotypes(pop_JackknifeSample, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))
    
                            if boolSuccess == False:
                                #LOGGING
                                with SSOutputHandler() as objSSOutputOperation:
                                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                                    #listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                                    stringMessage = '!!!ERROR - File create failed ERROR!!!; File: ' + strFilename_Export
                                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                    
                                    #DEBUG_ON                    
                                    simupop.dump(pop_Locus_Removed)
                                    #DEBUG_OFF
    
                                    objSSOutputOperation.method_Pause_Console()
                                #LOGGING
                            pass    
                        
                        
                        
                        pass #For loop

                    boolPrepNe2Bulk = True
                    if boolPrepNe2Bulk:
                    
                        #Copy input data file to analysis folder
                        strFileNameSuffix_Export = '.gp_gspy'
                        strFileNameCode_Export = 'EJKS'
                        strFileNamePattern_Copy = '*' + strFileNameCode_Export + '*' + strFileNameSuffix_Export
                        strFilePath_WorkingFolder = self.objSSParametersLocal.outfilePath + 'Ne2Bulk\\'
                        strFolderPathAndFile_Copy_Destination = strFilePath_WorkingFolder
                        strProcessFilePattern = strFileNameCode_Export
    
                        #Put executable files in place
                        self.method_Pre_Process_External_Program_Ne2Bulk(strFilePath_WorkingFolder)
                        
                        #Copy input files to the execution working folder
                        with FileHandler() as objFileOperation:
                            if objFileOperation.method_Path_Exists(strFilePath_WorkingFolder) == False:
                                objFileOperation.method_Create_Path(strFilePath_WorkingFolder)
                            pass
                        
                            objFileOperation.method_Copy_Files_By_Pattern(self.objSSParametersLocal.outfilePath, strFolderPathAndFile_Copy_Destination, strFileNamePattern_Copy)

                        boolExecuteNe2Bulk = False
                        if boolExecuteNe2Bulk:
    
                            #LOGGING
                            #with SSOutputHandler() as objSSOutputOperation:
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                            objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife - Running External Ne2Bulk Process', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                            #LOGGING
                        
    
                            #Execute external program
                            bool_Prevent_External_Function_Console_Output = True
                            self.method_Execute_External_Program_Ne2Bulk(strProcessFilePattern, strFilePath_WorkingFolder, bool_Prevent_External_Function_Console_Output)
    
                            #LOGGING
                            #with SSOutputHandler() as objSSOutputOperation:
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                            objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Empirical Jackknife - Running External Ne2Bulk Process', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                            #LOGGING                    
        
                            pass
                        pass
                    pass
                pass
                

                return True
            '''
            -----------------------------------
            Simulated Jackknife
            -----------------------------------
            '''
                       
            def method_Jackknife_Simulated_Dataset_With_Ne2(self):

                #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
                strFilePath_Working = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2_58_Py27\\Prod\\SOG_EAF_JKL_NE2_SAMP_SIZE_V1\\SS_2_58_Run_2015_03_16_19_00_28'
                
                bool_SubSample_SS_Pop = False
                if bool_SubSample_SS_Pop:                    
                    '''
                    -----------------------------------
                    Load simulated population
                    -----------------------------------
                    '''
                    strFileNameSuffix_Import = globalsSS.SS_Replicate_Details.static_Output_File_Suffix__SimuPOP_Pop_EOR
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
                    strFilePath_Import = strFilePath_Working
                    strFileName_Import = 'SS_2_58_pop_full_2015_03_16_19_00_28_{1_20_10_10_19.8_10000_0_1_4_3_2_2500}_rep_001'  #Simulated
                    #listLociToRemove = ['Locus-15','Locus-16','Locus-17','Locus-18','Locus-19','Locus-20'] #None assumes all
                    listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20'] #None assumes all
                    #Load pop
                    strSimuPop_Pop_FilePathAndName = strFilePath_Import + '\\' + strFileName_Import + strFileNameSuffix_Import
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - Main processing - Simulated Jackknife With Ne2', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                
                    pop_Imported = self.method_Load_SimuPop_Population(strSimuPop_Pop_FilePathAndName)
                    
                    '''
                    -----------------------------------
                    Sub-sample loaded population
                    -----------------------------------
                    '''
                    boolCohortDependentSample = False
                    if boolCohortDependentSample:
                        pass
                    else:
                        intSamplingMethod = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                    pass
                    dictSamplingParams = {}
                    dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.00833333 #0.01666666 #0.05
                    
                    pop_SubSample_Orig = self.method_SubSample_Simulated_Dataset(pop_Imported, intSamplingMethod, dictSamplingParams, listLociToRemove)
                    intSubSampleSize = pop_SubSample_Orig.subPopSize() 
                    
                    #Export that pop as a Genepop file
                    with FileHandler() as objFileOperation:
                        tupFilePathNameAndExt = objFileOperation.method_Get_FileNameAndExtension_From_FileName(strSimuPop_Pop_FilePathAndName)
                        strPathFileName_ImportWOSuffix = objFileOperation.method_Get_FileName_From_PathAndFileName(tupFilePathNameAndExt[0])
                    
                    strFileName_FreeText = '_V3'
                    strFileNameSuffix_Export = '.gp_gspy'
                    strFileNameCode_Export = 'SJN2'
                    strFilename_Export = strPathFileName_ImportWOSuffix[:36] + '_' + strFileNameCode_Export + '_SubSampSize_' + str(intSubSampleSize) + strFileName_FreeText

                    strFilePathAndNameFull_Export = strFilePath_Import + '\\' + strFilename_Export + strFileNameSuffix_Export
                    
                    '''
                    Create GENEPOP file
                    IMPORTANT - Allele adjust means the difference between an allele and missing data
                    if your data has zeros as missing data - set this to zero
                    if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                    '''
                    intAlleleAdjust = 1
                    bool_Prevent_Internal_Function_Console_Output = True
                    bool_Prevent_External_Function_Console_Output = True
                    
                    boolSuccess = self.method_Export_Genotypes(pop_SubSample_Orig, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))

                    if boolSuccess == False:
                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            #listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                            stringMessage = '!!!ERROR - File create failed ERROR!!!; File: ' + strFilename_Export
                            objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                            
                            #DEBUG_ON                    
                            simupop.dump(pop_SubSample_Orig)
                            #DEBUG_OFF

                            objSSOutputOperation.method_Pause_Console()
                        #LOGGING
                    pass    
                        
                        
                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = '>GENEPOP file exported: ' + strFilename_Export
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                    #LOGGING

                '''
                -----------------------------------
                Sub-sample GENPOP file by locus jackknife and run Ne2
                -----------------------------------
                ''' 
                bool_Systematic_Locus_Sampling = True
                if bool_Systematic_Locus_Sampling:


                    bool_Generate_And_Save_Locus_Combos = False
                    if bool_Generate_And_Save_Locus_Combos:
                        
                        '''
                        -----------------------------------
                        Generate unique combinations of loci for sampling
                        -----------------------------------
                        '''

                        #SIMULATED_PANEL_20_V1
                        #listLoci = ['Locus-1','Locus-2','Locus-3','Locus-4','Locus-5','Locus-6','Locus-7','Locus-8','Locus-9','Locus-10','Locus-11','Locus-12','Locus-13','Locus-14','Locus-15','Locus-16','Locus-17','Locus-18','Locus-19','Locus-20']
                        #strLocus_Panel_ID = 'SIMULATED_PANEL_20_V1'

                        #SIMULATED_PANEL_18_V1
                        #listLoci = ['Locus-1','Locus-2','Locus-3','Locus-4','Locus-5','Locus-6','Locus-7','Locus-8','Locus-9','Locus-10','Locus-11','Locus-12','Locus-13','Locus-14','Locus-15','Locus-16','Locus-17','Locus-18']
                        #strLocus_Panel_ID = 'SIMULATED_PANEL_18_V1'

                        #SIMULATED_PANEL_16_V1
                        listLoci = ['Locus-1','Locus-2','Locus-3','Locus-4','Locus-5','Locus-6','Locus-7','Locus-8','Locus-9','Locus-10','Locus-11','Locus-12','Locus-13','Locus-14','Locus-15','Locus-16']
                        strLocus_Panel_ID = 'SIMULATED_PANEL_16_V1'
                        
                        #SIMULATED_PANEL_14_V1
                        #listLoci = ['Locus-1','Locus-2','Locus-3','Locus-4','Locus-5','Locus-6','Locus-7','Locus-8','Locus-9','Locus-10','Locus-11','Locus-12','Locus-13','Locus-14']
                        #strLocus_Panel_ID = 'SIMULATED_PANEL_14_V1'
                        
                        strFilePath_Export = strFilePath_Working
                        strUniqueRunID = 'SS_2_58_Run_2015_03_16_19_00_28'
                        strFilenameSuffix = strLocus_Panel_ID
                        self.objSSParametersLocal.strOutputFileName_LocusCombos = strFilePath_Export + '\\' + strUniqueRunID + '_locus_combo_log_' + strFilenameSuffix + '.r_st_lc_ssim'
                        
                        self.method_Generate_Unique_Loci_Combinations(listLoci, strLocus_Panel_ID)
                       
                    pass
                
                    bool_Load_Locus_Combos_From_File = True
                    if bool_Load_Locus_Combos_From_File:
                  
                        '''
                        -----------------------------------
                        Specify Starting Simulated Dataset (already sub-sampled from a simulated population)
                        -----------------------------------
                        '''
        
                        strFileNameSuffix_Import = '.gp_gspy'
                        #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
                        strFilePath_Import = strFilePath_Working
                        strFileName_Import = 'SS_2_58_pop_full_2015_03_16_19_00_28_SJN2_3000_SubSamp_Rand_30pc_00000'  #CAOB
                        
                        #Locus combo - Simulated pop
                        #strFileName_Import = 'SS_2.42_Sampling_0.05_of_N_SJKS_1_0'
                        #strFileName_Import = 'SS_2.43_Run_2014_12_13_12_07_46_Sampling_0.05_of_N_SJKS_1_0_DCB' #CAPL Allele Freqs, 0.05 Sample of 95,000, STELLAR FILE, CAPL_SIMULATED_PANEL_14_V1 - 5 loci removed 
                        #strFileName_Import = 'SS_2.43_Run_2014_12_13_15_02_25_Sampling_0.03_of_N_SJKS_69_34_DCB' #CAPL Allele Freqs, 0.03 Sample of 95,000, GOOD FILE, CAPL_SIMULATED_PANEL_14_V1 - 5 loci removed
                        #strFileName_Import = 'SS_2.43_Run_2014_12_13_15_02_25_Sampling_0.03_of_N_SJKS_5_2_DCB' #CAPL Allele Freqs, 0.03 Sample of 95,000, POOR FILE, CAPL_SIMULATED_PANEL_14_V1 - 5 loci removed 
                        #strFileName_Import = 'SS_2.43_Run_2014_12_13_15_02_25_Sampling_0.03_of_N_SJKS_97_48_DCB' #CAPL Allele Freqs, 0.03 Sample of 95,000, AWEFUL FILE, CAPL_SIMULATED_PANEL_14_V1 - 5 loci removed 
                        
                         
                        strFilePathAndName_ImportGenotypes = strFilePath_Import + '\\'+ strFileName_Import + strFileNameSuffix_Import
                         
                        #pop_Imported = self.method_Import_Genotypes(strFilePathAndName_ImportGenotypes)
         
                        #LOGGING
                        with SSOutputHandler() as objSSOutputOperation:
                            listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                            objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Jackknife Empirical Dataset - Imported GENEPOP: ' + strFilePathAndName_ImportGenotypes, boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        #LOGGING
 
                       
                        '''
                        -----------------------------------
                        Load locus combos from file, generate genepop files containing the locus combos, export as genepop, and process Ne2
                        -----------------------------------
                        '''
                        strFileNameSuffix_Import = '.r_st_lc_ssim'
                        
                        #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
                        strFilePath_Import = strFilePath_Working
                        strFileName_Import = 'SS_2_58_Run_2015_03_16_19_00_28_locus_combo_log_SIMULATED_PANEL_16_V1'
                        
                        strFilePathAndName_ImportLocusCombos = strFilePath_Import + '\\' + strFileName_Import + strFileNameSuffix_Import

                        bool_Generate_Locus_Combo_Genotype_Files = True
                        if bool_Generate_Locus_Combo_Genotype_Files:
                            
                            bool_Use_Ne2_Win_DLL = True
                            if bool_Use_Ne2_Win_DLL:
                                self.method_Empirical_Dataset_Locus_Combination_Sampling_From_File_Using_Ne2_Win_DLL(strFilePathAndName_ImportGenotypes, strFilePathAndName_ImportLocusCombos)
                            else:
                                self.method_Empirical_Dataset_Locus_Combination_Sampling_From_File_Using_Ne2Bulk(strFilePathAndName_ImportGenotypes, strFilePathAndName_ImportLocusCombos)
                            pass
                        pass
                    pass
                pass
            
                           

                return True

            '''
            -----------------------------------
            Pop SubSample & NE2
            -----------------------------------
            '''
            def method_Define_Ne2_Experiments(self):

                #dictExperiments = AutoVivificationHandler()
                dictExperiments_Per_Pop_Rep = OrderedDict()

                int_Pop_Replicates_To_Experiment_On = 5

                for int_Rep in range(1, int_Pop_Replicates_To_Experiment_On + 1):               
 
                    dictExperiments = OrderedDict()

                    '''
                    ENTER Number of Experiments & Replicates per experiment ---->
                    '''
                    intNumExperiments = 5
                    int_Replicates_Per_Experiment = 20
    
                    for int_Current_Experiment in range(1, intNumExperiments+1):
                        
                        dictExperiment = AutoVivificationHandler()
                        
                        dictExperiment['Current_Experiment'] = int_Current_Experiment
    
                        '''
                        ?? ENTER Experiment base path ---->
                        '''                    
                        strFilePath_Base = 'C:\\' + self.str_SharkSim_Base_Path + 'v2_59_Py27\\Prod\\WF_POP_10000_NE2_SAMP_V1'
                        dictExperiment['Base_Path'] = strFilePath_Base
    
                        '''
                        ?? ENTER Experiment base path ---->
                        '''                    
                        str_Pop_Source_Run_UID = 'SS_2_59_Run_2015_03_22_18_03_55'
                        dictExperiment['Pop_Source_Unique_Run_ID'] = str_Pop_Source_Run_UID
    
                        '''
                        VSP to sample
                        '''
                        str_VSP_Name_To_Sample = globalsSS.VSP_LifeStage.static_string_Life_Stage_VSP_Name_Embryo
                        dictExperiment['VSP_Name_To_Sample'] = str_VSP_Name_To_Sample
    
                        '''
                        ?? ENTER Batch and Replicate to experiment on ---->
                        '''                    
                        '''Key to match with SS LEVEL VSP'''
                        int_Batch = 1
                        dictExperiment['Source_Batch'] = int_Batch 
                        #int_Rep = 1
                        dictExperiment['Source_Replicate'] = int_Rep
                        str_Source_Unique_Run_Batch_Rep_VSP_ID = str_Pop_Source_Run_UID + '_' + str(int_Batch) + '_' + str(int_Rep) + '_' + str_VSP_Name_To_Sample
                        dictExperiment['Source_Unique_Run_Batch_Rep_VSP_ID'] = str_Source_Unique_Run_Batch_Rep_VSP_ID
                        str_Pop_Batch = str(int_Batch)
                        str_Pop_Batch_Out = str_Pop_Batch.zfill(len(str_Pop_Batch))                    
                        str_Pop_Replicate = str(int_Rep)
                        str_Pop_Replicate_Out = str_Pop_Replicate.zfill(len(str_Pop_Replicate))                    
    
                        '''
                        Pop file to experiment on
                        '''
                        #str_Pop_Source_File_Name_WO_Suffix = 'SS_2_59_pop_full_2015_03_22_13_51_18_{1_20_10_0_4.8_1000_1_2_3_2_1_333}_rep_001'
                        str_Pop_File_Name_Prefix = str_Pop_Source_Run_UID[:7] + '_pop_full_' + str_Pop_Source_Run_UID[12:36] + '_rep_' + str(int_Rep).zfill(3)
                        str_Pop_File_Type_Suffix = globalsSS.SS_Replicate_Details.static_Output_File_Suffix__SimuPOP_Pop_EOR
                        str_Pop_Source_File_Name = str_Pop_File_Name_Prefix + str_Pop_File_Type_Suffix
                        dictExperiment['Pop_Source_File_Name'] = str_Pop_Source_File_Name
                        
                        '''
                        Replicates
                        '''
                        dictExperiment['Replicates'] = int_Replicates_Per_Experiment
                        
                        '''
                        Sampling method
                        '''
                        intSamplingMethod = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohort
                        dictExperiment['Sampling_Method'] = intSamplingMethod
    
                        '''
                        Loci to remove from sample
                        '''
                        #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20']
                        listLociToRemove = [] #None assumes keep all
                        dictExperiment['Loci_To_Remove'] = listLociToRemove
                        '''
                        Experiment sampling amount and path/label
                        '''
                        if int_Current_Experiment == 1:
                            str_Experiment_Label = 'Rand_5pc_of_Embryos_PC0'
                            dictExperiment['Experiment_Label'] = str_Experiment_Label
                            strFileName_AnalysisPath = str_Experiment_Label + '_B_' + str_Pop_Batch_Out + '_R_' + str_Pop_Replicate_Out
                            dictExperiment['FileName_AnalysisPath'] = strFileName_AnalysisPath
                            floatProportionOfVSP_Embryo = 0.05
                        
                        elif int_Current_Experiment == 2:
                            str_Experiment_Label = 'Rand_10pc_of_Embryos_PC0'
                            dictExperiment['Experiment_Label'] = str_Experiment_Label
                            strFileName_AnalysisPath = str_Experiment_Label + '_B_' + str_Pop_Batch_Out + '_R_' + str_Pop_Replicate_Out
                            dictExperiment['FileName_AnalysisPath'] = strFileName_AnalysisPath
                            floatProportionOfVSP_Embryo = 0.10
                       
                        elif int_Current_Experiment == 3:
                            str_Experiment_Label = 'Rand_20pc_of_Embryos_PC0'
                            dictExperiment['Experiment_Label'] = str_Experiment_Label
                            strFileName_AnalysisPath = str_Experiment_Label + '_B_' + str_Pop_Batch_Out + '_R_' + str_Pop_Replicate_Out
                            dictExperiment['FileName_AnalysisPath'] = strFileName_AnalysisPath
                            floatProportionOfVSP_Embryo = 0.20
                       
                        elif int_Current_Experiment == 4:
                            str_Experiment_Label = 'Rand_30pc_of_Embryos_PC0'
                            dictExperiment['Experiment_Label'] = str_Experiment_Label
                            strFileName_AnalysisPath = str_Experiment_Label + '_B_' + str_Pop_Batch_Out + '_R_' + str_Pop_Replicate_Out
                            dictExperiment['FileName_AnalysisPath'] = strFileName_AnalysisPath
                            floatProportionOfVSP_Embryo = 0.30
                       
                        elif int_Current_Experiment == 5:
                            str_Experiment_Label = 'Rand_40pc_of_Embryos_PC0'
                            dictExperiment['Experiment_Label'] = str_Experiment_Label
                            strFileName_AnalysisPath = str_Experiment_Label + '_B_' + str_Pop_Batch_Out + '_R_' + str_Pop_Replicate_Out
                            dictExperiment['FileName_AnalysisPath'] = strFileName_AnalysisPath
                            floatProportionOfVSP_Embryo = 0.40
                        pass                        
                        
                        '''
                        Experiment sampling params
                        '''
                        dictExperiment['Proportion_Of_VSP_To_Sample'] = floatProportionOfVSP_Embryo
                        odictAgeCohortSampleNumbers = OrderedDict([(0,floatProportionOfVSP_Embryo),(12,0),(24,0),(36,0)])
                        dictSamplingParams = {}
                        dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleNumbers
                        dictExperiment['Sampling_Params'] = dictSamplingParams
                        
                        '''
                        Add to dict of experiments
                        '''
                        dictExperiments[int_Current_Experiment] = dictExperiment
                    pass
                
                    dictExperiments_Per_Pop_Rep[int_Rep] = dictExperiments
                pass
            
                return dictExperiments_Per_Pop_Rep
                
            def method_SubSample_Pop_And_Produce_Ne2_Estimates(self):

                dictExperiments_Per_Pop_Rep = self.method_Define_Ne2_Experiments()

                                
                for keyEmperiments_Per_Rep_Num, valueDictExperiments in dictExperiments_Per_Pop_Rep.items():
                    
                    for keyEmperimentNum, valueDictExperiment in valueDictExperiments.items():
                        
                        dictExperiment = valueDictExperiment
                        
                       
                        #str_Source_Unique_Run_Batch_Rep_VSP_ID = dictExperiment['Source_Unique_Run_Batch_Rep_VSP_ID']
                        str_Experiment_Base_Path = dictExperiment['Base_Path']
                        str_Experiment_Source_UID = dictExperiment['Pop_Source_Unique_Run_ID']
                        strFilePath_Working = str_Experiment_Base_Path + '\\' + str_Experiment_Source_UID + '\\'
                        
                        dict_Results = OrderedDict()
    
                        #int_Batch = dictExperiment['Source_Batch']  
                        #int_Rep = dictExperiment['Source_Replicate']
                        #str_Pop_Batch = str(int_Batch)
                        #str_Pop_Batch_Out = str_Pop_Batch.zfill(len(str_Pop_Batch))                    
                        #str_Pop_Replicate = str(int_Rep)
                        #str_Pop_Replicate_Out = str_Pop_Replicate.zfill(len(str_Pop_Replicate))                    
    
                        ''' Get logger to record results '''
                        str_Experiment = str(dictExperiment['Current_Experiment'])
                        str_Experiment = str_Experiment.zfill(len(str_Experiment))
                        strFileName_Experiment_Label = dictExperiment['FileName_AnalysisPath']
                        strFileName_AnalysisPath = dictExperiment['FileName_AnalysisPath']
                        strFilePath_Export = strFilePath_Working + strFileName_AnalysisPath
                        with FileHandler() as obj_File_Op:
                            obj_File_Op.method_Create_Path(strFilePath_Export)
                        #str_Logger_Name = self.objSSParametersLocal.strUniqueRunID + '_B_' + str_Pop_Batch_Out + '_R_' + str_Pop_Replicate_Out + '_' + globalsSS.Logger_Details_Sampling.static_Logger_Name__Genepop_Ne2_Samples + '_' + strFileName_Experiment_Label + '_' + str_Experiment + globalsSS.Logger_Details_Sampling.static_Logger_File_Suffix__Genepop_Ne2_Samples
                        str_Logger_Name = self.objSSParametersLocal.strUniqueRunID + globalsSS.Logger_Details_Sampling.static_Logger_Name__Genepop_Ne2_Samples + '_' + strFileName_Experiment_Label + '_' + str_Experiment + globalsSS.Logger_Details_Sampling.static_Logger_File_Suffix__Genepop_Ne2_Samples
                        obj_Logging = self.func_Get_Func_Specific_Logger_Name(strFilePath_Export, str_Logger_Name)
        
                        ''' Create logger to record results '''
                        int_Level = 1
                        str_Logger_Name = obj_Logging.strLogFile
                        obj_Log_Results = self.func_Get_Func_Specific_Python_Logger(obj_Logging)    
                            
                        ''' Check if logger already exists - i.e. Genepop data file already processed for this function'''
                        with FileHandler() as objFileOperation:
                            boolFileExistsAtDestination = objFileOperation.fileExists(obj_Logging.strLogPath + '\\' + obj_Logging.strLogFile)
                        
                        bool_Load_SS_Pop = True
                        if bool_Load_SS_Pop:                    
                            '''
                            -----------------------------------
                            Load simulated population
                            -----------------------------------
                            '''
    #                         strFileNameSuffix_Import = globalsSS.SS_Replicate_Details.static_Output_File_Suffix__SimuPOP_Pop_EOR
    #                         #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
    #                         strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2_59_Py27\\Test\\TEST_WF_MATING_V4\\SS_2_59_Run_2015_03_22_13_51_18\\'
    #                         strFileName_Import = 'SS_2_59_pop_full_2015_03_22_13_51_18_{1_20_10_0_4.8_1000_1_2_3_2_1_333}_rep_001'  #Simulated
    #                         strPop_Imported_UID = strFileName_Import[:7] + '_Run_' + strFileName_Import[17:36]
                            str_Pop_Source_File_Path = strFilePath_Working
                            str_Pop_Source_File_Name = dictExperiment['Pop_Source_File_Name']
                            str_Pop_Source_File_Path_And_Name = str_Pop_Source_File_Path + str_Pop_Source_File_Name
                            
                            #listLociToRemove = ['Locus-15','Locus-16','Locus-17','Locus-18','Locus-19','Locus-20'] #None assumes all
                            #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20'] #None assumes all
                            #listLociToRemove = [] #None assumes all
                            listLociToRemove = dictExperiment['Loci_To_Remove']
                            #Load pop
                            #strSimuPop_Pop_FilePathAndName = strFilePath_Import + strFileName_Import + strFileNameSuffix_Import
                            with SSOutputHandler() as objSSOutputOperation:
                                listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                strMessage = 'SubSample_Pop_And_Produce_Ne2_Estimates - Import population: ' + str_Pop_Source_File_Name + ' and remove loci: ' + str(listLociToRemove)
                                objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, strMessage, boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        
                            pop_Imported = self.method_Load_SimuPop_Population(str_Pop_Source_File_Path_And_Name)
                            
                        pass
        
                        bool_SubSample_SS_Pop = True
                        if bool_SubSample_SS_Pop:    
                            '''
                            -----------------------------------
                            Sub-sample loaded population
                            -----------------------------------
                            '''
                            dictSamplingParams = {}
    #                         boolCohortDependentSample = True
    #                         if boolCohortDependentSample:
    #                             intSamplingMethod = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohort
    #                             
    #                             #strFileName_AnalysisPath = 'Rand_5pc_of_Embryos'
    #                             #floatPercentageOfVSP_Embryo = 0.05
    #                             strFileName_AnalysisPath = 'Rand_10pc_of_Embryos'
    #                             floatPercentageOfVSP_Embryo = 0.10
    #                             #strFileName_AnalysisPath = 'Rand_20pc_of_Embryos'
    #                             #floatPercentageOfVSP_Embryo = 0.20
    #                             #strFileName_AnalysisPath = 'Rand_30pc_of_Embryos'
    #                             #floatPercentageOfVSP_Embryo = 0.30
    #                             #strFileName_AnalysisPath = 'Rand_40pc_of_Embryos'
    #                             #floatPercentageOfVSP_Embryo = 0.40
    #                             
    #                             odictAgeCohortSampleNumbers = OrderedDict([(0,floatPercentageOfVSP_Embryo),(12,0),(24,0),(36,0)])
    #                             dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleNumbers
    #                                                     
    #                         else:
    #                             intSamplingMethod = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
    #                             #strFileName_AnalysisPath = 'Rand_5pc'
    #                             #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.05
    #                             #strFileName_AnalysisPath = 'Rand_10pc'
    #                             #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.10
    #                             strFileName_AnalysisPath = 'Rand_20pc'
    #                             dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.20
    #                             #strFileName_AnalysisPath = 'Rand_30pc'
    #                             #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.30
    #                             #strFileName_AnalysisPath = 'Rand_40pc'
    #                             #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.40
    #                             #strFileName_AnalysisPath = 'Rand_50pc'
    #                             #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.50
    #                         pass
                            
    
                            #intNumberOfReplicates = 10
                            intNumberOfReplicates = dictExperiment['Replicates']
                            #str_Replicates_Per_Experiment = str(intNumberOfReplicates)
                            #str_Replicates_Per_Experiment_Out = str_Replicates_Per_Experiment.zfill(len(str_Replicates_Per_Experiment))                    
                            
                            for intReplicate in range(0, intNumberOfReplicates):
                                
                                intGenepopFileCount = intReplicate
    
                                str_Experiment_Label = dictExperiment['Experiment_Label']
                                dict_Results['Experiment_Label'] = str_Experiment_Label
        
                                dict_Results['Source_UID'] = str_Experiment_Source_UID
                                '''Key to match with SS LEVEL VSP'''
    #                             int_Batch = 1
    #                             int_Rep = 1
    #                             str_VSP_Name = globalsSS.VSP_LifeStage.static_string_Life_Stage_VSP_Name_Embryo
    #                             str_Source_Unique_Run_Batch_Rep_VSP_ID = strPop_Imported_UID + '_' + str(int_Batch) + '_' + str(int_Rep) + '_' + str_VSP_Name
    #                              dict_Results[globalsSS.Ne2_Sampling_Stats.static_Label_Gen_Source_Unique_Run_Batch_Rep_VSP_ID] = str_Source_Unique_Run_Batch_Rep_VSP_ID
                                str_Source_Unique_Run_Batch_Rep_VSP_ID = dictExperiment['Source_Unique_Run_Batch_Rep_VSP_ID']   
                                dict_Results[globalsSS.Ne2_Sampling_Stats.static_Label_Gen_Source_Unique_Run_Batch_Rep_VSP_ID] = str_Source_Unique_Run_Batch_Rep_VSP_ID
                                
                                dict_Results['Source_Pop'] = str_Pop_Source_File_Name
                                dict_Results['Loci_To_Remove'] = ','.join(map(str, listLociToRemove))
                                dictSamplingParams = dictExperiment['Sampling_Params']
                                dict_Results['Sampling_Params'] = dictSamplingParams
                                intSamplingMethod = dictExperiment['Sampling_Method']
                                pop_SubSample_Orig, dict_Results = self.method_SubSample_Simulated_Dataset(pop_Imported, intSamplingMethod, dictSamplingParams, listLociToRemove, intNumberOfReplicates , intGenepopFileCount, dict_Results)
                                intSubSampleSize = pop_SubSample_Orig.subPopSize() 
                                
                                '''
                                Export the sampled pop as a Genepop file
                                '''
                                with FileHandler() as objFileOperation:
                                    tupFilePathNameAndExt = objFileOperation.method_Get_FileNameAndExtension_From_FileName(str_Pop_Source_File_Path_And_Name)
                                    strPathFileName_ImportWOSuffix = objFileOperation.method_Get_FileName_From_PathAndFileName(tupFilePathNameAndExt[0])
                                
                                strFileName_AnalysisPath = dictExperiment['FileName_AnalysisPath']
                                strFilePath_Export = strFilePath_Working + strFileName_AnalysisPath
                                with FileHandler() as obj_File_Op:
                                    obj_File_Op.method_Create_Path(strFilePath_Export)
                                
                                strFileNameSuffix_Export = '.gp_gspy'
                                strFileNameCode_Export = 'SJN2'
                                str_Genepop_File_Count = str(intGenepopFileCount)
                                str_Genepop_File_Count_Out = str_Genepop_File_Count.zfill(len(str_Genepop_File_Count))
                                
                                strFilename_Export = strPathFileName_ImportWOSuffix[:36] + strFileNameCode_Export + '_' + str(intSubSampleSize) + '_' + strFileName_AnalysisPath + '_' + str_Genepop_File_Count_Out + strFileNameSuffix_Export
                                #strFilename_Export = str_Source_Unique_Run_Batch_Rep_VSP_ID + '_' + strFileNameCode_Export + '_' + str(intSubSampleSize) + '_' + strFileName_AnalysisPath + '_' + str_Genepop_File_Count_Out + strFileNameSuffix_Export
                                strFilePathAndNameFull_Export = strFilePath_Export + '\\' + strFilename_Export 
                                '''
                                Create GENEPOP file
                                IMPORTANT - Allele adjust means the difference between an allele and missing data
                                if your data has zeros as missing data - set this to zero
                                if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                                '''
                                intAlleleAdjust = 1
                                bool_Prevent_Internal_Function_Console_Output = True
                                bool_Prevent_External_Function_Console_Output = True
        
                                dict_Results['Total_Samples'] = intNumberOfReplicates
                                dict_Results['Sample'] = str(intGenepopFileCount)
                                dict_Results['File'] = strFilename_Export
                                
                                boolSuccess = self.method_Export_Genotypes(pop_SubSample_Orig, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))
            
                                if boolSuccess == False:
                                    #LOGGING
                                    with SSOutputHandler() as objSSOutputOperation:
                                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                        #listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                                        stringMessage = '!!!ERROR - File create failed ERROR!!!; File: ' + strFilename_Export
                                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                        
                                        #DEBUG_ON                    
                                        simupop.dump(pop_SubSample_Orig)
                                        #DEBUG_OFF
            
                                        objSSOutputOperation.method_Pause_Console()
                                    #LOGGING
                                else:    
                                        
                                        
                                    #LOGGING
                                    with SSOutputHandler() as objSSOutputOperation:
                                        #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                        listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                        stringMessage = '>GENEPOP file exported: ' + strFilename_Export
                                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                        #objSSOutputOperation.method_Pause_Console()
                                    #LOGGING
                
                                    bool_Process_Genepop_With_Ne2 = True
                                    if bool_Process_Genepop_With_Ne2:    
                    
                                        '''
                                        -----------------------------------
                                        For generated genepop files process Ne2
                                        -----------------------------------
                                        '''
                                            
                                        bool_Use_Ne2_Win_DLL = True
                                        if bool_Use_Ne2_Win_DLL:
                                            strFilePath_Working_Ne2 = strFilePath_Export
                                            bool_Suppress_ALL_LDNe_Console_Output = False
                                            obj_SSNe2_Win_DLL = self.method_Process_Genepop_File_Using_Ne2_Win_DLL(bool_Suppress_ALL_LDNe_Console_Output, strFilePath_Working_Ne2, strFilename_Export, intGenepopFileCount)
                                        
                                            '''
                                            ------------------------------
                                            Extract Ne2 Results
                                            ------------------------------
                                            '''
                                            dict_Results['Ne'] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)
        
                                            dict_Results["c_intNeLoci"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeLoci)
                                            dict_Results["c_intNeSamples"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeSamples)
                                            dict_Results["c_strPopID"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_strPopID)
                                            
                                            dict_Results["c_intNeLoci"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Locus_Info.c_intNeLoci)
                                            
                                            dict_Results["c_intMatingScheme"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intMatingScheme)
                                            dict_Results["c_intIndependentAlleles"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intIndependentAlleles)
                                            dict_Results["c_floatWeightedMeanSampleSize"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatWeightedMeanSampleSize)
                                            dict_Results["c_floatPCrit"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatPCrit)
                                            dict_Results["c_floatRSquared_Observed"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Observed)
                                            dict_Results["c_floatRSquared_Expected"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Expected)
                                            
                                            dict_Results["c_floatLDNe"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)
                                            dict_Results["c_floatLDNeParametric_Lwr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Lwr_CI)
                                            dict_Results["c_floatLDNeParametric_Upr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Upr_CI)
                                            dict_Results["c_floatLDNeJackknife_Lwr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Lwr_CI)
                                            dict_Results["c_floatLDNeJackknife_Upr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Upr_CI)
                                        
                                            print('\n')
                                        pass
                                    
                                        '''
                                        --------------------------
                                        Log the results
                                        --------------------------
                                        '''
                                        if intGenepopFileCount == 0:
                                            self.Log_Ne2_Samples_Header(obj_Log_Results, dict_Results)
                                            self.Log_Ne2_Samples_Results(obj_Log_Results, dict_Results)
                                        else:
                                            self.Log_Ne2_Samples_Results(obj_Log_Results, dict_Results)
                                        pass
                                    pass
                    pass
                pass
            
                ''' Clear the log handlers'''
                obj_Log_Results.handlers = []

                return True

            def method_Get_Ne2_Ne2_Win_DLL_From_Genepop_Files(self):

                strFilePath_Working = 'C:\\' + self.str_SharkSim_Base_Path + 'v2_57_Py27\\Prod\\CAOB_LOCUS_COMBO_SAMPLING_V4\\SS_2_57_Run_2015_03_12_16_00_19\\0\\'

                ''' Get logger to record results '''

                strFileName_Experiment_Label = 'Test'
                str_Experiment = ''
                strFileName_AnalysisPath = 'Ne2_Win_DLL_From_Genepop_Files'
                strFilePath_Log = strFilePath_Working + strFileName_AnalysisPath
                with FileHandler() as obj_File_Op:
                    obj_File_Op.method_Create_Path(strFilePath_Log)
                
                str_Logger_Name = self.objSSParametersLocal.strUniqueRunID + globalsSS.Logger_Details_Sampling.static_Logger_Name__Genepop_Ne2_Samples + '_' + strFileName_Experiment_Label + '_' + str_Experiment + globalsSS.Logger_Details_Sampling.static_Logger_File_Suffix__Genepop_Ne2_Samples
                obj_Logging = self.func_Get_Func_Specific_Logger_Name(strFilePath_Log, str_Logger_Name)

                ''' Create logger to record results '''
                int_Level = 1
                str_Logger_Name = obj_Logging.strLogFile
                obj_Log_Results = self.func_Get_Func_Specific_Python_Logger(obj_Logging)    
                    
                ''' Check if logger already exists - i.e. Genepop data file already processed for this function'''
                with FileHandler() as objFileOperation:
                    boolFileExistsAtDestination = objFileOperation.fileExists(obj_Logging.strLogPath + '\\' + obj_Logging.strLogFile)
                pass
                
                ''' Get filenames to process'''
                str_Search_Path = strFilePath_Working
                #str_File_Search_Pattern = '*EESL*.lc'
                strFileNameSuffix_Import = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Suffix__Locus_Jackknifing
                strFileNameCode_Import = globalsSS.Genepop_Results_File_Details.static_Genepop_File_Name__Locus_Jackknifing
                str_File_Search_Pattern = '*' + strFileNameCode_Import + '*' + strFileNameSuffix_Import

                bool_Files_Located, list_Path_And_Files = self.method_Get_List_Of_Files_For_Processing(str_Search_Path, str_File_Search_Pattern)
            
            
                ''' Process file by file if located'''            
                if bool_Files_Located:
                   
                    dict_Results = OrderedDict()
                    intGenepopFileCount = 0
                    str_Path_And_File = ''
                    
                    '''Process each file in turn'''
                    for str_Path_And_File in list_Path_And_Files:
                        

                        
                        intGenepopFileCount += 1
                        
                        str_Path, str_File = os.path.split(str_Path_And_File)
                        strFilename_Genepop = str_File
                        strFilePath_Working_Ne2 = str_Path
                        strUniqueRunID = self.objSharkSimOperationLocal.strUniqueRunID
                        str_OutputResultsPath = self.objSharkSimOperationLocal.outfilePath
                        float_LDNe_PCrit = 0.02
                        bool_Suppress_ALL_LDNe_Console_Output = False
                        
                        dict_Results = self.method_Use_Ne2_Win_DLL_To_Produce_Estimates_From_Genepop_File(bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit, dict_Results)

                        '''
                        --------------------------
                        Log the results
                        --------------------------
                        '''
                        if intGenepopFileCount == 1:
                            self.Log_Ne2_Samples_Header(obj_Log_Results, dict_Results)
                            self.Log_Ne2_Samples_Results(obj_Log_Results, dict_Results)
                        else:
                            self.Log_Ne2_Samples_Results(obj_Log_Results, dict_Results)
                        pass 
                    pass
                pass

           
                ''' Clear the log handlers'''
                obj_Log_Results.handlers = []
                            
                return True
            
            def method_Get_List_Of_Files_For_Processing(self, str_Search_Path, str_File_Search_Pattern):
        
                bool_Files_Located = False
         
                with FileHandler() as obj_File_Op:
                    bool_Files_Located, list_Path_And_Files = obj_File_Op.func_Locate_Files(str_Search_Path, str_File_Search_Pattern)
                pass
                
                return bool_Files_Located, list_Path_And_Files
 
            
            def method_Use_Ne2_Win_DLL_To_Produce_Estimates_From_Genepop_File(self, bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit, dict_Results_By_PCrit): 
            
                '''
                -----------------------------------
                For generated genepop files process Ne2
                -----------------------------------
                '''
                    
                obj_SSNe2_Win_DLL = self.method_Process_Genepop_File_Using_Ne2_Win_DLL(bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit)
            
                '''
                ------------------------------
                Extract Ne2 Results
                ------------------------------
                '''
                #dict_Results_By_PCrit[float_LDNe_PCrit] = {'Ne': str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)}

                
                dict_Results_By_PCrit[float_LDNe_PCrit] = OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intNeLoci, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeLoci))])
                #dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intNeLoci: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeLoci)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intNeSamples, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeSamples))]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_strPopID, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_strPopID))]))
                
                #dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intNeLoci, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Locus_Info.c_intNeLoci))]))
                
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intMatingScheme, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intMatingScheme))]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intIndependentAlleles, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intIndependentAlleles))]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatWeightedMeanSampleSize, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatWeightedMeanSampleSize))]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatPCrit, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatPCrit))]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatRSquared_Observed, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Observed))]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatRSquared_Expected, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Expected))]))
                
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatLDNe, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe))]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatLDNeParametric_Lwr_CI, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Lwr_CI))]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatLDNeParametric_Upr_CI, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Upr_CI))]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatLDNeJackknife_Lwr_CI, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Lwr_CI))]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatLDNeJackknife_Upr_CI, str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Upr_CI))]))
            
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Genepop_Source_File, strFilename_Genepop)]))
                dict_Results_By_PCrit[float_LDNe_PCrit].update(OrderedDict([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Genepop_Source_Path, strFilePath_Working_Ne2)]))
                
                return dict_Results_By_PCrit
            
            def method_Use_Ne2_Win_DLL_To_Produce_Estimates_From_Genepop_File_OLD(self, bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit, dict_Results_By_PCrit): 
            
                '''
                -----------------------------------
                For generated genepop files process Ne2
                -----------------------------------
                '''
                    
                obj_SSNe2_Win_DLL = self.method_Process_Genepop_File_Using_Ne2_Win_DLL(bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit)
            
                '''
                ------------------------------
                Extract Ne2 Results
                ------------------------------
                '''
                #dict_Results_By_PCrit[float_LDNe_PCrit] = {'Ne': str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)}

                
                dict_Results_By_PCrit[float_LDNe_PCrit] = {globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intNeLoci: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeLoci)}
                #dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intNeLoci: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeLoci)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intNeSamples: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeSamples)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_strPopID: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_strPopID)})
                
                #dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intNeLoci: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Locus_Info.c_intNeLoci)})
                
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intMatingScheme: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intMatingScheme)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_intIndependentAlleles: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intIndependentAlleles)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatWeightedMeanSampleSize: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatWeightedMeanSampleSize)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatPCrit: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatPCrit)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatRSquared_Observed: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Observed)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatRSquared_Expected: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Expected)})
                
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatLDNe: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatLDNeParametric_Lwr_CI: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Lwr_CI)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatLDNeParametric_Upr_CI: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Upr_CI)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatLDNeJackknife_Lwr_CI: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Lwr_CI)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatLDNeJackknife_Upr_CI: str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Upr_CI)})
            
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Genepop_Source_File: strFilename_Genepop})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({globalsSS.Colnames_Ne2_Output.static_Str_Colname_Genepop_Source_Path: strFilePath_Working_Ne2})
                
                return dict_Results_By_PCrit
            
            def method_Use_Ne2_Win_DLL_To_Produce_Estimates_From_Genepop_File_DELETE(self, bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit, dict_Results_By_PCrit): 
            
                '''
                -----------------------------------
                For generated genepop files process Ne2
                -----------------------------------
                '''
                    
                obj_SSNe2_Win_DLL = self.method_Process_Genepop_File_Using_Ne2_Win_DLL(bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit)
            
                '''
                ------------------------------
                Extract Ne2 Results
                ------------------------------
                '''
                #dict_Results_By_PCrit[float_LDNe_PCrit] = {'Ne': str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)}

                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_intNeLoci": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeLoci)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_intNeSamples": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeSamples)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_strPopID": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_strPopID)})
                
                #dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_intNeLoci": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Locus_Info.c_intNeLoci)})
                
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_intMatingScheme": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intMatingScheme)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_intIndependentAlleles": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intIndependentAlleles)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_floatWeightedMeanSampleSize": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatWeightedMeanSampleSize)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_floatPCrit": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatPCrit)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_floatRSquared_Observed": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Observed)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_floatRSquared_Expected": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Expected)})
                
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_floatLDNe": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_floatLDNeParametric_Lwr_CI": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Lwr_CI)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_floatLDNeParametric_Upr_CI": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Upr_CI)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_floatLDNeJackknife_Lwr_CI": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Lwr_CI)})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({"c_floatLDNeJackknife_Upr_CI": str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Upr_CI)})
            
                dict_Results_By_PCrit[float_LDNe_PCrit].update({'Genepop_Source_File': strFilename_Genepop})
                dict_Results_By_PCrit[float_LDNe_PCrit].update({'Genepop_Source_Path': strFilePath_Working_Ne2})
                
                return dict_Results_By_PCrit
            
            def method_Use_Ne2_Win_DLL_To_Produce_Estimates_From_Genepop_File_ORIG(self, bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit, dict_Results): 
            
                '''
                -----------------------------------
                For generated genepop files process Ne2
                -----------------------------------
                '''
                    
                obj_SSNe2_Win_DLL = self.method_Process_Genepop_File_Using_Ne2_Win_DLL(bool_Suppress_ALL_LDNe_Console_Output, strUniqueRunID, str_OutputResultsPath, strFilePath_Working_Ne2, strFilename_Genepop, intGenepopFileCount, float_LDNe_PCrit)
            
                '''
                ------------------------------
                Extract Ne2 Results
                ------------------------------
                '''
                dict_Results['Ne'] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)

                dict_Results["c_intNeLoci"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeLoci)
                dict_Results["c_intNeSamples"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeSamples)
                dict_Results["c_strPopID"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_strPopID)
                
                dict_Results["c_intNeLoci"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Locus_Info.c_intNeLoci)
                
                dict_Results["c_intMatingScheme"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intMatingScheme)
                dict_Results["c_intIndependentAlleles"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intIndependentAlleles)
                dict_Results["c_floatWeightedMeanSampleSize"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatWeightedMeanSampleSize)
                dict_Results["c_floatPCrit"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatPCrit)
                dict_Results["c_floatRSquared_Observed"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Observed)
                dict_Results["c_floatRSquared_Expected"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Expected)
                
                dict_Results["c_floatLDNe"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)
                dict_Results["c_floatLDNeParametric_Lwr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Lwr_CI)
                dict_Results["c_floatLDNeParametric_Upr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Upr_CI)
                dict_Results["c_floatLDNeJackknife_Lwr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Lwr_CI)
                dict_Results["c_floatLDNeJackknife_Upr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Upr_CI)
            
                dict_Results['Genepop_Source_File'] = strFilename_Genepop
                dict_Results['Genepop_Source_Path'] = strFilePath_Working_Ne2


                return dict_Results

            def method_SubSample_Pop_And_Produce_Ne2_Estimates_ORIG(self):

                #strFilePath_Working = self.objSSParametersLocal.outfilePath
                strFilePath_Working = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2_59_Py27\\Test\\TEST_WF_MATING_V4\\SS_2_59_Run_2015_03_22_13_51_18\\'
                
                dict_Results = OrderedDict()
                
                ''' Get logger to record results '''
                str_Logger_Name = self.objSSParametersLocal.strUniqueRunID + '_' + globalsSS.Logger_Details_Sampling.static_Logger_Name__Genepop_Ne2_Samples + globalsSS.Logger_Details_Sampling.static_Logger_File_Suffix__Genepop_Ne2_Samples
                obj_Logging = self.func_Get_Func_Specific_Logger_Name(strFilePath_Working, str_Logger_Name)

                ''' Create logger to record results '''
                int_Level = 1
                str_Logger_Name = obj_Logging.strLogFile
                obj_Log_Results = self.func_Get_Func_Specific_Python_Logger(obj_Logging)    
                    
                ''' Check if logger already exists - i.e. Genepop data file already processed for this function'''
                with FileHandler() as objFileOperation:
                    boolFileExistsAtDestination = objFileOperation.fileExists(obj_Logging.strLogPath + '\\' + obj_Logging.strLogFile)
                
                bool_Load_SS_Pop = True
                if bool_Load_SS_Pop:                    
                    '''
                    -----------------------------------
                    Load simulated population
                    -----------------------------------
                    '''
                    strFileNameSuffix_Import = globalsSS.SS_Replicate_Details.static_Output_File_Suffix__SimuPOP_Pop_EOR
                    #strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
                    strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\SharkSim\\v2_59_Py27\\Test\\TEST_WF_MATING_V4\\SS_2_59_Run_2015_03_22_13_51_18\\'
                    strFileName_Import = 'SS_2_59_pop_full_2015_03_22_13_51_18_{1_20_10_0_4.8_1000_1_2_3_2_1_333}_rep_001'  #Simulated
                    strPop_Imported_UID = strFileName_Import[:7] + '_Run_' + strFileName_Import[17:36]
                    #listLociToRemove = ['Locus-15','Locus-16','Locus-17','Locus-18','Locus-19','Locus-20'] #None assumes all
                    #listLociToRemove = ['Locus-17','Locus-18','Locus-19','Locus-20'] #None assumes all
                    listLociToRemove = [] #None assumes all
                    #Load pop
                    strSimuPop_Pop_FilePathAndName = strFilePath_Import + strFileName_Import + strFileNameSuffix_Import
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        strMessage = 'SubSample_Pop_And_Produce_Ne2_Estimates - Import population: ' + strFileName_Import + ' and remove loci: ' + str(listLociToRemove)
                        objSSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, strMessage, boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                
                    pop_Imported = self.method_Load_SimuPop_Population(strSimuPop_Pop_FilePathAndName)
                    
                pass

                bool_SubSample_SS_Pop = True
                if bool_SubSample_SS_Pop:    
                    '''
                    -----------------------------------
                    Sub-sample loaded population
                    -----------------------------------
                    '''
                    dictSamplingParams = {}
                    boolCohortDependentSample = True
                    if boolCohortDependentSample:
                        intSamplingMethod = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsProportionPerVSPCohort
                        
                        #strFileName_AnalysisPath = 'Rand_5pc_of_Embryos'
                        #floatPercentageOfVSP_Embryo = 0.05
                        strFileName_AnalysisPath = 'Rand_10pc_of_Embryos'
                        floatPercentageOfVSP_Embryo = 0.10
                        #strFileName_AnalysisPath = 'Rand_20pc_of_Embryos'
                        #floatPercentageOfVSP_Embryo = 0.20
                        #strFileName_AnalysisPath = 'Rand_30pc_of_Embryos'
                        #floatPercentageOfVSP_Embryo = 0.30
                        #strFileName_AnalysisPath = 'Rand_40pc_of_Embryos'
                        #floatPercentageOfVSP_Embryo = 0.40
                        
                        odictAgeCohortSampleNumbers = OrderedDict([(0,floatPercentageOfVSP_Embryo),(12,0),(24,0),(36,0)])
                        dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_SampleSizeIsProportionPerVSPCohort] = odictAgeCohortSampleNumbers
                                                
                    else:
                        intSamplingMethod = globalsSS.Sampling_SamplingMethod.static_SamplingMethod_SampleSizeIsNonCohortRandom
                        #strFileName_AnalysisPath = 'Rand_5pc'
                        #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.05
                        #strFileName_AnalysisPath = 'Rand_10pc'
                        #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.10
                        strFileName_AnalysisPath = 'Rand_20pc'
                        dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.20
                        #strFileName_AnalysisPath = 'Rand_30pc'
                        #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.30
                        #strFileName_AnalysisPath = 'Rand_40pc'
                        #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.40
                        #strFileName_AnalysisPath = 'Rand_50pc'
                        #dictSamplingParams[globalsSS.Sampling_SamplingParameters.static_PercentageOfTotalPopulation] = 0.50
                    pass
                    
                    intNumberOfReplicates = 10
                    
                    for intReplicate in range(0, intNumberOfReplicates):
                        
                        intGenepopFileCount = intReplicate

                        dict_Results['Source_UID'] = strPop_Imported_UID
                        '''Key to match with SS LEVEL VSP'''
                        int_Batch = 1
                        int_Rep = 1
                        str_VSP_Name = globalsSS.VSP_LifeStage.static_string_Life_Stage_VSP_Name_Embryo
                        str_Source_Unique_Run_Batch_Rep_VSP_ID = strPop_Imported_UID + '_' + str(int_Batch) + '_' + str(int_Rep) + '_' + str_VSP_Name
                        dict_Results[globalsSS.Ne2_Sampling_Stats.static_Label_Gen_Source_Unique_Run_Batch_Rep_VSP_ID] = str_Source_Unique_Run_Batch_Rep_VSP_ID
                        
                        dict_Results['Source_Pop'] = strFileName_Import
                        dict_Results['Loci_To_Remove'] = ','.join(map(str, listLociToRemove)) 
                        dict_Results['Sampling_Params'] = dictSamplingParams
                        
                        pop_SubSample_Orig, dict_Results = self.method_SubSample_Simulated_Dataset(pop_Imported, intSamplingMethod, dictSamplingParams, listLociToRemove, intNumberOfReplicates , intGenepopFileCount, dict_Results)
                        intSubSampleSize = pop_SubSample_Orig.subPopSize() 
                        
                        #Export that pop as a Genepop file
                        with FileHandler() as objFileOperation:
                            tupFilePathNameAndExt = objFileOperation.method_Get_FileNameAndExtension_From_FileName(strSimuPop_Pop_FilePathAndName)
                            strPathFileName_ImportWOSuffix = objFileOperation.method_Get_FileName_From_PathAndFileName(tupFilePathNameAndExt[0])
                        
                        #strFileName_AnalysisPath = 'Rand_5pc'
                        strFilePath_Export = strFilePath_Working + strFileName_AnalysisPath
                        with FileHandler() as obj_File_Op:
                            obj_File_Op.method_Create_Path(strFilePath_Export)
                        
                        strFileNameSuffix_Export = '.gp_gspy'
                        strFileNameCode_Export = 'SJN2'
                        strFilename_Export = strPathFileName_ImportWOSuffix[:36] + '_' + strFileNameCode_Export + '_' + str(intSubSampleSize) + '_' + strFileName_AnalysisPath + '_' + str(intGenepopFileCount).zfill(5) + strFileNameSuffix_Export
                        strFilePathAndNameFull_Export = strFilePath_Export + '\\' + strFilename_Export 
                        '''
                        Create GENEPOP file
                        IMPORTANT - Allele adjust means the difference between an allele and missing data
                        if your data has zeros as missing data - set this to zero
                        if your data is simulated - set this to 1 to avoid external programs assuming Allele 0 is missing data
                        '''
                        intAlleleAdjust = 1
                        bool_Prevent_Internal_Function_Console_Output = True
                        bool_Prevent_External_Function_Console_Output = True

                        dict_Results['Total_Samples'] = intNumberOfReplicates
                        dict_Results['Sample'] = str(intGenepopFileCount)
                        dict_Results['File'] = strFilename_Export
                        
                        boolSuccess = self.method_Export_Genotypes(pop_SubSample_Orig, intAlleleAdjust, strFilePathAndNameFull_Export, bool_Prevent_Internal_Function_Console_Output, bool_Prevent_External_Function_Console_Output, (True, False, True))
    
                        if boolSuccess == False:
                            #LOGGING
                            with SSOutputHandler() as objSSOutputOperation:
                                listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                #listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                                stringMessage = '!!!ERROR - File create failed ERROR!!!; File: ' + strFilename_Export
                                objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                
                                #DEBUG_ON                    
                                simupop.dump(pop_SubSample_Orig)
                                #DEBUG_OFF
    
                                objSSOutputOperation.method_Pause_Console()
                            #LOGGING
                        else:    
                                
                                
                            #LOGGING
                            with SSOutputHandler() as objSSOutputOperation:
                                #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                listOutputDestinations = [self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                                stringMessage = '>GENEPOP file exported: ' + strFilename_Export
                                objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                                #objSSOutputOperation.method_Pause_Console()
                            #LOGGING
        
                            bool_Process_Genepop_With_Ne2 = True
                            if bool_Process_Genepop_With_Ne2:    
            
                                '''
                                -----------------------------------
                                For generated genepop files process Ne2
                                -----------------------------------
                                '''
                                    
                                bool_Use_Ne2_Win_DLL = True
                                if bool_Use_Ne2_Win_DLL:
                                    strFilePath_Working_Ne2 = strFilePath_Export
                                    obj_SSNe2_Win_DLL = self.method_Process_Genepop_File_Using_Ne2_Win_DLL(strFilePath_Working_Ne2, strFilename_Export, intGenepopFileCount)
                                
                                    '''
                                    ------------------------------
                                    Extract Ne2 Results
                                    ------------------------------
                                    '''
                                    dict_Results['Ne'] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)

                                    dict_Results["c_intNeLoci"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeLoci)
                                    dict_Results["c_intNeSamples"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_intNeSamples)
                                    dict_Results["c_strPopID"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Pop_Info.c_strPopID)
                                    
                                    dict_Results["c_intNeLoci"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Locus_Info.c_intNeLoci)
                                    
                                    dict_Results["c_intMatingScheme"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intMatingScheme)
                                    dict_Results["c_intIndependentAlleles"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_intIndependentAlleles)
                                    dict_Results["c_floatWeightedMeanSampleSize"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatWeightedMeanSampleSize)
                                    dict_Results["c_floatPCrit"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatPCrit)
                                    dict_Results["c_floatRSquared_Observed"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Observed)
                                    dict_Results["c_floatRSquared_Expected"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Burrows_Info.c_floatRSquared_Expected)
                                    
                                    dict_Results["c_floatLDNe"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNe)
                                    dict_Results["c_floatLDNeParametric_Lwr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Lwr_CI)
                                    dict_Results["c_floatLDNeParametric_Upr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeParametric_Upr_CI)
                                    dict_Results["c_floatLDNeJackknife_Lwr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Lwr_CI)
                                    dict_Results["c_floatLDNeJackknife_Upr_CI"] = str(obj_SSNe2_Win_DLL.c_struct_Ne2_Output.c_struct_Ne2_Output_LDNe_Ne_Info.c_floatLDNeJackknife_Upr_CI)
                                
                                    print('\n')
                                pass
                            
                                '''
                                --------------------------
                                Log the results
                                --------------------------
                                '''
                                if intGenepopFileCount == 0:
                                    self.Log_Ne2_Samples_Header(obj_Log_Results, dict_Results)
                                    self.Log_Ne2_Samples_Results(obj_Log_Results, dict_Results)
                                else:
                                    self.Log_Ne2_Samples_Results(obj_Log_Results, dict_Results)
                                pass
                            pass
                
                ''' Clear the log handlers'''
                obj_Log_Results.handlers = []
                        
                

                return True
            
            '''
            --------------------------------------------------------------------------------------------------------
            # Main Processing
            --------------------------------------------------------------------------------------------------------
            '''
           
            def method_SamplingTest_Processing(self, objSSParameters, objSharkSimOperation):    

                with SSOutputHandler() as SSOutputOperation:
                    listOutputDestinations = ['console', objSSParameters.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - Main processing', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                
                boolInstant_Pop_From_Empirical_AlleleFreq = False
                if boolInstant_Pop_From_Empirical_AlleleFreq:
                    SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - Main processing - Sim pop with allele freqs', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                    
                    self.method_Instant_Pop_From_Empirical_AlleleFreq(objSSParameters, objSharkSimOperation)
                
                boolLoadSimuPop_Pop = False
                if boolLoadSimuPop_Pop:

                    strFileNameSuffix_Import = '.r_pf_ssimupop.pop'
                    strFilePath_Import = 'C:\\DCB\\MUI\\MUI_Sync_Auto\\MUI_A_Analyses\\Shared_Data\\'
                    strFileName_Import = 'SS_2.37_pop_full_2014_10_05_10_53_58_{1_19_1_0_32.8_95046_1_1_31_30_15_45990}_rep_001'  #CAPL Simulated

                    #Load pop
                    strSimuPop_Pop_FilePathAndName = strFilePath_Import + strFileName_Import + strFileNameSuffix_Import
                    SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - Main processing - Simulated Jackknife', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
   
                    pop_Imported = self.method_Load_SimuPop_Population(strSimuPop_Pop_FilePathAndName)
                    
                    #Sample pop
                    boolJackknife_SS_Pop = False
                    if boolJackknife_SS_Pop:
                        self.method_Jackknife_Simulated_Dataset(objSSParameters, pop_Imported, objSharkSimOperation)
                    pass
                
                    boolExport_SS_Pop = True
                    if boolExport_SS_Pop:
                        self.method_Sample_Simulated_Dataset(pop_Imported, objSharkSimOperation)
                    pass
                
                boolSelectiveLocusJacknife = False
                if boolSelectiveLocusJacknife == True:
                    
                    boolSuccess = self.method_Selective_Locus_Jackknife()
                    
                pass
                
                bool_Test_Ne2_DLL = False
                if bool_Test_Ne2_DLL == True:
                    
                    with object_SSNe2_Win_DLL([objSSParameters]) as objSSNe2_Win_DLL_Operation:
                        
                        boolSuccess = objSSNe2_Win_DLL_Operation.func_Test_Ne2_DLL_Test()
                        pass
                    pass
                pass

 

                #LOGGING
                listOutputDestinations = ['console', objSSParameters.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - Main processing', boolIsHeader=False, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                #SSOutputOperation.method_Pause_Console()
                #LOGGING
                
                return True


            def method_Produce_Genepop_Stats(self, str_Search_Path, str_File_Suffix_Search_Pattern):

                with SSOutputHandler() as SSOutputOperation:
                    #listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches]
                    SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - method_Produce_Genepop_Stats', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)

                bool_Sample_Stats = True
                if bool_Sample_Stats:
                    SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - method_Produce_Genepop_Stats -  method_Genepop_Statistics', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                    self.method_Genepop_Statistics(str_Search_Path, str_File_Suffix_Search_Pattern)
                pass                

            def method_Emprical_Locus_Jackknifing(self):

                with SSOutputHandler() as SSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - Main processing', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)

                boolJackknife = True
                if boolJackknife:
                    SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - Main processing - Empirical Jackknife', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)

                    self.method_Jackknife_Empirical_Dataset()  
                pass
            
                return True
            
            def method_Simulation_Locus_Jacknifing(self):
                
                with SSOutputHandler() as SSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - method_Simulation_Jacknifing', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)

 
                bool_Jackknife_Simulated_Dataset = True
                if bool_Jackknife_Simulated_Dataset:


                    bool_Jackknife_SS_Pop_With_Ne2 = True
                    if bool_Jackknife_SS_Pop_With_Ne2:
                        SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - method_Simulation_Jacknifing -  method_Jackknife_Simulated_Dataset_With_Ne2', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                        self.method_Jackknife_Simulated_Dataset_With_Ne2()
                    pass
                pass                    
                
                return True                                    

            def method_Pop_SubSample_Ne2_Estimates(self):
                
                
                with SSOutputHandler() as SSOutputOperation:
                     listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                     SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'Sampling Test - method_Simulation_Jacknifing', boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
 
                bool_Sample_Dataset = True
                if bool_Sample_Dataset:
                    self.method_SubSample_Pop_And_Produce_Ne2_Estimates()
                
                return True
            
            def method_Win_Ne2_DLL_Estimates_From_File(self):
                
                self.method_Get_Ne2_Ne2_Win_DLL_From_Genepop_Files()
                
                return True
            '''
            --------------------------------------------------------------------------------------------------------
            # Utility Processing
            --------------------------------------------------------------------------------------------------------
            '''

            def method_Instant_Pop_From_Empirical_AlleleFreq(self, objSSParameters, objSharkSimOperation):
            
                objSharkSimOperation.pop = objSharkSimOperation.method_Population_Creation_From_Scratch()
            
                pop = objSharkSimOperation.pop
                
                objSharkSimOperation.method_InitGenotypes(pop)
                
                pop_ToSample = objSharkSimOperation.pop
                
                #DEBUG_ON                    
                simupop.dump(pop_ToSample)
                #DEBUG_OFF
                                        
                self.method_Jackknife_Simulated_Dataset(objSSParameters, pop_ToSample)
                
                return True
            
            
            def method_Calculate_DELTA_LDNe(self, listLDNePCritsToEvaluate, dictLDNe_Sample, dictLDNe_ForComparison, listOutputDestinations, strPrefixMessage):

#                 with SSAnalysisHandler() as objSSAnalysisOperation:
#                     dictLDNe_Sample = objSSAnalysisOperation.method_Statistics_On_NE_LD_Population_Size_For_VirtualSubPop(pop_In, listVSPsToReport)
                
                dictLDNe_Deltas = {}    
                for floatPCrit in listLDNePCritsToEvaluate:
 
                    '''
                    Validate Ne
                    '''
                   
                    
                    floatLDNe_Sample = float(dictLDNe_Sample[floatPCrit][globalsSS.LDNe_Estimate.static_LDNe_Estimate_Point])
                    if floatLDNe_Sample == eval('inf', {'inf': float('inf')}):
                        floatLDNe_Sample = float(9999999999) #Set to a billion
                    pass

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'LDNe_Sample       : ' + str(round(floatLDNe_Sample,0))
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, False)
                        #objSSOutputOperation.method_Pause_Console()
                    #LOGGING
                   

                    floatLDNeForComparison = float(dictLDNe_ForComparison[floatPCrit][globalsSS.LDNe_Estimate.static_LDNe_Estimate_Point])
                    if floatLDNeForComparison == eval('inf', {'inf': float('inf')}):
                        floatLDNeForComparison = float(9999999999) #Set to a billion
                    pass

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'LDNe_ForComparison: ' + str(round(floatLDNeForComparison,0))
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                    #LOGGING
                
                
                    '''
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    Calculate delta
                    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                    '''
                    floatLDNe_Delta = floatLDNe_Sample - floatLDNeForComparison
                    dictLDNe_Deltas[floatPCrit] = floatLDNe_Delta

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'LDNe_Delta        : ' + str(round(floatLDNe_Delta,0)) + '\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                    #LOGGING

                pass
                
                return dictLDNe_Deltas


            def method_Accumulate_Locus_Exclusion_LDNe_Deltas(self, dictLocusExclusion_Cumulative_LDNeDeltas, listLDNePCritsToEvaluate):

                '''
                Accumulate LDNe deltas into lists by locus and by PCrit
                '''
                dictWithListsOfLocusIndexedLDNeDeltas_ByPCrit = OrderedDict()
                intLocusCount = 0
                
                for strKeyLocus, dictValue_LDNeDelta in dictLocusExclusion_Cumulative_LDNeDeltas.items():
                    
                    
                    #listLocusIndexedLDNeDeltas_ByPCrit = []
                    for floatPcrit in listLDNePCritsToEvaluate:
                        if floatPcrit in dictWithListsOfLocusIndexedLDNeDeltas_ByPCrit:
                            pass
                        else:
                            dictWithListsOfLocusIndexedLDNeDeltas_ByPCrit[floatPcrit] = []
                        pass
                    
                        floatLDNeDeltaForPCrit = dictValue_LDNeDelta[floatPcrit]
                        #listLocusIndexedLDNeDeltas_ByPCrit.append(floatLDNeDeltaForPCrit)
                        tupLocusAndLDNeDelta = (strKeyLocus, floatLDNeDeltaForPCrit)
                        dictWithListsOfLocusIndexedLDNeDeltas_ByPCrit[floatPcrit].append(tupLocusAndLDNeDelta)
                    pass
                
                    #dictWithListsOfLocusIndexedLDNeDeltas_ByPCrit[floatPcrit] = listLocusIndexedLDNeDeltas_ByPCrit
                    
                    intLocusCount += 1
                pass

                return dictWithListsOfLocusIndexedLDNeDeltas_ByPCrit

            
            def method_Select_Exclusion_Locus_By_LDNe_Deltas(self, dictWithListsOfLocusIndexedLDNeDeltas_ByPCrit, floatPCritForEvaluation, intLDNeDeltaEvaluationMethod):

                listScore = []
                listScoreDetails = []
                strOutputScoreMethod = ''
                intScore = 0
                intScoreTotal = 0
                listReturn = []
                
                '''
                Conservative selection - Select the lowest delta - The locus with the least influence on reducung the LDNe
                '''
                strLocusSelected = ''

                intScore = +15
                intScoreTotal += intScore
                
                if intLDNeDeltaEvaluationMethod == globalsSS.Sampling_Locus_ExclusionLDNe_Deltas_Method.static_Sampling_LocusExclusionLDNeDeltas_Method_MinimumDelta:
                    
                    listLocusIndexedLDNeDeltas_ByPCrit = dictWithListsOfLocusIndexedLDNeDeltas_ByPCrit[floatPCritForEvaluation]
                    
                    #Unzip the list of tuples with locus name, LDNe delta pairs
                    listZip_LocusNameAnd_LDNeDelta = zip(*listLocusIndexedLDNeDeltas_ByPCrit)
                    listLocusNames = listZip_LocusNameAnd_LDNeDelta[0]
                    listLDNeDeltas = listZip_LocusNameAnd_LDNeDelta[1]
                    
                    floatMinLDNePCritDeltaForLocus = min(listLDNeDeltas)
                    intIndexMinLDNePCritDeltaForLocus = listLDNeDeltas.index(min(listLDNeDeltas))
                    
                    strLocusSelected = listLocusNames[intIndexMinLDNePCritDeltaForLocus]

                    floatEvaluatedLDNePCritDeltaForAllLoci = floatMinLDNePCritDeltaForLocus

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        strOutputScoreMethod = 'LDNe Delta Minimum - Accept the lowest LDNE Delta'
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'From LDNE deltas : ' + str(listLDNeDeltas) + ' ; for loci: ' + str(listLocusNames) 
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        stringMessage = 'Locus Min Delta : ' + str(floatMinLDNePCritDeltaForLocus) + ' ; Locus exclusion candidate selected: ' + strLocusSelected + '\n' 
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                        listScoreDetails.append(strOutputScoreMethod)
                        listScoreDetails.append(str(intScore))
                        listScoreDetails.append(str(intScoreTotal))
                        #LOGGING
                    
                elif intLDNeDeltaEvaluationMethod == globalsSS.Sampling_Locus_ExclusionLDNe_Deltas_Method.static_Sampling_LocusExclusionLDNeDeltas_Method_MaximumDelta:
                    
                    listLocusIndexedLDNeDeltas_ByPCrit = dictWithListsOfLocusIndexedLDNeDeltas_ByPCrit[floatPCritForEvaluation]
                    
                    #Unzip the list of tuples with locus name, LDNe delta pairs
                    listZip_LocusNameAnd_LDNeDelta = zip(*listLocusIndexedLDNeDeltas_ByPCrit)
                    listLocusNames = listZip_LocusNameAnd_LDNeDelta[0]
                    listLDNeDeltas = listZip_LocusNameAnd_LDNeDelta[1]
                    
                    floatMaxLDNePCritDeltaForLocus = max(listLDNeDeltas)
                    intIndexMaxLDNePCritDeltaForLocus = listLDNeDeltas.index(max(listLDNeDeltas))
                    
                    strLocusSelected = listLocusNames[intIndexMaxLDNePCritDeltaForLocus]

                    floatEvaluatedLDNePCritDeltaForAllLoci = floatMaxLDNePCritDeltaForLocus

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        strOutputScoreMethod = 'LDNe Delta Maximum - Accept the highest LDNE Delta'
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'From LDNE deltas : ' + str(listLDNeDeltas) + ' ; for loci: ' + str(listLocusNames) 
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        stringMessage = 'Locus Max Delta : ' + str(floatMaxLDNePCritDeltaForLocus) + ' ; Locus exclusion candidate selected: ' + strLocusSelected + '\n' 
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                        listScoreDetails.append(strOutputScoreMethod)
                        listScoreDetails.append(str(intScore))
                        listScoreDetails.append(str(intScoreTotal))
                        #LOGGING

                pass
                
                listScore = [intScoreTotal, listScoreDetails]
            
                listReturn = [floatEvaluatedLDNePCritDeltaForAllLoci, strLocusSelected, listLDNeDeltas, listLocusNames, listScore]
                
                return listReturn
            

            def method_Score_Locus_Exclusion_By_LDNe_Upper_Jackknife_CI(self, dictLocusExclusion_Cumulative_LDNes_ByPCrit, listLDNePCritsToEvaluate, objSSOutputOperation, listOutputDestinations, listSLJ_Sheet_Output3):

                listScore = []
                listScoreDetails = listSLJ_Sheet_Output3
                strOutputScoreMethod = ''
                intScore = 0
                intScoreTotal = 0
                
                '''
                Count the instances where the Upper Jackknife CI is not inf
                '''
                intCountUpperJKCIInstances = 0
                intLDNeEstimateCount = 0
                for strKeyLocus, dictValueLDNeEstimates in dictLocusExclusion_Cumulative_LDNes_ByPCrit.items():
                  
                    for floatPcrit in listLDNePCritsToEvaluate:
                        if floatPcrit in dictValueLDNeEstimates:
                            floatLDNeUprJKCI = dictValueLDNeEstimates[floatPcrit][2]
                            if floatLDNeUprJKCI == eval('inf', {'inf': float('inf')}):
                                pass
                            else:
                                intCountUpperJKCIInstances += 1
                            pass
                            intLDNeEstimateCount += 1
                        pass
                    pass
                
                '''
                Calculate the percentage of UprCI estimates relative to number of estimates
                '''
               
                floatProportionOfLDNeUprJKCI_Finite_Estimates = float(intCountUpperJKCIInstances) / float(intLDNeEstimateCount)
                
                if floatProportionOfLDNeUprJKCI_Finite_Estimates > 0.1:
                    
                    intScore = -25
                    intScoreTotal += intScore
                    
                    #LOGGING
                    strOutputScoreMethod = 'LDNe Upper JK CI Proportion > 0.1'
                    stringMessage = strOutputScoreMethod + ':' + '\n'
                    stringMessage += 'Local Score: ' + str(intScore) + ' '
                    stringMessage += 'LocalTotal : ' + str(intScoreTotal)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    listScoreDetails.append(strOutputScoreMethod)
                    listScoreDetails.append(str(intScore))
                    listScoreDetails.append(str(intScoreTotal))
                    #LOGGING

                pass
            
                if floatProportionOfLDNeUprJKCI_Finite_Estimates > 0 and floatProportionOfLDNeUprJKCI_Finite_Estimates < 0.01:
                    
                    intScore = +5
                    intScoreTotal += intScore
                    
                    #LOGGING
                    strOutputScoreMethod = 'LDNe Upper JK CI Proportion > 0 and < 0.01'
                    stringMessage = strOutputScoreMethod + ':' + '\n'
                    stringMessage += 'Local Score: ' + str(intScore) + ' '
                    stringMessage += 'LocalTotal : ' + str(intScoreTotal)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    listScoreDetails.append(strOutputScoreMethod)
                    listScoreDetails.append(str(intScore))
                    listScoreDetails.append(str(intScoreTotal))
                    #LOGGING

                pass
                
                listScore = [intScoreTotal, listScoreDetails]
                
                return listScore
            
            def method_Score_Locus_Exclusion_By_StdDeviation(self, floatLDNeDeltaStdDeviation, objSSOutputOperation, listOutputDestinations, listSLJ_Sheet_Output3):

                listScore = []
                listScoreDetails = listSLJ_Sheet_Output3
                strOutputScoreMethod = ''
                intScore = 0
                intScoreTotal = 0
                
                if floatLDNeDeltaStdDeviation > 15000:
                    
                    intScore = +5
                    intScoreTotal += intScore
                    
                    #LOGGING
                    strOutputScoreMethod = 'LDNe Delta Median StdDeviation > 10,000'
                    stringMessage = strOutputScoreMethod + ':' + '\n'
                    stringMessage += 'Local Score: ' + str(intScore) + ' '
                    stringMessage += 'LocalTotal : ' + str(intScoreTotal)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    listScoreDetails.append(strOutputScoreMethod)
                    listScoreDetails.append(str(intScore))
                    listScoreDetails.append(str(intScoreTotal))
                    #LOGGING

                pass
                
                listScore = [intScoreTotal, listScoreDetails]
                
                return listScore
           
            def method_Score_Locus_Exclusion_By_Variance(self, floatLDNeDeltaVariance, objSSOutputOperation, listOutputDestinations, listSLJ_Sheet_Output3):

                listScore = []
                listScoreDetails = listSLJ_Sheet_Output3
                strOutputScoreMethod = ''
                intScore = 0
                intScoreTotal = 0
                
                if floatLDNeDeltaVariance > 100000:
                    
                    intScore = +5
                    intScoreTotal += intScore
                    
                    #LOGGING
                    strOutputScoreMethod = 'LDNe Delta Median Variance > 100000'
                    stringMessage = strOutputScoreMethod + ':' + '\n'
                    stringMessage += 'Local Score: ' + str(intScore) + ' '
                    stringMessage += 'LocalTotal : ' + str(intScoreTotal)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    listScoreDetails.append(strOutputScoreMethod)
                    listScoreDetails.append(str(intScore))
                    listScoreDetails.append(str(intScoreTotal))
                    #LOGGING

                pass
                
                listScore = [intScoreTotal, listScoreDetails]
                
                return listScore
           
            def method_Score_Locus_Exclusion_By_Median(self, floatLDNeDeltaMedian, objSSOutputOperation, listOutputDestinations, listSLJ_Sheet_Output3):
                
                listScore = []
                listScoreDetails = listSLJ_Sheet_Output3
                strOutputScoreMethod = ''
                intScore = 0
                intScoreTotal = 0
                
                if floatLDNeDeltaMedian == 0:
                    
                    intScore = +15
                    intScoreTotal += intScore
                    
                    #LOGGING
                    strOutputScoreMethod = 'LDNe Delta Median = 0'
                    stringMessage = strOutputScoreMethod + ':' + '\n'
                    stringMessage += 'Local Score: ' + str(intScore) + ' '
                    stringMessage += 'LocalTotal : ' + str(intScoreTotal)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    listScoreDetails.append(strOutputScoreMethod)
                    listScoreDetails.append(str(intScore))
                    listScoreDetails.append(str(intScoreTotal))
                    #LOGGING

                pass
            
                if floatLDNeDeltaMedian > 0:
                    intScore = -5
                    intScoreTotal += intScore

                    #LOGGING
                    strOutputScoreMethod = 'LDNe Delta Median > 0'
                    stringMessage = strOutputScoreMethod + ':' + '\n'
                    stringMessage += 'Local Score: ' + str(intScore) + ' '
                    stringMessage += 'LocalTotal : ' + str(intScoreTotal)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    listScoreDetails.append(strOutputScoreMethod)
                    listScoreDetails.append(str(intScore))
                    listScoreDetails.append(str(intScoreTotal))
                    #LOGGING

                if floatLDNeDeltaMedian > 5000 and floatLDNeDeltaMedian < 9999999999.0 :
                    intScore = +15
                    intScoreTotal += intScore

                    #LOGGING
                    strOutputScoreMethod = 'LDNe Delta Median > 5,000 and < 9,999,999,999' #Lower was 30,000
                    stringMessage = strOutputScoreMethod + ':' + '\n'
                    stringMessage += 'Local Score: ' + str(intScore) + ' '
                    stringMessage += 'LocalTotal : ' + str(intScoreTotal)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    listScoreDetails.append(strOutputScoreMethod)
                    listScoreDetails.append(str(intScore))
                    listScoreDetails.append(str(intScoreTotal))
                    #LOGGING

                pass
            
                if floatLDNeDeltaMedian < 0:
                    intScore = +5
                    intScoreTotal += intScore
 
                    #LOGGING
                    strOutputScoreMethod = 'LDNe Delta Median < 0'
                    stringMessage = strOutputScoreMethod + ':' + '\n'
                    stringMessage += 'Local Score: ' + str(intScore) + ' '
                    stringMessage += 'LocalTotal : ' + str(intScoreTotal)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    listScoreDetails.append(strOutputScoreMethod)
                    listScoreDetails.append(str(intScore))
                    listScoreDetails.append(str(intScoreTotal))
                    #LOGGING
                   
                    if floatLDNeDeltaMedian > -1000 and floatLDNeDeltaMedian < -500:

                        intScore = -20
                        intScoreTotal += intScore
    
                        #LOGGING
                        strOutputScoreMethod = 'LDNe Delta Median > -1000 and < -500'
                        stringMessage = strOutputScoreMethod + ':' + '\n'
                        stringMessage += 'Local Score: ' + str(intScore) + ' '
                        stringMessage += 'LocalTotal : ' + str(intScoreTotal)
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        listScoreDetails.append(strOutputScoreMethod)
                        listScoreDetails.append(str(intScore))
                        listScoreDetails.append(str(intScoreTotal))
                        #LOGGING
                    
                    pass
                
                    if floatLDNeDeltaMedian < -30000:

                        intScore = +15
                        intScoreTotal += intScore
    
                        #LOGGING
                        strOutputScoreMethod = 'LDNe Delta Median < -30000'
                        stringMessage = strOutputScoreMethod + ':' + '\n'
                        stringMessage += 'Local Score: ' + str(intScore) + ' '
                        stringMessage += 'LocalTotal : ' + str(intScoreTotal)
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        listScoreDetails.append(strOutputScoreMethod)
                        listScoreDetails.append(str(intScore))
                        listScoreDetails.append(str(intScoreTotal))
                        #LOGGING
                    
                    pass
                pass
                
                listScore = [intScoreTotal, listScoreDetails]
                
                return listScore
                       
            def method_Evaluate_LDNe_Delta_Magnitude_Deciding_To_Select_Another_Locus_For_Exclusion(self, floatEvaluatedLDNePCritDeltaForAllLoci, objSSOutputOperation, listOutputDestinations):

                listScore = []
                listScoreDetails = []
                strOutputScoreMethod = ''
                intScore = 0
                intScoreTotal = 0
                boolExcludeLocus = False
            
                '''
                If the delta LDNe change is large enough then decide to exclude the locus
                '''
                
                
                
                '''Get the absolute difference
                '''
                floatEvaluatedLDNePCritDeltaForAllLoci_Absolute = abs(floatEvaluatedLDNePCritDeltaForAllLoci)
                
                #if floatEvaluatedLDNePCritDeltaForAllLoci_Absolute > intDeltaMagnitudeLocusExclusionCutoff:
                if floatEvaluatedLDNePCritDeltaForAllLoci < 0:
                    #Ne LDNe estimate is lower than the previous estimate - Expect this for POOR/AWFUL sub-samples
                    intDeltaMagnitudeLocusExclusionCutoff = -40000
                    intScore = +15
                    intScoreTotal += intScore 
                else:
                    #Nee LDNe estimate is higher than the previous estimate  - Expect this for OK sub-samples
                    intDeltaMagnitudeLocusExclusionCutoff = 5000 
                    intScore = +15
                    intScoreTotal += intScore
                pass
                    
                if floatEvaluatedLDNePCritDeltaForAllLoci > intDeltaMagnitudeLocusExclusionCutoff:
                    boolExcludeLocus = True

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        strOutputScoreMethod = 'LDNe Delta < 0 and LDNe Delta Magnitude > -40,000 Cutoff'
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'Delta : ' + str(floatEvaluatedLDNePCritDeltaForAllLoci) + ' ; exceeds Delta Cutoffi: ' + str(intDeltaMagnitudeLocusExclusionCutoff) + '; locus will be EXCLUDED' + '\n' 
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                        listScoreDetails.append(strOutputScoreMethod)
                        listScoreDetails.append(str(intScore))
                        listScoreDetails.append(str(intScoreTotal))
                        #LOGGING
                
                else:
                    boolExcludeLocus = False

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        strOutputScoreMethod = 'LDNe Delta < 0 and LDNe Delta Magnitude > -40,000 Cutoff'
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'Delta : ' + str(floatEvaluatedLDNePCritDeltaForAllLoci) + ' ; under Delta Cutoff: ' + str(intDeltaMagnitudeLocusExclusionCutoff) + '; locus will be KEPT' + '\n' 
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                        listScoreDetails.append(strOutputScoreMethod)
                        listScoreDetails.append(str(intScore))
                        listScoreDetails.append(str(intScoreTotal))
                        #LOGGING
                    
                    pass
                pass
                
                listScore = [intScoreTotal, listScoreDetails]
                
                return listScore
            
            '''
            SELCTIVE LOCUS JACKKNIFE
            '''
            def method_Score_Locus_Exclusion_Decision(self, intScore):
                
                intScoreCutoff = 10
                
                if intScore >= intScoreCutoff:
                    boolExcludeLocus = True

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'Locus Exclusion Final Score : ' + str(intScore) + ' ; exceeds Cutoff: ' + str(intScoreCutoff) + '; locus will be EXCLUDED' + '\n' 
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                    #LOGGING
                
                else:
                    boolExcludeLocus = False

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'Locus Exclusion Final Score : ' + str(intScore) + ' ; below Cutoff: ' + str(intScoreCutoff) + '; locus will be KEPT' + '\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                    #LOGGING

                pass 
                               
                return boolExcludeLocus
            
            def method_Score_Locus_Exclusion_Final_Decision(self, intScore, listSLJ_Sheet_Output3):

                listScore = []
                listScoreDetails = listSLJ_Sheet_Output3
                strOutputScoreMethod = ''
                intScore = 0
                intScoreTotal = 0
                
                intScoreCutoff = 10
                
                if intScore >= intScoreCutoff:
                    boolExcludeLocus = True

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        strOutputScoreMethod = 'Locus Exclusion Final Score >= ' + str(intScoreCutoff) + ' Cutoff'
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'Locus Exclusion Final Score : ' + str(intScore) + ' ; exceeds Cutoff: ' + str(intScoreCutoff) + '; locus will be EXCLUDED' + '\n' 
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                        listScoreDetails.append(strOutputScoreMethod)
                        listScoreDetails.append(str(intScore))
                        listScoreDetails.append(str(intScoreCutoff))
                    #LOGGING
                
                else:
                    boolExcludeLocus = False

                    #LOGGING
                    with SSOutputHandler() as objSSOutputOperation:
                        strOutputScoreMethod = 'Locus Exclusion Final Score < ' + str(intScoreCutoff) + ' Cutoff'
                        listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                        stringMessage = 'Locus Exclusion Final Score : ' + str(intScore) + ' ; below Cutoff: ' + str(intScoreCutoff) + '; locus will be KEPT' + '\n'
                        objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                        #objSSOutputOperation.method_Pause_Console()
                        listScoreDetails.append(strOutputScoreMethod)
                        listScoreDetails.append(str(intScore))
                        listScoreDetails.append(str(intScoreCutoff))
                    #LOGGING

                pass
                
                listScore = [intScoreTotal, listScoreDetails]
                
                listReturn = [boolExcludeLocus, listScore]
                
                return listReturn
            
            def method_Select_Exclusion_Locus_By_LDNe_Statistics(self, listLocusCandidateSelectedForExclusionByLDNeDeltas, dictLocusExclusion_Cumulative_LDNes_ByPCrit, listLDNePCritsToEvaluate):
                
                listReturn = []
                
                floatEvaluatedLDNePCritDeltaForAllLoci = listLocusCandidateSelectedForExclusionByLDNeDeltas[0]
                strLocusSelected = listLocusCandidateSelectedForExclusionByLDNeDeltas[1]
                listLDNeDeltas = listLocusCandidateSelectedForExclusionByLDNeDeltas[2]
                listScore = listLocusCandidateSelectedForExclusionByLDNeDeltas[4]
                listSLJ_Sheet_Output3 = listScore[1]
                 
                #LOGGING
                with SSOutputHandler() as objSSOutputOperation:
                    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                    #
                    floatLDNeDeltaMedian = round(numpy.median(numpy.array(listLDNeDeltas)),0)
                    stringMessage = 'Delta MEDIAN   : ' + str(floatLDNeDeltaMedian)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    strOutputScoreMethod = 'LDNe Delta Median'
                    listSLJ_Sheet_Output3.append(strOutputScoreMethod)
                    listSLJ_Sheet_Output3.append(str(floatLDNeDeltaMedian))
                    #
                    floatLDNeDeltaMean = round(numpy.mean(numpy.array(listLDNeDeltas)),0)
                    stringMessage = 'Delta Mean     : ' + str(floatLDNeDeltaMean)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    strOutputScoreMethod = 'LDNe Delta Mean'
                    listSLJ_Sheet_Output3.append(strOutputScoreMethod)
                    listSLJ_Sheet_Output3.append(str(floatLDNeDeltaMean))
                    #
                    floatLDNeDeltaStdDev = round(numpy.std(numpy.array(listLDNeDeltas)),0)
                    stringMessage = 'Delta StdDev   : ' + str(floatLDNeDeltaStdDev)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    strOutputScoreMethod = 'LDNe Delta StdDev'
                    listSLJ_Sheet_Output3.append(strOutputScoreMethod)
                    listSLJ_Sheet_Output3.append(str(floatLDNeDeltaStdDev))
                    #
                    floatLDNeDeltaVariance = round(numpy.var(numpy.array(listLDNeDeltas)),0)
                    stringMessage = 'Delta Variance : ' + str(floatLDNeDeltaVariance)
                    objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    strOutputScoreMethod = 'LDNe Delta Variance'
                    listSLJ_Sheet_Output3.append(strOutputScoreMethod)
                    listSLJ_Sheet_Output3.append(str(floatLDNeDeltaVariance))
                    #
#                     floatMode = round(stats.mode(numpy.array(listLDNeDeltas)),0)
#                     stringMessage = 'Delta Mode   : ' + str(floatLDNeDeltaVariance)
#                     objSSOutputOperation.methodOutput_SimGeneralMessageWithoutHeaderAndFooter(listOutputDestinations, stringMessage, True)
                    #objSSOutputOperation.method_Pause_Console()
#                     strOutputScoreMethod = 'LDNe Delta Mode'
#                     listSLJ_Sheet_Output3.append(strOutputScoreMethod)
#                     listSLJ_Sheet_Output3.append(str(floatLDNeDeltaVariance))

                #LOGGING

                '''
                Decide if LDNe delta drop was large enough to warrent excluding the locus
                '''
                intDecisionScore = 0
                    
                boolLDNeUpperJKCIDecide = True
                if boolLDNeUpperJKCIDecide:
                    listExcludeLocus = self.method_Score_Locus_Exclusion_By_LDNe_Upper_Jackknife_CI(dictLocusExclusion_Cumulative_LDNes_ByPCrit, listLDNePCritsToEvaluate, objSSOutputOperation, listOutputDestinations, listSLJ_Sheet_Output3)
                    intDecisionScore += listExcludeLocus[0]
                    listSLJ_Sheet_Output3 = listExcludeLocus[1]
                pass
            
#                 boolDeltaDecide = False
#                 if boolDeltaDecide:
#                     listExcludeLocus = self.method_Evaluate_LDNe_Delta_Magnitude_Deciding_To_Select_Another_Locus_For_Exclusion(floatEvaluatedLDNePCritDeltaForAllLoci, listSLJ_Sheet_Output3)
#                    listSLJ_Sheet_Output3 = listScoreDetails
#                 pass
            
                boolMedianDecide = True
                if boolMedianDecide:
                    listExcludeLocus = self.method_Score_Locus_Exclusion_By_Median(floatLDNeDeltaMedian, objSSOutputOperation, listOutputDestinations, listSLJ_Sheet_Output3)
                    intDecisionScore += listExcludeLocus[0]
                    listSLJ_Sheet_Output3 = listExcludeLocus[1]
                pass    
            
                boolStdDevDecide = False
                if boolStdDevDecide:
                    listExcludeLocus += self.method_Score_Locus_Exclusion_By_StdDeviation(floatLDNeDeltaStdDev, objSSOutputOperation, listOutputDestinations, listSLJ_Sheet_Output3)
                    intDecisionScore += listExcludeLocus[0]
                    listSLJ_Sheet_Output3 = listExcludeLocus[1]
                pass 
               
                boolVarianceDecide = False
                if boolVarianceDecide:
                    listExcludeLocus += self.method_Score_Locus_Exclusion_By_Variance(floatLDNeDeltaVariance, objSSOutputOperation, listOutputDestinations, listSLJ_Sheet_Output3)
                    intDecisionScore += listExcludeLocus[0]
                    listSLJ_Sheet_Output3 = listExcludeLocus[1]
                pass    
                
                listExcludeLocus = self.method_Score_Locus_Exclusion_Final_Decision(intDecisionScore, listSLJ_Sheet_Output3)
                boolExcludeLocus = listExcludeLocus[0]
                listSLJ_Sheet_Output3 = listExcludeLocus[1][1]
                
                listReturn = [boolExcludeLocus, strLocusSelected, listSLJ_Sheet_Output3] 
                       
                return listReturn

           
            '''
            --------------------------------------------------------------------------------------------------------
            # Output Processing
            --------------------------------------------------------------------------------------------------------
            '''


            
            def method_Calculate_And_Output_LDNE_To_File(self, objSSParameters, pop, listLDNeVSPToReport):
                
                listOutputDestinations = objSSParameters.listOutputDestinations_Custom_LDNE_1_Reporting_Experiment_Dump
                #with SSReportingCustom_LDNE_1() as objSSReportingCustom_LDNE_1:
                #    objSSReportingCustom_LDNE_1.pop = pop
                
                #listFullPopVSPsToOutput = [0]
                dictPropertiesNotSuppressed = objSSParameters.dictCustom_LDNE_1_PropertiesNotSuppressed
                dictOfObjectPropertiesToReport = objSSParameters.dictCustom_LDNE_1_OfObjectPropertiesToReport
                boolOutputHeader = True
                
                with SSOutputHandler() as SSOutputOperation:    
                    SSOutputOperation.method_Output_Population_Individuals_To_ILF_Files_With_Custom_LDNE_1_Reporting(objSSParameters, pop, listOutputDestinations, globalsSS.SP_SubPops.static_intSP_SubPop_Primary, objSSParameters.intCurrentTemporalFertilisation, listLDNeVSPToReport, dictPropertiesNotSuppressed, dictOfObjectPropertiesToReport, boolOutputHeader)
                
                
                return True
            
            def method_Calculate_And_Output_LDNE_To_Console(self, pop, listVSPsToReport, listLDNePCritOutput, listOutputDestinations, strPrefixMessage):

                with SSAnalysisHandler() as objSSAnalysisOperation:
                    dictNeLD = objSSAnalysisOperation.method_Statistics_On_NE_LD_Population_Size_For_VirtualSubPop(pop, listVSPsToReport)
                   
                with SSOutputHandler() as objSSOutputOperation:
                    objSSOutputOperation.methodOutput_Output_LDNE_Info(listOutputDestinations, strPrefixMessage, False, False, dictNeLD, listLDNePCritOutput) 
#                     dictRounded = {}
#                     for listItem in listLDNePCritOutput:
#                         listRounded = []
#                         for i in range(0,3):
#                             listRounded.append(round(dictNeLD[listItem][i],2))
#                         pass
#                         dictRounded[listItem] = listRounded
# 
#                     objOutput.write('    LDNe: ' + str(dictRounded))
#                     objOutput.write('\n')
                
                return True

            def method_Get_LDNe_Statistics(self, pop_In, listVSPsToReport):

                #DEBUG_ON
                #LOGGING
                #with SSOutputHandler() as SSOutputOperation:
                #    listOutputDestinations = ['console', self.objSSParametersLocal.outputFileNameSummaryLogAllBatches, self.objSSParametersLocal.outputFileNameSummaryLogPerReplicate]
                #    SSOutputOperation.method_Output_Sim_General_Message_With_Time(listOutputDestinations, 'method_Get_LDNe_Statistics - VSPs to Report:' + str(listVSPsToReport), boolIsHeader=True, boolReportDateTime=True, boolTimeSinceLastGeneralMessage=True)
                #    #SSOutputOperation.method_Pause_Console()
                #LOGGING
                #DEBUG_OFF
                
                with SSAnalysisHandler() as objSSAnalysisOperation:
                    dictLDNe_Sample = objSSAnalysisOperation.method_Statistics_On_NE_LD_Population_Size_For_VirtualSubPop(pop_In, listVSPsToReport)
                
                #del pop_In
                
                return dictLDNe_Sample
            
            def method_Output_LDNE_Summary(self, dictLDNe_Output, listLDNePCritOutput, listOutputDestinations, strPrefixMessage):

                with SSOutputHandler() as objSSOutputOperation:
                    objSSOutputOperation.methodOutput_Output_LDNE_Info(listOutputDestinations, strPrefixMessage, False, False, dictLDNe_Output, listLDNePCritOutput) 
                
                return True

            def method_Output_LDNE_To_Spreadsheet(self, pop_In, listLDNeVSPToReport, listOutputDestinations):
                
                listOutputDestinations = self.objSSParametersLocal.listOutputDestinations_Custom_LDNE_1_Reporting_Selective_Locus_Combo_Jackknife

                dictPropertiesNotSuppressed = self.objSSParametersLocal.dictCustom_LDNE_1_PropertiesNotSuppressed
                dictOfObjectPropertiesToReport = self.objSSParametersLocal.dictCustom_LDNE_1_OfObjectPropertiesToReport
                boolOutputHeader = True
                
                with SSOutputHandler() as objSSOutputOperation:    
                    objSSOutputOperation.method_Output_Population_Individuals_To_ILF_Files_With_Custom_LDNE_1_Reporting(self.objSSParametersLocal, pop_In, listOutputDestinations, globalsSS.SP_SubPops.static_intSP_SubPop_Primary, self.objSSParametersLocal.intCurrentTemporalFertilisation, listLDNeVSPToReport, dictPropertiesNotSuppressed, dictOfObjectPropertiesToReport, boolOutputHeader)
                
                
                return True
    
            def method_Output_Format_LDNe_Estimates_From_Dict_As_Delimited_String(self, dictNeLD, listLDNePCritOutput):
                
                strOutput = ''
                dictRounded = OrderedDict()
                for listItem in listLDNePCritOutput:
                    listRounded = []
                    listRounded.append(str(listItem))
                    for i in range(0,3):
                        listRounded.append(str(round(dictNeLD[listItem][i],2)))
                    pass
                    strOutput += globalsSS.StringDelimiters.static_stringDelimiter.join(listRounded )
                pass
            
                return strOutput
 
            def method_Output_Format_LDNe_Delta_Estimates_From_Dict_As_Delimited_String(self, dictNeLD, listLDNePCritOutput):
                
                strOutput = ''
                dictRounded = OrderedDict()
                for listItem in listLDNePCritOutput:
                    listRounded = []
                    listRounded.append(str(listItem))
                    #for i in range(0,3):
                        #b = [i for sub in dictNeLD for i in sub]
                        
                    for x,y in dictNeLD[listItem]:
                       listRounded.append(x)
                       listRounded.append(str(round(y,0)))
                    #listRounded.append(str(round(dictNeLD[listItem][i],2)))
                    pass
                    strOutput += globalsSS.StringDelimiters.static_stringDelimiter.join(listRounded )
                pass
            
                return strOutput

            '''
            --------------------------------------------------------------------------------------------------------
            #  Manage log files
            --------------------------------------------------------------------------------------------------------
            '''
            '''
            -------------------------
            Results Logging
            -------------------------
            '''
            def Log_Ne2_Samples_Header(self, obj_Log_Results, dict_Results):

                str_ID_Suf = globalsSS.StringDelimiters.static_stringDelimiter_SPACE
                int_Level = 1

                ''' Log header '''
                str_Log_Line = str(globalsSS.StringDelimiters.static_stringDelimiter_RESULTS_START +
                                   globalsSS.StringDelimiters.static_stringDelimiter_SEMI_COLON +
                                   self.Get_Log_Current_Column_Index(True, int_Level, True, str_ID_Suf) +
                                   globalsSS.Ne2_Sampling_Stats.static_Label_Gen_UniqueID)
                
                for key in dict_Results.keys():
                    str_Log_Line += str(globalsSS.StringDelimiters.static_stringDelimiter_SEMI_COLON +
                                        self.Get_Log_Current_Column_Index(False, int_Level, True, str_ID_Suf) +
                                        globalsSS.Ne2_Sampling_Stats.static_Label_Gen_File +
                                        key)
                   
                pass
                obj_Log_Results.info(str_Log_Line)
                
                return True

            def Log_Ne2_Samples_Results(self, obj_Log_Results, dict_Results):

                str_ID_Suf = globalsSS.StringDelimiters.static_stringDelimiter_SPACE
                int_Level = 1
                
#                 ''' Create logger to record results '''
#                 int_Level = 1
#                 str_Logger_Name = obj_Logging.strLogFile
#                 obj_Log_Results = self.func_Get_Func_Specific_Python_Logger(obj_Logging)
                
                ''' Log results '''

                str_Log_Line = str(globalsSS.StringDelimiters.static_stringDelimiter_RESULTS_START +
                                   globalsSS.StringDelimiters.static_stringDelimiter_SEMI_COLON +
                                   #globalsSS.StringDelimiters.static_stringDelimiterSPACE +
                                   self.objSSParametersLocal.strUniqueRunID)
                
                for value in dict_Results.values():
                    str_Log_Line += str(globalsSS.StringDelimiters.static_stringDelimiter_SEMI_COLON +
                                        #globalsSS.StringDelimiters.static_stringDelimiterSPACE +
                                        str(value))
                    
                pass
                obj_Log_Results.info(str_Log_Line)
                
                return True

            '''
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            # Open log files
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            '''
            def method_Open_Log_Files__Sampling(self, int_Experiment):


                if int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_0 or \
                   int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_AGE_COHORTS or \
                   int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_SAMPLE_NUMBERS or \
                   int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_SAMPLE_PROPORTIONS or \
                   int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_Sampling_Strategy_v1_1__USER_PROPORTIONS:
                    ''' Get logger - Sampling Strategy Results '''
                    bool_Report_Sampling_Strategy_Results = True
                    if bool_Report_Sampling_Strategy_Results:                
                        bool_LogToConsole = False
                        str_Logger_Path = self.objSSParametersLocal.str_Current_Run_Path__Logs
                        str_Logger_Name = globalsSS.Logger_Results_File_Details.static_Logger_Name__Sampling_Strategy_Results #+ '_' + self.objSSParametersLocal.str_Sim_Batch_Replicate_Identifier_Short
                        str_Logger_FileName_Suffix = globalsSS.Logger_Results_File_Details.static_Logger_File_Suffix__Sampling_Strategy_Results
                        strFileName_Experiment_Label = ''
                        str_Experiment = ''
                        self.obj_Logging__S_STRAT, self.obj_Results_Log__S_STRAT = self.method_Get_Results_Logger(bool_LogToConsole, str_Logger_Path, str_Logger_Name, str_Logger_FileName_Suffix, strFileName_Experiment_Label, str_Experiment)
                    pass

                elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_100_PERCENT_USER_SPECIFIED_AGE_COHORTS_v1_0: 
                    ''' Get logger - Sampling 100P_A_COHORTS Results '''
                    bool_Report_Sampling_Exp_100P_A_COHORTS_Results = True
                    if bool_Report_Sampling_Exp_100P_A_COHORTS_Results:                
                        bool_LogToConsole = False
                        str_Logger_Path = self.objSSParametersLocal.str_Current_Run_Path__Logs
                        str_Logger_Name = globalsSS.Logger_Results_File_Details.static_Logger_Name__Sampling_100P_A_COHORTS_Results #+ '_' + self.objSSParametersLocal.str_Sim_Batch_Replicate_Identifier_Short
                        str_Logger_FileName_Suffix = globalsSS.Logger_Results_File_Details.static_Logger_File_Suffix__Sampling_100P_A_COHORTS_Results
                        strFileName_Experiment_Label = ''
                        str_Experiment = ''
                        self.obj_Logging__100P_A_COHORTS, self.obj_Results_Log__100P_A_COHORTS = self.method_Get_Results_Logger(bool_LogToConsole, str_Logger_Path, str_Logger_Name, str_Logger_FileName_Suffix, strFileName_Experiment_Label, str_Experiment)
                    pass

                elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_EMBRYO_COHORT: 
                    ''' Get logger - Sampling 100P_A_COHORTS Results '''
                    bool_Report_Sampling_Exp_FULL_EMBRYO_COHORT_Results = True
                    if bool_Report_Sampling_Exp_FULL_EMBRYO_COHORT_Results:                
                        bool_LogToConsole = False
                        str_Logger_Path = self.objSSParametersLocal.str_Current_Run_Path__Logs
                        str_Logger_Name = globalsSS.Logger_Results_File_Details.static_Logger_Name__Sampling_FULL_EMBRYO_COHORT_Results #+ '_' + self.objSSParametersLocal.str_Sim_Batch_Replicate_Identifier_Short
                        str_Logger_FileName_Suffix = globalsSS.Logger_Results_File_Details.static_Logger_File_Suffix__Sampling_FULL_EMBRYO_COHORT_Results
                        strFileName_Experiment_Label = ''
                        str_Experiment = ''
                        self.obj_Logging__FULL_EMBRYO_COHORT, self.obj_Results_Log__FULL_EMBRYO_COHORT = self.method_Get_Results_Logger(bool_LogToConsole, str_Logger_Path, str_Logger_Name, str_Logger_FileName_Suffix, strFileName_Experiment_Label, str_Experiment)
                    pass

                elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_JUVENILE_COHORTS: 
                    ''' Get logger - Sampling 100P_A_COHORTS Results '''
                    bool_Report_Sampling_Exp_FULL_JUVENILE_COHORTS_Results = True
                    if bool_Report_Sampling_Exp_FULL_JUVENILE_COHORTS_Results:                
                        bool_LogToConsole = False
                        str_Logger_Path = self.objSSParametersLocal.str_Current_Run_Path__Logs
                        str_Logger_Name = globalsSS.Logger_Results_File_Details.static_Logger_Name__Sampling_FULL_JUVENILE_COHORTS_Results #+ '_' + self.objSSParametersLocal.str_Sim_Batch_Replicate_Identifier_Short
                        str_Logger_FileName_Suffix = globalsSS.Logger_Results_File_Details.static_Logger_File_Suffix__Sampling_FULL_JUVENILE_COHORTS_Results
                        strFileName_Experiment_Label = ''
                        str_Experiment = ''
                        self.obj_Logging__FULL_JUVENILE_COHORTS, self.obj_Results_Log__FULL_JUVENILE_COHORTS = self.method_Get_Results_Logger(bool_LogToConsole, str_Logger_Path, str_Logger_Name, str_Logger_FileName_Suffix, strFileName_Experiment_Label, str_Experiment)
                    pass

                elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_ADULT_COHORTS: 
                    ''' Get logger - Sampling 100P_A_COHORTS Results '''
                    bool_Report_Sampling_Exp_FULL_ADULT_COHORTS_Results = True
                    if bool_Report_Sampling_Exp_FULL_ADULT_COHORTS_Results:                
                        bool_LogToConsole = False
                        str_Logger_Path = self.objSSParametersLocal.str_Current_Run_Path__Logs
                        str_Logger_Name = globalsSS.Logger_Results_File_Details.static_Logger_Name__Sampling_FULL_ADULT_COHORTS_Results #+ '_' + self.objSSParametersLocal.str_Sim_Batch_Replicate_Identifier_Short
                        str_Logger_FileName_Suffix = globalsSS.Logger_Results_File_Details.static_Logger_File_Suffix__Sampling_FULL_ADULT_COHORTS_Results
                        strFileName_Experiment_Label = ''
                        str_Experiment = ''
                        self.obj_Logging__FULL_ADULT_COHORTS, self.obj_Results_Log__FULL_ADULT_COHORTS = self.method_Get_Results_Logger(bool_LogToConsole, str_Logger_Path, str_Logger_Name, str_Logger_FileName_Suffix, strFileName_Experiment_Label, str_Experiment)
                    pass

                elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_FULL_SAMPLING_OF_COHORTS: 
                    ''' Get logger - Sampling 100P_A_COHORTS Results '''
                    bool_Report_Sampling_Exp_FULL_SAMPLING_OF_COHORTS_Results = True
                    if bool_Report_Sampling_Exp_FULL_SAMPLING_OF_COHORTS_Results:                
                        bool_LogToConsole = False
                        str_Logger_Path = self.objSSParametersLocal.str_Current_Run_Path__Logs
                        str_Logger_Name = globalsSS.Logger_Results_File_Details.static_Logger_Name__Sampling_FULL_SAMPLING_OF_COHORTS_Results #+ '_' + self.objSSParametersLocal.str_Sim_Batch_Replicate_Identifier_Short
                        str_Logger_FileName_Suffix = globalsSS.Logger_Results_File_Details.static_Logger_File_Suffix__Sampling_FULL_SAMPLING_OF_COHORTS_Results
                        strFileName_Experiment_Label = ''
                        str_Experiment = ''
                        self.obj_Logging__FULL_SAMPLING_OF_COHORTS, self.obj_Results_Log__FULL_SAMPLING_OF_COHORTS = self.method_Get_Results_Logger(bool_LogToConsole, str_Logger_Path, str_Logger_Name, str_Logger_FileName_Suffix, strFileName_Experiment_Label, str_Experiment)
                    pass

                elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION: 
                    ''' Get logger - Sampling 100P_A_COHORTS Results '''
                    bool_Report_Sampling_Exp_SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION_Results = True
                    if bool_Report_Sampling_Exp_SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION_Results:                
                        bool_LogToConsole = False
                        str_Logger_Path = self.objSSParametersLocal.str_Current_Run_Path__Logs
                        str_Logger_Name = globalsSS.Logger_Results_File_Details.static_Logger_Name__Sampling_SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION_Results #+ '_' + self.objSSParametersLocal.str_Sim_Batch_Replicate_Identifier_Short
                        str_Logger_FileName_Suffix = globalsSS.Logger_Results_File_Details.static_Logger_File_Suffix__Sampling_SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION_Results
                        strFileName_Experiment_Label = ''
                        str_Experiment = ''
                        self.obj_Logging__SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION, self.obj_Results_Log__SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION = self.method_Get_Results_Logger(bool_LogToConsole, str_Logger_Path, str_Logger_Name, str_Logger_FileName_Suffix, strFileName_Experiment_Label, str_Experiment)
                    pass

                elif int_Experiment == globalsSS.Experment_Groups.static_int_Experiment_2_Ver_2: 
                    ''' Get logger - Sampling Exp_2_2 Results '''
                    bool_Report_Sampling_Exp_2_2_Results = True
                    if bool_Report_Sampling_Exp_2_2_Results:                
                        bool_LogToConsole = False
                        str_Logger_Path = self.objSSParametersLocal.str_Current_Run_Path__Logs
                        str_Logger_Name = globalsSS.Logger_Results_File_Details.static_Logger_Name__Sampling_Exp_2_2_Results #+ '_' + self.objSSParametersLocal.str_Sim_Batch_Replicate_Identifier_Short
                        str_Logger_FileName_Suffix = globalsSS.Logger_Results_File_Details.static_Logger_File_Suffix__Sampling_Exp_2_2_Results
                        strFileName_Experiment_Label = ''
                        str_Experiment = ''
                        self.obj_Logging__EXP_2_2, self.obj_Results_Log__EXP_2_2 = self.method_Get_Results_Logger(bool_LogToConsole, str_Logger_Path, str_Logger_Name, str_Logger_FileName_Suffix, strFileName_Experiment_Label, str_Experiment)
                    pass
 
                pass

            def method_Start_Of_SAMPLING_Reporting__Common_Experiment_Details(self):
                
                dict_Experiment = OrderedDict()
                
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Unique_Run_ID] = self.objSSParametersLocal.strUniqueRunID 
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Run_User_Defined_Folder] = self.objSSParametersLocal.strRunSpecificUserDefinedFolder
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Gens_Overlapp] = self.objSSParametersLocal.bool_Overlapping_Gens_Simulation
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Pop_Size] = self.objSSParametersLocal.popnSize
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Allow_Mutation] = self.objSSParametersLocal.bool_Allow_Mutation
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Mutation_Rate] = self.objSSParametersLocal.float_Mutation_Rate
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Loci] = self.objSSParametersLocal.nLoci
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Alleles_Per_Locus] = self.objSSParametersLocal.int_MatingCount_Replicate_Total
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_Batches] = self.objSSParametersLocal.intBatches
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_Replicates] = self.objSSParametersLocal.intReplicates
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_MatingsToSimulate] = self.objSSParametersLocal.int_Sim_Total_MatingsToSimulate
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_MatingsToSimulatePerReplicate] = self.objSSParametersLocal.int_Total_MatingsToSimulatePerReplicate
                
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Burn_In] = self.objSSParametersLocal.boolBurnIn
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_Current_Batch] = self.objSSParametersLocal.intCurrentBatch
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_Current_Replicate] = self.objSSParametersLocal.intCurrentReplicate
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Replicate_Current_Year] = self.objSSParametersLocal.intSimulationCurrentMonth//12
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Replicate_Current_Month] = self.objSSParametersLocal.intYearCurrentMonth
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Mating_Count_Sim_Total] = self.objSSParametersLocal.int_Sim_Total_MatingsToSimulate #self.objSSParametersLocal.int_MatingCount_Sim_Total
                dict_Experiment[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Mating_Count_Replicate_Total] = self.objSSParametersLocal.int_MatingCount_Replicate_Total
                
                
            
                return dict_Experiment
                        
            def method_End_Of_SAMPLING_Reporting__Sampling_Strategy(self, dict_Experiment):
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     

                dict_Multiline_Results = self.method_End_Of_SAMPLING_Reporting__Extract_Multilines_To_Be_Logged(dict_Experiment)

                '''
                --------------------------
                Log the results
                --------------------------
                '''

                str_Results_1 = self.objSSParametersLocal.strUniqueRunID
                str_Heading_1 = globalsSS.Logger_Results_File_Details.static_Logger_Label_Gen_UniqueID
                str_Heading_Prefix_1 = globalsSS.Logger_Results_File_Details.static_Logger_Colname__Prefix__Sampling_Strategy_Results

                self.obj_Logging__S_STRAT.func_Log_MultiLine_Results_Header(self.obj_Results_Log__S_STRAT, str_Heading_1, str_Heading_Prefix_1, dict_Multiline_Results)
                self.obj_Logging__S_STRAT.func_Log_MultiLine_Results_Detail(str_Results_1, self.obj_Results_Log__S_STRAT, dict_Multiline_Results)

            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass  
                                
                return dict_Experiment

            def method_End_Of_SAMPLING_Reporting__Sampling_Exp_100_PERCENT_USER_SPECIFIED_AGE_COHORTS_1_0(self, dict_Experiment):
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     

                dict_Multiline_Results = self.method_End_Of_SAMPLING_Reporting__Extract_Multilines_To_Be_Logged(dict_Experiment)

                '''
                --------------------------
                Log the results
                --------------------------
                '''

                str_Results_1 = self.objSSParametersLocal.strUniqueRunID
                str_Heading_1 = globalsSS.Logger_Results_File_Details.static_Logger_Label_Gen_UniqueID
                str_Heading_Prefix_1 = globalsSS.Logger_Results_File_Details.static_Logger_Colname__Prefix__Sampling_100P_A_COHORTS_Results

                self.obj_Logging__100P_A_COHORTS.func_Log_MultiLine_Results_Header(self.obj_Results_Log__100P_A_COHORTS, str_Heading_1, str_Heading_Prefix_1, dict_Multiline_Results)
                self.obj_Logging__100P_A_COHORTS.func_Log_MultiLine_Results_Detail(str_Results_1, self.obj_Results_Log__100P_A_COHORTS, dict_Multiline_Results)

            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass  
                                
                return dict_Experiment

            def method_End_Of_SAMPLING_Reporting__Sampling_Exp_Full_Embryo_Cohort_FEM(self, dict_Experiment):
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     

                dict_Multiline_Results = self.method_End_Of_SAMPLING_Reporting__Extract_Multilines_To_Be_Logged(dict_Experiment)

                '''
                --------------------------
                Log the results
                --------------------------
                '''

                str_Results_1 = self.objSSParametersLocal.strUniqueRunID
                str_Heading_1 = globalsSS.Logger_Results_File_Details.static_Logger_Label_Gen_UniqueID
                str_Heading_Prefix_1 = globalsSS.Logger_Results_File_Details.static_Logger_Colname__Prefix__Sampling_FULL_EMBRYO_COHORT_Results

                self.obj_Logging__FULL_EMBRYO_COHORT.func_Log_MultiLine_Results_Header(self.obj_Results_Log__FULL_EMBRYO_COHORT, str_Heading_1, str_Heading_Prefix_1, dict_Multiline_Results)
                self.obj_Logging__FULL_EMBRYO_COHORT.func_Log_MultiLine_Results_Detail(str_Results_1, self.obj_Results_Log__FULL_EMBRYO_COHORT, dict_Multiline_Results)

            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass  
                                
                return dict_Experiment

            def method_End_Of_SAMPLING_Reporting__Sampling_Exp_Full_Juvenile_Cohorts_FJV(self, dict_Experiment):
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     

                dict_Multiline_Results = self.method_End_Of_SAMPLING_Reporting__Extract_Multilines_To_Be_Logged(dict_Experiment)

                '''
                --------------------------
                Log the results
                --------------------------
                '''

                str_Results_1 = self.objSSParametersLocal.strUniqueRunID
                str_Heading_1 = globalsSS.Logger_Results_File_Details.static_Logger_Label_Gen_UniqueID
                str_Heading_Prefix_1 = globalsSS.Logger_Results_File_Details.static_Logger_Colname__Prefix__Sampling_FULL_JUVENILE_COHORTS_Results

                self.obj_Logging__FULL_JUVENILE_COHORTS.func_Log_MultiLine_Results_Header(self.obj_Results_Log__FULL_JUVENILE_COHORTS, str_Heading_1, str_Heading_Prefix_1, dict_Multiline_Results)
                self.obj_Logging__FULL_JUVENILE_COHORTS.func_Log_MultiLine_Results_Detail(str_Results_1, self.obj_Results_Log__FULL_JUVENILE_COHORTS, dict_Multiline_Results)

            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass  
                                
                return dict_Experiment

            def method_End_Of_SAMPLING_Reporting__Sampling_Exp_Full_Adult_Cohorts_FMT(self, dict_Experiment):
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     

                dict_Multiline_Results = self.method_End_Of_SAMPLING_Reporting__Extract_Multilines_To_Be_Logged(dict_Experiment)

                '''
                --------------------------
                Log the results
                --------------------------
                '''

                str_Results_1 = self.objSSParametersLocal.strUniqueRunID
                str_Heading_1 = globalsSS.Logger_Results_File_Details.static_Logger_Label_Gen_UniqueID
                str_Heading_Prefix_1 = globalsSS.Logger_Results_File_Details.static_Logger_Colname__Prefix__Sampling_FULL_ADULT_COHORTS_Results

                self.obj_Logging__FULL_ADULT_COHORTS.func_Log_MultiLine_Results_Header(self.obj_Results_Log__FULL_ADULT_COHORTS, str_Heading_1, str_Heading_Prefix_1, dict_Multiline_Results)
                self.obj_Logging__FULL_ADULT_COHORTS.func_Log_MultiLine_Results_Detail(str_Results_1, self.obj_Results_Log__FULL_ADULT_COHORTS, dict_Multiline_Results)

            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass  
                                
                return dict_Experiment

            def method_End_Of_SAMPLING_Reporting__Sampling_Exp_Full_Sampling_Of_Cohorts_FUL(self, dict_Experiment):
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     

                dict_Multiline_Results = self.method_End_Of_SAMPLING_Reporting__Extract_Multilines_To_Be_Logged(dict_Experiment)

                '''
                --------------------------
                Log the results
                --------------------------
                '''

                str_Results_1 = self.objSSParametersLocal.strUniqueRunID
                str_Heading_1 = globalsSS.Logger_Results_File_Details.static_Logger_Label_Gen_UniqueID
                str_Heading_Prefix_1 = globalsSS.Logger_Results_File_Details.static_Logger_Colname__Prefix__Sampling_FULL_SAMPLING_OF_COHORTS_Results

                self.obj_Logging__FULL_SAMPLING_OF_COHORTS.func_Log_MultiLine_Results_Header(self.obj_Results_Log__FULL_SAMPLING_OF_COHORTS, str_Heading_1, str_Heading_Prefix_1, dict_Multiline_Results)
                self.obj_Logging__FULL_SAMPLING_OF_COHORTS.func_Log_MultiLine_Results_Detail(str_Results_1, self.obj_Results_Log__FULL_SAMPLING_OF_COHORTS, dict_Multiline_Results)

            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass  
                                
                return dict_Experiment

            def method_End_Of_SAMPLING_Reporting__Sampling_Exp_Sampling_Proportions_Scaled_By_Max_Proportion_PSMP(self, dict_Experiment):
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     

                dict_Multiline_Results = self.method_End_Of_SAMPLING_Reporting__Extract_Multilines_To_Be_Logged(dict_Experiment)

                '''
                --------------------------
                Log the results
                --------------------------
                '''

                str_Results_1 = self.objSSParametersLocal.strUniqueRunID
                str_Heading_1 = globalsSS.Logger_Results_File_Details.static_Logger_Label_Gen_UniqueID
                str_Heading_Prefix_1 = globalsSS.Logger_Results_File_Details.static_Logger_Colname__Prefix__Sampling_FULL_SAMPLING_OF_COHORTS_Results

                self.obj_Logging__SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION.func_Log_MultiLine_Results_Header(self.obj_Results_Log__SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION, str_Heading_1, str_Heading_Prefix_1, dict_Multiline_Results)
                self.obj_Logging__SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION.func_Log_MultiLine_Results_Detail(str_Results_1, self.obj_Results_Log__SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION, dict_Multiline_Results)

            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass  
                                
                return dict_Experiment

            def method_End_Of_SAMPLING_Reporting__Sampling_Exp_2_2(self, dict_Experiment):
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     

                dict_Multiline_Results = self.method_End_Of_SAMPLING_Reporting__Extract_Multilines_To_Be_Logged(dict_Experiment)

                '''
                --------------------------
                Log the results
                --------------------------
                '''

                str_Results_1 = self.objSSParametersLocal.strUniqueRunID
                str_Heading_1 = globalsSS.Logger_Results_File_Details.static_Logger_Label_Gen_UniqueID
                str_Heading_Prefix_1 = globalsSS.Logger_Results_File_Details.static_Logger_Colname__Prefix__Sampling_Exp_2_2_Results

                self.obj_Logging__EXP_2_2.func_Log_MultiLine_Results_Header(self.obj_Results_Log__EXP_2_2, str_Heading_1, str_Heading_Prefix_1, dict_Multiline_Results)
                self.obj_Logging__EXP_2_2.func_Log_MultiLine_Results_Detail(str_Results_1, self.obj_Results_Log__EXP_2_2, dict_Multiline_Results)

            
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass  
                                
                return dict_Experiment

            def method_End_Of_SAMPLING_Reporting__Extract_Multilines_To_Be_Logged_RETIRE(self, dict_Experiment):
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     


                dict_Multiline_Results__Experiment = OrderedDict()
                for key_Exp, value_Exp in dict_Experiment.items():
                    if not isinstance(value_Exp, (OrderedDict, list)):
                        if key_Exp not in dict_Multiline_Results__Experiment.keys():
                            dict_Multiline_Results__Experiment[key_Exp] = value_Exp
                        else:
                            dict_Multiline_Results__Experiment[key_Exp].update(value_Exp)
                        pass
                    pass
                pass
                
                dict_Multiline_Results = OrderedDict()
                int_Line = 0    
                for key_Exp, value_Exp in dict_Experiment.items():
                    
                    dict_Line_Results = OrderedDict(dict_Multiline_Results__Experiment)
                    
                    if isinstance(value_Exp, OrderedDict):  
                        if key_Exp == globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories:
                            dict_Stats_Categories = OrderedDict(value_Exp)
                
                            for key_Stats_Cat, value_Stats_Cat in dict_Stats_Categories.items():
                                
                                if key_Stats_Cat not in dict_Line_Results.keys(): 
                                    dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category] = key_Stats_Cat
                                else:
                                    dict_Line_Results.update([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category, key_Stats_Cat)])
                                pass
                            
                                if isinstance(value_Stats_Cat, OrderedDict):

                                    dict_Stats_Cat_Details = OrderedDict(value_Stats_Cat)
                                    
                                    for key_Stats_Cat_Detail, value_Stats_Cat_Detail in dict_Stats_Cat_Details.items():
                                        
                                        if not isinstance(value_Stats_Cat_Detail, (OrderedDict, list)):
                                            if key_Stats_Cat_Detail not in dict_Line_Results.keys():
                                                dict_Line_Results[key_Stats_Cat_Detail] = value_Stats_Cat_Detail
                                            else:
                                                dict_Line_Results.update([(key_Stats_Cat_Detail, value_Stats_Cat_Detail)])
                                                pass
                                            pass
                                        elif isinstance(value_Stats_Cat_Detail, list): 
                                            if key_Stats_Cat_Detail == globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get:
                                                list_LDNe_PCrits_To_Get = value_Stats_Cat_Detail
                                                str_PCrits_To_Get = str(list_LDNe_PCrits_To_Get).strip('[]')
                                                if key_Stats_Cat_Detail not in dict_Line_Results.keys():
                                                    #dict_Line_Results[key_Stats_Cat_Detail] = str_PCrits_To_Get
                                                    dict_Line_Results[globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatPCrit] = str_PCrits_To_Get
                                                else:
                                                    #dict_Line_Results.update([(key_Stats_Cat_Detail, str_PCrits_To_Get)])
                                                    dict_Line_Results.update([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatPCrit, str_PCrits_To_Get)])
                                                    pass
                                                pass                                                
                                        elif isinstance(value_Stats_Cat_Detail, OrderedDict):      
                                    
                                            if key_Stats_Cat_Detail == globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates:
                                                    
                                                dict_Sampling_Replicates = OrderedDict(value_Stats_Cat_Detail)
                                                
                                                for key_Sampling_Replicates, value_Sampling_Replicates in dict_Sampling_Replicates.items():
                                                    
                                                    if key_Sampling_Replicates not in dict_Line_Results.keys(): 
                                                        dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates] = key_Sampling_Replicates
                                                    else:
                                                        dict_Line_Results.update([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates, key_Sampling_Replicates)])
                                                    pass
                                                
                                                    
                                                    if isinstance(value_Sampling_Replicates, OrderedDict):  
                                                        
                                                        dict_Sample_Replicate = OrderedDict(value_Sampling_Replicates)
                                                        
                                                        ''' Get Sample Filename '''
                                                        dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicate_Filename] = dict_Sample_Replicate[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicate_Filename]
                                                        ''' Sample stats by age '''
                                                        dict_Sample_Replicate_Source_VSP_Ages_And_Sizes = dict_Sample_Replicate[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_VSP_Ages_And_Sizes]
                                                        dict_Sample_Replicate_Sample_VSP_Ages_And_Sizes = dict_Sample_Replicate[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_VSP_Ages_And_Sizes]
                                                        dict_Sample_Replicate_Sample_VSP_Ages_And_Percent_Sample_Sizes = dict_Sample_Replicate[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Percent_VSP_Ages_And_Sizes]
                                                        
                                                        for key_Sample_Replicate, value_Sample_Replicate in dict_Sample_Replicate_Source_VSP_Ages_And_Sizes.items():
                                                              
                                                            #dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates] = key_Sample_Replicate
                                                                  
                                                            dict_Line_Results_New = OrderedDict(dict_Line_Results)
                                                            
                                                            
                                                            dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_VSP_Ages_And_Sizes__Ages] = int(key_Sample_Replicate)
                                                            dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_VSP_Ages_And_Sizes__Sizes] = value_Sample_Replicate
                                                            #dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_VSP_Ages_And_Sizes__Ages] = int(key_Sample_Replicate)
                                                            dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_VSP_Ages_And_Sizes__Sizes] = dict_Sample_Replicate_Sample_VSP_Ages_And_Sizes[key_Sample_Replicate]
                                                            #dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Percent_VSP_Ages_And_Sizes__Ages] = int(key_Sample_Replicate)
                                                            dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Percent_VSP_Ages_And_Sizes__Sizes] = dict_Sample_Replicate_Sample_VSP_Ages_And_Percent_Sample_Sizes[key_Sample_Replicate]
                                                              
                                                            dict_Multiline_Results[int_Line] = OrderedDict(dict_Line_Results_New) 
                                                              
                                                            int_Line += 1
                                                            pass
                                                        pass
                                                    pass
                                                pass
                                            pass
                                        pass     
                                    pass
                                pass
                            pass
                        pass
                    pass
                pass

                return dict_Multiline_Results

            def method_End_Of_SAMPLING_Reporting__Extract_Multilines_To_Be_Logged(self, dict_Experiment):
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass     


                dict_Multiline_Results__Experiment = OrderedDict()
                for key_Exp, value_Exp in dict_Experiment.items():
                    if not isinstance(value_Exp, (OrderedDict, list)):
                        if key_Exp not in dict_Multiline_Results__Experiment.keys():
                            dict_Multiline_Results__Experiment[key_Exp] = value_Exp
                        else:
                            dict_Multiline_Results__Experiment[key_Exp].update(value_Exp)
                        pass
                    pass
                pass
                
                dict_Multiline_Results = OrderedDict()
                int_Line = 0    
                for key_Exp, value_Exp in dict_Experiment.items():
                    
                    dict_Line_Results = OrderedDict(dict_Multiline_Results__Experiment)
                    
                    if isinstance(value_Exp, OrderedDict):

                        if key_Exp == 'Sim_Replicate_Details':
                            dict_Sim_Replicate_Details = OrderedDict(value_Exp)
                
                            for key_Sim_Replicate_Details, value_Sim_Replicate_Details in dict_Sim_Replicate_Details.items():
 
                                dict_Sim_Replicate_Details = OrderedDict(value_Sim_Replicate_Details)

                                #dict_Line_Results['Sim_Replicate'] = dict_Sim_Replicate_Details['Sim_Replicate']
                                dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_Data_Sim_Current_Replicate] = dict_Sim_Replicate_Details[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_Data_Sim_Current_Replicate]
                                dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_Last_Mating_In_Replicate] = dict_Sim_Replicate_Details[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sim_Last_Mating_In_Replicate]
                                #dict_Line_Results['Sim_Replicate_Filename'] = dict_Sim_Replicate_Details['Sim_Replicate_Filename']
                                dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_Data_Sim_Current_File] = dict_Sim_Replicate_Details[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_Data_Sim_Current_File]
                                
#                                 if key_Sim_Replicate_Details not in dict_Line_Results.keys(): 
#                                     dict_Line_Results['Sim_Replicate'] = key_Sim_Replicate_Details
#                                 else:
#                                     dict_Line_Results.update([('Sim_Replicate', key_Sim_Replicate_Details)])
#                                 pass
                                
                                for key_Sim_Replicate, value_Sim_Replicate in dict_Sim_Replicate_Details.items(): 
                                                                                 
                                    if isinstance(value_Sim_Replicate, OrderedDict):
                                        
                                        if key_Sim_Replicate == globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Categories:
                                            dict_Stats_Categories = OrderedDict(value_Sim_Replicate)
                                
                                            for key_Stats_Cat, value_Stats_Cat in dict_Stats_Categories.items():
                                                
                                                if key_Stats_Cat not in dict_Line_Results.keys(): 
                                                    dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category] = key_Stats_Cat
                                                else:
                                                    dict_Line_Results.update([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Stats_Category, key_Stats_Cat)])
                                                pass
                                            
                                                if isinstance(value_Stats_Cat, OrderedDict):
                
                                                    dict_Stats_Cat_Details = OrderedDict(value_Stats_Cat)
                                                    
                                                    for key_Stats_Cat_Detail, value_Stats_Cat_Detail in dict_Stats_Cat_Details.items():
                                                        
                                                        if not isinstance(value_Stats_Cat_Detail, (OrderedDict, list)):
                                                            if key_Stats_Cat_Detail not in dict_Line_Results.keys():
                                                                dict_Line_Results[key_Stats_Cat_Detail] = value_Stats_Cat_Detail
                                                            else:
                                                                dict_Line_Results.update([(key_Stats_Cat_Detail, value_Stats_Cat_Detail)])
                                                                pass
                                                            pass
                                                        elif isinstance(value_Stats_Cat_Detail, list): 
                                                            if key_Stats_Cat_Detail == globalsSS.Colnames_EXPERIMENT_Parent_Offspring_Ne_1.static_Str_Colname_list_LDNe_PCrits_To_Get:
                                                                list_LDNe_PCrits_To_Get = value_Stats_Cat_Detail
                                                                str_PCrits_To_Get = str(list_LDNe_PCrits_To_Get).strip('[]')
                                                                if key_Stats_Cat_Detail not in dict_Line_Results.keys():
                                                                    #dict_Line_Results[key_Stats_Cat_Detail] = str_PCrits_To_Get
                                                                    dict_Line_Results[globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatPCrit] = str_PCrits_To_Get
                                                                else:
                                                                    #dict_Line_Results.update([(key_Stats_Cat_Detail, str_PCrits_To_Get)])
                                                                    dict_Line_Results.update([(globalsSS.Colnames_Ne2_Output.static_Str_Colname_Ne2_floatPCrit, str_PCrits_To_Get)])
                                                                    pass
                                                                pass                                                
                                                        elif isinstance(value_Stats_Cat_Detail, OrderedDict):      
                                                    
                                                            if key_Stats_Cat_Detail == globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates:
                                                                    
                                                                dict_Sampling_Replicates = OrderedDict(value_Stats_Cat_Detail)
                                                                
                                                                for key_Sampling_Replicates, value_Sampling_Replicates in dict_Sampling_Replicates.items():
                                                                    
                                                                    if key_Sampling_Replicates not in dict_Line_Results.keys(): 
                                                                        dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates] = key_Sampling_Replicates
                                                                    else:
                                                                        dict_Line_Results.update([(globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates, key_Sampling_Replicates)])
                                                                    pass
                                                                
                                                                    
                                                                    if isinstance(value_Sampling_Replicates, OrderedDict):  
                                                                        
                                                                        dict_Sample_Replicate = OrderedDict(value_Sampling_Replicates)
                                                                        
                                                                        ''' Get Sample Filename '''
                                                                        dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicate_Filename] = dict_Sample_Replicate[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicate_Filename]
                                                                        ''' Sample stats by age '''
                                                                        dict_Sample_Replicate_Source_VSP_Ages_And_Sizes = dict_Sample_Replicate[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_VSP_Ages_And_Sizes]
                                                                        dict_Sample_Replicate_Sample_VSP_Ages_And_Sizes = dict_Sample_Replicate[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_VSP_Ages_And_Sizes]
                                                                        dict_Sample_Replicate_Sample_VSP_Ages_And_Percent_Sample_Sizes = dict_Sample_Replicate[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Percent_VSP_Ages_And_Sizes]
                                                                        
                                                                        for key_Sample_Replicate, value_Sample_Replicate in dict_Sample_Replicate_Source_VSP_Ages_And_Sizes.items():
                                                                              
                                                                            #dict_Line_Results[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sampling_Replicates] = key_Sample_Replicate
                                                                                  
                                                                            dict_Line_Results_New = OrderedDict(dict_Line_Results)
                                                                            
                                                                            
                                                                            dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_VSP_Ages_And_Sizes__Ages] = int(key_Sample_Replicate)
                                                                            dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Source_VSP_Ages_And_Sizes__Sizes] = value_Sample_Replicate
                                                                            #dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_VSP_Ages_And_Sizes__Ages] = int(key_Sample_Replicate)
                                                                            dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_VSP_Ages_And_Sizes__Sizes] = dict_Sample_Replicate_Sample_VSP_Ages_And_Sizes[key_Sample_Replicate]
                                                                            #dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Percent_VSP_Ages_And_Sizes__Ages] = int(key_Sample_Replicate)
                                                                            dict_Line_Results_New[globalsSS.Colnames_COMMON_EXPERIMENT.static_Str_Colname_Sample_Percent_VSP_Ages_And_Sizes__Sizes] = dict_Sample_Replicate_Sample_VSP_Ages_And_Percent_Sample_Sizes[key_Sample_Replicate]
                                                                              
                                                                            dict_Multiline_Results[int_Line] = OrderedDict(dict_Line_Results_New) 
                                                                              
                                                                            int_Line += 1
                                                                            pass
                                                                        pass
                                                                    pass
                                                                pass
                                                            pass
                                                        pass     
                                                    pass
                                                pass
                                            pass
                                        pass
                                    pass
                                pass
                            pass
                        pass
                    pass
                pass

                return dict_Multiline_Results
                                                                     

            def method_Close_Log_Files__Sampling(self):

                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2 = Timer2(True)
                    t2.Start()
                pass
                            
                '''
                ---------------------------
                Close log files
                ---------------------------
                '''
                list_tup_Logs = [
                                (self.obj_Logging__S_STRAT, self.obj_Results_Log__S_STRAT)
                                ,(self.obj_Logging__100P_A_COHORTS, self.obj_Results_Log__100P_A_COHORTS)
                                ,(self.obj_Logging__FULL_EMBRYO_COHORT, self.obj_Results_Log__FULL_EMBRYO_COHORT)
                                ,(self.obj_Logging__FULL_JUVENILE_COHORTS, self.obj_Results_Log__FULL_JUVENILE_COHORTS)
                                ,(self.obj_Logging__FULL_ADULT_COHORTS, self.obj_Results_Log__FULL_ADULT_COHORTS)
                                ,(self.obj_Logging__FULL_SAMPLING_OF_COHORTS, self.obj_Results_Log__SAMPLING_OF_COHORTS)
                                ,(self.obj_Logging__SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION, self.obj_Results_Log__SAMPLING_PROPORTIONS_SCALED_BY_MAX_PROPORTION)
                                ,(self.obj_Logging__EXP_2_2, self.obj_Results_Log__EXP_2_2)
                                ]
                
                self.method_Close_Log_Files(list_tup_Logs)
                
                
                if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    t2.Stop(self.obj_Log_Debug_Timing, '', bool_Pause_Run=globalsSS.Logger_Debug_Timing.bool_Debug_Timing__Pause)
                    #if globalsSS.Logger_Debug_Timing.bool_Debug_Timing:
                    #    t2 = Timer2(True)
                    #    t2.Start()
                    #pass                    
                pass  
                                    
                return True
            
            '''
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            Generic Logging Operations
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            '''

            '''
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            # Close log files
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            '''
            def method_Close_Log_Files(self, list_tup_Logs):

                for tup_Log_obj in list_tup_Logs:
                    ''' Clear the log handlers'''
                    tup_Log_obj[1].handlers = []
                    ''' None the log object '''
                    #obj_Logger = tup_Log_obj[0]
                    #obj_Logger = None
                pass

                return True 
                      
            def Get_Log_Current_Column_Index(self, bool_Reset, intLevel, bool_Add_Suffix = False, str_Suffix = ''):
                
                if bool_Reset:
                    self.str_Current_Col_Index = str(
                                                     str(intLevel) +
                                                     globalsSS.StringDelimiters.static_stringDelimiter_DOT +
                                                     '0' +
                                                     globalsSS.StringDelimiters.static_stringDelimiter_DOT +
                                                     '0' +
                                                     globalsSS.StringDelimiters.static_stringDelimiter_DOT +
                                                     '0')
                else:
                    L, h, i, j = self.str_Current_Col_Index.split(globalsSS.StringDelimiters.static_stringDelimiter_DOT)
                    
                    h = int(h)
                    i = int(i)
                    j = int(j)
                    
                    j += 1
                    
                    '''Get column numbering'''
                    if j == 10:
                        j = 0
                        i += 1
                        if i == 10:
                            i = 0
                            h += 1
                            if h == 10:
                                self.obj_Log_Default.warn('Column index number has exceeded its max number 9.9.9. Dataframes will not be in the correct column order')
                        pass
                    pass
                    
                    self.str_Current_Col_Index = str(
                                        str(intLevel) +
                                        globalsSS.StringDelimiters.static_stringDelimiter_DOT +
                                        str(h) +
                                        globalsSS.StringDelimiters.static_stringDelimiter_DOT +
                                        str(i) +
                                        globalsSS.StringDelimiters.static_stringDelimiter_DOT +
                                        str(j))
                    
                pass
        
                if bool_Add_Suffix:
                    self.str_Current_Col_Index = self.str_Current_Col_Index + str(str_Suffix)
                pass
            
                return self.str_Current_Col_Index
            
            def func_Get_Func_Specific_Logger_Name(self, str_Log_Output_Path, str_Logger_Name): 
                
                obj_Logging = Logging()
                obj_Logging.str_Logger_Name = str_Logger_Name
                obj_Logging.str_Logger_Level = 'info'
                obj_Logging.bool_ClearLogFileAtStart = True
                obj_Logging.bool_LogToConsole = True
                obj_Logging.bool_LogToFile = True
                obj_Logging.strLogPath = str_Log_Output_Path
                obj_Logging.strLogFile = str_Logger_Name
        
                return obj_Logging
               
               
            def func_Get_Func_Specific_Python_Logger(self, obj_Logging): 
                
                obj_Logging.func_Initialise_New_Logger()
                obj_Log = logging__getLogger(obj_Logging.str_Logger_Name)
                
                return obj_Log
                   
            '''
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            Logger initilisation
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            '''
            def method_Get_Results_Logger(self, bool_LogToConsole, str_Logger_Path, str_Logger_Name, str_Logger_FileName_Suffix, strFileName_Experiment_Label, str_Experiment):

                with FileHandler() as obj_File_Op:
                    obj_File_Op.method_Create_Path(str_Logger_Path)
                    
                str_Logger_Name = self.objSSParametersLocal.strUniqueRunID + '_' + str_Logger_Name + '_' + strFileName_Experiment_Label + '_' + str_Experiment + str_Logger_FileName_Suffix
                                
                obj_Logging = Logging()
                obj_Logging.str_Logger_Name = str_Logger_Name
                obj_Logging.str_Logger_Level = 'info'
                obj_Logging.bool_ClearLogFileAtStart = True
                obj_Logging.bool_LogToConsole = bool_LogToConsole
                obj_Logging.bool_LogToFile = True
                obj_Logging.strLogPath = str_Logger_Path
                obj_Logging.strLogFile = str_Logger_Name
                #obj_Logging = self.func_Get_Func_Specific_Logger_Name(str_Logger_Path, str_Logger_Name)

                ''' Create logger to record results '''
                int_Level = 1
                str_Logger_Name = obj_Logging.strLogFile
                obj_Logging.func_Initialise_New_Logger()
                obj_Log_Results = logging__getLogger(obj_Logging.str_Logger_Name)
                    
                ''' Check if logger already exists'''
                with FileHandler() as objFileOperation:
                    boolFileExistsAtDestination = objFileOperation.fileExists(obj_Logging.strLogPath + '\\' + obj_Logging.strLogFile)

                return obj_Logging, obj_Log_Results
                        
            '''
            --------------------------------------------------------------------------------------------------------
            # Database Processing
            --------------------------------------------------------------------------------------------------------
            '''
           

                
            '''            
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< CLASS FINALIZATION
            '''
            def classCleanUp(self):

                #del self.pop
                # Add class clean up items here
                boolSuccessful=False

                return boolSuccessful

        self.SSSamplingOperation_obj = SSSamplingTestOperation() 
        return self.SSSamplingOperation_obj
 
    def __exit__(self, type, value, traceback): 
        self.SSSamplingOperation_obj.classCleanUp()