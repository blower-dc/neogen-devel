'''
-----------------------------------------------
                FUTURE PYTHON COMPATIBILITY
-----------------------------------------------
'''
#------------------< Import future python modules
from __future__ import print_function

'''
-----------------------------------------------
                MODULE NOTES
-----------------------------------------------
'''
'''
Created on 25/01/2016

@author: Dean
'''
'''
-----------------------------------------------
                RELEASE INFO
-----------------------------------------------
'''
#------------------------------------< Import app details modules
from version import version as app_details
''' Display app version details '''
print('\nProject: '+ str(app_details.__project__))
print('Author: '+ str(app_details.__author__))
print('Version: '+ str(app_details.__version__))
print('Date: '+ str(app_details.__date__))
print('Copyright: '+ str(app_details.__copyright__))
print('License: '+ str(app_details.__license__))

#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< PACKAGE IMPORTS
#
#------------------< Import python modules
# DEBUG Imports
from handler_Debug import Debug_Location as dcb_Debug_Location
from handler_Debug import Timer2
#
from time import sleep as time__sleep
from threading import Timer as threading__Timer
from collections import OrderedDict
from datetime import datetime
from logging import getLogger as logging__getLogger
from os import path as os__path
from os import extsep as os__extsep
from os import chdir as os__chdir
from os import getcwd as os__getcwd
import os
#from os import getcwd as os__getcwd
from shutil import rmtree as shutil__rmtree
import sys
import traceback
#import os, fnmatch
from subprocess import Popen as subprocess__Popen
from subprocess import CREATE_NEW_CONSOLE as subprocess__CREATE_NEW_CONSOLE
import psutil
from multiprocessing import cpu_count as multiprocessing__cpu_count
import tkMessageBox
import Tkinter as tkinter
from PIL import Image as PIL__Image
from PIL import ImageTk as PIL__ImageTk
import zipfile
from unicodedata import category as unicodedata__category
from PyQt4 import QtCore, QtGui, uic, QtWebKit
from PyQt4.QtWebKit import QWebView
#------------------< Import DCB_General modules
from globals_DCB_General import globalsDCBGen
from FileHandler import FileHandler
from SSInputHandler import SSInputHandler
from SSConfigHandler import SSConfigOperation
from globals_SharkSimFE import globalsSSFE
from globals_SharkSim import globalsSS
from object_SSConfigBatchScenario import object_SSConfigBatchScenario
from object_SSConfigBatchSettings import object_SSConfigBatchSettings
#from object_SSConfigFiles import object_SSConfigFiles
from object_SSConfigProject import object_SSConfigProject
from object_SSConfigProjects import object_SSConfigProjects
from object_SSConfigSamplingStrategy import object_SSConfigSamplingStrategy
from object_SSConfigSettings import object_SSConfigSettings
from object_SSFEFormDialog_Age_Cohort_Mortality_Rates import Ui_Dialog_Age_Cohort_Mortality_Rates
from object_SSFEFormDialog_Age_Cohort_Sampling_Proportions import Ui_Dialog_Age_Cohort_Sampling_Proportions
from object_SSFEFormDialog_Context_Help import Ui_Dialog_Context_Help
#
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< CLASS DECLARATIONS
qtDesigner_Main_Form = uic.loadUiType("SharkSimFE_CURRENT_FORM.ui")[0]
#  
#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< CLASS DEFINITION

class Ui_MainWindow(QtGui.QMainWindow, qtDesigner_Main_Form):

    '''
    -------------------------------------------------------------------------------
        Initialse
    -------------------------------------------------------------------------------
    '''
    def __init__(self, str_Application_Working_Path, str_Application_Settings_Path_And_File, bool_App_Arg_Debug_Logging, parent=None):
                
        ''' Flag that INIT has STARTED '''
        self.bool_Init_Finished = False

        '''
        -------------------------------------------
        Initialise STARTING PATHS and FILES
        -------------------------------------------
        '''
        self.str_Application_Working_Path = str_Application_Working_Path
        self.str_Application_Settings_Path_And_File = str_Application_Settings_Path_And_File
        self.str_Application_Run_Path, _ = os__path.split(self.str_Application_Settings_Path_And_File)
        self.bool_App_Arg_Debug_Logging = bool_App_Arg_Debug_Logging
                       
        '''
        -------------------------------------------
        Initialise LOGGERS
        -------------------------------------------
        '''
        ''' Get all the loggers required for monitoring this object '''
        self.func_Initialise_Monitor_Loggers()
        
        '''
        -------------------------------------------
        Initialise VARIABLES
        -------------------------------------------
        '''
        self.func_Initialise_Variables__Pre_Settings_Load()
                       
        '''
        -------------------------------------------
        Initialise MAIN FORM WINDOW
        -------------------------------------------
        '''
        super(Ui_MainWindow, self).__init__(parent)
        self.setupUi(self)

        '''
        -------------------------------------------
        Initialise ERROR HANDLING
        -------------------------------------------
        '''        
        ''' Intercept and handle uncaught exceptions '''
        sys.excepthook = self.func_Error_Handler__UNCaught_Exceptions
        
        '''
        -------------------------------------------
        Initialise EVENT FILTERS
        -------------------------------------------
        '''        
        self.func_Bind_Event_Filters()
        self.func_Bind_Event_Handlers()

        '''
        -------------------------------------------
        Get DEFAULT SETTINGS from config file
        -------------------------------------------
        '''  
        ''' Read SETTINGS file '''
        obj_Config = object_SSConfigSettings()
        self.obj_Config_Settings = self.func_Read_Config_File(self.str_Application_Settings_Path_And_File, obj_Config)              
        
        ''' Get SETTINGS config data '''
        self.func_Get_Config_Data__SETTINGS(self.obj_Config_Settings)    
        
        ''' Get paths from the Setting config file '''
        self.str_Application_Settings_Path = os__path.join(self.str_Application_Working_Path, self.str_Settings_Run_Config_Folder__Default_Value)
        
        ''' Get paths path of projects config file '''
        self.str_Application_Projects_Path = os__path.join(self.str_Application_Settings_Path, self.str_Settings_Run_Projects_Folder__Default_Value)
        
        ''' Get the Projects path & file '''
        str_Projects_Base_Path = self.str_Application_Projects_Path
        str_Base_Filename =  globalsSSFE.App_File.static_str__App_File_Prefix__Projects #'Projects'
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        #DEBUG_ON
        #''' Use this to test an Handled exception - Comment the Line after the DEBUG_OFF'''
        #self.str_Application_Projects_Path_And_File = ''
        #DEBUG_OFF  
        self.str_Application_Projects_Path_And_File = os__path.join(str_Projects_Base_Path, ''.join([str_Base_Filename, os__extsep, str_Extension]))        
        self.str_Application_Projects_Path, self.str_Application_Projects_File = os__path.split(self.str_Application_Projects_Path_And_File)
        self.str_Application_Docs_Path = os__path.join(self.str_Application_Working_Path, self.str_Settings_Run_Docs_Folder__Default_Value)        
        '''
        -------------------------------------------
        Initialise VALIDATORS & WIDGETS
        -------------------------------------------
        '''        
        self.func_Initialise_Validators__Post_Settings_Load()
        self.func_Initialise_Widgets__Post_Settings_Load()
        
        '''
        -------------------------------------------
        Run App FIRST TIME RUN Operations 
        -------------------------------------------
        '''        
        if self.bool_Settings_Run_FirstTime:
            ''' May not need this function '''
            self.func_Initialise_App__First_Run_Initialisation()
        pass
        '''
        -------------------------------------------
        Load Config file data and prepare App for User interaction
        -------------------------------------------
        '''        
        self.func_Initialise_PROJECT_Widgets_With_Data(self.str_Application_Projects_Path_And_File)
        
        self.bool_Changed_Config__Batch_Scenario = True

        if len(self.list_Scenario_Files) > 0:
            str_Batch_Scenario_Relative_Path_And_File__Current = str(self.comboBox_200.currentText())  
            self.func_Populate_Widgits_With_Config_Data__BATCH_SCENARIO(str_Batch_Scenario_Relative_Path_And_File__Current)
        pass
    
        #DEBUG_ON
        #''' Use this to test an Unhandled exception - Comment the Line after the DEBUG_OFF'''
        #if len() > 0:
        #DEBUG_OFF            
        if len(self.list_Sampling_Strategy_Files) > 0:
            str_Sampling_Strategy_Relative_Path_And_File__Current = str(self.comboBox_300.currentText())             
            self.func_Populate_Widgits_With_Config_Data__SAMPLING_STRATEGY(str_Sampling_Strategy_Relative_Path_And_File__Current)
        pass
        self.bool_Changed_Config__Batch_Scenario = False
        
        ''' Flag that INIT has finished '''
        self.bool_Init_Finished = True
        
        '''
        --------------------------------------------
        Post-Initialisation Operations
        --------------------------------------------
        '''
        self.func_Initalise_App__Post_Initialisation_Operations()
        
        return None

    def raise_above_all(self, window):
        #window.raiseW() # this might be raiseW() in Python
        window.setActiveWindow()
    
    def func_Initialise_Monitor_Loggers(self):
        
        ''' 
        ~~~~~~~~~~~~~~~~~~~~~~~~~~
        Get all the loggers required for monitoring this object
        ~~~~~~~~~~~~~~~~~~~~~~~~~~
        '''
        ''' Get Run Display Logger '''
        #self.obj_Log_Run_Display = logging__getLogger(globalsSSFE.Logger_Run_Display.static_Logger_Name__Run_Display)
                    
        ''' Get Default Logger '''
        self.obj_Log_Default_Display = logging__getLogger(globalsSSFE.Logger_Default_Display.static_Logger_Name__Default_Display)
 
        ''' Get Debug Logger '''
        self.obj_Log_Debug_Display = None
        if self.bool_App_Arg_Debug_Logging:
            self.obj_Log_Debug_Display = logging__getLogger(globalsSSFE.Logger_Debug_Display.static_Logger_Name__Debug_Display)
        pass
    
        ''' Get Debug Timer '''
        self.obj_Log_Debug_Timing = None
        if globalsSSFE.Logger_Debug_Timing.bool_Debug_Timing:
            self.obj_Log_Debug_Timing = logging__getLogger(globalsSSFE.Logger_Debug_Timing.static_Logger_Name__Debug_Timing)
        pass

#         ''' Get Debug Events Logger '''
#         self.obj_Log_Debug_Events = None
#         if globalsSSFE.Logger_Debug_Events.bool_Debug_Events:
#             self.obj_Log_Debug_Events = logging__getLogger(globalsSSFE.Logger_Debug_Events.static_Logger_Name__Debug_Events)
#         pass
                                 
        return True

    def func_Initialise_Variables__Pre_Settings_Load(self):

        self.func_Initialise_Variables__Main_Form()
        self.func_Initialise_Variables__Page_Choose_Project_Scenario__Tab_Choose_Project_Scenario()
        self.func_Initialise_Variables__Page_Modify_Scenario__Tab_Life_History()
        self.func_Initialise_Variables__Page_Modify_Scenario__Tab_Demography()
        self.func_Initialise_Variables__Page_Modify_Scenario__Tab_Genetics()
        self.func_Initialise_Variables__Page_Run_Scenario__Tab_Run_Scenario()
        self.func_Initialise_Variables__Page_Results_Batch_Scenario()
        self.func_Initialise_Variables__Page_Create_Select_Sampling_Strategy__Tab_Choose_Strategy()
        self.func_Initialise_Variables__Page_Modify_Sampling_Strategy__Tab_Modify_Sample_Size_And_Locus_Range()
        self.func_Initialise_Variables__Page_Run_Sampling_Strategy__Tab_Modify_Run_Parameters()
        self.func_Initialise_Variables__Page_Results_Sampling_Strategy()
        self.func_Initialise_Variables__Linked_Sliders_And_Spinboxes__Define_Companions()
        return True

    def func_Initialise_Variables__Main_Form(self):
        
        self.dialog_Context_Help = None
        self.bool_Context_Help__Follow_Context = True
        
        self.dict_Parameter_Status = OrderedDict()
        
        self.str_Settings_Path_And_Name__Current = ''
        self.str_Settings_Run_App_Version__Default_Value = ''
        self.str_Settings_Run_App_Name__Default_Value = ''
        self.bool_Settings_Run_FrontEnd_DEBUG_Show_Settings_Menu__Default_Value = False
        self.bool_Settings_Run_FrontEnd_DEBUG_Logging__Default_Value = False
        self.int_Settings_Run_FrontEnd_Job_Run_Monitor_Job_Status_Time_Delay_Secs__Default_Value = 0
        self.int_Settings_Run_FrontEnd_Job_Run_Monitor_Job_Termination_Status_Time_Delay_Secs__Default_Value = 0

        self.str_Settings_Run_Project_Configs_Path__Default_Value = ''
        self.str_Settings_Run_Project_Configs_Relative_Path__Default_Value = ''
        self.str_Settings_Run_Projects_Folder__Default_Value = ''
        self.str_Settings_Run_Project_Folder_Prefix__Default_Value = ''
        self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value = ''
        self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value = ''
        self.str_Settings_Run_Results_Folder_Prefix__Default_Value = ''
        self.str_Settings_Run_Results_Plots_Folder_Prefix__Default_Value = ''
        self.str_Settings_Run_Results_Thumbnail_Images_Folder_Prefix__Default_Value = ''
        self.str_Settings_Run_File_Extension_Config_File__Default_Value = ''
        self.str_Settings_Run_File_Extension_Image_File__Default_Value = ''

#         self.str_App_Run_Path_And_File = ''
#         self.str_App_Run_Path = ''
#         self.str_App_Run_File = ''
#         ''' GET THE CURRENT FRONTEND EXECUTABLE PATH '''
#         self.str_App_Run_Path_And_File = __file__
#         self.str_App_Run_Path, self.str_App_Run_File = os__path.split(self.str_App_Run_Path_And_File)

        self.str_Settings_Run_FrontEnd_Relative_Path__Default_Value = ''
        self.str_Settings_Run_BackEnd_Relative_Path__Default_Value = ''
        self.str_Settings_Run_BackEnd_Working_Base_Relative_Path__Default_Value = ''
        self.str_Settings_Run_BackEnd_BINARY_Executable_Relative_Path__Default_Value = ''

        self.bool_Settings_Run_FirstTime = False
        self.str_Settings_Run_FrontEnd_Path__Default_Value = ''
        self.str_Settings_Run_BackEnd_Path__Default_Value = ''
        self.str_Settings_Run_BackEnd_ExecutableName__Default_Value = ''
        self.str_BackEnd_Working_Base_Path = ''
        self.int_Settings_Run_BackEnd_Job_CPUs_To_Leave_In_Reserve__Default_Value = 0
        self.int_Settings_Run_BackEnd_Path_Max_Allowable_Length__Default_Value = ''
        self.str_Settings_Run_Python_Executable_Path__Default_Value = ''
        self.str_Settings_Run_Python_Executable_Name__Default_Value = ''
        self.str_Settings_Run_BackEnd_BINARY_Executable_Path__Default_Value = ''
        self.str_Settings_Run_BackEnd_BINARY_Executable_Name__Default_Value = ''
        self.bool_Settings_Run_BackEnd_BINARY_Executable__Default_Value = False
        self.bool_Settings_Context_Help_Display_At_Start__Default_Value = False
        self.float_Settings_Context_Help_Zoom_Factor__Default_Value = 0.0 
        self.float_Settings_Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep__Default_Value = 0.0
            
        self.str_BackEnd_Working_Path = ''
        self.str_Project_Path_And_File__Current = ''
        self.str_Batch_Scenario_Relative_Path_And_File__Current = ''
        self.str_Batch_Scenario_Path_And_File__Current = ''
        self.str_Batch_Scenario_Path__Current = ''
        self.str_Batch_Scenario_File__Current = ''
        self.str_Batch_Settings_Relative_Path_And_File__Current = ''
        self.str_Batch_Settings_Path_And_File__Current = ''
        self.str_Batch_Settings_Path__Current = ''
        self.str_Batch_Settings_File__Current = ''
        #self.str_Config_File_Path_And_Name__Sampling_Strategy = ''
        self.str_Sampling_Strategy_Relative_Path_And_File__Current = ''
        self.str_Sampling_Strategy_Path_And_File__Current = ''
        self.str_Sampling_Strategy_Path__Current = ''
        self.str_Sampling_Strategy_File__Current = ''
                       
        self.int_Job_Run_Current_Processing_Step = -1
        self.int_Run_Status_Error_Flag__Current = 0
        self.int_Run_Status_Flag__Current = 0
        self.int_Run_Status_Flag__Current__Scenario = 0
        self.int_Run_Status_Flag__Current__Sampling_Strategy = 0
        
        self.pid_Spawned_PARENT_Process = 0
        self.pid_Spawned_CHILD_Process = 0
        
        self.list_Project_Files = []
        self.list_Project_Names = []
        self.list_Scenario_Files = []
        self.list_Scenario_Names = []

        self.obj_Config_Settings = None
        self.obj_Config_Projects = None
        self.obj_Config_Project = None
        self.obj_Config_Batch_Scenario = None
        self.obj_Config_Batch_Settings = None
        self.obj_Config_Sampling_Strategy = None
        
        ''' Retain orig Companion Control value '''
        self.int_Slider_Orig_Value = 0
        self.int_SpinBox_Orig_Value = 0
        ''' Check if Companion Control is being interacted with '''
        self.bool_ComboBox_Events_Disabled = False
        self.bool_Slider_Events_Disabled = False
        self.bool_Slider_Engaged = False
        self.bool_SpinBox_Engaged = False
        self.str_Slider_Engaged_Name = ''
        self.str_SpinBox_Engaged_Name = ''
        ''' Check if Companion Control has had its mouse button released thereby setting its value '''
        self.bool_SpinBoxMouseButtonReleased = False
        self.bool_SliderMouseButtonReleased = False
         
        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False  
        self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False  
        self.bool_Reload_Widgets_Finished__Batch_Scenario = False
        self.bool_Reload_Widgets_Finished__Sampling_Strategy = False

        self.str_Project_Name__Current = ''
        self.int_Project_UID = 0
        
        self.bool_str_Project_Name_FOUND = False
        self.bool_int_Project_UID_FOUND = False
        
        self.int_Settings_Job_Run_Scenario_Job__Time_Delay_In_Secs_Before_Monitoring__Default_Value = 0 
        self.bool_Job_Status__Terminated = False
        self.bool_Job_Status__Complete = False
        self.str_Job_Status__Terminated_Reason = ''
        self.str_Job_Status__Status = ''
        self.t2 = None
        self.t1 = None     
       
        self.bool_Results_Window_Displayed = False

        self.int_Edit_Warning_Count__All_Batch_Scenario_Params = 0
        self.int_Edit_Warning_Count__All_Sampling_Strategy_Params = 0

        self.str_Path_And_Thumb_Displayed__Sampling_Strategy = ''
        self.str_Path_And_Thumb_Displayed__Batch_Scenario = ''
        self.list_Path_And_Files__Batch_Scenario__Results_Plots_Thumbs = []
        self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Thumbs = []
        self.list_Path_And_Files__Batch_Scenario__Results_PDFs = []
        self.list_Path_And_Files__Sampling_Strategy__Results_PDFs = []
        
        return True
    
    def func_Initialise_Variables__Page_Choose_Project_Scenario__Tab_Choose_Project_Scenario(self):

        self.str_Project_Name__Current = ''
        self.int_Batch_Scenario_UID__Current = 0
        self.str_Project_Species_Name = ''
        self.str_Scenario_Project_Name = ''
        self.int_Scenario_Project_UID = 0
        self.str_Scenario_Name__Current = ''
        self.str_Sampling_Strategy_Path_And_File__Current = ''
                
        self.bool_int_Project_Name__FOUND = False
        self.bool_int_Scenario_UID__FOUND= False
        self.bool_int_Project_Species_Name__FOUND= False
        self.bool_str_Scenario_Project_Name__FOUND = False
        self.bool_int_Scenario_Project_UID__FOUND = False
        self.bool_str_Scenario_Name__FOUND = False
        self.bool_int_Scenario_UID__FOUND = False
        self.bool_str_Sampling_Strategy_Path_And_File__Current__FOUND = False
        
        self.str_Project_Name__Label_Text = ''
        self.str_Project_Species_Name__Label_Text = ''
        self.str_Scenario_Name__Current__Label_Text = ''
        self.str_Scenario_Cloned_Name__Label_Text = ''
        
        ''' BATCH SETTINGS '''
        self.str_Batch_Settings_Relative_Path_And_File = ''
        self.str_Batch_Settings_Scenario_Name = ''
        self.int_Batch_Settings_Batch_Scenario_UID = ''
        self.str_Batch_Setting_Last_Batch_Scenario_Run_UID = ''
        self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status = ''
        self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason = ''
        self.int_Batch_Setting_Last_Batch_Scenario_Run_Shell_PID = 0
        self.int_Batch_Setting_Last_Batch_Scenario_Run_Python_PID = 0

        self.bool_str_Batch_Settings_Scenario_Name__FOUND = False
        self.bool_int_Batch_Settings_Batch_Scenario_UID__FOUND = False             
        self.bool_str_Batch_Setting_Last_Batch_Scenario_Run_UID__FOUND = False   
        self.bool_Batch_Setting_Last_Batch_Scenario_Run_Job_Status__FOUND = False
        self.bool_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason__FOUND = False
        self.bool_int_Batch_Setting_Last_Batch_Scenario_Run_Shell_PID__FOUND = False
        self.bool_int_Batch_Setting_Last_Batch_Scenario_Run_Python_PID__FOUND = False
        
        self.str_Batch_Setting_Last_Sampling_Strategy_Run_UID = ''
        self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status = ''
        self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason = ''
        self.int_Batch_Setting_Last_Sampling_Strategy_Run_Shell_PID = 0
        self.int_Batch_Setting_Last_Sampling_Strategy_Run_Python_PID = 0

        self.bool_str_Batch_Setting_Last_Sampling_Strategy_Run_UID__FOUND = False   
        self.bool_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status__FOUND = False
        self.bool_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason__FOUND = False
        self.bool_int_Batch_Setting_Last_Sampling_Strategy_Run_Shell_PID__FOUND = False
        self.bool_int_Batch_Setting_Last_Sampling_Strategy_Run_Python_PID__FOUND = False
        
        self.bool_Batch_Scenario__Batch_Settings_Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED = False
        self.bool_Sampling_Strategy__Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED = False
   
        return True
    
    def func_Initialise_Variables__Page_Modify_Scenario__Tab_Life_History(self):

        ''' Page_Modify_Scenario__Tab_Life_History '''
        self.bool_int_Species_Life_History_Max_Age__FOUND = False          
        self.bool_int_Species_Life_History_Max_Mating_Age__FOUND = False          
        self.bool_int_Species_Life_History_Min_Mating_Age__FOUND = False          
        self.bool_int_Species_Life_History_Max_Age__CHANGED = False          
        self.bool_int_Species_Life_History_Max_Mating_Age__CHANGED = False          
        self.bool_int_Species_Life_History_Min_Mating_Age__CHANGED = False          
        self.bool_Species_Offspring_Distribution__FOUND = False
        self.bool_Species_Offspring_Distribution__CHANGED = False
        
        self.str_Species_Offspring_Distribution = ''
        self.str_Species_Offspring_Distribution__Label_Text = ''
        self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number = 0
        self.float_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number = 0.0
        self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number = 0.0
        self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev = 0.0
        self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min = 0
        self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max = 0
        self.float_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean = 0.0

        self.int_Species_Life_History_Max_Age__Default_Value = 0
        self.int_Species_Life_History_Max_Age__Max__Default_Value = 0
        self.int_Species_Life_History_Max_Age__Min__Default_Value = 0
        self.int_Species_Life_History_Max_Mating_Age__Default_Value = 0
        self.int_Species_Life_History_Max_Mating_Age__Max__Default_Value = 0
        self.int_Species_Life_History_Max_Mating_Age__Min__Default_Value = 0
        self.int_Species_Life_History_Min_Mating_Age__Default_Value = 0
        self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value = 0
        self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value = 0

        self.int_Species_Life_History_Max_Age__Default_Value = 0
        #self.int_Species_Life_History_Max_Age__Max__Default_Value = 0
        #self.int_Species_Life_History_Max_Age__Min__Default_Value = 0
        self.int_Species_Life_History_Max_Mating_Age__Default_Value = 0
        #self.int_Species_Life_History_Max_Mating_Age__Max__Default_Value = 0
        #self.int_Species_Life_History_Max_Mating_Age__Min__Default_Value = 0
        self.int_Species_Life_History_Min_Mating_Age__Default_Value = 0
        #self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value = 0
        #self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value = 0

        self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Default_Value = 0
        self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Max = 0
        self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Min = 0
        self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Default_Value = 0
        self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Max = 0
        self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Min = 0
        self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor = 0

        self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Default_Value = 0
        self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Max = 0
        self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Min = 0
        self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Decimals = 0
        self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor = 0
        self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Default_Value = 0
        self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Max = 0
        self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Min = 0
        self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Decimals = 0
        self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor = 0
        self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Default_Value = 0
        self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Max = 0
        self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Min = 0
        self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Default_Value = 0
        self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Max = 0
        self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Min = 0
        self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Default_Value = 0
        self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Max = 0
        self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Min = 0
        self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Decimals = 0
        self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor = 0

        self.str_Max_Age__Label_Text = ''
        self.str_Max_Mating_Age__Label_Text = ''
        self.str_Min_Mating_Age__Label_Text = ''
        self.str_Species_Offspring_Distribution__Label_Text = ''
        self.str_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Label_Text = ''
        self.str_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Label_Text = ''           
        self.str_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Label_Text = ''          
        self.str_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Label_Text = ''       
        self.str_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Label_Text = ''          
        self.str_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Label_Text = ''           
        self.str_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Label_Text = ''   


        self.int_Verify_Change__Scenario_Max_Age__Warning_Count = 0
        
        return True

    def func_Initialise_Variables__Page_Modify_Scenario__Tab_Demography(self):

        ''' Page_Modify_Scenario__Tab_Demography '''
        self.bool_int_Population_Size__FOUND = False
        self.bool_int_Population_Size__CHANGED = False
        self.int_Population_Size = 0
        self.int_Population_Size__Default_Value = 0
        self.int_Population_Size__Max = 0
        self.int_Population_Size__Min = 0

        self.str_Population_Size__Label_Text = ''
        self.str_Edit_Natural_Mortality_Rates__Label_Text = ''
        
        self.dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE = OrderedDict()
        self.dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE = OrderedDict()
        self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__FOUND = False
        self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__FOUND = False
        self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__CHANGED = False
        self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__CHANGED = False


        self.dict_Species_Demographic_Natural_MORTALITY_CSV_Age_And_MORTALITY_Rate__MALE = OrderedDict()
        self.dict_Species_Demographic_Natural_MORTALITY_CSV_Age_And_MORTALITY_Rate__FEMALE = OrderedDict()
        
        self.int_Verify_Change__Scenario_Demography_Population_Size__Warning_Count = 0
                
        return True

    def func_Initialise_Variables__Page_Modify_Scenario__Tab_Genetics(self):

        ''' Page_Modify_Scenario__Tab_Genetics '''
        self.bool_Genome_Mutation_Allowed__Default_Value = False
        self.float_Genome_Mutation_Rate__Default_Value = 0.0
        self.list_Settings__Genome_Source = []
        self.str_Genome_Source__Default_Value = ''
        self.str_Genome_Source_File__Default_Value = ''
        self.int_Genome_Locus_Number__Default_Value = 0
        self.int_Genome_Locus_Number__Max = 0
        self.int_Genome_Locus_Number__Min = 0
        self.list_Settings__Genome_Alleles_Per_Locus_Distribution = []
        self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Default_Value = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Max = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Min = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Default_Value = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Max = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Min = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Decimals = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Step_Divisor = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Default_Value = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Max = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Min = 0
        self.int_GGenome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Decimals = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor = 0
        self.list_Settings__Genome_Allele_Frequency_Distribution = []
        self.int_Genome_Locus_Number__Default_Value = 0

        self.bool_int_Genome_Locus_Number__FOUND = False
        self.int_Genome_Locus_Number = 0
        self.bool_Genome_Allele_Frequency_Distribution__FOUND = False
        self.str_Genome_Allele_Frequency_Distribution = ''
        self.bool_Genome_Alleles_Per_Locus_Distribution__FOUND = False
        self.str_Genome_Alleles_Per_Locus_Distribution = ''
        self.bool_str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name__FOUND = False
        self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name = ''
        self.int_Genome__Source_ALL_ALLELE_FREQUENCIES__Total_Loci = 0
        self.bool_str_Genome__Source_GENEPOP_File_Path_And_Name__FOUND = False
        self.str_Genome__Source_GENEPOP_File_Path_And_Name = ''
        self.int_Genome__Source_GENEPOP__Total_Loci = 0
        self.bool_int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__FOUND = False
        self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus = 0
        self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus = 0 
        self.bool_int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__FOUND = False        
        self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus = 0.0 
        self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__FOUND = False
        self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus = 0.0 
        self.bool_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__FOUND = False                        
        
        self.bool_int_Genome_Locus_Number__CHANGED = False
        self.bool_str_Genome_Allele_Frequency_Distribution__CHANGED = False
        self.bool_str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name__CHANGED = False
        self.bool_str_Genome__Source_GENEPOP_File_Path_And_Name__CHANGED = False
        self.bool_str_Genome_Alleles_Per_Locus_Distribution__CHANGED = False
        self.bool_int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__CHANGED = False        
        self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__CHANGED = False
        self.bool_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__CHANGED = False 
        
        self.str_Genome_Locus_Number__Label_Text = ''
        self.str_Genome_Alleles_Per_Locus_Distribution__Label_Text = ''
        self.str_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Label_Text = ''
        self.str_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Label_Text = ''
        self.str_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Label_Text = ''
        self.str_Genome_Allele_Frequency_Distribution__Label_Text = ''
        self.str_str_Genome_Source_File__Label_Text = ''
        
        return True

    def func_Initialise_Variables__Page_Run_Scenario__Tab_Run_Scenario(self):

        ''' Page_Run_Scenario__Tab_Run_Scenario '''
        
        self.int_Simulation_Batch_Replicates__Default_Value = 0
        self.int_Simulation_Batch_Replicates__Max = 0
        self.int_Simulation_Batch_Replicates__Min = 0
        self.int_Simulation_Batch_Replicate_Length__Calc_Default_Muliplier = 0
        self.int_Simulation_Batch_Replicate_Length_Burn_In__Default_Value = 0
        self.int_Simulation_Batch_Replicate_Length_Burn_In__Max = 0
        self.int_Simulation_Batch_Replicate_Length_Burn_In__Min = 0
        self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Default_Value = 0
        self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Max = 0
        self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Min = 0
        
        self.bool_int_Simulation_Batch_Replicates__FOUND = False          
        self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__FOUND = False          
        self.bool_int_Simulation_Batch_Replicate_Length_Temporal_Evolution__FOUND = False          

        self.bool_int_Simulation_Batch_Replicates__CHANGED = False          
        self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__CHANGED = False          
        self.bool_int_Simulation_Batch_Replicate_Length_Temporal_Evolution__CHANGED = False          

        self.int_Simulation_Batch_Replicates = 0
        self.str_Simulation_Batch_Replicates__Label_Text = ''
        self.int_Simulation_Batch_Replicate_Length_Burn_In = 0
        self.str_Simulation_Batch_Replicate_Length_Burn_In__Label_Text = ''            
        self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution = 0
        self.str_Simulation_Batch_Replicate_Length_Temporal_Evolution__Label_Text = ''            
        self.str_Scenario_Run_Simulation_Output_Base_Path = ''
        
        self.str_Scenario_Run_Simulation_Output_Base_Path = ''
        self.bool_str_Scenario_Run_Simulation_Output_Base_Path__FOUND = False
        self.bool_str_Scenario_Run_Simulation_Output_Base_Path__CHANGED = False

        self.int_Process_JOB_SHELL__PID = 0
        self.str_BackEnd_Run_UID__ENDED = ''  

        self.int_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts = 0
        self.bool_int_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts__FOUND = False
        self.bool_int_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts__CHANGED = False   
        self.int_Batch_Setting__Pop_Saving__Save_Pop_Every_Replicate_Mating_Count = 0
        self.bool_int_Batch_Setting__Pop_Saving__Save_Pop_Every_Replicate_Mating_Count__FOUND = False
        self.bool_int_Batch_Setting__Pop_Saving__Save_Pop_Every_Replicate_Mating_Count__CHANGED = False   
                 
        self.int_Batch_Setting__Pop_Sampling__Sample_Pop_Every_Mating_Count = 0
        self.bool_int_Batch_Setting__Pop_Sampling__Sample_Pop_Every_Mating_Count__FOUND = False
        self.bool_int_Batch_Setting__Pop_Sampling__Sample_Pop_Every_Mating_Count__CHANGED = False
        self.int_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count = 0
        self.bool_int_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count__FOUND = False  
        self.bool_int_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count__CHANGED = False  
     
        return True

    def func_Initialise_Variables__Page_Results_Batch_Scenario(self):

        ''' Page_Results_Sampling_Strategy '''
        
        self.list_Path_And_Files__Batch_Scenario__Results_Plots = []
        self.list_Path_And_Files__Batch_Scenario__Results_Plots_Captions = []
        return True
    
    def func_Initialise_Variables__Page_Create_Select_Sampling_Strategy__Tab_Choose_Strategy(self):

        self.str_Sampling_Strategy_Path_And_File__Current = ''
        self.int_Sampling_Strategy_UID__Current = 0
        self.str_Sampling_Strategy_Name = ''
        self.int_Sampling_Strategy_UID = 0
        self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path = ''
        self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path = ''

        self.str_Sampling_Strategy_Last_Run_UID = ''
        self.str_Sampling_Strategy_Last_Run_Job_Status = ''
        self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason = ''
        self.int_Sampling_Strategy_Last_Run_Shell_PID = 0
        self.int_Sampling_Strategy_Last_Run_Python_PID = 0
        
        self.bool_str_Sampling_Strategy_Name__FOUND = False
        self.bool_int_Sampling_Strategy_UID__FOUND = False
        self.bool_str_Sampling_Strategy_Run_Simulation_Working_Base_Path__FOUND = False
        self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__FOUND = False

        self.bool_str_Sampling_Strategy_Last_Run_UID__FOUND = False   
        self.bool_Sampling_Strategy_Last_Run_Job_Status__FOUND = False
        self.bool_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason__FOUND = False
        self.bool_int_Sampling_Strategy_Last_Run_Shell_PID__FOUND = False
        self.bool_int_Sampling_Strategy_Last_Run_Python_PID__FOUND = False
                
        self.str_Sampling_Strategy_Name__Label_Text = ''
        self.str_Sampling_Strategy_Cloned_Name__Label_Text = ''
        
        self.list_Sampling_Strategy_Files = []     
        self.list_Sampling_Strategy_Names = []  
        #self.bool_Sampling_Strategy_ComboBoxes_AddItems_Finished = False

        self.str_Sampling_Strategy_Name__Label_Text = ''        
        self.str_Sampling_Strategy_Cloned_Name__Label_Text = '' 
               
        return True
    
    def func_Initialise_Variables__Page_Modify_Sampling_Strategy__Tab_Modify_Sample_Size_And_Locus_Range(self):

        ''' Page_Modify_Sampling_Strategy__Tab_Sample_Size_And_Locus_Range '''
        
        self.int_Sampling_Strategy_Sample_Range_Min__Default_Value__Default_Value = 0
        self.int_Sampling_Strategy_Sample_Range_Min__Max__Default_Value = 0
        self.int_Sampling_Strategy_Sample_Range_Min__Min__Default_Value = 0
        self.int_Sampling_Strategy_Sample_Range_Max__Default_Value = 0
        self.int_Sampling_Strategy_Sample_Range_Max__Max__Default_Value = 0
        self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value = 0
        self.int_Sampling_Strategy_Sample_Range_Increment__Default_Value = 0
        self.int_Sampling_Strategy_Sample_Range_Increment__Max__Default_Value = 0
        self.int_Sampling_Strategy_Sample_Range_Increment__Min__Default_Value = 0
        
        self.int_Sampling_Strategy_Sample_Range_Min = 0
        #self.int_Sampling_Strategy_Sample_Range_Min__Max__Default_Value = 0
        #self.int_Sampling_Strategy_Sample_Range_Min__Min__Default_Value = 0
        self.int_Sampling_Strategy_Sample_Range_Max = 0
        #self.int_Sampling_Strategy_Sample_Range_Max__Max__Default_Value = 0
        #self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value = 0
        self.int_Sampling_Strategy_Sample_Range_Increment = 0
        #self.int_Sampling_Strategy_Sample_Range_Increment__Max__Default_Value = 0
        #self.int_Sampling_Strategy_Sample_Range_Increment__Min__Default_Value = 0
    
        self.int_Sampling_Strategy_Locus_Range_Min__Default_Value = 0
        self.int_Sampling_Strategy_Locus_Range_Min__Max__Default_Value = 0
        self.int_Sampling_Strategy_Locus_Range_Min__Min__Default_Value = 0
        self.int_Sampling_Strategy_Locus_Range_Max__Default_Value = 0
        self.int_Sampling_Strategy_Locus_Range_Max__Max__Default_Value = 0
        self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value = 0
        self.int_Sampling_Strategy_Locus_Range_Increment__Default_Value = 0
        self.int_Sampling_Strategy_Locus_Range_Increment__Max__Default_Value = 0
        self.int_Sampling_Strategy_Locus_Range_Increment__Min__Default_Value = 0
        
        self.int_Sampling_Strategy_Locus_Range_Min = 0
        #self.int_Sampling_Strategy_Locus_Range_Min__Max__Default_Value = 0
        #self.int_Sampling_Strategy_Locus_Range_Min__Min__Default_Value = 0
        self.int_Sampling_Strategy_Locus_Range_Max = 0
        #self.int_Sampling_Strategy_Locus_Range_Max__Max__Default_Value = 0
        #self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value = 0
        self.int_Sampling_Strategy_Locus_Range_Increment = 0
        #self.int_Sampling_Strategy_Locus_Range_Increment__Max__Default_Value = 0
        #self.int_Sampling_Strategy_Locus_Range_Increment__Min__Default_Value = 0

        self.bool_str_Sampling_Strategy_Path_And_File__Current__FOUND = False
        self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND = False
        self.bool_int_Sampling_Strategy_Sample_Range_Max__FOUND = False
        self.bool_int_Sampling_Strategy_Sample_Range_Increment__FOUND = False
        self.bool_int_Sampling_Strategy_Locus_Range_Min__FOUND = False
        self.bool_int_Sampling_Strategy_Locus_Range_Max__FOUND = False
        self.bool_int_Sampling_Strategy_Locus_Range_Increment__FOUND = False
        self.bool_int_Sampling_Strategy_Sample_Range_Min__CHANGED = False
        self.bool_int_Sampling_Strategy_Sample_Range_Max__CHANGED = False
        self.bool_int_Sampling_Strategy_Sample_Range_Increment__CHANGED = False
        self.bool_int_Sampling_Strategy_Locus_Range_Min__CHANGED = False
        self.bool_int_Sampling_Strategy_Locus_Range_Max__CHANGED = False
        self.bool_int_Sampling_Strategy_Locus_Range_Increment__CHANGED = False        

#         self.int_Sampling_Strategy_Sample_Range_Min = 0
#         self.int_Sampling_Strategy_Sample_Range_Max = 0
#         self.int_Sampling_Strategy_Sample_Range_Increment = 0
#         self.int_Sampling_Strategy_Locus_Range_Min = 0
#         self.int_Sampling_Strategy_Locus_Range_Max = 0
#         self.int_Sampling_Strategy_Locus_Range_Increment = 0

        self.str_int_Sampling_Strategy_Sample_Range_Min__Label_Text = ''
        self.str_int_Sampling_Strategy_Sample_Range_Max__Label_Text = ''
        self.str_int_Sampling_Strategy_Sample_Range_Increment__Label_Text = ''
        self.str_int_Sampling_Strategy_Locus_Range_Min__Label_Text = ''
        self.str_int_Sampling_Strategy_Locus_Range_Max__Label_Text = ''
        self.str_int_Sampling_Strategy_Locus_Range_Increment__Label_Text = ''

        self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion = OrderedDict()
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__FOUND = False
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__CHANGED = False

        self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion = OrderedDict()
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion__FOUND = False
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion__CHANGED = False

        self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number = OrderedDict()
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number__FOUND = False
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number__CHANGED = False

        self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion = OrderedDict()
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__FOUND = False
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__CHANGED = False

        self.list_Settings_Sampling_Strategy_Sample_Proportions_Source = []
        self.str_Sampling_Strategy_Sample_Proportions_Source = ''
        self.bool_str_Sampling_Strategy_Sample_Proportions_Source__FOUND = False
        self.bool_str_Sampling_Strategy_Sample_Proportions_Source__CHANGED = False

        self.float_Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep = 0.0
        self.bool_float_Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep__FOUND = False
        
        return True

    def func_Initialise_Variables__Page_Run_Sampling_Strategy__Tab_Modify_Run_Parameters(self):

        ''' Page_Run_Sampling_Strategy__Tab_Modify_Run_Parameters '''
        
        self.int_Sampling_Strategy_LDNe_Replicates__Default_Value = 0
        self.int_Sampling_Strategy_LDNe_Replicates__Max = 0
        self.int_Sampling_Strategy_LDNe_Replicates__Min = 0
        self.list_Settings_Sampling_Strategy_LDNe_PCrit_To_Get = []
        
        self.int_Sampling_Strategy_LDNe_Replicates = 0
        self.str_Sampling_Strategy_LDNe_PCrit_To_Get = ''
                
        self.bool_int_Sampling_Strategy_LDNe_Replicates__Default_Value__FOUND = False
        self.bool_int_Sampling_Strategy_LDNe_Replicates__Max__FOUND = False
        self.bool_int_Sampling_Strategy_LDNe_Replicates__Min__FOUND = False
        self.bool_int_Sampling_Strategy_LDNe_Replicates__FOUND = False
        
        self.bool_int_Sampling_Strategy_LDNe_Replicates__FOUND = False
        self.bool_str_Sampling_Strategy_LDNe_PCrit_To_Get__FOUND = False
        self.bool_int_Sampling_Strategy_LDNe_Replicates__CHANGED = False
        self.bool_str_Sampling_Strategy_LDNe_PCrit_To_Get__CHANGED = False
        
        self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path = ''
        
        self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__FOUND = False
        self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__CHANGED = False
        
        self.str_int_Sampling_Strategy_LDNe_Replicates__Label_Text = ''
        self.str_str_Sampling_Strategy_LDNe_PCrit_To_Get__Label_Text = ''

        return True

    def func_Initialise_Variables__Page_Results_Sampling_Strategy(self):

        ''' Page_Results_Sampling_Strategy '''
        
        self.list_Path_And_Files__Sampling_Strategy__Results_Plots = []
        self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Captions = []
        self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Thumbs = []
        
        return True

    def func_Initialise_Variables__Linked_Sliders_And_Spinboxes__Define_Companions(self):
        
        self.dict_LINKED_Sliders_And_SpinBoxes = OrderedDict()

        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_31'] = 'spinBox_24'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_24'] = 'horizontalSlider_31' 

        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_32'] = 'spinBox_25'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_25'] = 'horizontalSlider_32'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_33'] = 'spinBox_27'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_27'] = 'horizontalSlider_33'

        '''
        ----------------------------
        Scenario - Life History Offspring distribution widgets
        ----------------------------
        '''   
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_27'] = 'spinBox_23'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_23'] = 'horizontalSlider_27'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_30'] = 'doubleSpinBox_9'
        self.dict_LINKED_Sliders_And_SpinBoxes['doubleSpinBox_9'] = 'horizontalSlider_30'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_28'] = 'doubleSpinBox_5'
        self.dict_LINKED_Sliders_And_SpinBoxes['doubleSpinBox_5'] = 'horizontalSlider_28'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_29'] = 'doubleSpinBox_6'
        self.dict_LINKED_Sliders_And_SpinBoxes['doubleSpinBox_6'] = 'horizontalSlider_29'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_39'] = 'spinBox_26'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_26'] = 'horizontalSlider_39'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_40'] = 'spinBox_31'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_31'] = 'horizontalSlider_40'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_41'] = 'doubleSpinBox_10'
        self.dict_LINKED_Sliders_And_SpinBoxes['doubleSpinBox_10'] = 'horizontalSlider_41'

        '''
        ----------------------------
        Scenario - Demography widgets
        ----------------------------
        '''
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_34'] = 'spinBox_28'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_28'] = 'horizontalSlider_34'

        '''
        ----------------------------
        Scenario - Genetics widgets
        ----------------------------
        '''  
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_38'] = 'spinBox_30'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_30'] = 'horizontalSlider_38'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_35'] = 'spinBox_29'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_29'] = 'horizontalSlider_35'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_37'] = 'doubleSpinBox_7'
        self.dict_LINKED_Sliders_And_SpinBoxes['doubleSpinBox_7'] = 'horizontalSlider_37'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_42'] = 'doubleSpinBox_8'
        self.dict_LINKED_Sliders_And_SpinBoxes['doubleSpinBox_8'] = 'horizontalSlider_42'

        '''
        ----------------------------
        Scenario - Simulation widgets
        ----------------------------
        ''' 
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_45'] = 'spinBox_37'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_37'] = 'horizontalSlider_45'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_46'] = 'spinBox_38'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_38'] = 'horizontalSlider_46'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_47'] = 'spinBox_39'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_39'] = 'horizontalSlider_47'
        '''
        ----------------------------
        Sampling Strategy - Sample Size widgets
        ----------------------------
        '''
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_48'] = 'spinBox_40'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_40'] = 'horizontalSlider_48'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_49'] = 'spinBox_41'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_41'] = 'horizontalSlider_49'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_50'] = 'spinBox_42'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_42'] = 'horizontalSlider_50'
        '''
        ----------------------------
        Sampling Strategy - Locus Number widgets
        ----------------------------
        '''
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_51'] = 'spinBox_43'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_43'] = 'horizontalSlider_51'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_52'] = 'spinBox_44'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_44'] = 'horizontalSlider_52'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_53'] = 'spinBox_45'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_45'] = 'horizontalSlider_53'
        
        self.dict_LINKED_Sliders_And_SpinBoxes['horizontalSlider_54'] = 'spinBox_46'
        self.dict_LINKED_Sliders_And_SpinBoxes['spinBox_46'] = 'horizontalSlider_54'
        
        return True
        

    def func_Initialise_Validators__Post_Settings_Load(self):
    
        ''' reg exs '''
        qregexp_Alpha = QtCore.QRegExp("[a-z-A-Z]+")        
        qregexp_Alphanumeric_0 = QtCore.QRegExp("[a-zA-Z0-9]+")        
        qregexp_Alphanumeric_1 = QtCore.QRegExp("[a-zA-Z0-9_-\s]+")        
        
        ''' Project Page - Project Name'''
        qregexpvalidator_lineEdit_4 = QtGui.QRegExpValidator(qregexp_Alphanumeric_1, self.lineEdit_4)
        self.lineEdit_4.setValidator(qregexpvalidator_lineEdit_4)
        ''' Project Page - Project Species Name'''
        qregexpvalidator_lineEdit_13 = QtGui.QRegExpValidator(qregexp_Alphanumeric_1, self.lineEdit_13)
        self.lineEdit_13.setValidator(qregexpvalidator_lineEdit_13)
        
        ''' Project Page - Scenario Name'''
        qregexpvalidator_lineEdit_5 = QtGui.QRegExpValidator(qregexp_Alphanumeric_1, self.lineEdit_5)
        self.lineEdit_5.setValidator(qregexpvalidator_lineEdit_5)      
          
        qregexpvalidator_lineEdit_8 = QtGui.QRegExpValidator(qregexp_Alphanumeric_1, self.lineEdit_8)
        self.lineEdit_8.setValidator(qregexpvalidator_lineEdit_8)        
        
        ''' Sampling Strategy Page Creat/Select Sampling strategy'''
        qregexpvalidator_lineEdit_21 = QtGui.QRegExpValidator(qregexp_Alphanumeric_1, self.lineEdit_21)
        self.lineEdit_21.setValidator(qregexpvalidator_lineEdit_21)      
          
        qregexpvalidator_lineEdit_22 = QtGui.QRegExpValidator(qregexp_Alphanumeric_1, self.lineEdit_22)
        self.lineEdit_22.setValidator(qregexpvalidator_lineEdit_22)        

        return True
    
    def func_Initialise_Widgets__Post_Settings_Load(self):
        
        self.func_Initialise_Widgets__Main_Form()
        self.func_Initialise_Widgets__Context_Help()
        self.func_Initialise_Widgets__Page_Choose_Project_Scenario__Tab_Choose_Project_Scenario()
        self.func_Initialise_Widgets__Page_Modify_Scenario__Tab_Life_History()
        self.func_Initialise_Widgets__Page_Modify_Scenario__Tab_Demography()
        self.func_Initialise_Widgets__Page_Modify_Scenario__Tab_Genetics()
        self.func_Initialise_Widgets__Page_Run_Scenario__Tab_Run_Scenario()
        self.func_Initialise_Widgets__Page_Results_Scenario()
        self.func_Initialise_Widgets__Page_Create_Select_Sampling_Strategy__Tab_Choose_Strategy()
        self.func_Initialise_Widgets__Page_Modify_Sampling_Strategy__Tab_Modify_Sample_Size_And_Locus_Range()
        self.func_Initialise_Widgets__Page_Run_Sampling_Strategy__Tab_Modify_Run_Parameters()
        self.func_Initialise_Widgets__Page_Results_Sampling_Strategy()
        return True
    
    def func_Initialise_Widgets__Main_Form(self):

        ''' Window Title '''
        self.str_App_Name_And_Version = self.str_Settings_Run_App_Name__Default_Value + ' v' + self.str_Settings_Run_App_Version__Default_Value       
        self.setWindowTitle(self.str_App_Name_And_Version)
        
        ''' Window geometry '''
        int_Window_Width = 0
        int_Window_Height = 0
        int_Window_X_Pos = 700
        int_Window_Y_Pos = 747
        #self.setGeometry(int_Window_Width, int_Window_Height, int_Window_X_Pos, int_Window_Y_Pos)
        #self.geometry() #0, 0, 700, 747
        #self.centre()
        
        ''' Main Page '''
        self.lineEdit_9.setDisabled(True)
        self.lineEdit_6.setDisabled(True)
        self.lineEdit_10.setDisabled(True)
        self.lineEdit_7.setDisabled(True)
        
        ''' Main Toolbox '''
        #self.toolBox.removeWidget(0)
        #self.toolBox.setCurrentIndex(0)
        #self.toolBox.setDisabled(globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Admin)
        #self.toolBox.removeItem(7)
        
        ''' Connect menu items to their functions '''
        self.actionPreferences.triggered.connect(self.func_QToolBox__MainToolBar__Menu_Item_Settings_Preferences_Clicked)
        self.actionShow_Context_specific_Help.triggered.connect(self.func_QToolBox__MainToolBar__Menu_Item_Help_Show_Context_specific_Help_Clicked)
        
        ''' Control the ability to turn on the Admin page by the SETTING Config file option to make the settings menu item visible or not '''
        self.menuSettings.menuAction().setVisible(self.bool_Settings_Run_FrontEnd_DEBUG_Show_Settings_Menu__Default_Value)
            
            
        self.bool_Admin_Page_Currently_Hidden = False
        self.func_QToolBox__MainToolBar__Menu_Item_Settings_Preferences_Clicked()
        pass
    
        '''
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        #NOTE: For final PROD version set to 0 ie page 0
        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        '''
        self.toolBox.setCurrentIndex(globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario) 
        #DEBUG_ON
        #self.tabWidget_3.setCurrentIndex(1)
        #DEBUF_OFF
                
        return True

        
    def func_Window_Position(self):
        '''
        Center the window on screen. This implemention will handle the window
        being resized or the screen resolution changing.
        '''
        
        ''' Get the current screens' dimensions... '''
        screen__Geometry = QtGui.QDesktopWidget().screenGeometry()
        # ... and get this windows' dimensions
        qForm_Main__Geometry = self.geometry()

        ''' Get dimensions of Context Help Dialog '''
        if self.dialog_Context_Help is not None:
            qDialog_Modeless__Context_Help__Geometry = self.dialog_Context_Help.geometry()
            # The horizontal position is calulated as screenwidth - windowwidth /2
            #hpos_qDialog_Modeless__Context_Help = ( screen.width() - qForm_Main__Geometry.width() - qDialog_Modeless__Context_Help__Geometry.width()) * 2
            
            ''' Calculate the help dialog position so the LEFT margin is in the center of the screen '''
            int_Space = 20
            #int_X_Window_Pos__qDialog_Modeless__Context_Help = (screen__Geometry.width()/2 + int_Space)
            float_Width_Diff_Percent = float(qDialog_Modeless__Context_Help__Geometry.width())/float(screen__Geometry.width()) * float(100)
            if float_Width_Diff_Percent >= 90.0:
                int_X_Window_Pos__qDialog_Modeless__Context_Help = 5 + int_Space
            else:
                int_X_Window_Pos__qDialog_Modeless__Context_Help = (screen__Geometry.width()/2 + int_Space)
            pass             
            # And vertical position the same, but with the height dimensions
            #int_Y_Window_Pos__qDialog_Modeless__Context_Help = (screen__Geometry.height() - qDialog_Modeless__Context_Help__Geometry.height()) / 2
            float_Height_Diff_Percent = float(qDialog_Modeless__Context_Help__Geometry.height())/float(screen__Geometry.height()) * float(100)
            if float_Height_Diff_Percent >= 90.0:
                int_Y_Window_Pos__qDialog_Modeless__Context_Help = 0
            else:
                int_Y_Window_Pos__qDialog_Modeless__Context_Help = (screen__Geometry.height() - qDialog_Modeless__Context_Help__Geometry.height()) / 2
                #int_Y_Window_Pos__qDialog_Modeless__Context_Help = (screen__Geometry.height()/ 2)
            pass
            ''' reposition the dialog '''
            #self.dialog_Context_Help.move(int_X_Window_Pos__qDialog_Modeless__Context_Help, int_Y_Window_Pos__qDialog_Modeless__Context_Help)                            
            self.dialog_Context_Help.move(int_X_Window_Pos__qDialog_Modeless__Context_Help, int_Y_Window_Pos__qDialog_Modeless__Context_Help)
            
            ''' Calculate the main form position so the RIGHT margin is in the center of the screen '''
            # The horizontal position is calulated as screenwidth - windowwidth /2
            #hpos_qForm_Main = ( screen.width() - qForm_Main__Geometry.width() - qDialog_Modeless__Context_Help__Geometry.width()) / 2
            #int_X_Window_Pos__qForm_Main = (screen__Geometry.width()/2 - qForm_Main__Geometry.width())
            float_Width_Diff_Percent = float(qForm_Main__Geometry.width())/float(screen__Geometry.width()) * float(100)
            if float_Width_Diff_Percent >= 90.0:
                int_X_Window_Pos__qForm_Main = 5
            else:
                int_X_Window_Pos__qForm_Main = (screen__Geometry.width()/2 - qForm_Main__Geometry.width())
            pass            
            # And vertical position the same, but with the height dimensions
            float_Height_Diff_Percent = float(qForm_Main__Geometry.height())/float(screen__Geometry.height()) * float(100)
            if float_Height_Diff_Percent >= 90.0:
                int_Y_Window_Pos__qForm_Main = 0
            else:
                int_Y_Window_Pos__qForm_Main = (screen__Geometry.height() - qForm_Main__Geometry.height()) / 2
                #int_Y_Window_Pos__qForm_Main = (screen__Geometry.height()/ 2)
            pass
        else:
        
            
            ''' If the help dialog is not shown, calculate the main form position so the WINDOW in the center of the screen '''
            # The horizontal position is calulated as screenwidth - windowwidth /2
            #hpos_qForm_Main = ( screen.width() - qForm_Main__Geometry.width() - qDialog_Modeless__Context_Help__Geometry.width()) / 2
            
            #int_X_Window_Pos__qForm_Main = ( screen__Geometry.width()/2)
            float_Width_Diff_Percent = float(qForm_Main__Geometry.width())/float(screen__Geometry.width()) * float(100)
            if float_Width_Diff_Percent >= 90.0:
                int_X_Window_Pos__qForm_Main = 5
            else:
                int_X_Window_Pos__qForm_Main = (screen__Geometry.width()/2 - (qForm_Main__Geometry.width()/2))
            pass 
            # And vertical position the same, but with the height dimensions
            #vpos_qForm_Main = ( screen.height() - qForm_Main__Geometry.height()) / 2
            float_Height_Diff_Percent = float(qForm_Main__Geometry.height())/float(screen__Geometry.height()) * float(100)
            if float_Height_Diff_Percent >= 90.0:
                int_Y_Window_Pos__qForm_Main = 0
            else:
                #int_Y_Window_Pos__qForm_Main = (screen__Geometry.height()/ 2)
                int_Y_Window_Pos__qForm_Main = (screen__Geometry.height() - qForm_Main__Geometry.height()) / 2
            pass
            
            #int_Y_Window_Pos__qForm_Main = ( screen__Geometry.height()/ 2)
        pass
                
        ''' reposition the main form '''
        #self.move(int_X_Window_Pos__qForm_Main, int_Y_Window_Pos__qForm_Main)
        self.move(int_X_Window_Pos__qForm_Main, int_Y_Window_Pos__qForm_Main)
        
        return True
        
            
    def func_Initialise_Widgets__Context_Help(self):

        #self.groupBox_11.hide()
        #self.frame.hide()
        
        return True
    
    def func_Initialise_Widgets__Page_Choose_Project_Scenario__Tab_Choose_Project_Scenario(self):

        ''' Project Page - Save Project & Scenario'''
        self.tabWidget.removeTab(1) #Hide the settings tab'
        
        self.str_Project_Name__Label_Text = self.label_6.text()
        self.str_Project_Species_Name__Label_Text = self.label_30.text()
        self.str_Scenario_Name__Current__Label_Text = self.label_7.text()
        self.str_Scenario_Cloned_Name__Label_Text = self.label_9.text()
                
        self.radioButton.setChecked(True)
        self.radioButton_2.setChecked(False)
        
        self.lineEdit_12.setEnabled(False)
        self.pushButton.setEnabled(False)
        
        self.checkBox_3.setChecked(False)
        self.checkBox_2.setChecked(False)
        
        return True
    
    def func_Initialise_Widgets__Page_Modify_Scenario__Tab_Life_History(self):

        ''' Default label texts '''
        self.str_Max_Age__Label_Text = self.label_42.text()
        self.str_Max_Mating_Age__Label_Text = self.label_43.text()
        self.str_Min_Mating_Age__Label_Text = self.label_44.text()

        self.str_Species_Offspring_Distribution__Label_Text = self.label_38.text()
        self.str_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Label_Text = self.label_39.text()
        self.str_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Label_Text = self.label_68.text()           
        self.str_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Label_Text = self.label_40.text()          
        self.str_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Label_Text = self.label_41.text()       
        self.str_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Label_Text = self.label_69.text()          
        self.str_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Label_Text = self.label_70.text()           
        self.str_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Label_Text = self.label_71.text()   
        
        ''' Modify Scenarios Page '''
        self.comboBox_201.hide()
        self.label_36.hide()  
              
        ''' Slider and linked SpinBox defaults '''
        self.spinBox_24.setRange(self.int_Species_Life_History_Max_Age__Min__Default_Value, self.int_Species_Life_History_Max_Age__Max__Default_Value) 
        self.horizontalSlider_31.setRange(self.int_Species_Life_History_Max_Age__Min__Default_Value, self.int_Species_Life_History_Max_Age__Max__Default_Value) 
        self.spinBox_24.setValue(self.int_Species_Life_History_Max_Age__Default_Value) 
        
        self.spinBox_25.setRange(self.int_Species_Life_History_Max_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Max_Mating_Age__Max__Default_Value) 
        self.horizontalSlider_32.setRange(self.int_Species_Life_History_Max_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Max_Mating_Age__Max__Default_Value) 
        self.spinBox_25.setValue(self.int_Species_Life_History_Max_Mating_Age__Default_Value) 
        
        self.spinBox_27.setRange(self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value) 
        self.horizontalSlider_33.setRange(self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value) 
        self.spinBox_27.setValue(self.int_Species_Life_History_Min_Mating_Age__Default_Value) 

        ''' Offspring Distribution defaults '''
        self.comboBox_4.clear()
        self.comboBox_4.addItems(self.list_Settings_Species_Offspring_Distribution)               

        ''' Offspring Distribution - ABSOLUTE - Settings '''
        self.horizontalSlider_27.setRange(self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Min
                                          , self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Max)
        self.spinBox_23.setValue(self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Default_Value)
        
        ''' Offspring Distribution - POISSON - Settings '''
        self.horizontalSlider_30.setRange(self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor*self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Min
                                          ,self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor*self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Max)
        self.horizontalSlider_30.setSingleStep(1)
        
        self.doubleSpinBox_9.setDecimals(self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Decimals)
        self.doubleSpinBox_9.setRange(self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Min
                                      ,self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Max)
        self.doubleSpinBox_9.setSingleStep(float(1)/float(self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor))
        self.doubleSpinBox_9.setValue(self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Default_Value)
        
        ''' Offspring Distribution - BINOMIAL - Settings '''
        ''' Offspring Distribution - BINOMIAL - Settings - MEAN'''
        self.horizontalSlider_28.setRange(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Min
                                          ,self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Max)
        self.horizontalSlider_28.setSingleStep(1)
        
        self.doubleSpinBox_5.setDecimals(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Decimals)
        self.doubleSpinBox_5.setRange(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Min
                                      ,self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Max)
        self.doubleSpinBox_5.setSingleStep(float(1)/float(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor))
        self.doubleSpinBox_5.setValue(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Default_Value)
        
        ''' Offspring Distribution - BINOMIAL - Settings - STDDEV'''
        self.horizontalSlider_29.setRange(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Min
                                          ,self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Max)
        self.horizontalSlider_29.setSingleStep(1)
        
        self.doubleSpinBox_6.setDecimals(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Decimals)
        self.doubleSpinBox_6.setRange(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Min
                                      ,self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Max)
        self.doubleSpinBox_6.setSingleStep(float(1)/float(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor))
        self.doubleSpinBox_6.setValue(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Default_Value)
        
        ''' Offspring Distribution - UNIFORM - Settings '''
        ''' Offspring Distribution - UNIFORM - Settings - Min'''
        self.horizontalSlider_39.setRange(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Min
                                          ,self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Max)
        self.horizontalSlider_39.setSingleStep(1)
        
        self.spinBox_26.setRange(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Min
                                      ,self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Max)
        self.spinBox_26.setValue(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Default_Value)
        
        ''' Offspring Distribution - UNIFORM - Settings - Max'''
        self.horizontalSlider_40.setRange(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Min
                                          ,self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Max)
        self.horizontalSlider_40.setSingleStep(1)
        
        self.spinBox_31.setRange(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Min
                                      ,self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Max)
        self.spinBox_31.setValue(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Default_Value)
        
        ''' Offspring Distribution - GEOMETRIC - Settings '''
        self.horizontalSlider_41.setRange(self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor*self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Min
                                          ,self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor*self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Max)
        self.horizontalSlider_41.setSingleStep(1)
        
        self.doubleSpinBox_10.setDecimals(self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Decimals)
        self.doubleSpinBox_10.setRange(self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Min
                                      ,self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Max)
        self.doubleSpinBox_10.setSingleStep(float(1)/float(self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor))
        self.doubleSpinBox_10.setValue(self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Default_Value)
        
        return True

    def func_Initialise_Widgets__Page_Modify_Scenario__Tab_Demography(self):

        ''' Default label texts '''
        self.str_Population_Size__Label_Text = self.label_45.text()
        self.str_Edit_Natural_Mortality_Rates__Label_Text = self.pushButton_6.text()
        
        ''' Slider and linked SpinBox defaults '''
        ''' Population Size - Settings'''
        self.horizontalSlider_34.setRange(self.int_Population_Size__Min
                                          ,self.int_Population_Size__Max)
        self.horizontalSlider_34.setSingleStep(1)
        self.spinBox_28.setRange(self.int_Population_Size__Min
                                      ,self.int_Population_Size__Max)
        self.horizontalSlider_34.setValue(self.int_Population_Size__Default_Value)
        
        return True

    def func_Initialise_Widgets__Page_Modify_Scenario__Tab_Genetics(self):

        ''' Default label texts '''
        self.str_Genome_Locus_Number__Label_Text = self.label_8.text()
        #self.str_Genome_Alleles_Per_Locus_Distribution__Label_Text = self.label_46.text()
        self.str_Genome_Alleles_Per_Locus_Distribution__Label_Text = self.groupBox_23.title()
        self.str_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Label_Text = self.label_47.text()
        self.str_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Label_Text = self.label_48.text()
        self.str_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Label_Text = self.label_49.text()
        #self.str_Genome_Allele_Frequency_Distribution__Label_Text = self.label_50.text()
        self.str_Genome_Allele_Frequency_Distribution__Label_Text = self.groupBox_24.title()
        self.str_str_Genome_Source_File__Label_Text = self.label_51.text()
        
        ''' Hide controls '''
        self.lineEdit_2.hide()
        
        ''' Disbale controls '''
        self.lineEdit_11.setEnabled(False)
        
        ''' Default label texts '''
        self.label_16.setText('')
        self.label_17.setText('')
        
        ''' Combobox defaults '''
        ''' Genome_Allele_Frequency_Distribution combobox items '''
        self.comboBox_6.clear()
        self.comboBox_6.addItems(self.list_Settings__Genome_Allele_Frequency_Distribution)               
        ''' Genome_Alleles_Per_Locus_Distribution combobox items '''
        self.comboBox_5.clear()
        self.comboBox_5.addItems(self.list_Settings__Genome_Alleles_Per_Locus_Distribution)               

        ''' Slider and linked SpinBox defaults '''
        ''' Locus Number Size - Settings'''
        self.horizontalSlider_38.setRange(self.int_Genome_Locus_Number__Min
                                          ,self.int_Genome_Locus_Number__Max)
        self.horizontalSlider_38.setSingleStep(1)
        self.spinBox_30.setRange(self.int_Genome_Locus_Number__Min
                                      ,self.int_Genome_Locus_Number__Max)
        #self.horizontalSlider_38.setValue(self.int_Genome_Locus_Number__Default_Value)
        self.spinBox_30.setValue(self.int_Genome_Locus_Number__Default_Value)

        ''' Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus - Settings'''
        self.horizontalSlider_35.setRange(self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Min
                                          ,self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Max)
        self.horizontalSlider_35.setSingleStep(1)
        self.spinBox_29.setRange(self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Min
                                      ,self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Max)
        self.horizontalSlider_35.setValue(self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Default_Value)

        ''' Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus - Settings'''
        self.horizontalSlider_37.setRange(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Step_Divisor*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Min
                                          ,self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Step_Divisor*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Max)
        self.horizontalSlider_37.setSingleStep(1)
        self.doubleSpinBox_7.setDecimals(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Decimals)
        self.doubleSpinBox_7.setRange(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Min
                                      ,self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Max)
        self.doubleSpinBox_7.setSingleStep(float(1)/float(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Step_Divisor))
        #self.horizontalSlider_37.setValue(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Default_Value)
        self.doubleSpinBox_7.setValue(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Default_Value)
        
        ''' int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus - Settings'''
        self.horizontalSlider_42.setRange(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Min
                                          ,self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Max)
        self.horizontalSlider_42.setSingleStep(1)
        self.doubleSpinBox_8.setDecimals(self.int_GGenome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Decimals)
        self.doubleSpinBox_8.setRange(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Min
                                      ,self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Max)
        self.doubleSpinBox_8.setSingleStep(float(1)/float(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor))
        #self.horizontalSlider_42.setValue(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Default_Value)
        self.doubleSpinBox_8.setValue(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Default_Value)
        
        return True

    def func_Initialise_Widgets__Page_Run_Scenario__Tab_Run_Scenario(self):

        ''' Default label texts '''
        self.str_Simulation_Batch_Replicates__Label_Text = self.label_58.text()
        self.str_Simulation_Batch_Replicate_Length_Burn_In__Label_Text = self.label_59.text()
        self.str_Simulation_Batch_Replicate_Length_Temporal_Evolution__Label_Text = self.label_60.text()

        ''' Modify Scenarios Page '''
        self.tabWidget_2.removeTab(1) #Hide the settings tab
              
        ''' Slider and linked SpinBox defaults '''
        self.spinBox_37.setRange(self.int_Simulation_Batch_Replicates__Min, self.int_Simulation_Batch_Replicates__Max) 
        self.horizontalSlider_45.setRange(self.int_Simulation_Batch_Replicates__Min, self.int_Simulation_Batch_Replicates__Max) 
        #self.horizontalSlider_45.setValue(self.int_Simulation_Batch_Replicates__Default_Value) 
        self.spinBox_37.setValue(self.int_Simulation_Batch_Replicates__Default_Value) 

        ''' Simulation_Batch_Replicates - Settings '''
        bool_Run = True
        if bool_Run:
            bool_Use_Static_Sim_Length_Defaults = True
            if bool_Use_Static_Sim_Length_Defaults:
                #
                ''' Simulation_Batch_Replicate_Length_Burn_In - Settings '''
                self.spinBox_38.setRange(self.int_Simulation_Batch_Replicate_Length_Muliplier__Min * self.int_Simulation_Batch_Replicate_Length_Burn_In__Min, self.int_Simulation_Batch_Replicate_Length_Burn_In__Max) 
                #self.spinBox_38.setSingleStep(self.int_Simulation_Batch_Replicate_Length_Burn_In__Default_Value)
                self.horizontalSlider_46.setRange(self.int_Simulation_Batch_Replicate_Length_Muliplier__Min * self.int_Simulation_Batch_Replicate_Length_Burn_In__Min, self.int_Simulation_Batch_Replicate_Length_Burn_In__Max)
                #self.horizontalSlider_46.setTickInterval(self.int_Simulation_Batch_Replicate_Length_Burn_In__Default_Value) 
                #self.horizontalSlider_46.setSingleStep(self.int_Simulation_Batch_Replicate_Length_Burn_In__Default_Value)
                #self.horizontalSlider_46.setValue(self.int_Simulation_Batch_Replicate_Length_Burn_In__Default_Value) 
                self.spinBox_38.setValue(self.int_Simulation_Batch_Replicate_Length_Burn_In__Default_Value) 
                #
                ''' Simulation_Batch_Replicate_Length_Temporal_Evolution - Settings '''
                self.spinBox_39.setRange(self.int_Simulation_Batch_Replicate_Length_Muliplier__Min * self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Min, self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Max) 
                #self.spinBox_39.setSingleStep(self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Default_Value) 
                self.horizontalSlider_47.setRange(self.int_Simulation_Batch_Replicate_Length_Muliplier__Min*2, self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Max) 
                #self.horizontalSlider_47.setSingleStep(self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Default_Value)
                #self.horizontalSlider_47.setValue(self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Default_Value) 
                self.spinBox_39.setValue(self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Default_Value) 
            else:
                ''' Set the defaults for the Simulation Length Sliders based on the MAX found for the scenario'''
                self.func_Set_SIM_LENGTH_Slider_Range_And_Value__horizontalslider_31()
            pass
    
        ''' Disable controls '''
        #self.spinBox_38.setDisabled(True)
        #self.horizontalSlider_46.setDisabled(True)
        
        #self.spinBox_39.setDisabled(True)
        #self.horizontalSlider_47.setDisabled(True)
        
        self.lineEdit_16.setDisabled(True)

         
        return True

    
    def func_Initialise_Widgets__Page_Results_Scenario(self):

        self.pushButton_2.setEnabled(False)
        self.pushButton_3.setEnabled(False)
        
        self.pushButton_18.setEnabled(False)
        self.pushButton_19.setEnabled(False)
        self.pushButton_21.setEnabled(False)
        
        ''' Disable this button as the function has been replaced '''
        self.pushButton_2.setVisible(False)
        
        return True
    
    def func_Initialise_Widgets__Page_Create_Select_Sampling_Strategy__Tab_Choose_Strategy(self):

        ''' Create / Modify Sampling Startegy Config files page '''
        self.tabWidget_7.removeTab(1) #Hide the settings tab'
        
        self.str_Sampling_Strategy_Name__Label_Text = self.label_74.text()
        self.str_Sampling_Strategy_Cloned_Name__Label_Text = self.label_76.text()
        
        self.radioButton_8.setChecked(True)
        self.radioButton_9.setChecked(False)
        self.radioButton_10.setChecked(False)
               
        self.pushButton_5.setEnabled(False)
        
        self.checkBox.setChecked(False)    
          
        return True

    def func_Initialise_Widgets__Page_Modify_Sampling_Strategy__Tab_Modify_Sample_Size_And_Locus_Range(self):

        ''' Default label texts '''
        self.str_int_Sampling_Strategy_Sample_Range_Min__Label_Text = self.label_61.text()
        self.str_int_Sampling_Strategy_Sample_Range_Max__Label_Text = self.label_62.text()
        self.str_int_Sampling_Strategy_Sample_Range_Increment__Label_Text = self.label_63.text()
        self.str_int_Sampling_Strategy_Locus_Range_Min__Label_Text = self.label_64.text()
        self.str_int_Sampling_Strategy_Locus_Range_Max__Label_Text = self.label_65.text()
        self.str_int_Sampling_Strategy_Locus_Range_Increment__Label_Text = self.label_66.text()
        
        
        ''' Modify Sampling Strategy Page '''
        self.tabWidget_4.removeTab(1) #Hide the settings tab
              
#         ''' Slider and linked SpinBox defaults '''
#         self.spinBox_40.setRange(self.int_Sampling_Strategy_Sample_Range_Min__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Min__Max__Default_Value) 
#         self.horizontalSlider_48.setRange(self.int_Sampling_Strategy_Sample_Range_Min__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Min__Max__Default_Value) 
#         self.horizontalSlider_48.setValue(self.int_Sampling_Strategy_Sample_Range_Min__Default_Value) 
#         self.spinBox_41.setRange(self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Max__Max__Default_Value) 
#         self.horizontalSlider_49.setRange(self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Max__Max__Default_Value) 
#         self.horizontalSlider_49.setValue(self.int_Sampling_Strategy_Sample_Range_Max__Default_Value) 
#         self.spinBox_42.setRange(self.int_Sampling_Strategy_Sample_Range_Increment__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Increment__Max__Default_Value) 
#         self.horizontalSlider_50.setRange(self.int_Sampling_Strategy_Sample_Range_Increment__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Increment__Max__Default_Value) 
#         self.horizontalSlider_50.setValue(self.int_Sampling_Strategy_Sample_Range_Increment__Default_Value) 
#         
        ''' Slider and linked SpinBox defaults '''
        self.spinBox_40.setRange(self.int_Sampling_Strategy_Sample_Range_Min__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Min__Max__Default_Value) 
        self.horizontalSlider_48.setRange(self.int_Sampling_Strategy_Sample_Range_Min__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Min__Max__Default_Value) 
        #self.horizontalSlider_48.setValue(self.int_Sampling_Strategy_Sample_Range_Min__Default_Value) 
        self.spinBox_40.setValue(self.int_Sampling_Strategy_Sample_Range_Min__Default_Value) 
        
        self.spinBox_41.setRange(self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Max__Max__Default_Value) 
        #self.horizontalSlider_49.setRange(self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Max__Max__Default_Value) 
        self.horizontalSlider_49.setValue(self.int_Sampling_Strategy_Sample_Range_Max__Default_Value) 
        self.spinBox_41.setValue(self.int_Sampling_Strategy_Sample_Range_Max__Default_Value) 
        
        self.spinBox_42.setRange(self.int_Sampling_Strategy_Sample_Range_Increment__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Increment__Max__Default_Value) 
        self.horizontalSlider_50.setRange(self.int_Sampling_Strategy_Sample_Range_Increment__Min__Default_Value, self.int_Sampling_Strategy_Sample_Range_Increment__Max__Default_Value) 
        #self.horizontalSlider_50.setValue(self.int_Sampling_Strategy_Sample_Range_Increment__Default_Value) 
        self.spinBox_42.setValue(self.int_Sampling_Strategy_Sample_Range_Increment__Default_Value) 
        
        ''' Locus number range defaults '''
        self.spinBox_43.setRange(self.int_Sampling_Strategy_Locus_Range_Min__Min__Default_Value, self.int_Sampling_Strategy_Locus_Range_Min__Max__Default_Value) 
        self.horizontalSlider_51.setRange(self.int_Sampling_Strategy_Locus_Range_Min__Min__Default_Value, self.int_Sampling_Strategy_Locus_Range_Min__Max__Default_Value) 
        #self.horizontalSlider_51.setValue(self.int_Sampling_Strategy_Locus_Range_Min__Default_Value) 
        self.spinBox_43.setValue(self.int_Sampling_Strategy_Locus_Range_Min__Default_Value) 

        self.spinBox_44.setRange(self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value, self.int_Sampling_Strategy_Locus_Range_Max__Max__Default_Value) 
        self.horizontalSlider_52.setRange(self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value, self.int_Sampling_Strategy_Locus_Range_Max__Max__Default_Value) 
        #self.horizontalSlider_52.setValue(self.int_Sampling_Strategy_Locus_Range_Max__Default_Value) 
        self.spinBox_44.setValue(self.int_Sampling_Strategy_Locus_Range_Max__Default_Value) 
        
        self.spinBox_45.setRange(self.int_Sampling_Strategy_Locus_Range_Increment__Min__Default_Value, self.int_Sampling_Strategy_Locus_Range_Increment__Max__Default_Value) 
        self.horizontalSlider_53.setRange(self.int_Sampling_Strategy_Locus_Range_Increment__Min__Default_Value, self.int_Sampling_Strategy_Locus_Range_Increment__Max__Default_Value) 
        #self.horizontalSlider_53.setValue(self.int_Sampling_Strategy_Locus_Range_Increment__Default_Value) 
        self.spinBox_45.setValue(self.int_Sampling_Strategy_Locus_Range_Increment__Default_Value) 

        ''' Disable controls '''
        self.spinBox_40.setDisabled(True)
        self.horizontalSlider_48.setDisabled(True)
        #self.horizontalSlider_48.blockSignals(True)
        
        self.spinBox_43.setDisabled(True)
        self.horizontalSlider_51.setDisabled(True)
        #self.horizontalSlider_51.blockSignals(True)
        
        bool_Hide_Loci_Min = False
        if bool_Hide_Loci_Min:
            ''' Hide the minimum Sample widgets '''
            self.label_61.hide()
            self.horizontalSlider_48.hide()
            self.spinBox_40.hide()
            
            ''' Hide the minimum Loci widgets '''
            self.label_64.hide()
            self.horizontalSlider_51.hide()
            self.spinBox_43.hide()
        pass
    
        self.func_Validate_Sampling_Strategy__Display_Combinations()        
        return True

    def func_Initialise_Widgets__Page_Run_Sampling_Strategy__Tab_Modify_Run_Parameters(self):

        ''' Default label texts '''
        self.str_int_Sampling_Strategy_LDNe_Replicates__Label_Text = self.label_67.text()
        self.str_str_Sampling_Strategy_LDNe_PCrit_To_Get__Label_Text = self.label_28.text()

        ''' Modify Sampling Strategy Page '''
        self.tabWidget_5.removeTab(1) #Hide the settings tab

        ''' Combobox defaults '''
        ''' Genome_Allele_Frequency_Distribution combobox items '''
        self.comboBox_13.clear()
        self.comboBox_13.addItems(self.list_Settings_Sampling_Strategy_LDNe_PCrit_To_Get)               
              
        ''' Slider and linked SpinBox defaults '''
        self.spinBox_46.setRange(self.int_Sampling_Strategy_LDNe_Replicates__Min, self.int_Sampling_Strategy_LDNe_Replicates__Max) 
        self.horizontalSlider_54.setRange(self.int_Sampling_Strategy_LDNe_Replicates__Min, self.int_Sampling_Strategy_LDNe_Replicates__Max) 
        self.horizontalSlider_54.setValue(self.int_Sampling_Strategy_LDNe_Replicates__Default_Value) 
       
        self.lineEdit_17.setDisabled(True)
        
        ''' Disable the tool button for changing the Sampling Strategy output path '''
        self.toolButton_5.setDisabled(True)
                
        return True
    
    def func_Initialise_Widgets__Page_Results_Sampling_Strategy(self):

        self.pushButton_14.setEnabled(False)
        self.pushButton_13.setEnabled(False)
        
        ''' Hide this button as not needed '''
        self.pushButton_14.setVisible(False)
        
        return True
    
    def func_Initialise_App__First_Run_Initialisation(self):
        
        bool_Success = False

        ''' May not need this function '''
        bool_Success = self.func_Initialise_App__First_Run_Initialisation__Of_Environment()
        
        return bool_Success
    
    def func_Initialise_App__First_Run_Initialisation__Of_Environment(self):
        
        bool_Success = False

        ''' May not need this function '''
                
        return bool_Success
        
        
    def func_Initialise_PROJECT_Widgets_With_Data(self, str_Projects_FULL_Path_And_File__Current):
        
        bool_Block_Signals = True
        self.radioButton_3.blockSignals(bool_Block_Signals) 
        self.radioButton_4.blockSignals(bool_Block_Signals)
        self.radioButton_5.blockSignals(bool_Block_Signals)
                
        self.radioButton_4.setChecked(False)
        self.radioButton_3.setChecked(False)
        
        bool_Block_Signals = False
        self.radioButton_3.blockSignals(bool_Block_Signals) 
        self.radioButton_4.blockSignals(bool_Block_Signals) 
        self.radioButton_5.blockSignals(bool_Block_Signals) 
        
        self.radioButton_5.setChecked(True)
        
        self.func_QComboBox_PROJECTS_add(str_Projects_FULL_Path_And_File__Current)

        #self.func_Enable_Widgets__QToolBox__MainToolBox(1)
        
        return True


    def func_Initalise_App__Post_Initialisation_Operations(self):
        
        bool_Success = False
        
        ''' If App has successfully started, & its the Apps first run time, set the First run settings flag to False '''
        if self.bool_Settings_Run_FirstTime:
            str_Section = self.obj_Config_Settings.static_str_Section__Settings_Run_Details
            str_Option = self.obj_Config_Settings.static_str_Option__Settings_Run_FrontEnd_FirstTime
            value_Option = False
            bool_Success, self.obj_Config_Settings = self.func_Update_Config_File(self.str_Application_Settings_Path_And_File, self.obj_Config_Settings, str_Section, str_Option, value_Option)
        pass        
        
        if self.bool_Settings_Context_Help_Display_At_Start__Default_Value:
            self.func_QToolBox__MainToolBar__Menu_Item_Help_Show_Context_specific_Help_Clicked()
        pass

        ''' Position the windows relative to the screen resolution and each other '''
        self.func_Window_Position()
            
        return bool_Success
    
    '''
    -------------------------------------------------------------------------------
        Native Events 
    -------------------------------------------------------------------------------
    '''
    def closeEvent(self, event):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, 'User has clicked the red x on the main window')
        #DEBUG_OFF        

        if self.int_Run_Status_Error_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL:
            #if self.int_Run_Status_Flag__Current > globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL and self.int_Run_Status_Flag__Current < globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED:
            if self.int_Run_Status_Flag__Current > globalsDCBGen.Run_Status.static_int_Run_Status__NO_JOB and self.int_Run_Status_Flag__Current < globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED:
                str_MessageBox_Text = 'A Batch Simulation Run (process ID: ' + str(self.int_Process_JOB_SHELL__PID) + ') is still in progress.  \n\n Please wait until it is complete,... \n\n or if absolutely necessary, kill the Job Run by closing the Console window.'
                messageBox_Reponse = QtGui.QMessageBox.information(self, 'Exit Application', str_MessageBox_Text, buttons=QtGui.QMessageBox.Ok, defaultButton=QtGui.QMessageBox.Ok)
                event.ignore()
            else:
                event.accept()
                pass
        else:
            bool_Check_Exit = False
            if bool_Check_Exit:
                str_MessageBox_Text = 'Are you sure you wish to exit?'
                messageBox_Reponse = QtGui.QMessageBox.question(self, 'Exit Application?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
             
                if messageBox_Reponse == QtGui.QMessageBox.Yes:
                    ''' End the application as gracefully as possible'''
                    event.accept()
#                     self.close()
#                     QtGui.QApplication.quit()
#                     QtGui.QApplication.exec_()
                pass
            pass
        pass

    '''
    -------------------------------------------------------------------------------
        Bind signal handlers
    -------------------------------------------------------------------------------
    '''    
    def func_Bind_Event_Handlers(self):
        
        self.func_Bind_Event_Handlers__QToolBox()
        self.func_Bind_Event_Handlers__QLineEdit()
        self.func_Bind_Event_Handlers__QComboBox()
        self.func_Bind_Event_Handlers__QPushButton()
        self.func_Bind_Event_Handlers__QToolButton()
        self.func_Bind_Event_Handlers__QRadioButton()
        self.func_Bind_Event_Handlers__QCheckBox()
        self.func_Bind_Event_Handlers__Joined_QSliders_And_QSpinBoxes()
        
        return True

    def func_Bind_Event_Handlers__QToolBox(self):
        
        '''Main QToolBox '''
        self.connect(self.toolBox, QtCore.SIGNAL("currentChanged(int)"),
                     self.func_QToolBox__MainToolBox__CurrentChanged)
        return True

    def func_Bind_Event_Handlers__QLineEdit(self):
        
        '''Main Page '''
        #self.lineEdit_10.textChanged.connect(self.func_QLineEdit__MainWindow_ScenarioName__Text_Changed)
        
        ''' Project Page - Project Name'''
        self.lineEdit_4.textChanged.connect(self.func_QLineEdit__Project_Name__Text_Changed) 
        ''' Project Page - Project Species Name'''
        self.lineEdit_13.textChanged.connect(self.func_QLineEdit__Project_Species_Name__Text_Changed) 
        
        ''' Project Page - Scenario Name'''
        self.lineEdit_5.textChanged.connect(self.func_QLineEdit__Scenario_Name__Text_Changed)  
        self.lineEdit_8.textChanged.connect(self.func_QLineEdit__Scenario_Name__Text_Changed)     
        
        ''' Sampling Strategy Page Create/Select sampling strategy'''
        self.lineEdit_21.textChanged.connect(self.func_QLineEdit__Sampling_Strategy_Name__Text_Changed)  
        self.lineEdit_22.textChanged.connect(self.func_QLineEdit__Sampling_Strategy_Name__Text_Changed)     
        return True
        
    def func_Bind_Event_Handlers__QComboBox(self):

        ''' AVAILABLE SIGNALS '''
        '''QComboBox SIGNAL: currentIndexChanged - Event occurs when the index changes programatically or by user. Occurs on clear and addItems too '''        
        '''QComboBox SIGNAL: activated - Event occurs only when user selcts from comboBox '''
        
        '''QComboBox - Select Project File '''
        self.comboBox_100.currentIndexChanged['int'].connect(self.func_QComboBox_PROJECT_FILE_From_PROJECTS_Selected)

        '''QComboBox - Select Project Name '''
        self.comboBox_110.currentIndexChanged['int'].connect(self.func_QComboBox_PROJECT_NAME_From_PROJECTS_Selected)
        self.comboBox_111.currentIndexChanged['int'].connect(self.func_QComboBox_PROJECT_NAME_From_PROJECTS_Selected)
        
        self.comboBox_120.currentIndexChanged['int'].connect(self.func_QComboBox_SCENARIO_Clone_PROJECT_FILE__Selected)
        self.comboBox_121.currentIndexChanged['int'].connect(self.func_QComboBox_SCENARIO_Clone_PROJECT_NAME__Selected)

        '''QComboBox - Select Scenario File '''
        self.comboBox_200.currentIndexChanged['int'].connect(self.func_QComboBox_SCENARIO_FILE_Selected)
        self.comboBox_201.currentIndexChanged['int'].connect(self.func_QComboBox_SCENARIO_FILE_Selected)
        
        '''QComboBox - Select Scenario Name '''
        self.comboBox_210.currentIndexChanged['int'].connect(self.func_QComboBox_SCENARIO_NAME_Selected)
        self.comboBox_211.currentIndexChanged['int'].connect(self.func_QComboBox_SCENARIO_NAME_Selected)

        '''QComboBox - Select Scenario Name CLONE '''
#         self.comboBox_201.currentIndexChanged['int'].connect(self.func_QComboBox_SCENARIO_FILE_Selected__Page_2)
#         self.comboBox_210.currentIndexChanged['int'].connect(self.func_QComboBox_SCENARIO_NAME_Selected__Page_2)
        self.comboBox_220.currentIndexChanged['int'].connect(self.func_QComboBox_SCENARIO_Clone_FILE_Selected)
        self.comboBox_221.currentIndexChanged['int'].connect(self.func_QComboBox_SCENARIO_Clone_NAME_Selected)
        
        
        '''QComboBox - Select Offspring Distribution '''
        self.comboBox_4.currentIndexChanged['QString'].connect(self.func_QComboBox_Offspring_Distribution_Selected__Page_2)
        
        '''QComboBox - Select Allele Frequency Distribution '''
        self.comboBox_6.currentIndexChanged['QString'].connect(self.func_QComboBox_Genome_Allele_Frequency_Distribution_Selected__Page_2)
        
        '''QComboBox - Select Alleles per Locus Distribution '''
        self.comboBox_5.currentIndexChanged['QString'].connect(self.func_QComboBox_Alleles_Per_Locus_Distribution_Selected__Page_2)
        
        '''QComboBox - Select Sampling_Strategy_LDNe_PCrit_To_Get '''
        self.comboBox_13.currentIndexChanged['QString'].connect(self.func_QComboBox_Sampling_Strategy_LDNe_PCrit_To_Get__Selected)
        
        '''QComboBox - Select Sampling_Strategy File '''
        self.comboBox_300.currentIndexChanged['int'].connect(self.func_QComboBox_SAMPLING_STRATEGY_FILE_Selected)
        
        '''QComboBox - Select Sampling_Strategy Name '''
        self.comboBox_311.currentIndexChanged['int'].connect(self.func_QComboBox_SAMPLING_STRATEGY_NAME_Selected)
        self.comboBox_320.currentIndexChanged['int'].connect(self.func_QComboBox_SAMPLING_STRATEGY_Clone_NAME_Selected)
        
        '''QComboBox - Select Sampling_Strategy Name '''
        #self.comboBox_310.currentIndexChanged['int'].connect(self.func_QComboBox_SAMPLING_STRATEGY_NAME_Page_Modify_Strategy_Selected)
        self.comboBox_310.currentIndexChanged['int'].connect(self.func_QComboBox_SAMPLING_STRATEGY_NAME_Selected)
        
        return True
    
    def func_Bind_Event_Handlers__QPushButton(self):
        
        '''QPushButton - Save Project & Scenario Files '''
        self.pushButton.clicked.connect(self.func_QPushButton_Clicked__Save_Project_And_Scenario) 
        
        '''QPushButton - Page Modify Scenario - Modify Scenario File '''
        self.pushButton_6.clicked.connect(self.func_QPushButton_Clicked__Edit_Age_Cohort_Mortality_Rates) 
        
        '''QPushButton - Page Modify Scenario - Modify Scenario File '''
        self.pushButton_7.clicked.connect(self.func_QPushButton_Clicked__Save_Modified_Scenario) 
        
        '''QPushButton - Page Run Scenario - Modify Scenario File '''
        self.pushButton_8.clicked.connect(self.func_QPushButton_Clicked__Save_Modified_Scenario) 
        
        '''QPushButton - Page Run Scenario - Save Run Scenario '''
        self.pushButton_11.clicked.connect(self.func_QPushButton_Clicked__Run_Scenario) 
        
        '''QPushButton - Page Create/Select Sampling Strategy - Save Sampling Strategy '''
        self.pushButton_5.clicked.connect(self.func_QPushButton_Clicked__Save_New_Sampling_Strategy) 

        '''QPushButton - Page Run Scenario - Modify Scenario File '''
        self.pushButton_9.clicked.connect(self.func_QPushButton_Clicked__Save_Modified_Sampling_Strategy) 

        '''QPushButton - Page Modify Sampling Strategy - Modify Sampling Proportions '''
        self.pushButton_15.clicked.connect(self.func_QPushButton_Clicked__Edit_Age_Cohort_Sampling_Proportions) 
                
        '''QPushButton - Page Run Sampling Strategy - Save Sampling Strategy '''
        self.pushButton_10.clicked.connect(self.func_QPushButton_Clicked__Save_Modified_Sampling_Strategy) 

        '''QPushButton - Page Run Sampling Strategy - Run Sampling Strategy '''
        self.pushButton_12.clicked.connect(self.func_QPushButton_Clicked__Run_Sampling_Strategy)  
               
        '''QPushButton - Page Review Batch Scenario results - Display plots as slides '''
        self.pushButton_2.clicked.connect(self.func_QPushButton_Clicked__Show_Batch_Scenario_Result_Plots) 

        '''QPushButton - Page Review Scenario results - Display plots as PDF '''
        self.pushButton_21.clicked.connect(self.func_QPushButton_Clicked__Show_Batch_Scenario_Result_Plots_As_PDF)        
        
        '''QPushButton - Page Review Batch Scenario results - Copy results to user-defined location '''
        self.pushButton_3.clicked.connect(self.func_QPushButton_Clicked__Batch_Scenario__Copy_Results_To_User_Location) 

        '''QPushButton - Page Review Sampling Strategy results - Display Next Thumb '''
        self.pushButton_19.clicked.connect(self.func_QPushButton_Clicked__Show_Batch_Scenario_Next_Thumbnail_Result)        

        '''QPushButton - Page Review Sampling Strategy results - Display Prev Thumb '''
        self.pushButton_18.clicked.connect(self.func_QPushButton_Clicked__Show_Batch_Scenario_Prev_Thumbnail_Result)        
        
        #'''QPushButton - Page Run Sampling Strategy - Save Sampling Strategy '''
        self.pushButton_4.clicked.connect(self.func_QPushButton_Clicked__Zip) 

        '''QPushButton - Page Review Sampling Strategy results - Display plots as slides '''
        self.pushButton_14.clicked.connect(self.func_QPushButton_Clicked__Show_Sampling_Strategy_Result_Plots)        

        '''QPushButton - Page Review Sampling Strategy results - Copy results to user-defined location '''
        self.pushButton_13.clicked.connect(self.func_QPushButton_Clicked__Sampling_Strategy__Copy_Results_To_User_Location) 

        '''QPushButton - Page Review Sampling Strategy results - Display Next Thumb '''
        self.pushButton_16.clicked.connect(self.func_QPushButton_Clicked__Show_Sampling_Strategy_Next_Thumbnail_Result)        

        '''QPushButton - Page Review Sampling Strategy results - Display Prev Thumb '''
        self.pushButton_17.clicked.connect(self.func_QPushButton_Clicked__Show_Sampling_Strategy_Prev_Thumbnail_Result)        

        '''QPushButton - Page Review Sampling Strategy results - Display plots as PDF '''
        self.pushButton_20.clicked.connect(self.func_QPushButton_Clicked__Show_Sampling_Strategy_Result_Plots_As_PDF)        
                
        return True
    
    def func_Bind_Event_Handlers__QToolButton(self):
        
        '''QToolButton - Get Projects File '''
        #self.toolButton_3.clicked.connect(self.func_QFile_Dialog_Button_Clicked) 
        
        '''QToolButton - Get AllAlleleFrequencies File '''
        self.toolButton_2.clicked.connect(self.func_QFile_Dialog_Button_Genome_Allele_Frequency_Distribution_File_Clicked) 

        '''QToolButton - Select sim output path '''
        self.toolButton_4.clicked.connect(self.func_QToolButton__Get_Scenario_Simulation_Output_Path__Clicked) 
                
        '''QToolButton - Select sim output path '''
        self.toolButton_5.clicked.connect(self.func_QToolButton__Get_Sampling_Strategy_Simulation_Output_Path__Clicked) 
                
        return True
    
    def func_Bind_Event_Handlers__QRadioButton(self):
        
        '''QRadioButton - Existing Project File '''
        self.radioButton.toggled.connect(self.func_QRadioButton_EXISTING_PROJECT_FILE_Toggled)
        
        '''QRadioButton - New Project File '''
        self.radioButton_2.toggled.connect(self.func_QRadioButton_NEW_PROJECT_FILE_Toggled)
        
        '''QRadioButton - Existing Scenario File '''
        self.radioButton_5.toggled.connect(self.func_QRadioButton_EXISTING_SCENARIO_FILE_Toggled)
        
        '''QRadioButton - New Scenario File '''
        self.radioButton_4.toggled.connect(self.func_QRadioButton_NEW_SCENARIO_FILE_Toggled)
        
        '''QRadioButton - Clone Scenario File '''
        self.radioButton_3.toggled.connect(self.func_QRadioButton_CLONED_SCENARIO_FILE_Toggled)
        
        '''QRadioButton - Existing Sampling_Strategy File '''
        self.radioButton_8.toggled.connect(self.func_QRadioButton_EXISTING_SAMPLING_STRATEGY_FILE_Toggled)
        
        '''QRadioButton - New Sampling_Strategy File '''
        self.radioButton_9.toggled.connect(self.func_QRadioButton_NEW_SAMPLING_STRATEGY_FILE_Toggled)
        
        '''QRadioButton - Clone Sampling_Strategy File '''
        self.radioButton_10.toggled.connect(self.func_QRadioButton_CLONED_SAMPLING_STRATEGY_FILE_Toggled)
        
        return True
    
    def func_Bind_Event_Handlers__QCheckBox(self):
        
        '''QCheckBox - Delete Project File '''
        self.checkBox_3.stateChanged["int"].connect(self.func_QCheckBox_DELETE_PROJECT_StateChanged)
        
        '''QCheckBox - Delete Scenario File '''
        self.checkBox_2.stateChanged["int"].connect(self.func_QCheckBox_DELETE_BATCH_SCENARIO_StateChanged)
        
        '''QCheckBox - Delete Sampling Strategy File '''
        self.checkBox.stateChanged["int"].connect(self.func_QCheckBox_DELETE_SAMPLING_STRATEGY_StateChanged)
        
        return True
    
    def func_Bind_Event_Handlers__Joined_QSliders_And_QSpinBoxes(self):
        
        '''QToolButton - Get Projects File '''
        #self.horizontalSlider_31.mouseMoveEvent.connect(self.func_QHorizontalSlider_MouseMoveEvent)
#         self.horizontalSlider_31.actionTriggered.connect(self.func_QHorizontalSlider_ActionTriggered)
#         self.horizontalSlider_31.sliderPressed.connect(self.func_QHorizontalSlider_SliderPressed)
#         self.horizontalSlider_31.sliderReleased.connect(self.func_QHorizontalSlider_SliderReleased)
#         self.horizontalSlider_31.sliderMoved.connect(self.func_QHorizontalSlider_SliderMoved)
#         QtCore.QObject.connect(self.horizontalSlider_31, QtCore.SIGNAL("valueChanged(int)"), self.func_QHorizontalSlider_ValueChanged)

        '''
        ----------------------------
        Scenario - Life history slider widgets
        ----------------------------
        '''        
        self.horizontalSlider_31.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Max_Age__SetValue)
        self.spinBox_24.valueChanged["int"].connect(self.func_QSpinBox__Scenario_Max_Age__SetValue)
        #self.spinBox_24.editingFinished.connect(self.func_QSpinBox__Scenario_Max_Age__EditingFinished)
        self.spinBox_24.setKeyboardTracking(False)
        
        self.horizontalSlider_32.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Max_Mating_Age__SetValue)
        self.spinBox_25.valueChanged["int"].connect(self.func_QSpinBox__Scenario_Max_Mating_Age__SetValue)
        #self.spinBox_25.editingFinished.connect(self.func_QSpinBox__Scenario_Max_Mating_Age__EditingFinished)
        self.spinBox_25.setKeyboardTracking(False)
        
        self.horizontalSlider_33.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Min_Mating_Age__SetValue)
        self.spinBox_27.valueChanged["int"].connect(self.func_QSpinBox__Scenario_Min_Mating_Age__SetValue)
        #self.spinBox_27.editingFinished.connect(self.func_QSpinBox__Scenario_Min_Mating_Age__EditingFinished)
        self.spinBox_27.setKeyboardTracking(False)
        
        '''
        ----------------------------
        Scenario - Life History Offspring distribution widgets
        ----------------------------
        '''   
        self.horizontalSlider_27.valueChanged["int"].connect(self.func_QHorizontalSlider__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__SetValue)
        self.spinBox_23.valueChanged["int"].connect(self.func_QSpinBox__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__SetValue)
        #self.spinBox_23.editingFinished.connect(self.func_QSpinBox__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__EditingFinished)
        self.spinBox_23.setKeyboardTracking(False)
        
        self.horizontalSlider_30.valueChanged["int"].connect(self.func_QHorizontalSlider__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__SetValue)
        self.doubleSpinBox_9.valueChanged["double"].connect(self.func_QDoubleSpinBox__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__SetValue)
        #self.doubleSpinBox_9.editingFinished.connect(self.func_QDoubleSpinBox__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__EditingFinished)
        self.doubleSpinBox_9.setKeyboardTracking(False)
        
        self.horizontalSlider_28.valueChanged["int"].connect(self.func_QHorizontalSlider__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__SetValue)
        self.doubleSpinBox_5.valueChanged["double"].connect(self.func_QDoubleSpinBox__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__SetValue)
        #self.doubleSpinBox_5.editingFinished.connect(self.func_QDoubleSpinBox__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__EditingFinished)
        self.doubleSpinBox_5.setKeyboardTracking(False)
        
        self.horizontalSlider_29.valueChanged["int"].connect(self.func_QHorizontalSlider__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__SetValue)
        self.doubleSpinBox_6.valueChanged["double"].connect(self.func_QDoubleSpinBox__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__SetValue)
        #self.doubleSpinBox_6.editingFinished.connect(self.func_QDoubleSpinBox__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__EditingFinished)
        self.doubleSpinBox_6.setKeyboardTracking(False)
        
        self.horizontalSlider_39.valueChanged["int"].connect(self.func_QHorizontalSlider__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Min__SetValue)
        self.spinBox_26.valueChanged["int"].connect(self.func_QSpinBox__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Min__SetValue)
        #self.spinBox_26.editingFinished.connect(self.func_QSpinBox__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Min__EditingFinished)
        self.spinBox_26.setKeyboardTracking(False)
        
        self.horizontalSlider_40.valueChanged["int"].connect(self.func_QHorizontalSlider__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Max__SetValue)
        self.spinBox_31.valueChanged["int"].connect(self.func_QSpinBox__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Max__SetValue)
        #self.spinBox_31.editingFinished.connect(self.func_QSpinBox__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Max__EditingFinished)
        self.spinBox_31.setKeyboardTracking(False)
        
        self.horizontalSlider_41.valueChanged["int"].connect(self.func_QHorizontalSlider__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean_Number__SetValue)
        self.doubleSpinBox_10.valueChanged["double"].connect(self.func_QDoubleSpinBox__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean_Number__SetValue)
        #self.doubleSpinBox_10.editingFinished.connect(self.func_QDoubleSpinBox__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean_Number__EditingFinished)
        self.doubleSpinBox_10.setKeyboardTracking(False)
        '''
        ----------------------------
        Scenario - Demography widgets
        ----------------------------
        '''
        self.horizontalSlider_34.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Demography_Population_Size__SetValue)
        self.spinBox_28.valueChanged["int"].connect(self.func_QSpinBox__Scenario_Demography_Population_Size__SetValue)
        #self.spinBox_28.editingFinished.connect(self.func_QSpinBox__Scenario_Demography_Population_Size__EditingFinished)
        self.spinBox_28.setKeyboardTracking(False)
        
        '''
        ----------------------------
        Scenario - Genetics widgets
        ----------------------------
        '''  
        self.horizontalSlider_38.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Genome_Locus_Number__SetValue)
        self.spinBox_30.valueChanged["int"].connect(self.func_QSpinBox__Scenario_Genome_Locus_Number__SetValue)
        #self.spinBox_30.editingFinished.connect(self.func_QSpinBox__Scenario_Genome_Locus_Number__EditingFinished)
        self.spinBox_30.setKeyboardTracking(False)
        
        self.horizontalSlider_35.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__SetValue)
        self.spinBox_29.valueChanged["int"].connect(self.func_QSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__SetValue)
        #self.spinBox_29.editingFinished.connect(self.func_QSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__EditingFinished)
        self.spinBox_29.setKeyboardTracking(False)
        
        self.horizontalSlider_37.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__SetValue)
        self.doubleSpinBox_7.valueChanged["double"].connect(self.func_QDoubleSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__SetValue)
        #self.doubleSpinBox_7.editingFinished.connect(self.func_QDoubleSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__EditingFinished)
        self.doubleSpinBox_7.setKeyboardTracking(False)
        
        self.horizontalSlider_42.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__SetValue)
        self.doubleSpinBox_8.valueChanged["double"].connect(self.func_QDoubleSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__SetValue)
        #self.doubleSpinBox_8.editingFinished.connect(self.func_QDoubleSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__EditingFinished)
        self.doubleSpinBox_8.setKeyboardTracking(False)
        
        '''
        ----------------------------
        Scenario - Simulation widgets
        ----------------------------
        ''' 
        self.horizontalSlider_45.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Simulation_Batch_Replicates__SetValue)
        self.spinBox_37.valueChanged["int"].connect(self.func_QSpinBox__Scenario_Simulation_Batch_Replicates__SetValue)
        #self.spinBox_37.editingFinished.connect(self.func_QSpinBox__Scenario_Simulation_Batch_Replicates__EditingFinished)
        self.spinBox_37.setKeyboardTracking(False)
        
        self.horizontalSlider_46.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Simulation_Batch_Replicate_Length_Burn_In__SetValue)
        self.spinBox_38.valueChanged["int"].connect(self.func_QSpinBox__Scenario_Simulation_Batch_Replicate_Length_Burn_In__SetValue)
        #self.spinBox_38.editingFinished.connect(self.func_QSpinBox__Scenario_Simulation_Batch_Replicate_Length_Burn_In__EditingFinished)
        self.spinBox_38.setKeyboardTracking(False)
        
        self.horizontalSlider_47.valueChanged["int"].connect(self.func_QHorizontalSlider__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution__SetValue)
        self.spinBox_39.valueChanged["int"].connect(self.func_QSpinBox__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution__SetValue)
        #self.spinBox_39.editingFinished.connect(self.func_QSpinBox__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution__EditingFinished)
        self.spinBox_39.setKeyboardTracking(False)
        '''
        ----------------------------
        Sampling Strategy - Sample Size widgets
        ----------------------------
        '''
        self.horizontalSlider_48.valueChanged["int"].connect(self.func_QHorizontalSlider__Sampling_Strategy_Sample_Range_Min__SetValue)
        self.spinBox_40.valueChanged["int"].connect(self.func_QSpinBox__Sampling_Strategy_Sample_Range_Min__SetValue)
        #self.spinBox_40.editingFinished.connect(self.func_QSpinBox__Sampling_Strategy_Sample_Range_Min__EditingFinished)
        self.spinBox_40.setKeyboardTracking(False)
        
        self.horizontalSlider_49.valueChanged["int"].connect(self.func_QHorizontalSlider__Sampling_Strategy_Sample_Range_Max__SetValue)
        self.spinBox_41.valueChanged["int"].connect(self.func_QSpinBox__Sampling_Strategy_Sample_Range_Max__SetValue)
        #self.spinBox_41.editingFinished.connect(self.func_QSpinBox__Sampling_Strategy_Sample_Range_Max__EditingFinished)
        self.spinBox_41.setKeyboardTracking(False)
        
        self.horizontalSlider_50.valueChanged["int"].connect(self.func_QHorizontalSlider__Sampling_Strategy_Sample_Range_Increment__SetValue)
        self.spinBox_42.valueChanged["int"].connect(self.func_QSpinBox__Sampling_Strategy_Sample_Range_Increment__SetValue)
        #self.spinBox_42.editingFinished.connect(self.func_QSpinBox__Sampling_Strategy_Sample_Range_Increment__EditingFinished)
        self.spinBox_42.setKeyboardTracking(False)
        '''
        ----------------------------
        Sampling Strategy - Locus Number widgets
        ----------------------------
        '''
        self.horizontalSlider_51.valueChanged["int"].connect(self.func_QHorizontalSlider__Sampling_Strategy_Locus_Range_Min__SetValue)
        self.spinBox_43.valueChanged["int"].connect(self.func_QSpinBox__Sampling_Strategy_Locus_Range_Min__SetValue)
        #self.spinBox_43.editingFinished.connect(self.func_QSpinBox__Sampling_Strategy_Locus_Range_Min__EditingFinished)
        self.spinBox_43.setKeyboardTracking(False)
        
        self.horizontalSlider_52.valueChanged["int"].connect(self.func_QHorizontalSlider__Sampling_Strategy_Locus_Range_Max__SetValue)
        self.spinBox_44.valueChanged["int"].connect(self.func_QSpinBox__Sampling_Strategy_Locus_Range_Max__SetValue)
        #self.spinBox_44.editingFinished.connect(self.func_QSpinBox__Sampling_Strategy_Locus_Range_Max__EditingFinished)
        self.spinBox_44.setKeyboardTracking(False)
        
        self.horizontalSlider_53.valueChanged["int"].connect(self.func_QHorizontalSlider__Sampling_Strategy_Locus_Range_Increment__SetValue)
        self.spinBox_45.valueChanged["int"].connect(self.func_QSpinBox__Sampling_Strategy_Locus_Range_Increment__SetValue)
        #self.spinBox_45.editingFinished.connect(self.func_QSpinBox__Sampling_Strategy_Locus_Range_Increment__EditingFinished)
        self.spinBox_45.setKeyboardTracking(False)
        
        self.horizontalSlider_54.valueChanged["int"].connect(self.func_QHorizontalSlider__Sampling_Strategy_LDNe_Replicates__SetValue)
        self.spinBox_46.valueChanged["int"].connect(self.func_QSpinBox__Sampling_Strategy_LDNe_Replicates__SetValue)
        #self.spinBox_46.editingFinished.connect(self.func_QSpinBox__Sampling_Strategy_LDNe_Replicates__EditingFinished)
        self.spinBox_46.setKeyboardTracking(False)
        
        return True

    
    '''
    -------------------------------------------------------------------------------
        Event filters
    -------------------------------------------------------------------------------
    '''

    def func_Bind_Event_Filters(self):
        
        self.func_Bind_Event_Filters__QComboBox()
        self.func_Bind_Event_Filters__QSpinBox()
        self.func_Bind_Event_Filters__QSliders()
        self.func_Bind_Event_Filters__QDoubleSpinBox()
        self.func_Bind_Event_Filters__QGroupBox()
        self.func_Bind_Event_Filters__QFrame()
        
        return True

    def func_Bind_Event_Filters__QSliders(self):

        '''Modify Scenario Page - Tab - Life History'''
        self.horizontalSlider_31.installEventFilter(self)
        self.horizontalSlider_32.installEventFilter(self)
        self.horizontalSlider_33.installEventFilter(self)
        
        self.horizontalSlider_27.installEventFilter(self)
        self.horizontalSlider_30.installEventFilter(self)
        
        self.horizontalSlider_28.installEventFilter(self)
        self.horizontalSlider_29.installEventFilter(self)
        
        self.horizontalSlider_39.installEventFilter(self)
        self.horizontalSlider_40.installEventFilter(self)
        
        self.horizontalSlider_41.installEventFilter(self)

        '''Modify Scenario Page - Tab - Demography'''
        self.horizontalSlider_34.installEventFilter(self)
        
        '''Modify Scenario Page - Tab - Genetics'''
        self.horizontalSlider_38.installEventFilter(self)
        self.horizontalSlider_35.installEventFilter(self)
        self.horizontalSlider_37.installEventFilter(self)
        self.horizontalSlider_42.installEventFilter(self)
        
        '''Run Scenario Page - Tab - Run Scenario'''
        self.horizontalSlider_45.installEventFilter(self)
        self.horizontalSlider_46.installEventFilter(self)
        self.horizontalSlider_47.installEventFilter(self)
        
        '''Modify Samping Strategy Page - Tab - Sample Size & Locus Range'''
        #self.horizontalSlider_48.installEventFilter(self) #Disable Min
        self.horizontalSlider_49.installEventFilter(self)
        self.horizontalSlider_50.installEventFilter(self)
        #self.horizontalSlider_51.installEventFilter(self) #Disable Min
        self.horizontalSlider_52.installEventFilter(self)
        self.horizontalSlider_53.installEventFilter(self)
        
        '''Run Sampling Strategy Page - Tab - Sampling Strategy run Parameters'''        
        self.horizontalSlider_54.installEventFilter(self)
        
        return True
        
    def func_Bind_Event_Filters__QComboBox(self):

        '''Scenario Page - General'''
        
        self.comboBox_110.installEventFilter(self)
        #self.comboBox_111.installEventFilter(self)
        self.comboBox_210.installEventFilter(self)
        #self.comboBox_211.installEventFilter(self)
        self.comboBox_310.installEventFilter(self)
        #self.comboBox_311.installEventFilter(self)
        
        '''Scenario Page - Tab - Genetics'''
        #self.comboBox_6.installEventFilter(self)
        
        return True
        
    def func_Bind_Event_Filters__QSpinBox(self):

        ''' Max Age Spinbox '''
        self.spinBox_24.installEventFilter(self)
        ''' Max Mating Age Spinbox '''
        self.spinBox_25.installEventFilter(self)
        ''' Min Mating Age Spinbox '''
        self.spinBox_27.installEventFilter(self)
        
        ''' Offspring Dist ABSOLUTE Size Spinbox '''
        self.spinBox_23.installEventFilter(self)
        ''' Offspring Dist UNIFORM Max Size Spinbox '''
        self.spinBox_31.installEventFilter(self)
        ''' Offspring Dist UNIFORM Min Size Spinbox '''
        self.spinBox_26.installEventFilter(self)

        ''' Pop Size Spinbox '''
        self.spinBox_28.installEventFilter(self)
        
        ''' Genome Locus Number Spinbox '''
        self.spinBox_30.installEventFilter(self)
        
        ''' Genome Allele Per Locus UNIFORM Spinbox '''
        self.spinBox_29.installEventFilter(self)
        
        ''' Sim Length Pop Replicates Spinbox '''
        self.spinBox_37.installEventFilter(self)
        ''' Sim Burn-in Length Spinbox '''
        self.spinBox_38.installEventFilter(self)
        ''' Sim Temporal Evo Length Spinbox '''
        self.spinBox_39.installEventFilter(self)

        ''' Sampling Strategy Sample Size Max Spinbox '''
        self.spinBox_41.installEventFilter(self)
        ''' Sampling Strategy Sample Size Increment Spinbox '''
        self.spinBox_42.installEventFilter(self)
        ''' Sampling Strategy Sample Size Min Spinbox '''
        #self.spinBox_40.installEventFilter(self)

        ''' Sampling Strategy Locus Number Max Spinbox '''
        self.spinBox_44.installEventFilter(self) 
        ''' Sampling Strategy Locus Number Increment Spinbox '''
        self.spinBox_45.installEventFilter(self) 
        ''' Sampling Strategy Locus Number Min Spinbox '''
        self.spinBox_43.installEventFilter(self) 
        
        ''' Sampling Strategy Sim Length Replicates Spinbox '''
        self.spinBox_46.installEventFilter(self) 
                       
        return True
        
    def func_Bind_Event_Filters__QDoubleSpinBox(self):

        ''' Offspring Dist POISSON Mean DoubleSpinbox '''
        self.doubleSpinBox_9.installEventFilter(self)
        
        ''' Offspring Dist BINOMIAL Mean DoubleSpinbox '''
        self.doubleSpinBox_5.installEventFilter(self)
        ''' Offspring Dist BINOMIAL StdDev DoubleSpinbox '''
        self.doubleSpinBox_6.installEventFilter(self)

        ''' Offspring Dist GEOMETRIC Mean DoubleSpinbox '''
        self.doubleSpinBox_10.installEventFilter(self)

        ''' Genome Allele Per Locus BINOMIAL Mean DoubleSpinbox '''
        self.doubleSpinBox_7.installEventFilter(self)
        ''' Genome Allele Per Locus BINOMIAL StdDev DoubleSpinbox '''
        self.doubleSpinBox_8.installEventFilter(self)

                
        return True
        
    def func_Bind_Event_Filters__QGroupBox(self):

        ''' CONTEXT HELP QGroupBoxes '''
        #self.groupBox_4.installEventFilter(self)
        #self.groupBox_5.installEventFilter(self)
        
        return True
        
    def func_Bind_Event_Filters__QFrame(self):

        ''' CONTEXT HELP QFrames '''
        #self.frame_0.installEventFilter(self)
        self.frame_1.installEventFilter(self)
        self.frame_2.installEventFilter(self)
        self.frame_3.installEventFilter(self)
        self.frame_4.installEventFilter(self)
        self.frame_5.installEventFilter(self)
        self.frame_6.installEventFilter(self)
        self.frame_7.installEventFilter(self)
        self.frame_8.installEventFilter(self)
        
        return True
        
    def eventFilter(self, object, event):
        
        if object.objectName() == 'comboBox_110': # or object.objectName() == 'comboBox_111':
            self.eventFilter__comboBox_110(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'comboBox_210': # or object.objectName() == 'comboBox_211':
            self.eventFilter__comboBox_210(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'comboBox_310': # or object.objectName() == 'comboBox_311':
            self.eventFilter__comboBox_310(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'comboBox_6':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__comboBox_6(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
#         elif object.objectName() == 'spinBox_24':
#             self.eventFilter__spinBox_24(object, event)
#             #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
#         elif object.objectName() == 'horizontalSlider_31':
#             self.eventFilter__horizontalSlider_31(object, event)
#             #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        elif object.objectName() == 'horizontalSlider_31':
            #list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__OBJECT_SPECIFIC_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_24':
            #list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__OBJECT_SPECIFIC_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_32':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)
            #self.eventFilter__horizontalSlider_32(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_25':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_33':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)
            #self.eventFilter__horizontalSlider_33(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_27':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        
        elif object.objectName() == 'horizontalSlider_27':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)
            #self.eventFilter__horizontalSlider_27(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_23':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_30':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)
            #self.eventFilter__horizontalSlider_30(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'doubleSpinBox_9':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_28':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)
            #self.eventFilter__horizontalSlider_28(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'doubleSpinBox_5':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_29':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)
            #self.eventFilter__horizontalSlider_29(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'doubleSpinBox_6':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_39':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)
            #self.eventFilter__horizontalSlider_39(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_26':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_40':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)
            #self.eventFilter__horizontalSlider_40(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_32':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_41':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)
            #self.eventFilter__horizontalSlider_41(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'doubleSpinBox_10':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?


        elif object.objectName() == 'horizontalSlider_34':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)            
            #self.eventFilter__horizontalSlider_34(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_28':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)            
            #self.eventFilter__spinBox_28(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        elif object.objectName() == 'horizontalSlider_38':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)            
            #self.eventFilter__horizontalSlider_38(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_30':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)            
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        
        
        elif object.objectName() == 'horizontalSlider_35':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)            
            #self.eventFilter__horizontalSlider_35(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_29':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_37':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)            
            #self.eventFilter__horizontalSlider_37(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'doubleSpinBox_7':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_42':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)            
            #self.eventFilter__horizontalSlider_42(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'doubleSpinBox_8':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        elif object.objectName() == 'horizontalSlider_45':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)   
            #self.eventFilter__horizontalSlider_45(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_37':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_46':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider_STEPPED_By_MaxAge(object, event, list_Object_Groups)   
            #self.eventFilter__horizontalSlider_46(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_38':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_47':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_horizontalSlider_STEPPED_By_MaxAge(object, event, list_Object_Groups)   
            #self.eventFilter__horizontalSlider_47(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_39':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?


        elif object.objectName() == 'horizontalSlider_48':
            #list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            #self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)   
            self.eventFilter__horizontalSlider_48(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_40':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_49':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)   
            #self.eventFilter__horizontalSlider_48(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_41':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_50':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)   
            #self.eventFilter__horizontalSlider_50(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_42':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        elif object.objectName() == 'horizontalSlider_51':
            #list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            #self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)   
            self.eventFilter__horizontalSlider_51(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_43':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_52':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)   
            #self.eventFilter__horizontalSlider_52(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_44':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'horizontalSlider_53':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)   
            #self.eventFilter__horizontalSlider_53(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_45':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        elif object.objectName() == 'horizontalSlider_54':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_horizontalSlider(object, event, list_Object_Groups)   
            #self.eventFilter__horizontalSlider_54(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        elif object.objectName() == 'spinBox_46':
            list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            self.eventFilter__LINKED_spinBox(object, event, list_Object_Groups)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        elif object.objectName() == 'frame_1' or \
            object.objectName() == 'frame_2' or \
            object.objectName() == 'frame_3' or \
            object.objectName() == 'frame_4' or \
            object.objectName() == 'frame_5' or \
            object.objectName() == 'frame_6' or \
            object.objectName() == 'frame_7' or \
            object.objectName() == 'frame_8':
          
            ''' CONTEXT HELP Widgets '''
            self.eventFilter__groupBox_Context_Help(object, event)
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        else:
            pass
        pass
        
        return False

    '''
    ----------------------------
    LINKED Sliders & SpinBoxes = General Purpose routines
    ----------------------------
    ''' 
    
    def func_Linked_Slider_And_Spinbox__Companion_Engaged(self, str_Object_Name, str_Object_Companion_Engaged):
        
        bool_Companion_Engaged = False
        
        str_Object_Companion = self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name]
        if str_Object_Companion == str_Object_Companion_Engaged:
            bool_Companion_Engaged = True
        pass
        
        return bool_Companion_Engaged
        
    def eventFilter__LINKED_spinBox(self, object, event, list_Object_Groups):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        str_Object_Name = str(object.objectName())
        list_Events_Not_To_Log = [110,12,170,129]
        if int_Event_type not in list_Events_Not_To_Log:
            if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            else:
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + "; Unlisted Event:"  + str(event.type()))
            pass
        pass
    
        if event.type() == QtCore.QEvent.MouseButtonPress :
            return True
        
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            '''set the mouse button pressed flag'''
            self.bool_SpinBoxMouseButtonReleased = True
            ''' Get the value'''
            int_Object_Value = object.value()
            ''' Check if other parameters that are dependent on MaxAge will have to be changed '''
            ''' Verify if the change can proceed '''
            int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Object_Groups)
            if int_Verify_Change__Warning_Count < 1:
                ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                object.blockSignals(True)
                ''' Warn that other parameters that are dependent will have to be changed '''
                bool_Continue = self.func_Verify_Change__Can_Change_Proceed__Bind_Event_Filter_Downstream_Actions(object, self.int_SpinBox_Orig_Value, list_Object_Groups)
                object.blockSignals(False)
            else:
                bool_Continue = True
            pass
            if bool_Continue:
                ''' Set the value '''         
                object.setValue(int_Object_Value)
                #''' Update config but dont Save file...yet'''
                #bool_Save = True
                #self.func_Update__Bind_Event_Filter_Downstream_Actions(str_Object_Name, int_Object_Value, bool_Save)
                ''' Get the value to remember'''
                self.int_SpinBox_Orig_Value = int_Object_Value
            else:
                ''' Do nothing - Object will revert to orginal value'''
                object.setValue(self.int_SpinBox_Orig_Value)
            pass
            self.bool_SpinBoxMouseButtonReleased = False
            return True
        
        elif event.type() == QtCore.QEvent.HoverEnter :
            '''Get value '''
            self.int_SpinBox_Orig_Value = object.value()
            return True
        
        elif event.type() == QtCore.QEvent.FocusIn :
            self.str_SpinBox_Engaged_Name = str_Object_Name
            return True
        
        elif event.type() == QtCore.QEvent.FocusOut :
            self.str_SpinBox_Engaged_Name = ''
            return True
        
        elif event.type() == QtCore.QEvent.KeyRelease :
            ''' Get the value'''
            #QtGui.QApplication.processEvents()
            int_Object_Value = object.value()            
            ''' Verify if the change can proceed '''
            int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Object_Groups)
            if int_Verify_Change__Warning_Count < 1:
                ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                object.blockSignals(True)
                ''' Warn that other parameters that are dependent will have to be changed '''
                bool_Continue = self.func_Verify_Change__Can_Change_Proceed__Bind_Event_Filter_Downstream_Actions(object, self.int_SpinBox_Orig_Value, list_Object_Groups)
                object.blockSignals(False)
                if bool_Continue:
                    ''' Allow editing to continue '''
                    #object.setValue(int_Object_Value)
                    object.setValue(self.int_SpinBox_Orig_Value)
                    object.selectAll()
                    pass
                else:
                    '''Revert to orginal value'''
                    object.setValue(self.int_SpinBox_Orig_Value)
                    object.selectAll()
                    pass
                pass
            pass     
            return True
        
        else:
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass

        return False
               
    def eventFilter__LINKED_horizontalSlider(self, object, event, list_Object_Groups):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        str_Object_Name = str(object.objectName())
        list_Events_Not_To_Log = [110,12,24, 129]
        if int_Event_type not in list_Events_Not_To_Log:        
            if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            else:
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + "; Unlisted Event:"  + str(event.type()))
            pass
        pass
        
        if self.bool_Slider_Events_Disabled:
            self.func_Debug_Logging(True, 2, str('CANCELLED EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            return True
        pass
            
        bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, self.str_SpinBox_Engaged_Name)
        self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()) + '; str_Object_Name: ' + str_Object_Name + '; self.str_SpinBox_Engaged_Name: ' + self.str_SpinBox_Engaged_Name + '; bool_Companion_Engaged: ' + self.str_Slider_Engaged_Name)
        
        if event.type() == QtCore.QEvent.MouseButtonPress :
            return True
        
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Verify if the change can proceed '''
            int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Object_Groups)
            if int_Verify_Change__Warning_Count < 1:
                ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                object.blockSignals(True)
                ''' Warn that other parameters that are dependent will have to be changed '''
                bool_Continue = self.func_Verify_Change__Can_Change_Proceed__Bind_Event_Filter_Downstream_Actions(object, self.int_SpinBox_Orig_Value, list_Object_Groups)
                object.blockSignals(False)
            else:
                bool_Continue = True
            pass
            if bool_Continue:
                ''' Set the value '''
                object.setValue(int_Object_Value)
#                 ''' NOTE: I dont know why the setValue above doesnt fire the SIGNAL for these linked controls...
#                 so I have to set it this way...
#                 '''
#                 qWidget_Companion = self.findChild(QtGui.QSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
#                 if qWidget_Companion == None:
#                     qWidget_Companion = self.findChild(QtGui.QDoubleSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
#                     qWidget_Companion.setValue(int_Object_Value)
#                 else:
#                     qWidget_Companion.setValue(int_Object_Value)                    
#                 pass   
#                 ''' NOTE: I dont know why the setValue above doesnt fire the SIGNAL for these linked controls...
#                 so I have to set it this way...
#                 '''
                qWidget_Companion = self.findChild(QtGui.QSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
                if qWidget_Companion == None:
                    qWidget_Companion = self.findChild(QtGui.QDoubleSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
                    value_Object = qWidget_Companion.value()
                else:
                    value_Object = qWidget_Companion.value()                    
                pass                
                ''' Update config but dont Save file...yet'''
                bool_Save = True
                self.func_Update__Bind_Event_Filter_Downstream_Actions(str_Object_Name, value_Object, bool_Save)
                ''' Get the value to remember'''
                self.int_Slider_Orig_Value = int_Object_Value
            else:
                ''' Do nothing - Object will revert to orginal value'''
                object.setValue(self.int_Slider_Orig_Value)
#                 ''' NOTE: I dont know why the setValue above doesnt fire the SIGNAL for these linked controls...
#                 so I have to set it this way...
#                 '''
#                 qWidget_Companion = self.findChild(QtGui.QSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
#                 if qWidget_Companion == None:
#                     qWidget_Companion = self.findChild(QtGui.QDoubleSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
#                     qWidget_Companion.setValue(self.int_Companion_Orig_Value)
#                 else:
#                     qWidget_Companion.setValue(self.int_Slider_Orig_Value)                    
#                 pass
            pass
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        
        elif event.type() == QtCore.QEvent.HoverEnter :
            if self.bool_SliderMouseButtonReleased == False:
                '''Get slider value '''
                #QtGui.QApplication.processEvents()
                qWidget_Companion = self.findChild(QtGui.QSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
                if qWidget_Companion == None:
                    qWidget_Companion = self.findChild(QtGui.QDoubleSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
                pass
                self.int_Companion_Orig_Value = qWidget_Companion.value()
                                   
                self.int_Slider_Orig_Value = object.value()
                
                self.str_Slider_Engaged_Name = str_Object_Name
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()) + '; self.str_Slider_Engaged_Name: ' + self.str_Slider_Engaged_Name)
                
                self.bool_Slider_Engaged = True
                
                if not bool_Companion_Engaged:
                    object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
                pass
            pass
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            if not bool_Companion_Engaged:
                ''' Get the mouse cursor x pos relative to the widget '''
                x = event.pos().x()
                self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
                ''' Get the value of the slider to the value calculated from the mouse x pos '''
                int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
                self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
                ''' Set the value of the slider to the value calculated from the mouse x pos '''
                ''' Set the slider and spinbox values '''
                object.setValue(int_Object_Value)
                ''' Dont update config but set the ranges for related sliders '''
                bool_Save = False
                self.func_Update__Bind_Event_Filter_Downstream_Actions(str_Object_Name, int_Object_Value, bool_Save)
            pass
            return True
        
        elif event.type() == QtCore.QEvent.HoverLeave :
            #if not bool_Companion_Engaged:
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider value '''
                object.setValue(int_Slider_Value)
                #QtGui.QApplication.processEvents()
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.str_Slider_Engaged_Name = ''
            self.bool_Slider_Engaged = False
            pass
            return True
        
        elif event.type() == QtCore.QEvent.FocusIn :
            self.str_Slider_Engaged_Name = str_Object_Name
            return True
        
        elif event.type() == QtCore.QEvent.FocusOut :
            self.str_Slider_Engaged_Name = ''
            return True
        
        else:
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__LINKED_horizontalSlider_STEPPED_By_MaxAge(self, object, event, list_Object_Groups):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        str_Object_Name = str(object.objectName())
        list_Events_Not_To_Log = [110,12,24, 129]
        if int_Event_type not in list_Events_Not_To_Log:        
            if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            else:
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + "; Unlisted Event:"  + str(event.type()))
            pass
        pass

        if self.bool_Slider_Events_Disabled:
            self.func_Debug_Logging(True, 2, str('CANCELLED EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            return True
        pass
        
        bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, self.str_SpinBox_Engaged_Name)
    
        if event.type() == QtCore.QEvent.MouseButtonPress :
            return True
        
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Verify if the change can proceed '''
            int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Object_Groups)
            if int_Verify_Change__Warning_Count < 1:
                ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                object.blockSignals(True)
                ''' Warn that other parameters that are dependent will have to be changed '''
                bool_Continue = self.func_Verify_Change__Can_Change_Proceed__Bind_Event_Filter_Downstream_Actions(object, self.int_SpinBox_Orig_Value, list_Object_Groups)
                object.blockSignals(False)
            else:
                bool_Continue = True
            pass
            if bool_Continue:
                ''' Set the value '''
                int_Object_Value__New = int_Object_Value - (int_Object_Value%self.int_Species_Life_History_Max_Age)
                object.setValue(int_Object_Value__New)
#                 ''' NOTE: I dont know why the setValue above doesnt fire the SIGNAL for these linked controls...
#                 so I have to set it this way...
#                 '''
#                 qWidget_Companion = self.findChild(QtGui.QSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
#                 if qWidget_Companion == None:
#                     qWidget_Companion = self.findChild(QtGui.QDoubleSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
#                     qWidget_Companion.setValue(int_Object_Value)
#                 else:
#                     qWidget_Companion.setValue(int_Object_Value)                    
#                 pass   
#                 ''' NOTE: I dont know why the setValue above doesnt fire the SIGNAL for these linked controls...
#                 so I have to set it this way...
#                 '''
                qWidget_Companion = self.findChild(QtGui.QSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
                if qWidget_Companion == None:
                    qWidget_Companion = self.findChild(QtGui.QDoubleSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
                    value_Object = qWidget_Companion.value()
                else:
                    value_Object = qWidget_Companion.value()                    
                pass                
                ''' Update config but dont Save file...yet'''
                bool_Save = True
                self.func_Update__Bind_Event_Filter_Downstream_Actions(str_Object_Name, value_Object, bool_Save)
                ''' Get the value to remember'''
                self.int_Slider_Orig_Value = int_Object_Value__New
            else:
                ''' Do nothing - Object will revert to orginal value'''
                object.setValue(self.int_Slider_Orig_Value)
#                 ''' NOTE: I dont know why the setValue above doesnt fire the SIGNAL for these linked controls...
#                 so I have to set it this way...
#                 '''
#                 qWidget_Companion = self.findChild(QtGui.QSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
#                 if qWidget_Companion == None:
#                     qWidget_Companion = self.findChild(QtGui.QDoubleSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
#                     qWidget_Companion.setValue(self.int_Companion_Orig_Value)
#                 else:
#                     qWidget_Companion.setValue(self.int_Slider_Orig_Value)                    
#                 pass
            pass
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        
        elif event.type() == QtCore.QEvent.HoverEnter :
            if self.bool_SliderMouseButtonReleased == False:
                '''Get slider value '''
                #QtGui.QApplication.processEvents()
                qWidget_Companion = self.findChild(QtGui.QSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
                if qWidget_Companion == None:
                    qWidget_Companion = self.findChild(QtGui.QDoubleSpinBox, self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name])
                pass
                self.int_Companion_Orig_Value = qWidget_Companion.value()
                                   
                self.int_Slider_Orig_Value = object.value()
                self.str_Slider_Engaged_Name = str_Object_Name
                self.bool_Slider_Engaged = True
                if not bool_Companion_Engaged:
                    object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
                pass
            pass
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            if not bool_Companion_Engaged:
                ''' Get the mouse cursor x pos relative to the widget '''
                x = event.pos().x()
                self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
                ''' Get the value of the slider to the value calculated from the mouse x pos '''
                int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
                self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
                ''' Set the value of the slider to the value calculated from the mouse x pos '''
                ''' Set the slider and spinbox values '''
                ''' Substitute a multimple of the Max Age - num - (num%divisor) ie. rounded down to the nearest multiple of MaxAge'''
                int_Object_Value__New = int_Object_Value - (int_Object_Value%self.int_Species_Life_History_Max_Age)
                object.setValue(int_Object_Value__New)
                ''' Dont update config but set the ranges for related sliders '''
                bool_Save = False
                self.func_Update__Bind_Event_Filter_Downstream_Actions(str_Object_Name, int_Object_Value, bool_Save)
            pass
            return True
        
        elif event.type() == QtCore.QEvent.HoverLeave :
            #if not bool_Companion_Engaged:
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
                #QtGui.QApplication.processEvents()
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.str_Slider_Engaged_Name = ''
            self.bool_Slider_Engaged = False
            pass
            return True
        
        elif event.type() == QtCore.QEvent.FocusIn :
            self.str_Slider_Engaged_Name = str_Object_Name
            return True
        
        elif event.type() == QtCore.QEvent.FocusOut :
            self.str_Slider_Engaged_Name = ''
            return True
        
        else:
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False
   
    '''
    Bind Event Filter Downstream actions
    '''    
    def func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(self, str_Object_Name, list_Object_Groups):

        int_Verify_Change__Warning_Count = 0
        ''' Get OBJECT_SPECIFIC count '''
        if globalsSSFE.Parameter_Group.static_str__Parameter_Group__OBJECT_SPECIFIC_PARAM in list_Object_Groups:
            try:
                int_Verify_Change__Warning_Count += self.dict_Parameter_Status[str_Object_Name][globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Edit_Warning_Count__Object_Specific]
            except KeyError:
                pass
            pass
            try:
                str_Object_Companion = self.dict_LINKED_Sliders_And_SpinBoxes[str_Object_Name]
                int_Verify_Change__Warning_Count += self.dict_Parameter_Status[str_Object_Companion][globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Edit_Warning_Count__Object_Specific]
            except KeyError:
                pass
            pass
        
            return int_Verify_Change__Warning_Count
        pass
    
        ''' Get GROUP SPECIFIC count '''
        #if int_Verify_Change__Warning_Count == 0:
        if globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM in list_Object_Groups:
            int_Verify_Change__Warning_Count = self.int_Edit_Warning_Count__All_Batch_Scenario_Params
#             list_Keys = [key for _, dict_Items in self.dict_Parameter_Status.items() for key in dict_Items.keys()]
#             if globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Edit_Warning_Count__All_BS_Params in list_Keys:
#                 int_Verify_Change__Warning_Count += 1
#             pass
        pass
    
        if globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM in list_Object_Groups:
            int_Verify_Change__Warning_Count = self.int_Edit_Warning_Count__All_Sampling_Strategy_Params
#             list_Keys = [key for _, dict_Items in self.dict_Parameter_Status.items() for key in dict_Items.keys()]
#             if globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Edit_Warning_Count__All_BS_Params in list_Keys:
#                 int_Verify_Change__Warning_Count += 1
#             pass
        pass
        pass
    
        return int_Verify_Change__Warning_Count    
    
    def func_Verify_Change__Can_Change_Proceed__Bind_Event_Filter_Downstream_Actions(self, qWidget, value_Object, list_Object_Groups):

        bool_Continue = False
        
        str_Object_Name = str(qWidget.objectName())
        
        '''
        ----------------------------
        Scenario - Life history Ages
        ----------------------------
        '''
        
        if str_Object_Name == 'horizontalSlider_31' or str_Object_Name == 'spinBox_24':
            bool_Continue = self.func_Verify_Change__Can_Change_Proceed__Scenario_Max_Age(qWidget, value_Object)
        elif globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM in list_Object_Groups:
            bool_Continue = self.func_Verify_Change__Can_Change_Proceed__ANY_Scenario_PARAMETER()
        elif globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM in list_Object_Groups:
            bool_Continue = self.func_Verify_Change__Can_Change_Proceed__ANY_Sampling_Strategy_PARAMETER()
        pass
    
        return bool_Continue    
    
    def func_Update__Bind_Event_Filter_Downstream_Actions(self, str_Object_Name, value_Object, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        '''
        ----------------------------
        Scenario - Life history Ages
        ----------------------------
        '''
        
        if str_Object_Name == 'horizontalSlider_31':
            self.func_Update__Scenario_Life_History_Ages(str_Object_Name, value_Object, bool_Save)
        if str_Object_Name == 'spinBox_24':
            self.func_Update__Scenario_Life_History_Ages(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_32':
            self.func_Update__Scenario_Life_History_Ages(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_33':
            self.func_Update__Scenario_Life_History_Ages(str_Object_Name, value_Object, bool_Save)
        pass
    
        '''
        ----------------------------
        Scenario - Life History Offspring distribution 
        ----------------------------
        '''          
        if str_Object_Name == 'horizontalSlider_27':
            self.func_Update__Scenario_Offspring_Distribution(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_30':
            self.func_Update__Scenario_Offspring_Distribution(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_28':
            self.func_Update__Scenario_Offspring_Distribution(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_29':
            self.func_Update__Scenario_Offspring_Distribution(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_39':
            self.func_Update__Scenario_Offspring_Distribution(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_40':
            self.func_Update__Scenario_Offspring_Distribution(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_41':
            self.func_Update__Scenario_Offspring_Distribution(str_Object_Name, value_Object, bool_Save)
        pass
    
        '''
        ----------------------------
        Scenario - Demography 
        ----------------------------
        '''   
        
        if str_Object_Name == 'horizontalSlider_34':
            self.func_Update__Scenario_Demography(str_Object_Name, value_Object, bool_Save)
        pass
        '''
        ----------------------------
        Scenario - Genetics 
        ----------------------------
        '''         
        if str_Object_Name == 'horizontalSlider_38':
            self.func_Update__Scenario_Genome(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_35':
            self.func_Update__Scenario_Genome(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_37':
            self.func_Update__Scenario_Genome(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_42':
            self.func_Update__Scenario_Genome(str_Object_Name, value_Object, bool_Save)
        pass
        '''
        ----------------------------
        Scenario - Simulation 
        ----------------------------
        ''' 
        
        if str_Object_Name == 'horizontalSlider_45':
            self.func_Update__Scenario_Simulation_Length(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_46':
            self.func_Update__Scenario_Simulation_Length(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_47':
            self.func_Update__Scenario_Simulation_Length(str_Object_Name, value_Object, bool_Save)
        pass
    
        '''
        ----------------------------
        Sampling Strategy - Sample Size 
        ----------------------------
        '''   
        
        if str_Object_Name == 'horizontalSlider_48':
            self.func_Update__Sampling_Strategy_Sample_Range(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_49':
            self.func_Update__Sampling_Strategy_Sample_Range(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_50':
            self.func_Update__Sampling_Strategy_Sample_Range(str_Object_Name, value_Object, bool_Save)
        pass
    
        '''
        ----------------------------
        Sampling Strategy - Locus Number 
        ----------------------------
        '''
        if str_Object_Name == 'horizontalSlider_51':
            self.func_Update__Sampling_Strategy_Locus_Range(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_52':
            self.func_Update__Sampling_Strategy_Locus_Range(str_Object_Name, value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_53':
            self.func_Update__Sampling_Strategy_Locus_Range(str_Object_Name, value_Object, bool_Save)
        pass

        '''
        ----------------------------
        Sampling Strategy - Validation
        ----------------------------
        '''    
          
        if str_Object_Name == 'horizontalSlider_54':
            self.func_Update__Sampling_Strategy_Run_Parameters(str_Object_Name, value_Object, bool_Save)
        pass
    
        return True    
    
      
    '''
    ----------------------------
    QToolBox - Index 1
    ----------------------------
    '''    
    '''
    ----------------------------
    Scenario - Change Project
    ----------------------------
    '''    
    def eventFilter__comboBox_110(self, object, event):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        str_Object_Name = str(object.objectName())
        list_Events_Not_To_Log = [110,12,24,170,129]
        if int_Event_type not in list_Events_Not_To_Log:        
            if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            else:
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + "; Unlisted Event:"  + str(event.type()))
            pass
        pass
    
        if self.bool_ComboBox_Events_Disabled:
            self.func_Debug_Logging(True, 2, str('CANCELLED EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            return True
        pass
     
        if event.type() == QtCore.QEvent.MouseButtonPress :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            object.setEnabled(False)
            if self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:
                self.func_Save_Check__Should_I_Save_And_Continue__Scenario()
            pass
            if self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:
                self.func_Save_Check__Should_I_Save_And_Continue__Sampling_Strategy()
            pass
            object.setEnabled(True)
            return True
        elif event.type() == QtCore.QEvent.MouseButtonDblClick :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonDblClick:"  + str(event.type()))
            object.setEnabled(False)
            if self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:
                self.func_Save_Check__Should_I_Save_And_Continue__Scenario()
            pass
            if self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:
                self.func_Save_Check__Should_I_Save_And_Continue__Sampling_Strategy()
            pass
            object.setEnabled(True)
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            pass 
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.Enter :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.Leave :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.FocusOut :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; FocusOut:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.WindowBlocked :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; WindowBlocked:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.Paint :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Paint:"  + str(event.type()))
            pass
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        pass
        return False
    
    '''
    ----------------------------
    Scenario - Change Scenario
    ----------------------------
    '''    
    def eventFilter__comboBox_210(self, object, event):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        str_Object_Name = str(object.objectName())
        list_Events_Not_To_Log = [110,12,24,170,129]
        if int_Event_type not in list_Events_Not_To_Log:        
            if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            else:
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + "; Unlisted Event:"  + str(event.type()))
            pass
        pass
    
        if self.bool_ComboBox_Events_Disabled:
            self.func_Debug_Logging(True, 2, str('CANCELLED EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            return True
        pass
     
        if event.type() == QtCore.QEvent.MouseButtonPress :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            object.setEnabled(False)
            if self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:
                self.func_Save_Check__Should_I_Save_And_Continue__Scenario()
            pass
            if self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:
                self.func_Save_Check__Should_I_Save_And_Continue__Sampling_Strategy()
            pass
            object.setEnabled(True)
            return True
        elif event.type() == QtCore.QEvent.MouseButtonDblClick :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonDblClick:"  + str(event.type()))
            object.setEnabled(False)
            if self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:
                self.func_Save_Check__Should_I_Save_And_Continue__Scenario()
            pass
            if self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:
                self.func_Save_Check__Should_I_Save_And_Continue__Sampling_Strategy()
            pass
            object.setEnabled(True)
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            pass 
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.Enter :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.Leave :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.FocusOut :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; FocusOut:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.WindowBlocked :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; WindowBlocked:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.Paint :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Paint:"  + str(event.type()))
            pass
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        pass
        return False
    
    def eventFilter__comboBox_310(self, object, event):
 
        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        str_Object_Name = str(object.objectName())
        list_Events_Not_To_Log = [110,12,24,170,129]
        if int_Event_type not in list_Events_Not_To_Log:        
            if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            else:
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + "; Unlisted Event:"  + str(event.type()))
            pass
        pass
     
        if self.bool_ComboBox_Events_Disabled:
            self.func_Debug_Logging(True, 2, str('CANCELLED EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            return True
        pass
    
        if event.type() == QtCore.QEvent.MouseButtonPress :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            object.setEnabled(False)
            if self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:
                self.func_Save_Check__Should_I_Save_And_Continue__Sampling_Strategy()
            pass
            object.setEnabled(True)
            return True
        elif event.type() == QtCore.QEvent.MouseButtonDblClick :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonDblClick:"  + str(event.type()))
            object.setEnabled(False)
            if self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:
                self.func_Save_Check__Should_I_Save_And_Continue__Sampling_Strategy()
            pass
            object.setEnabled(True)
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            pass 
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.Enter :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.Leave :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.FocusOut :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; FocusOut:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.WindowBlocked :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; WindowBlocked:"  + str(event.type()))
            pass
            return True
        elif event.type() == QtCore.QEvent.Paint :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Paint:"  + str(event.type()))
            pass
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        pass
        return False
    
    '''
    ----------------------------
    Scenario - Life history slider widgets
    ----------------------------
    '''
    def eventFilter__spinBox_24(self, object, event):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
            self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str(object.objectName()) + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
        else:
            self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Unlisted Event:"  + str(event.type()))
        pass

        if event.type() == QtCore.QEvent.MouseButtonPress :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the value'''
            int_Object_Value = object.value()
            ''' Check if other parameters that are dependent on MaxAge will have to be changed '''
            ''' Verify if the change can proceed '''
            bool_Continue, _ = self.func_Verify_Change__Scenario_Max_Age(int_Object_Value)
            if bool_Continue:
                ''' Update config but dont Save file...yet'''
                bool_Save = True
                self.func_Update__Scenario_Life_History_Ages(object.objectName(), int_Object_Value, bool_Save)
                ''' Get the slider value to remember'''
                self.int_SpinBox_Orig_Value = int_Object_Value
            else:
                ''' Do nothing - Object will revert to orginal value'''
                object.setValue(self.int_SpinBox_Orig_Value)
            pass
            self.bool_SliderMouseButtonReleased = False
            return True
        
        elif event.type() == QtCore.QEvent.HoverEnter :
            '''Get slider value '''
            self.int_SpinBox_Orig_Value = object.value()
            return True
        
        elif event.type() == QtCore.QEvent.FocusIn :
            self.str_SpinBox_Engaged_Name = object.objectName()
            return True
        
        elif event.type() == QtCore.QEvent.FocusOut :
            self.str_SpinBox_Engaged_Name = ''
            return True
        
        elif event.type() == QtCore.QEvent.KeyRelease :
            ''' Verify if the change can proceed '''
            if self.int_Verify_Change__Scenario_Max_Age__Warning_Count < 1:
                ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                object.blockSignals(True)
                ''' Warn that other parameters that are dependent will have to be changed '''
                bool_Continue, _ = self.func_Verify_Change__Scenario_Max_Age(self.int_SpinBox_Orig_Value)
                object.blockSignals(False)
                if bool_Continue:
                    ''' Allow editing to continue '''
                    #object.setValue(int(event.text()))
                    object.selectAll()
                    pass
                else:
                    '''Revert to orginal value'''
                    object.setValue(self.int_SpinBox_Orig_Value)
                    pass
                pass
            pass     
            return True
        
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass

        return False
    
    def eventFilter__horizontalSlider_31(self, object, event):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
            self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str(object.objectName()) + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
        else:
            self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Unlisted Event:"  + str(event.type()))
        pass
    
        if self.str_SpinBox_Engaged_Name == 'spinBox_24':
            self.bool_SpinBox_Engaged = True
        else:
            self.bool_SpinBox_Engaged = False
        pass
    
        if event.type() == QtCore.QEvent.MouseButtonPress :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Verify if the change can proceed '''
            bool_Continue, _ = self.func_Verify_Change__Scenario_Max_Age(int_Object_Value)
            if bool_Continue:
                ''' Set the slider value '''         
                #object.setValue(int_Object_Value)
                ''' Update config but dont Save file...yet'''
                bool_Save = True
                self.func_Update__Scenario_Life_History_Ages(object.objectName(), int_Object_Value, bool_Save)
                ''' Get the slider value to remember'''
                self.int_Slider_Orig_Value = int_Object_Value
            else:
                ''' Do nothing - Object will revert to orginal value'''
                object.setValue(self.int_Slider_Orig_Value)
                pass
            pass
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            if not self.bool_SpinBox_Engaged:
                '''Get slider value '''
                self.int_Slider_Orig_Value = object.value()
                self.bool_Slider_Engaged = True
                object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            pass
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            if not self.bool_SpinBox_Engaged:
                ''' Get the mouse cursor x pos relative to the widget '''
                x = event.pos().x()
                self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
                ''' Get the value of the slider to the value calculated from the mouse x pos '''
                int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
                self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
                ''' Set the value of the slider to the value calculated from the mouse x pos '''
                ''' Set the slider and spinbox values '''
                object.setValue(int_Object_Value)
                ''' Dont update config but set the ranges for related sliders '''
                bool_Save = False
                self.func_Update__Scenario_Life_History_Ages(object.objectName(), int_Object_Value, bool_Save)
            pass
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            if not self.bool_SpinBox_Engaged:
                ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
                if self.bool_SliderMouseButtonReleased == False:
                    ''' Reset slider to original value '''
                    ''' Get the slider value '''
                    int_Slider_Value = self.int_Slider_Orig_Value
                    ''' Set the slider and spinbox values '''
                    object.setValue(int_Slider_Value)
                else:
                    self.bool_SliderMouseButtonReleased = False
                pass
                self.bool_Slider_Engaged = False
            pass
            return True
        elif event.type() == QtCore.QEvent.Enter :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False
 
    def eventFilter__horizontalSlider_32(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            bool_Save = True
            self.func_Update__Scenario_Life_History_Ages(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Life_History_Ages(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False
 
    def eventFilter__horizontalSlider_33(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            bool_Save = True
            self.func_Update__Scenario_Life_History_Ages(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            #self.int_Slider_Orig_Value__Scenario_Max_Mating_Age = self.horizontalSlider_32.value()
            #self.int_Slider_Orig_Value__Scenario_Min_Mating_Age = self.horizontalSlider_33.value()
            #''' Set the ranges for related sliders '''
            #self.func_Set_Associated_Slider_Range_And_Value__horizontalslider_32(int_Object_Value)            
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            #self.int_Slider_Orig_Value__Scenario_Max_Mating_Age = self.horizontalSlider_32.value()
            #self.int_Slider_Orig_Value__Scenario_Min_Mating_Age = self.horizontalSlider_33.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Life_History_Ages(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
                #self.horizontalSlider_32.setValue(self.int_Slider_Orig_Value__Scenario_Max_Mating_Age) 
                #self.horizontalSlider_33.setValue(self.int_Slider_Orig_Value__Scenario_Min_Mating_Age)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False
    
    '''
    ----------------------------
    Scenario - Life History Offspring distribution widgets
    ----------------------------
    '''        
    def eventFilter__horizontalSlider_27(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            #''' Set the ranges for related sliders '''
            #self.func_Set_Associated_Slider_Range_And_Value__horizontalslider_31(int_Object_Value)            
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False
    
    def eventFilter__horizontalSlider_30(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_28(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_29(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_39(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_40(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_41(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Offspring_Distribution(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    '''
    ----------------------------
    Scenario - Demography widgets
    ----------------------------
    '''
    def eventFilter__spinBox_28(self, object, event):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
            self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str(object.objectName()) + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
        else:
            self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Unlisted Event:"  + str(event.type()))
        pass

        if event.type() == QtCore.QEvent.MouseButtonPress :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the value'''
            int_Object_Value = object.value()
            ''' Check if other parameters that are dependent on MaxAge will have to be changed '''
            ''' Verify if the change can proceed '''
            bool_Continue, _ = self.func_Verify_Change__Scenario_Population_Size(int_Object_Value)
            if bool_Continue:
                ''' Update config but dont Save file...yet'''
                bool_Save = True
                self.func_Update__Scenario_Demography(object.objectName(), int_Object_Value, bool_Save)
                ''' Get the slider value to remember'''
                self.int_SpinBox_Orig_Value = int_Object_Value
            else:
                ''' Do nothing - Object will revert to orginal value'''
                object.setValue(self.int_SpinBox_Orig_Value)
            pass
            self.bool_SliderMouseButtonReleased = False
            return True
        
        elif event.type() == QtCore.QEvent.HoverEnter :
            '''Get slider value '''
            self.int_SpinBox_Orig_Value = object.value()
            return True
        
        elif event.type() == QtCore.QEvent.FocusIn :
            self.str_SpinBox_Engaged_Name = object.objectName()
            return True
        
        elif event.type() == QtCore.QEvent.FocusOut :
            self.str_SpinBox_Engaged_Name = ''
            return True
        
        elif event.type() == QtCore.QEvent.KeyRelease :
            ''' Verify if the change can proceed '''
            if self.int_Verify_Change__Scenario_Demography_Population_Size__Warning_Count < 1:
                ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                object.blockSignals(True)
                ''' Warn that other parameters that are dependent will have to be changed '''
                bool_Continue, _ = self.func_Verify_Change__Scenario_Population_Size(self.int_SpinBox_Orig_Value)
                object.blockSignals(False)
                if bool_Continue:
                    ''' Allow editing to continue '''
                    #object.setValue(int(event.text()))
                    object.selectAll()
                    pass
                else:
                    '''Revert to orginal value'''
                    object.setValue(self.int_SpinBox_Orig_Value)
                    pass
                pass
            pass     
            return True
        
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass

        return False

    def eventFilter__horizontalSlider_34(self, object, event):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
            self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str(object.objectName()) + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
        else:
            self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Unlisted Event:"  + str(event.type()))
        pass
    
        if self.str_SpinBox_Engaged_Name == 'spinBox_28':
            self.bool_SpinBox_Engaged = True
        else:
            self.bool_SpinBox_Engaged = False
        pass
     
        if event.type() == QtCore.QEvent.MouseButtonPress :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Demography(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            if not self.bool_SpinBox_Engaged:
                '''Get slider value '''
                self.int_Slider_Orig_Value = object.value()
                self.bool_Slider_Engaged = True
                object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            pass
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            if not self.bool_SpinBox_Engaged:
                ''' Get the mouse cursor x pos relative to the widget '''
                x = event.pos().x()
                self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
                ''' Get the value of the slider to the value calculated from the mouse x pos '''
                int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
                self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
                ''' Set the value of the slider to the value calculated from the mouse x pos '''
                ''' Set the slider and spinbox values '''
                object.setValue(int_Object_Value)
                ''' Dont update config but set the ranges for related sliders '''
                bool_Save = False
                self.func_Update__Scenario_Demography(object.objectName(), int_Object_Value, bool_Save)
            pass
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            if not self.bool_SpinBox_Engaged:
                ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
                if self.bool_SliderMouseButtonReleased == False:
                    ''' Reset slider to original value '''
                    ''' Get the slider value '''
                    int_Slider_Value = self.int_Slider_Orig_Value
                    ''' Set the slider and spinbox values '''
                    object.setValue(int_Slider_Value)
                else:
                    self.bool_SliderMouseButtonReleased = False
                pass
                self.bool_Slider_Engaged = False
                #self.func_Validate_Sampling_Strategy__Display_Combinations()
            pass
            return True
        elif event.type() == QtCore.QEvent.Enter :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    '''
    ----------------------------
    Scenario - Genetics widgets
    ----------------------------
    '''  
    def eventFilter__comboBox_6(self, object, event, list_Object_Groups):
 
        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Event_type = event.type()
        str_Object_Name = str(object.objectName())
        list_Events_Not_To_Log = [110,12,24,170,129]
        if int_Event_type not in list_Events_Not_To_Log:        
            if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            else:
                self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + "; Unlisted Event:"  + str(event.type()))
            pass
        pass

        if self.bool_ComboBox_Events_Disabled:
            self.func_Debug_Logging(True, 2, str('CANCELLED EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
            return True
        pass
        
        if event.type() == QtCore.QEvent.MouseButtonPress:

            self.int_Allele_Freq_Dist__Prev_Index = object.currentIndex()
            return True
        
        elif event.type() == QtCore.QEvent.FocusOut :
            
            self.int_Allele_Freq_Dist__New_Index = object.currentIndex()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()) + ';Prev_Index:' + str(self.int_Allele_Freq_Dist__Prev_Index) + ';New_Index:' + str(self.int_Allele_Freq_Dist__New_Index))
 
            if self.int_Allele_Freq_Dist__New_Index != self.int_Allele_Freq_Dist__Prev_Index:
                self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()) + '; SAVE')
                 
                ''' Save the selection '''
                self.str_Genome_Allele_Frequency_Distribution = object.currentText()
                if self.str_Genome_Allele_Frequency_Distribution != object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES or\
                   self.str_Genome_Allele_Frequency_Distribution != object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP:
                    self.func_Update_Config__Genome_Allele_Frequency_Distribution()
                pass
            pass 
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
        pass
        return False

    def eventFilter__horizontalSlider_38(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Genome(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Genome(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_35(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Genome(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Genome(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_37(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Genome(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Genome(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_42(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Genome(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Genome(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    '''
    ----------------------------
    QToolBox - Index 2
    ----------------------------
    '''    
    '''
    ----------------------------
    Scenario - Simulation widgets
    ----------------------------
    ''' 
    def eventFilter__horizontalSlider_45(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Simulation_Length(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Simulation_Length(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_46_RETIRE(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Simulation_Length(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            ''' Substitute a multimple of the Max Age - num - (num%divisor) ie. rounded down to the nearest multiple of MaxAge'''
            int_Object_Value__New = int_Object_Value - (int_Object_Value%self.int_Species_Life_History_Max_Age)
            object.setValue(int_Object_Value__New)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Simulation_Length(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_47_RETIRE(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            self.bool_Slider_Engaged = False
            bool_Save = True
            self.func_Update__Scenario_Simulation_Length(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            ''' Substitute a multimple of the Max Age - num - (num%divisor) '''
            int_Object_Value__New = int_Object_Value - (int_Object_Value%self.int_Species_Life_History_Max_Age)
            object.setValue(int_Object_Value__New)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Scenario_Simulation_Length(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False


    '''
    ----------------------------
    QToolBox - Index 4
    ----------------------------
    '''
    def eventFilter__groupBox_29(self, object, event):
 
        if event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            
            str_Option = str(object.objectName())
            self.func_Context_Specific_Help__Get_File(str_Option)
            
            return True
#         elif event.type() == QtCore.QEvent.Leave :
#             self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
#             if self.dialog_Context_Help is not None:
#                 for qTextBrowser_Help_Text in self.dialog_Context_Help.findChildren(QtGui.QTextBrowser):
#                     qURL = QtCore.QUrl.fromLocalFile(QtCore.QString('C:\\DCB\\MUI\\MUI_Sync_Controlled\\MUI_SC_SharkSim\\SharkSim_App\\v3_04\\doc\\Leave.html'))
#                     qTextBrowser_Help_Text.setSource(qURL) 
#                 pass
#             pass
#             return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        pass
        return False
        
    def eventFilter__groupBox_Context_Help(self, object, event):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
#         int_Event_type = event.type()
#         str_Object_Name = str(object.objectName())
#         list_Events_Not_To_Log = [110,12,129]
#         if int_Event_type not in list_Events_Not_To_Log:        
#             if int_Event_type in globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type.keys():
#                 self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + '; ' + globalsDCBGen.PyQT4_QEvent_Type.static_dict_PyQT4_QEvent_Type[int_Event_type] + ': ' + str(event.type()))
#             else:
#                 self.func_Debug_Logging(True, 2, str('EVENT @ ' + object.staticMetaObject.className()) + '; ' + str_Object_Name + "; Unlisted Event:"  + str(event.type()))
#             pass
#         pass
    
        if event.type() == QtCore.QEvent.Enter :
            if self.bool_Context_Help__Follow_Context:
                str_Option = str(object.objectName())
                self.func_Context_Specific_Help__Get_File(str_Option)
            pass
        
            return True
        else:
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?

        pass
        return False    

    def func_Context_Specific_Help__Get_File(self, str_Option):  
        
        '''
        ------------------------------
        Check if the Context Help dialog is open - if not quietly abort function, otherwise get the QWebView object
        ------------------------------
        '''
        if self.dialog_Context_Help is not None:
            for qWebView_Help_Text_Browser in self.dialog_Context_Help.findChildren(QWebView):
                break
            pass
        else:
            return False
        pass  
        
        '''
        -------------------------------
        Get the Context Help file name from the SETTINGS Config file
        -------------------------------
        '''              
        obj_Config = self.obj_Config_Settings
        ''' <<<<<<< SECTION: Context_Help '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Settings_Context_Help_Files
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(obj_Config.config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass   
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            ''' Its OK if the OPTION doesnt exist '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                str_Help_Context_File = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        
        '''
        -----------------------------------
        If the Context Help file exists for the specified object name
        - Determine if it a URL or URL#Fragment
        -----------------------------------
        '''
        if bool_Exists:
            str_Help_Context_Fragment = ''
            bool_Fragment = False
            if '#' in str_Help_Context_File:
                bool_Fragment = True
                str_Help_Context_File, str_Help_Context_Fragment = str_Help_Context_File.split('#')
            pass
        
            str_Context_Help_Path_And_File = os__path.join(self.str_Application_Docs_Path, str_Help_Context_File)
            qURL = QtCore.QUrl.fromLocalFile(QtCore.QString(str_Context_Help_Path_And_File))
            if bool_Fragment:
                qURL.setFragment(QtCore.QString(str_Help_Context_Fragment))
            pass 
    
            ''' Load the URL '''
            qWebView_Help_Text_Browser.load(qURL) 
            #qWebView_Help_Text_Browser.setZoomFactor(1)
        pass
    
        return True
     
    '''
    ----------------------------
    Sampling Strategy - Sample Size widgets
    ----------------------------
    '''
    def eventFilter__horizontalSlider_48(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
#             ''' Get the slider value'''
#             int_Object_Value = object.value()
#             ''' Set the slider value '''         
#             object.setValue(int_Object_Value)
#             ''' Update config but dont Save file...yet'''
#             bool_Save = True
#             #self.func_Update__Sampling_Strategy_Sample_Range(object.objectName(), int_Object_Value, bool_Save)
#             ''' Get the slider value to remember'''
#             self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            #self.func_Update__Sampling_Strategy_Sample_Range(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            #self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_49(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            bool_Save = True
            self.func_Update__Sampling_Strategy_Sample_Range(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            self.int_Slider_Orig_Value__Sample_Range_Min = self.horizontalSlider_48.value()
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.int_Slider_Orig_Value__Sample_Range_Min = self.horizontalSlider_48.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Sampling_Strategy_Sample_Range(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
                self.horizontalSlider_48.setValue(self.int_Slider_Orig_Value__Sample_Range_Min)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_50(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            bool_Save = True
            self.func_Update__Sampling_Strategy_Sample_Range(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            self.int_Slider_Orig_Value__Sample_Range_Min = self.horizontalSlider_48.value()
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.int_Slider_Orig_Value__Sample_Range_Min = self.horizontalSlider_48.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Sampling_Strategy_Sample_Range(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
                self.horizontalSlider_48.setValue(self.int_Slider_Orig_Value__Sample_Range_Min)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    '''
    ----------------------------
    Sampling Strategy - Locus Number widgets
    ----------------------------
    '''
    def eventFilter__horizontalSlider_51(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
#             ''' Get the slider value'''
#             int_Object_Value = object.value()
#             ''' Set the slider value '''         
#             object.setValue(int_Object_Value)
#             ''' Update config but dont Save file...yet'''
#             bool_Save = True
#             #self.func_Update__Sampling_Strategy_Locus_Range(object.objectName(), int_Object_Value, bool_Save)
#             ''' Get the slider value to remember'''
#             self.int_Slider_Orig_Value = int_Object_Value
#             #self.int_Slider_Orig_Value__Locus_Range_Min = self.horizontalSlider_51.value()
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            #self.func_Update__Sampling_Strategy_Locus_Range(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_52(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            bool_Save = True
            self.func_Update__Sampling_Strategy_Locus_Range(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            self.int_Slider_Orig_Value__Locus_Range_Min = self.horizontalSlider_51.value()
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.int_Slider_Orig_Value__Locus_Range_Min = self.horizontalSlider_51.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Sampling_Strategy_Locus_Range(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
                self.horizontalSlider_51.setValue(self.int_Slider_Orig_Value__Locus_Range_Min)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            #self.bool_Slider_Engaged = True
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            #self.bool_Slider_Engaged = False
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    def eventFilter__horizontalSlider_53(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            bool_Save = True
            self.func_Update__Sampling_Strategy_Locus_Range(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            self.int_Slider_Orig_Value__Locus_Range_Min = self.horizontalSlider_51.value()
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.int_Slider_Orig_Value__Locus_Range_Min = self.horizontalSlider_51.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Sampling_Strategy_Locus_Range(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
                self.horizontalSlider_51.setValue(self.int_Slider_Orig_Value__Locus_Range_Min)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            self.func_Validate_Sampling_Strategy__Display_Combinations()
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            #self.bool_Slider_Engaged = True
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            #self.bool_Slider_Engaged = False
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False


    '''
    ----------------------------
    QToolBox - Index 5
    ----------------------------
    '''    
    '''
    ----------------------------
    Sampling Strategy - Run Parameters
    ----------------------------
    '''
    def eventFilter__horizontalSlider_54(self, object, event):
 
        if event.type() == QtCore.QEvent.MouseButtonPress :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonPress:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseButtonRelease :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseButtonRelease:"  + str(event.type()))
            '''set the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = True
            ''' Get the slider value'''
            int_Object_Value = object.value()
            ''' Set the slider value '''         
            object.setValue(int_Object_Value)
            ''' Update config but dont Save file...yet'''
            bool_Save = True
            self.func_Update__Sampling_Strategy_Run_Parameters(object.objectName(), int_Object_Value, bool_Save)
            ''' Get the slider value to remember'''
            self.int_Slider_Orig_Value = int_Object_Value
            '''reset the mouse button pressed flag'''
            self.bool_SliderMouseButtonReleased = False
            return True
        elif event.type() == QtCore.QEvent.MouseMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseMove:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.MouseTrackingChange :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; MouseTrackingChange:"  + str(event.type()))
            return True
        elif event.type() == QtCore.QEvent.HoverEnter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverEnter:"  + str(event.type()))
            '''Get slider value '''
            self.int_Slider_Orig_Value = object.value()
            self.bool_Slider_Engaged = True
            object.setFocus() #Set the focus so that the spinBox cannot be edited whilst slider is engaged
            return True
        elif event.type() == QtCore.QEvent.HoverMove :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove:"  + str(event.type()))
            ''' Get the mouse cursor x pos relative to the widget '''
            x = event.pos().x()
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove X pos:"  + str(x))
            ''' Get the value of the slider to the value calculated from the mouse x pos '''
            int_Object_Value = QtGui.QStyle.sliderValueFromPosition (object.minimum(), object.maximum(), x, object.width())
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverMove sliderValueFromPosition:"  + str(int_Object_Value))
            ''' Set the value of the slider to the value calculated from the mouse x pos '''
            ''' Set the slider and spinbox values '''
            object.setValue(int_Object_Value)
            ''' Dont update config but set the ranges for related sliders '''
            bool_Save = False
            self.func_Update__Sampling_Strategy_Run_Parameters(object.objectName(), int_Object_Value, bool_Save)
            return True
        elif event.type() == QtCore.QEvent.HoverLeave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; HoverLeave:"  + str(event.type()))
            ''' Leaving the slider - if the mouse button hasnt been pressed reset the slider to its orig value'''
            if self.bool_SliderMouseButtonReleased == False:
                ''' Reset slider to original value '''
                ''' Get the slider value '''
                int_Slider_Value = self.int_Slider_Orig_Value
                ''' Set the slider and spinbox values '''
                object.setValue(int_Slider_Value)
            else:
                self.bool_SliderMouseButtonReleased = False
            pass
            self.bool_Slider_Engaged = False
            return True
        elif event.type() == QtCore.QEvent.Enter :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Enter:"  + str(event.type()))
            #self.bool_Slider_Engaged = True
            return True
        elif event.type() == QtCore.QEvent.Leave :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Leave:"  + str(event.type()))
            #self.bool_Slider_Engaged = False
            return True
        elif event.type() == QtCore.QEvent.ToolTip :
            self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; ToolTip:"  + str(event.type()))
            return True
        else:
            #self.func_Debug_Logging(True, 2, str(object.staticMetaObject.className()) + '; ' + str(object.objectName()) + "; Untrapped Event:"  + str(event.type()))
            pass
            #return True #NOTE: uncommenting this return True or removing any above makes the control disappear!?
        pass
        return False

    '''
    -------------------------------------------------------------------------------
        Signal specific functions
    -------------------------------------------------------------------------------
    '''

    '''
    ----------------------------
    Base Form Widgets
    ----------------------------
    '''    
    def func_QToolBox__MainToolBar__Menu_Item_Settings_Preferences_Clicked(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        list_QAbstract_Buttons = self.toolBox.findChildren(QtGui.QAbstractButton)
        #DEBUG_ON
        #list_QAbstract_Buttons[0].objectName()
        #list_QAbstract_Buttons[0].text()
        #DEBUG_OFF
            
        if not self.bool_Admin_Page_Currently_Hidden:
            
            qToolBox_Button = list_QAbstract_Buttons[0]
            qToolBox_Button.setVisible(False)
            
            self.toolBox.setItemEnabled(0, False)

            self.bool_Admin_Page_Currently_Hidden = True          
        else:
            qToolBox_Button = list_QAbstract_Buttons[0]
            qToolBox_Button.setVisible(True)
            
            self.toolBox.setItemEnabled(0, True)            
            
            self.bool_Admin_Page_Currently_Hidden = False
        pass
    
        return True
        
    def func_QToolBox__MainToolBar__Menu_Item_Help_Show_Context_specific_Help_Clicked(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        if self.dialog_Context_Help is not None:
            self.dialog_Context_Help.close()
        pass
    
        self.dialog_Context_Help = Ui_Dialog_Context_Help(self)
        self.dialog_Context_Help.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        ''' Show as modeless...  .exec_() only shows as modal '''
        self.dialog_Context_Help.show()
        
        ''' Position the windows relative to the screen resolution and each other '''
        self.func_Window_Position()
        
        str_Option = self.obj_Config_Settings.static_str_Option__Settings_Context_Help_File_Start_Splash_Screen
        self.func_Context_Specific_Help__Get_File(str_Option)        
        pass
        
        return True
        
    def func_QToolBox__MainToolBox__CurrentChanged(self, int_Current_Tab_Index):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '; int_Current_Tab_Index: ' + str(int_Current_Tab_Index))
        #DEBUG_OFF        

        '''
        --------------------------------------
        Enable / Disable MainToolBox Pages
        --------------------------------------
        '''
        if self.bool_Init_Finished:
            self.func_Enable_Widgets__QToolBox__MainToolBox(int_Current_Tab_Index, False)
        pass
        
        '''
        --------------------------------------
        Check if Save is required
        --------------------------------------
        '''        
        ''' Check if Save Scenario can proceed '''
        list_Ignore_Save_Pages = [
                                   #globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
                                   globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Scenario
                                   ,globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario
                                   ]
        if int_Current_Tab_Index not in list_Ignore_Save_Pages:
            bool_Allow_Save = self.func_Save_Check__Should_I_Save_And_Continue__Scenario()
            if bool_Allow_Save:
                bool_Allow_Save = self.func_Save_Check__Should_I_Save_And_Continue__Scenario()
            pass
        pass
    
        ''' Check if Save Sampling can proceed '''
        list_Ignore_Save_Pages = [
                                   #globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
                                   globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Sampling_Strategy
                                   ,globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy
                                   ]
        if int_Current_Tab_Index not in list_Ignore_Save_Pages:
            bool_Allow_Save = self.func_Save_Check__Should_I_Save_And_Continue__Sampling_Strategy()
            if bool_Allow_Save:
                bool_Allow_Save = self.func_Save_Check__Should_I_Save_And_Continue__Sampling_Strategy()
            pass
        pass
    
        '''
        --------------------------------------
        Page - Run Scenario
        --------------------------------------
        '''
        if self.bool_Init_Finished:
            if int_Current_Tab_Index == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario:
                '''
                ----------------------------------------------
                Re-establish the status of a previous job that is reporting a INCOMPLETE but NOT FAILED
                ----------------------------------------------
                '''
                if self.bool_Batch_Scenario__Batch_Settings_Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED:
                    ''' 
                    Batch Setting Job Status logging is reporting thet a prior job was not logged as COMPLETE but also did not report an ERROR
                    This may happen if the FrontEnd App terminate before a BackEnd job has finished...
                    So, start the job monitor with the prior job PIDS and check its status
                    '''
                    
                    self.int_Job_Run_Current_Processing_Step = globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM
                    
                    self.int_Process_JOB_SHELL__PID = self.int_Batch_Setting_Last_Batch_Scenario_Run_Shell_PID
                    
                    self.str_BackEnd_Run_UID__STARTED = self.str_Batch_Setting_Last_Batch_Scenario_Run_UID
                    
                    ''' Check if specifying the BackEnd working path is required '''
                    self.str_BackEnd_Working_Path = self.str_Scenario_Run_Simulation_Output_Base_Path
                    if self.str_BackEnd_Working_Path == '' or not self.bool_str_Scenario_Run_Simulation_Output_Base_Path__FOUND:
                        self.func_QToolButton__Get_Scenario_Simulation_Output_Path__Clicked()
                        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True  
                    pass            
                    
                    ''' Check if a save is required first '''
                    bool_Allow_Save = False
                    bool_Allow_Save = self.func_Save_Check__Is_Save_ALLOWED__Scenario() 
                

                    ''' Monitor job repeatedly until job completion'''
                    bool_Success = False
                    self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                    self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                    
                    self.bool_Job_Status__Terminated = False
                    self.bool_Job_Status__Complete = False
                    bool_Success = self.func_Run_Job__Monitor_Job(self.int_Process_JOB_SHELL__PID) 
                    if bool_Success:
                        self.bool_Batch_Scenario__Batch_Settings_Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED = False
                    pass                    
                pass
            pass
        pass
        '''
        --------------------------------------
        Page - Run Sampling Strategy
        --------------------------------------
        '''
        if self.bool_Init_Finished:
            if int_Current_Tab_Index == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy:
                '''
                ----------------------------------------------
                Re-establish the status of a previos job that is reporting a INCOMPLETE but NOT FAILED
                ----------------------------------------------
                '''
                if self.bool_Sampling_Strategy__Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED:
                    ''' 
                    Batch Setting Job Status logging is reporting thet a prior job was not logged as COMPLETE but also did not report an ERROR
                    This may happen if the FrontEnd App terminate before a BackEnd job has finished...
                    So, start the job monitor with the prior job PIDS and check its status
                    '''
                    
                    self.int_Job_Run_Current_Processing_Step = globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT
                    
                    self.int_Process_JOB_SHELL__PID = self.int_Batch_Setting_Last_Sampling_Strategy_Run_Shell_PID
                    
                    self.str_BackEnd_Run_UID__STARTED = self.str_Batch_Setting_Last_Sampling_Strategy_Run_UID
                    
                    ''' Check if specifying the BackEnd working path is required '''
                    self.str_BackEnd_Working_Path = self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path
                    if self.str_BackEnd_Working_Path == '' or not self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__FOUND:
                        self.func_QToolButton__Get_Sampling_Strategy_Simulation_Output_Path__Clicked()
                        self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True  
                    pass            
                    
                    ''' Check if a save is required first '''
                    bool_Allow_Save = False
                    bool_Allow_Save = self.func_Save_Check__Is_Save_ALLOWED__Sampling_Strategy()


                    ''' Monitor job repeatedly until job completion'''
                    bool_Success = False
                    self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                    self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL

                    self.bool_Job_Status__Terminated = False
                    self.bool_Job_Status__Complete = False
                    bool_Success = self.func_Run_Job__Monitor_Job(self.int_Process_JOB_SHELL__PID) 
                    if bool_Success:
                        self.bool_Sampling_Strategy__Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED = False
                    pass                    
                pass
            pass
        pass

        '''
        --------------------------------------
        Page - Scenario Results
        --------------------------------------
        '''
        if self.bool_Init_Finished:
            if int_Current_Tab_Index == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Scenario:
                bool_Success = False    
                
                bool_Success = self.func_Display_Results__Batch_Scenario__View_Results__Refresh_Text_Browser()
                
            pass        
        pass

        '''
        --------------------------------------
        Page - Sampling Strategy Results
        --------------------------------------
        '''    
        if self.bool_Init_Finished:
            if int_Current_Tab_Index == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Sampling_Strategy:
                bool_Success = False
                
                bool_Success = self.func_Display_Results__Sampling_Strategy__View_Results__Refresh_Text_Browser()
                
            pass        
        pass

        return True

    def func_Enable_Widgets__QToolBox__MainToolBox(self, int_Page__Current, bool_Allow_Page_Change):
 
        self.func_Enable_Widgets__QToolBox__MainToolBox__All_Pages(int_Page__Current, bool_Allow_Page_Change)
        
        return True
    
    def func_Enable_Widgets__QToolBox__MainToolBox__All_Pages(self, int_Page__Current, bool_Allow_Page_Change):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
         
        bool_Block_Signals = True
        int_Page_To_Switch_To = -1
        list_Pages_Enabled = []
        
        self.func_Debug_Logging(False, 2, '')
        self.toolBox.blockSignals(bool_Block_Signals) 
        pass

        bool_Enabled = False
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
        self.func_Debug_Logging(False, 2, '')
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Scenario
        self.func_Debug_Logging(False, 2, '')
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario
        self.func_Debug_Logging(False, 2, '')
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Scenario
        self.func_Debug_Logging(False, 2, '')
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
        self.func_Debug_Logging(False, 2, '')
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Sampling_Strategy
        self.func_Debug_Logging(False, 2, '')
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy
        self.func_Debug_Logging(False, 2, '')
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Sampling_Strategy
        self.func_Debug_Logging(False, 2, '')
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        
        if len(self.list_Project_Files) == 0:
            int_Page__To_Change = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
            if int_Page__Current == int_Page__To_Change:
                self.func_Debug_Logging(False, 2, '')
                self.radioButton.setEnabled(False)
                self.radioButton_2.setEnabled(True)
                self.radioButton_2.setChecked(True)
                
                self.radioButton_5.setEnabled(False)
                self.radioButton_4.setEnabled(False)
                self.radioButton_3.setEnabled(False)            
                self.checkBox_3.setChecked(False)
                self.checkBox_3.setEnabled(False) 
                self.checkBox_2.setChecked(False)
                self.checkBox_2.setEnabled(False)
                
                self.pushButton.setEnabled(False)
                self.func_Debug_Logging(False, 2, '')
            pass 
        else:
            if len(self.list_Scenario_Files) == 0:
                int_Page__To_Change = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
                if int_Page__Current == int_Page__To_Change:
                    self.func_Debug_Logging(False, 2, '')
                    self.radioButton.setEnabled(True)
                    self.radioButton_2.setEnabled(True)                    
                    self.radioButton.setChecked(True)
                    
                    self.radioButton_5.setEnabled(False)
                    self.radioButton_4.setEnabled(True)
                    self.radioButton_3.setEnabled(False)
                    self.radioButton_4.setChecked(True)
               
                    self.checkBox_3.setEnabled(True)
                    self.checkBox_3.setChecked(False)                
                    self.checkBox_2.setEnabled(True)
                    self.checkBox_2.setChecked(False)  
                    
                    self.pushButton.setEnabled(False)
                    self.func_Debug_Logging(False, 2, '')
                pass
                if int_Page__Current not in list_Pages_Enabled:
                    int_Page_To_Switch_To = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario if int_Page_To_Switch_To != int_Page__Current else -1
                pass
            else:
                int_Page__To_Change = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
                if int_Page__Current == int_Page__To_Change:
                    self.func_Debug_Logging(False, 2, '')
                    self.radioButton.setEnabled(True)
                    self.radioButton_2.setEnabled(True)                    
                    self.radioButton.setChecked(True)
                                        
                    self.radioButton_5.setEnabled(True)
                    self.radioButton_4.setEnabled(True)
                    self.radioButton_3.setEnabled(True)
                    self.radioButton_5.setChecked(True) 
    
                    self.checkBox_2.setChecked(False)
                    self.checkBox_2.setEnabled(True)                
                    self.checkBox_3.setChecked(False)
                    self.checkBox_3.setEnabled(True)  
                    
                    self.pushButton.setEnabled(False)    
                    self.func_Debug_Logging(False, 2, '')           
                pass 
                            
                bool_Enabled = True
                int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
                list_Pages_Enabled.append(int_Page__To_Enable)
                self.func_Debug_Logging(False, 2, '')
                self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Scenario
                list_Pages_Enabled.append(int_Page__To_Enable)
                self.func_Debug_Logging(False, 2, '')
                self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario
                list_Pages_Enabled.append(int_Page__To_Enable)
                self.func_Debug_Logging(False, 2, '')
                self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                
                if self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED:
                    bool_Enabled = True
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Scenario
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.func_Debug_Logging(False, 2, '')
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                pass
    
      
            pass
            
    
            if len(self.list_Sampling_Strategy_Files) == 0:
                if self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED:
                    bool_Enabled = True
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.func_Debug_Logging(False, 2, '')
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                else:
                    if int_Page__Current not in list_Pages_Enabled:
                        int_Page_To_Switch_To = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario if int_Page_To_Switch_To != int_Page__Current else -1
                    pass
                pass
    
                int_Page__To_Change = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
                if int_Page__Current == int_Page__To_Change:
                    self.func_Debug_Logging(False, 2, '')            
                    self.radioButton_8.setEnabled(False)
                    self.radioButton_9.setEnabled(True)
                    self.radioButton_10.setEnabled(False)
                     
                    self.radioButton_9.setChecked(True)
                    
                    #self.pushButton_5.setEnabled(False) 
                    self.func_Debug_Logging(False, 2, '') 
                pass
            else:
                
                if self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED:
                    bool_Enabled = True
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.func_Debug_Logging(False, 2, '')
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Sampling_Strategy
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.func_Debug_Logging(False, 2, '')
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.func_Debug_Logging(False, 2, '')
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                pass
            
                if self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED:
                    bool_Enabled = True
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Sampling_Strategy
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.func_Debug_Logging(False, 2, '')
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                pass
    
                int_Page__To_Change = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
                if int_Page__Current == int_Page__To_Change:
                    self.func_Debug_Logging(False, 2, '')        
                    self.radioButton_8.setEnabled(True)
                    self.radioButton_9.setEnabled(True)
                    self.radioButton_10.setEnabled(True)
                     
                    self.radioButton_8.setChecked(True)
                    
                    #self.pushButton_5.setEnabled(False) 
                    self.func_Debug_Logging(False, 2, '') 
                pass
            pass
        pass

        bool_Block_Signals = False
        self.func_Debug_Logging(False, 2, '')
        self.toolBox.blockSignals(bool_Block_Signals) 
        pass
    
        if bool_Allow_Page_Change and int_Page_To_Switch_To != -1:
            self.func_Debug_Logging(False, 2, '')
            self.toolBox.setCurrentIndex(int_Page_To_Switch_To)
        pass
                    
        return True
    
    def func_Enable_Widgets__QToolBox__MainToolBox__All_Pages_NON_DEBUG(self, int_Page__Current, bool_Allow_Page_Change):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
         
        bool_Block_Signals = True
        int_Page_To_Switch_To = -1
        list_Pages_Enabled = []
        
        self.toolBox.blockSignals(bool_Block_Signals) 
        pass

        bool_Enabled = False
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        
        if len(self.list_Project_Files) == 0:
            int_Page__To_Change = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
            if int_Page__Current == int_Page__To_Change:
                self.radioButton.setEnabled(False)
                self.radioButton_2.setEnabled(True)
                self.radioButton_2.setChecked(True)
                
                self.radioButton_5.setEnabled(False)
                self.radioButton_4.setEnabled(False)
                self.radioButton_3.setEnabled(False)            
                self.checkBox_3.setChecked(False)
                self.checkBox_3.setEnabled(False) 
                self.checkBox_2.setChecked(False)
                self.checkBox_2.setEnabled(False)
                
                self.pushButton.setEnabled(False)
            pass 
        else:
            if len(self.list_Scenario_Files) == 0:
                int_Page__To_Change = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
                if int_Page__Current == int_Page__To_Change:
                    self.radioButton.setEnabled(True)
                    self.radioButton_2.setEnabled(True)                    
                    self.radioButton.setChecked(True)
                    
                    self.radioButton_5.setEnabled(False)
                    self.radioButton_4.setEnabled(True)
                    self.radioButton_3.setEnabled(False)
                    self.radioButton_4.setChecked(True)
               
                    self.checkBox_3.setEnabled(True)
                    self.checkBox_3.setChecked(False)                
                    self.checkBox_2.setEnabled(True)
                    self.checkBox_2.setChecked(False)  
                    
                    self.pushButton.setEnabled(False)
                pass
                if int_Page__Current not in list_Pages_Enabled:
                    int_Page_To_Switch_To = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario if int_Page_To_Switch_To != int_Page__Current else -1
                pass
            else:
                int_Page__To_Change = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
                if int_Page__Current == int_Page__To_Change:
                    self.radioButton.setEnabled(True)
                    self.radioButton_2.setEnabled(True)                    
                    self.radioButton.setChecked(True)
                                        
                    self.radioButton_5.setEnabled(True)
                    self.radioButton_4.setEnabled(True)
                    self.radioButton_3.setEnabled(True)
                    self.radioButton_5.setChecked(True) 
    
                    self.checkBox_2.setChecked(False)
                    self.checkBox_2.setEnabled(True)                
                    self.checkBox_3.setChecked(False)
                    self.checkBox_3.setEnabled(True)  
                    
                    self.pushButton.setEnabled(False)               
                pass 
                            
                bool_Enabled = True
                int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
                list_Pages_Enabled.append(int_Page__To_Enable)
                self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Scenario
                list_Pages_Enabled.append(int_Page__To_Enable)
                self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario
                list_Pages_Enabled.append(int_Page__To_Enable)
                self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                
                if self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED:
                    bool_Enabled = True
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Scenario
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                pass
    
      
            pass
            
    
            if len(self.list_Sampling_Strategy_Files) == 0:
                if self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED:
                    bool_Enabled = True
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                else:
                    if int_Page__Current not in list_Pages_Enabled:
                        int_Page_To_Switch_To = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario if int_Page_To_Switch_To != int_Page__Current else -1
                    pass
                pass
    
                int_Page__To_Change = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
                if int_Page__Current == int_Page__To_Change:            
                    self.radioButton_8.setEnabled(False)
                    self.radioButton_9.setEnabled(True)
                    self.radioButton_10.setEnabled(False)
                     
                    self.radioButton_9.setChecked(True)
                    
                    #self.pushButton_5.setEnabled(False)  
                pass
            else:
                
                if self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED:
                    bool_Enabled = True
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Sampling_Strategy
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                pass
            
                if self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED:
                    bool_Enabled = True
                    int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Sampling_Strategy
                    list_Pages_Enabled.append(int_Page__To_Enable)
                    self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
                pass
    
                int_Page__To_Change = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
                if int_Page__Current == int_Page__To_Change:        
                    self.radioButton_8.setEnabled(True)
                    self.radioButton_9.setEnabled(True)
                    self.radioButton_10.setEnabled(True)
                     
                    self.radioButton_8.setChecked(True)
                    
                    #self.pushButton_5.setEnabled(False)  
                pass
            pass
        pass

        bool_Block_Signals = False
        self.toolBox.blockSignals(bool_Block_Signals) 
        pass
    
        if bool_Allow_Page_Change and int_Page_To_Switch_To != -1:
            self.toolBox.setCurrentIndex(int_Page_To_Switch_To)
        pass
                    
        return True
    
    def func_QLineEdit__MainWindow_ScenarioName__Text_Changed(self):

        return True

    def func_QLineEdit__Project_Name__Text_Changed(self):
        
        if self.lineEdit_4.text():
            self.label_6.setText(self.str_Project_Name__Label_Text)
        else:
            self.label_6.setText(self.str_Project_Name__Label_Text + '*')
        pass
        
        if (self.lineEdit_4.text() and self.lineEdit_13.text()) and (self.lineEdit_5.text() or self.lineEdit_8.text()):
            self.pushButton.setEnabled(True)
        else:
            self.pushButton.setEnabled(False)
        pass
    
        return True
    
    def func_QLineEdit__Project_Species_Name__Text_Changed(self):

        if self.lineEdit_13.text():
            self.label_30.setText(self.str_Project_Species_Name__Label_Text)
        else:
            self.label_30.setText(self.str_Project_Species_Name__Label_Text + '*')
        pass        
    
        if (self.lineEdit_4.text() and self.lineEdit_13.text()) and (self.lineEdit_5.text() or self.lineEdit_8.text()):
            self.pushButton.setEnabled(True)
        else:
            self.pushButton.setEnabled(False)
        pass
    
        return True
    
    def func_QLineEdit__Scenario_Name__Text_Changed(self):
        
        if self.lineEdit_5.text():
            self.label_7.setText(self.str_Scenario_Name__Current__Label_Text)
        else:
            self.label_7.setText(self.str_Scenario_Name__Current__Label_Text + '*')
        pass    
            
        if self.lineEdit_8.text():
            self.label_9.setText(self.str_Scenario_Cloned_Name__Label_Text)
        else:
            self.label_9.setText(self.str_Scenario_Cloned_Name__Label_Text + '*')
        pass    
            
        if self.lineEdit_8.text() and self.radioButton.isChecked() and self.radioButton_3.isChecked():
            self.pushButton.setEnabled(True)
        elif (self.lineEdit_4.text() and self.lineEdit_13.text()) and (self.lineEdit_5.text() or self.lineEdit_8.text()):
            self.pushButton.setEnabled(True)
        elif self.radioButton.isChecked() and self.radioButton_4.isChecked() and self.lineEdit_5.text() :
            self.pushButton.setEnabled(True)
        else:
            self.pushButton.setEnabled(False)            
        pass
    
        return True

    '''
    ----------------------------
    QToolBox - Index 0
    ----------------------------
    '''    
    '''
    ----------------------------
    Project & Scenario Widgets
    ----------------------------
    '''   
    def func_QRadioButton_NEW_PROJECT_FILE_Toggled(self):
        
        if self.radioButton_2.isChecked():
            self.label_6.setText(self.str_Project_Name__Label_Text + '*')
            self.label_30.setText(self.str_Project_Species_Name__Label_Text + '*')
    
            ''' Generate a default name for the new Project based on the current settings '''
            int_Project_Count = self.comboBox_100.count() + 1
            str_Project_Name_Default = globalsSSFE.Name.static_str__Name__Project + str(int_Project_Count)
            self.lineEdit_4.setText(str_Project_Name_Default)
            self.lineEdit_13.setText('Species')
            
            ''' Generate a default name for the Scenario based on the current settings '''
            self.func_QLineEdit__Project_Name__Text_Changed()
            self.func_QLineEdit__Project_Species_Name__Text_Changed() 
             
            ''' Display the New Project widgets '''
            self.stackedWidget_2.setCurrentIndex(1)
            
            ''' Disable the Existing Scenario option '''
            self.radioButton_5.setEnabled(False)
            
            ''' Ensure the New Scenario widigets are displayed and initialised '''
            if self.radioButton_4.isChecked():
                
                self.func_QRadioButton_NEW_SCENARIO_FILE_Toggled()
            else:
                self.radioButton_4.setChecked(True)
            pass
            self.lineEdit_4.setFocus()
            self.lineEdit_4.selectAll()        
        pass
                
        return True
    
    def func_QRadioButton_EXISTING_PROJECT_FILE_Toggled(self):
        
        if self.radioButton.isChecked():
        
            self.lineEdit_4.setText('')
            self.lineEdit_13.setText('')
            
            ''' Display the New Project widgets '''
            self.stackedWidget_2.setCurrentIndex(0)

            ''' Enable the Existing Scenario option '''
            self.radioButton_5.setEnabled(True)
            
#             ''' Ensure the New Scenario widigets are displayed and initialised '''
#             if self.radioButton_4.isChecked():
#                 self.func_QRadioButton_NEW_SCENARIO_FILE_Toggled()
#             else:
#                 self.radioButton_4.setChecked(True)
#             pass
            ''' Ensure the Existing Scenario widigets are displayed and initialised '''
            if self.radioButton_5.isChecked():
                self.func_QRadioButton_EXISTING_SCENARIO_FILE_Toggled()
            else:
                self.radioButton_5.setChecked(True)
            pass
        
            self.comboBox_111.setFocus()
        pass
            
        return True
     

    def func_QComboBox_PROJECTS_add(self, str_Projects_Relative_Path_And_File__Current):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        ''' Read PROJECTS file '''
        obj_Config = object_SSConfigProjects()
        self.obj_Config_Projects = self.func_Read_Config_File(str_Projects_Relative_Path_And_File__Current, obj_Config, True)
        
        self.list_Project_Files, self.list_Project_Names = self.func_Get_Config_File_List_Of_PROJECT_from_PROJECTS(self.obj_Config_Projects)
        
        ''' Project Page - Choose Project'''

        ''' Project File '''
        #self.bool_Project_ComboBoxes_AddItems_Finished = False
        
        ''' Load the comboboxes with all the items '''
        ''' Block signals so that downstream events dont trigger '''
        bool_Block_Signals = True
        self.comboBox_100.blockSignals(bool_Block_Signals)        
        self.comboBox_110.blockSignals(bool_Block_Signals)        
        self.comboBox_111.blockSignals(bool_Block_Signals)        
        self.comboBox_120.blockSignals(bool_Block_Signals)        
        self.comboBox_121.blockSignals(bool_Block_Signals)        
        
        ''' THIS IS THE MASTER COMBOBOX that controls all other SLAVE comboboxes '''
        ''' Load Project FILE comboboxes '''
        self.comboBox_100.clear()
        self.comboBox_100.addItems(self.list_Project_Files)

        ''' These are SLAVE comboboxes driven by what the MASTER does '''
        ''' Load Project File comboboxes '''        
        self.comboBox_120.clear()
        self.comboBox_120.addItems(self.list_Project_Files)
        
        ''' These are SLAVE comboboxes driven by what the MASTER does '''
        ''' Load Project Name comboboxes '''
        self.comboBox_110.clear()
        self.comboBox_110.addItems(self.list_Project_Names)
        self.comboBox_111.clear()
        self.comboBox_111.addItems(self.list_Project_Names)
        self.comboBox_121.clear()
        self.comboBox_121.addItems(self.list_Project_Names)

        ''' Now the comboboxes have been loaded...'''
        ''' ...Allow signals and events to resume '''
        bool_Block_Signals = False
        self.comboBox_100.blockSignals(bool_Block_Signals) 
        self.comboBox_110.blockSignals(bool_Block_Signals)        
        self.comboBox_111.blockSignals(bool_Block_Signals)    
        self.comboBox_120.blockSignals(bool_Block_Signals)    
        self.comboBox_121.blockSignals(bool_Block_Signals)    
                       
        #self.bool_Project_ComboBoxes_AddItems_Finished = True

        ''' ...get the number of loaded items '''
        int_Index = self.comboBox_100.count() - 1
        
        ''' ...ensure the new / last item is selected '''
        '''
        Ensure the new / last item is selected - SCENARIO list will be loaded automatically after this
        because the currentIndexChanged signal from setCurrentIndex causes that code to run...
        BUT will not run if there is only one item and int_Index  = 0...in which case force the equivalent of an indexChaneged SIGNAL
         '''
        if int_Index > 0:
            ''' 
            setCurrentIndex fires the currentIndexChanged signal
            but only when setting it to an index other than its current one
            
            Updates to associated comboboxes are then automatically triggered
            '''              
            self.comboBox_100.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one  
            self.comboBox_120.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one  
        else:
            '''
            When there is only 1 item in the combo the setCurrentIndex doesnt fire
            because changing the index to the same index is ignored
            so run the desred events manually
            '''            
            self.func_QComboBox_PROJECT_FILE_From_PROJECTS_Selected(int_Index)
            
            self.func_QComboBox_SCENARIO_Clone_PROJECT_FILE__Selected(int_Index)
        pass
       
        #self.func_QComboBox_PROJECTS_add()
        
        return True
        
    def func_QComboBox_PROJECT_FILE_From_PROJECTS_Selected (self, int_Index):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
            
        ''' THIS IS THE MASTER COMBOBOX that controls all other SLAVE comboboxes '''
        if self.comboBox_100.currentText(): #<-- This needs to be done because comboBox_100.clear signals currentIndexChanged and ends up here with an empty comboBox
            
            str_Project_Relative_Path_And_File__Current = str(self.comboBox_100.currentText())
            _, str_Project_File__Current = os__path.split(self.str_Project_Path_And_File__Current)
            
            self.lineEdit_6.setText(str_Project_File__Current)

            ''' These are SLAVE comboboxes driven by what the MASTER does '''
            ''' Trigger signal to update the Project_Name comboBox with the same item'''
            self.comboBox_110.setCurrentIndex(int_Index) #This fires the currentIndexChanged signal 
            self.comboBox_111.setCurrentIndex(int_Index) #This fires the currentIndexChanged signal 

            ''' Read the Project file '''
            self.func_Populate_Widgits_With_Config_Data__PROJECT(str_Project_Relative_Path_And_File__Current)        
            
            ''' Reload the SCENARIO comboboxes with the PROJECT-specific sceanrios '''
            self.func_QComboBox_SCENARIOS_add(str_Project_Relative_Path_And_File__Current)
        pass
    
        return int_Index
    
    def func_QComboBox_PROJECT_NAME_From_PROJECTS_Selected (self, int_Index):
    
        if self.comboBox_110.currentText(): #<-- This needs to be done because comboBox_100.clear signals currentIndexChanged and ends up here with an empty comboBox
            
            self.str_Project_Name__Current = str(self.comboBox_110.currentText())
            
            self.lineEdit_9.setText(self.str_Project_Name__Current)

            ''' Trigger signal to update the Project_File comboBox with the same item'''
            self.comboBox_100.setCurrentIndex(int_Index) #This fires the currentIndexChanged signal 
        pass
    
        return int_Index

    def func_QCheckBox_DELETE_PROJECT_StateChanged(self, int_State):
        
        if self.checkBox_3.isChecked():
            self.checkBox_2.setChecked(False)
            self.checkBox_2.setEnabled(False)
            
            self.radioButton_2.setEnabled(False)
            
            self.radioButton_5.setEnabled(False)
            self.radioButton_4.setEnabled(False)
            self.radioButton_3.setEnabled(False)
            
            self.pushButton.setEnabled(True)
        else:
            self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex(), True)
                        
            #self.pushButton.setEnabled(False) 
        pass
    
        return int_State
    
    
    def func_QRadioButton_EXISTING_SCENARIO_FILE_Toggled(self):
        
        if self.radioButton_5.isChecked():
            self.lineEdit_5.setText('')
            self.lineEdit_8.setText('')
            self.stackedWidget_3.setCurrentIndex(0)
        pass
    
        return True
        
    def func_QRadioButton_NEW_SCENARIO_FILE_Toggled(self):

        if self.radioButton_4.isChecked():
            
            ''' Prepare to edit the Scenario Name '''
            self.label_7.setText(self.str_Scenario_Name__Current__Label_Text + '*')
                    
            self.lineEdit_8.setText('')
            self.stackedWidget_3.setCurrentIndex(1)
            
            ''' Generate a default name for the new Scenario based on the current settings '''
            if self.radioButton.isChecked():
                str_Project_Name = self.comboBox_110.currentText()
                int_Batch_Scenario_Count = len(self.list_Scenario_Files) + 1 #self.comboBox_210.count() + 1
                int_Tries = 1
                str_Suffix = str(int_Batch_Scenario_Count)
                while True:
                    str_Batch_Scenario_Name_Default = str_Project_Name + '_' + globalsSSFE.Name.static_str__Name__Batch_Scenario + str_Suffix
                    if str_Batch_Scenario_Name_Default in self.list_Scenario_Names:
                        str_Suffix = str_Suffix + '_' + str(int_Tries)
                        int_Tries += 1
                        if int_Tries >= 6:
                            break
                        pass
                    else:
                        break
                    pass
                pass
            elif self.radioButton_2.isChecked():
                str_Project_Name = self.lineEdit_4.text()
                int_Batch_Scenario_Count = 1
                str_Batch_Scenario_Name_Default = str_Project_Name + '_' + globalsSSFE.Name.static_str__Name__Batch_Scenario + str(int_Batch_Scenario_Count)
            pass
            #str_Batch_Scenario_Name_Default = str_Project_Name + '_' + globalsSSFE.Name.static_str__Name__Batch_Scenario + str(int_Batch_Scenario_Count)
            self.lineEdit_5.setText(str_Batch_Scenario_Name_Default)
            self.lineEdit_5.setFocus()
            self.lineEdit_5.selectAll()
            ''' Indicate that the text has changed '''
            self.func_QLineEdit__Scenario_Name__Text_Changed()  
        pass
    
        return True
    
    def func_QRadioButton_CLONED_SCENARIO_FILE_Toggled(self):

        if self.radioButton_3.isChecked():
            
            ''' Update the clone comboBoxes to the current lists '''
            int_Index = self.comboBox_100.currentIndex()
            self.func_QComboBox_SCENARIO_Clone_PROJECT_FILE__Selected(int_Index)
            
            ''' Prepare to edit the Scenario Name '''
            self.label_9.setText(self.str_Scenario_Cloned_Name__Label_Text + '*')
            
            self.lineEdit_5.setText('')
            self.stackedWidget_3.setCurrentIndex(2)
            
            ''' Generate a default name for the new Scenario based on the current settings '''
            if self.radioButton.isChecked():
                str_Project_Name = self.comboBox_110.currentText()
                int_Batch_Scenario_Count = self.comboBox_210.count() + 1
            elif self.radioButton_2.isChecked():
                str_Project_Name = self.lineEdit_4.text()
                int_Batch_Scenario_Count = 1
            pass
            str_Batch_Scenario_Name_Default = str_Project_Name + '_' + globalsSSFE.Name.static_str__Name__Batch_Scenario + str(int_Batch_Scenario_Count)
            self.lineEdit_8.setText(str_Batch_Scenario_Name_Default)
            self.lineEdit_8.setFocus()
            self.lineEdit_8.selectAll()  
            ''' Indicate that the text has changed '''  
            self.func_QLineEdit__Scenario_Name__Text_Changed()  
        pass
     
        return True
   
    def func_QComboBox_SCENARIOS_add(self, str_Project_Relative_Path_And_File__Current):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        self.list_Scenario_Files = []
        self.list_Scenario_Names = []
        
        ''' read the PROJECT file for the list of scearios ''' 
        obj_Config = object_SSConfigProject()
        obj_Config = self.func_Read_Config_File(str_Project_Relative_Path_And_File__Current, obj_Config, True)
        
        '''NOTE: This assumes that the PROJECT config has just been read '''
        #self.list_Scenario_Files, self.list_Scenario_Names = self.func_Get_Config_File_List_Of_SCENARIOS_from_PROJECT(self.obj_Config_Project)
        self.list_Scenario_Files, self.list_Scenario_Names = self.func_Get_Config_File_List_Of_SCENARIOS_from_PROJECT(obj_Config)

        #self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex())

#         if len(self.list_Scenario_Files) <= 0:
#             return False
#         pass
            
        ''' Load the comboboxes with all the items '''
        ''' Block signals so that downstream events dont trigger '''        
        #self.bool_Scenario_ComboBoxes_AddItems_Finished = False
        bool_Block_Signals = True
        self.comboBox_200.blockSignals(bool_Block_Signals)
        self.comboBox_201.blockSignals(bool_Block_Signals)
        self.comboBox_210.blockSignals(bool_Block_Signals)
        self.comboBox_211.blockSignals(bool_Block_Signals)
        #self.comboBox_220.blockSignals(bool_Block_Signals)
        #self.comboBox_221.blockSignals(bool_Block_Signals)
        
        ''' THIS IS THE MASTER COMBOBOX that controls all other SLAVE comboboxes '''
        ''' Load Sampling Strategy FILE comboboxes '''
        self.comboBox_200.clear()
        self.comboBox_200.addItems(self.list_Scenario_Files)        

        self.comboBox_201.clear()
        self.comboBox_201.addItems(self.list_Scenario_Files) 
        
        ''' These are SLAVE comboboxes driven by what the MASTER does '''
        ''' Load Batch Scenario Name comboboxes '''
        self.comboBox_210.clear()
        self.comboBox_210.addItems(self.list_Scenario_Names)
        self.comboBox_211.clear()
        self.comboBox_211.addItems(self.list_Scenario_Names)

        ''' Load Batch Scenario CLONE Name comboboxes '''                
        #self.comboBox_220.clear()
        #self.comboBox_220.addItems(self.list_Scenario_Files)
        #self.comboBox_221.clear()
        #self.comboBox_221.addItems(self.list_Scenario_Names)
                        
#         self.comboBox_221.setCurrentIndex(int_Index)       
#         self.comboBox_200.setCurrentIndex(int_Index)
#         self.comboBox_201.setCurrentIndex(int_Index)
#         self.comboBox_211.setCurrentIndex(int_Index)   
#         self.comboBox_220.setCurrentIndex(int_Index)   
#         self.comboBox_210.setCurrentIndex(int_Index)   


        ''' Now the comboboxes have been loaded...'''
        ''' ...Allow signals and events to resume '''
        bool_Block_Signals = False
        self.comboBox_200.blockSignals(bool_Block_Signals)
        self.comboBox_201.blockSignals(bool_Block_Signals)
        self.comboBox_210.blockSignals(bool_Block_Signals)
        self.comboBox_211.blockSignals(bool_Block_Signals)
        #self.comboBox_220.blockSignals(bool_Block_Signals)
        #self.comboBox_221.blockSignals(bool_Block_Signals)
        
        #self.bool_Scenario_ComboBoxes_AddItems_Finished = True

        ''' ...get the number of loaded items '''
        int_Index = self.comboBox_200.count() - 1        
        
        ''' ...ensure the new / last item is selected '''
        '''
        Ensure the new / last item is selected - SCENARIO list will be loaded automatically after this
        because the currentIndexChanged signal from setCurrentIndex causes that code to run...
        BUT will not run if there is only one item and int_Index  = 0...in which case force the equivalent of an indexChaneged SIGNAL
         '''
        if int_Index > 0:
            ''' 
            setCurrentIndex fires the currentIndexChanged signal
            but only when setting it to an index other than its current one
            
            Updates to associated comboboxes are then automatically triggered
            '''  
            self.comboBox_200.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one  
            
        else:
            '''
            When there is only 1 item in the combo the setCurrentIndex doesnt fire
            because changing the index to the same index is ignored
            so run the desred events manually
            '''            
            self.func_QComboBox_SCENARIO_FILE_Selected(int_Index)
            #self.func_QComboBox_SCENARIO_NAME_Selected(int_Index)
            #self.func_QComboBox_SCENARIO_FILE_Selected__Page_2(int_Index)
        pass        
    
        self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex(), True)
        
        return True

    def func_QComboBox_SCENARIO_FILE_Selected (self, int_Index):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        ''' THIS IS THE MASTER COMBOBOX that controls all other SLAVE comboboxes '''
        if self.comboBox_200.currentText():
            str_Batch_Scenario_Relative_Path_And_File__Current = str(self.comboBox_200.currentText())
            _, str_Batch_Scenario_File__Current = os__path.split(str_Batch_Scenario_Relative_Path_And_File__Current)
            str_Batch_Scenario_File_Name__Current, _ = os__path.splitext(str_Batch_Scenario_Relative_Path_And_File__Current)
            self.int_Batch_Scenario_UID__Current = int(str_Batch_Scenario_File_Name__Current[-14:])
            
            self.lineEdit_7.setText(str_Batch_Scenario_File__Current)
 
            ''' These are SLAVE comboboxes driven by what the MASTER does '''
            ''' Trigger signal to update the Scenario_Name comboBox with the same item'''
            self.comboBox_210.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one 
            self.comboBox_211.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one 

            ''' Load the appropriate data into all the widgets '''
            self.func_Populate_Widgits_With_Config_Data__BATCH_SCENARIO(str_Batch_Scenario_Relative_Path_And_File__Current)
            
            ''' Re-initilise the SAMPLING STRATEGY combobox with the associated items '''            
            self.func_QComboBox_SAMPLING_STATEGIES_add(str_Batch_Scenario_Relative_Path_And_File__Current)
            
            ''' When the SCENARIO list is refreshed also refresh the SCENARIO Name Clone field if it is on screen'''
            if self.toolBox.currentIndex() == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario:
                if self.radioButton_4.isChecked():
                    self.func_QRadioButton_NEW_SCENARIO_FILE_Toggled()
                elif self.radioButton_3.isChecked():
                    self.func_QRadioButton_CLONED_SCENARIO_FILE_Toggled()
                pass
            pass
        
            ''' Display the appropriate results '''
            if self.toolBox.currentIndex() == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Scenario:
                self.func_Display_Results__Batch_Scenario__View_Results__Refresh_Text_Browser()
            pass
        
            self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex(), True)        
        
        pass
        return int_Index

    def func_Display_Results__Batch_Scenario__View_Results__Refresh_Text_Browser_RETIRE(self):
        
        bool_Success = False
        
        #str_FrontEnd_Batch_Scenario_Folder__Current = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current)
        str_FrontEnd_Batch_Scenario_Folder__Results = self.str_Settings_Run_Results_Folder_Prefix__Default_Value + '_' + self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current)
        str_FrontEnd_Results_Path = os__path.join(self.str_Batch_Scenario_Path__Current, str_FrontEnd_Batch_Scenario_Folder__Results)
        
        bool_Files_Found, list_Path_And_Files__Plots, list_Captions__Plots = self.func_Display_Results__Get_Results_Plots(str_FrontEnd_Results_Path, bool_Error_On_Files_Not_Found = False, bool_Search_Sub_Folders = False)
        
        str_FrontEnd_Results_Thumbs_Path = os__path.join(str_FrontEnd_Results_Path, self.str_Settings_Run_Results_Thumbnail_Images_Folder_Prefix__Default_Value)
        bool_Files_Found, list_Path_And_Files__Thumbs, list_Captions__Thumbs = self.func_Display_Results__Get_Results_Plots(str_FrontEnd_Results_Thumbs_Path, bool_Error_On_Files_Not_Found = False, bool_Search_Sub_Folders = False)
        
        bool_Success = bool_Files_Found
        
        if bool_Files_Found:
            self.list_Path_And_Files__Batch_Scenario__Results_Plots = list(list_Path_And_Files__Plots)
            self.list_Path_And_Files__Batch_Scenario__Results_Plots_Captions = list(list_Captions__Plots)

            ''' Embed desired thumbnail in textBrowser '''
            str_Path_And_Thumb = list_Path_And_Files__Thumbs[len(list_Path_And_Files__Thumbs)-1]
            textBrowser = self.textBrowser_4
            bool_Success = self.func_Display_Results__Insert_TextBrowser_Image(textBrowser, str_Path_And_Thumb)
            
            self.pushButton_2.setEnabled(True)             
            self.pushButton_3.setEnabled(True)             
            pass
        else:
            self.pushButton_2.setEnabled(False)
            self.pushButton_3.setEnabled(False)
        pass        
        
    def func_Display_Results__Batch_Scenario__View_Results__Refresh_Text_Browser(self):
        
        bool_Success = False
        
        #str_FrontEnd_Batch_Scenario_Folder__Current = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current)
        str_FrontEnd_Batch_Scenario_Folder__Results = self.str_Settings_Run_Results_Folder_Prefix__Default_Value + '_' + self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current)
        str_FrontEnd_Results_Path = os__path.join(self.str_Batch_Scenario_Path__Current, str_FrontEnd_Batch_Scenario_Folder__Results)
        
        bool_Files_Found, list_Path_And_Files__Plots, list_Captions__Plots = self.func_Display_Results__Get_Results_Plots(str_FrontEnd_Results_Path, bool_Error_On_Files_Not_Found = False, bool_Search_Sub_Folders = False)
        
        str_FrontEnd_Results_Thumbs_Path = os__path.join(str_FrontEnd_Results_Path, self.str_Settings_Run_Results_Thumbnail_Images_Folder_Prefix__Default_Value)
        bool_Files_Found, list_Path_And_Files__Thumbs, list_Captions__Thumbs = self.func_Display_Results__Get_Results_Plots(str_FrontEnd_Results_Thumbs_Path, bool_Error_On_Files_Not_Found = False, bool_Search_Sub_Folders = False)
        
        bool_Success = bool_Files_Found
        
        if bool_Files_Found:
            self.list_Path_And_Files__Batch_Scenario__Results_Plots = list(list_Path_And_Files__Plots)
            self.list_Path_And_Files__Batch_Scenario__Results_Plots_Captions = list(list_Captions__Plots)
            self.list_Path_And_Files__Batch_Scenario__Results_Plots_Thumbs = list(list_Path_And_Files__Thumbs)
            
            ''' Embed desired thumbnail in textBrowser '''
            self.str_Path_And_Thumb_Displayed__Batch_Scenario = list_Path_And_Files__Thumbs[0]
            textBrowser = self.textBrowser_4
            bool_Success = self.func_Display_Results__Insert_TextBrowser_Image(textBrowser, self.str_Path_And_Thumb_Displayed__Batch_Scenario)
            
            if not self.bool_Results_Window_Displayed:
                self.pushButton_2.setEnabled(True)
            pass                
            self.pushButton_3.setEnabled(True)  

            if len(list_Path_And_Files__Thumbs) > 1:
                self.pushButton_18.setEnabled(True)
                self.pushButton_19.setEnabled(True)
            pass
            self.pushButton_21.setEnabled(True)                                  
        else:
            if not self.bool_Results_Window_Displayed:
                self.pushButton_2.setEnabled(False)
            pass
            self.pushButton_3.setEnabled(False)
            
            self.pushButton_18.setEnabled(False)
            self.pushButton_19.setEnabled(False)
            self.pushButton_21.setEnabled(False)                    
            
        pass

        return True
            
    def func_QComboBox_SCENARIO_NAME_Selected(self, int_Index):
        
        if self.comboBox_210.currentText():
            self.str_Scenario_Name__Current = str(self.comboBox_210.currentText())
            
            self.lineEdit_10.setText(self.str_Scenario_Name__Current)
            self.bool_Changed_Config__Batch_Scenario = True
                        
            ''' Trigger signal to update the Scenario_File comboBox with the same item'''
            self.comboBox_200.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one 
        pass
        return int_Index


    def func_QComboBox_SCENARIO_Clone_PROJECT_FILE__Selected(self, int_Index):
         
        if self.comboBox_120.currentText():
            ''' Trigger signal to update the Scenario_File comboBox with the same item'''
            self.comboBox_121.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one 

            str_Project_Path_And_File__To_Clone_From = str(self.comboBox_120.currentText())
            self.func_QComboBox_SCENARIOS_To_Clone_add(str_Project_Path_And_File__To_Clone_From)
        pass
        return int_Index
    
    def func_QComboBox_SCENARIO_Clone_PROJECT_NAME__Selected(self, int_Index):
         
        if self.comboBox_121.currentText():
            ''' Trigger signal to update the Scenario_File comboBox with the same item'''
            self.comboBox_120.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one 
            
        pass
        return int_Index

    def func_QComboBox_SCENARIOS_To_Clone_add(self, str_Project_Path_And_File__To_Clone_From):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.list_Scenario_Files_For_Clone = []
        self.list_Scenario_Names_For_Clone = []
        
        ''' read the PROJECT file for the list of scearios ''' 
        obj_Config_Project__Temp = object_SSConfigProject()
        #obj_Config_Project__Temp = self.func_Read_Config_File(str_Project_Path_And_File__To_Clone_From, obj_Config_Project__Temp)
        obj_Config_Project__Temp = self.func_Read_Config_File(os__path.join(self.str_Application_Projects_Path, str_Project_Path_And_File__To_Clone_From), obj_Config_Project__Temp)

        '''NOTE: This assumes that the PROJECT config has just been read '''
        self.list_Scenario_Files_For_Clone, self.list_Scenario_Names_For_Clone = self.func_Get_Config_File_List_Of_SCENARIOS_from_PROJECT(obj_Config_Project__Temp)
        
#         if len(self.list_Scenario_Files_For_Clone) <= 0:
#             return False
#         pass
    
        ''' Load the comboboxes with all the items '''
        ''' Block signals so that downstream events dont trigger '''        
        #self.bool_Scenario_ComboBoxes_AddItems_Finished = False
        bool_Block_Signals = True
        self.comboBox_220.blockSignals(bool_Block_Signals)
        self.comboBox_221.blockSignals(bool_Block_Signals)
        
        ''' THIS IS THE MASTER COMBOBOX that controls all other SLAVE comboboxes '''
        ''' Load Sampling Strategy FILE comboboxes '''
        self.comboBox_220.clear()
        self.comboBox_220.addItems(self.list_Scenario_Files_For_Clone)        
        
        ''' These are SLAVE comboboxes driven by what the MASTER does '''
        ''' Load Batch Scenario CLONE Name comboboxes '''                
        self.comboBox_221.clear()
        self.comboBox_221.addItems(self.list_Scenario_Names_For_Clone)

        ''' Now the comboboxes have been loaded...'''
        ''' ...Allow signals and events to resume '''
        bool_Block_Signals = False
        self.comboBox_220.blockSignals(bool_Block_Signals)
        self.comboBox_221.blockSignals(bool_Block_Signals)
        
        #self.bool_Scenario_ComboBoxes_AddItems_Finished = True

        ''' ...get the number of loaded items '''
        int_Index = self.comboBox_220.count() - 1        
        
        ''' ...ensure the new / last item is selected '''
        '''
        Ensure the new / last item is selected - SCENARIO list will be loaded automatically after this
        because the currentIndexChanged signal from setCurrentIndex causes that code to run...
        BUT will not run if there is only one item and int_Index  = 0...in which case force the equivalent of an indexChaneged SIGNAL
         '''
        if int_Index > 0:
            ''' 
            setCurrentIndex fires the currentIndexChanged signal
            but only when setting it to an index other than its current one
            
            Updates to associated comboboxes are then automatically triggered
            '''  
            self.comboBox_220.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one  
            
        else:
            '''
            When there is only 1 item in the combo the setCurrentIndex doesnt fire
            because changing the index to the same index is ignored
            so run the desred events manually
            '''            
            self.func_QComboBox_SCENARIO_Clone_FILE_Selected(int_Index)
        pass        
        return True
    
    def func_QComboBox_SCENARIO_Clone_FILE_Selected(self, int_Index):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                 
        if self.comboBox_220.currentText():
            
            #DEBUG_ON
            #str_Batch_Scenario_Path_And_File__To_Clone_From = self.comboBox_220.currentText()
            #str_Batch_Scenario_Name__To_Clone_From = self.comboBox_221.currentText()
            #DEBUG_OFF
            ''' Trigger signal to update the Scenario_File comboBox with the same item'''
            self.comboBox_221.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one 
        
        pass
        return int_Index
    
    def func_QComboBox_SCENARIO_Clone_NAME_Selected(self, int_Index):
         
        if self.comboBox_221.currentText():
            ''' Trigger signal to update the Scenario_File comboBox with the same item'''
            self.comboBox_220.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one 
        pass
        return int_Index

    def func_QCheckBox_DELETE_BATCH_SCENARIO_StateChanged(self, int_State):
        
        if self.checkBox_2.isChecked():
            self.radioButton.setEnabled(False)
            self.radioButton_2.setEnabled(False)
            self.radioButton.setChecked(True)

            self.checkBox_3.setChecked(False)
            self.checkBox_3.setEnabled(False)
            
            self.radioButton_5.setEnabled(True)
            self.radioButton_4.setEnabled(False)
            self.radioButton_3.setEnabled(False)
            #self.checkBox_5.setChecked(True)
                        
#             self.checkBox_3.setChecked(False)
#             self.checkBox_3.setEnabled(False)            
            self.pushButton.setEnabled(True)
        else:
#             self.checkBox_3.setChecked(False)
#             self.checkBox_3.setEnabled(True)            
#             self.pushButton.setEnabled(False) 
            self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex(), True)
                        
            #self.pushButton.setEnabled(False) 
        pass
    
        return int_State
    
    '''
    ----------------------------
    QToolBox - Index 1
    ----------------------------
    '''        
    '''
    ----------------------------
    Scenario - Life history slider widgets
    ----------------------------
    '''      
    def func_QHorizontalSlider__Scenario_Max_Age__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.spinBox_24.setValue(int_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QSpinBox__Scenario_Max_Age__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        self.horizontalSlider_31.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_24'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Max_Age(int_Value, bool_Save)
                pass
            pass
        pass         
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
# #                     ''' Check if other parameters that are dependent on MaxAge will have to be changed '''
# #                     bool_Continue = False
# #                     if self.bool_int_Species_Life_History_Max_Age__FOUND or self.bool_int_Species_Life_History_Max_Age__CHANGED:
# #                         ''' The Mortality Dist will have to be changed '''
# #                         str_MessageBox_Text = 'Changing the Maximum Age will require that you redefine the Age Cohort Mortality Distribution.\n\nAre you sure you wish to continue?'
# #                         messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Max Age?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
# #                         if messageBox_Reponse == QtGui.QMessageBox.Yes:
# #                             ''' Continue to change Max Age'''
# #                             bool_Continue = True
# #                             #self.horizontalSlider_31.setValue(int_Value)
# #                             ''' Change the Status for the Age Cohort Mortality Dist to force the user to alter and re-save it '''
# #                             qWidget = self.pushButton_6
# #                             str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
# #                             self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                    
# #                         else:
# #                             ''' Abort Max Age change'''
# #                             bool_Continue = False
# #                         pass
# #                     pass
# #                     if bool_Continue:                    
# #                         ''' Update widgets and config with changes '''
# #                         bool_Save = True
# #                         self.func_Update__Scenario_Max_Age(int_Value, bool_Save)
# #                     pass
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Max_Age(int_Value, bool_Save)
#                 pass
#             pass
#         pass
            
        return int_Value
    
    def func_QSpinBox__Scenario_Max_Age__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        int_Value = self.spinBox_24.value()
        #self.horizontalSlider_31.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
                ''' If change is NOT detected then dont Save '''        
                if self.int_Species_Life_History_Max_Age == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes '''    
                self.func_Update__Scenario_Max_Age(int_Value, bool_Save)
            pass
        pass
    
        return True

    def func_QHorizontalSlider__Scenario_Max_Mating_Age__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.spinBox_25.setValue(int_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QSpinBox__Scenario_Max_Mating_Age__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_32.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_25'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Max_Mating_Age(int_Value, bool_Save)
                pass
            pass
        pass      
            
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Max_Mating_Age(int_Value, bool_Save)
#                 pass
#             pass
#         pass            
        return int_Value

    def func_QSpinBox__Scenario_Max_Mating_Age__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_25.value()
        self.horizontalSlider_32.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:

                ''' If change is NOT detected then dont Save '''        
                if self.int_Species_Life_History_Max_Mating_Age == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Max_Mating_Age(int_Value, bool_Save)
            pass
        pass            
        return int_Value

    def func_QHorizontalSlider__Scenario_Min_Mating_Age__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.spinBox_27.setValue(int_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QSpinBox__Scenario_Min_Mating_Age__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_33.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_27'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Min_Mating_Age(int_Value, bool_Save)
                pass
            pass
        pass           
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Min_Mating_Age(int_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return int_Value

    def func_QSpinBox__Scenario_Min_Mating_Age__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_27.value()
        self.horizontalSlider_33.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:

                ''' If change is NOT detected then dont Save '''        
                if self.int_Species_Life_History_Min_Mating_Age == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Min_Mating_Age(int_Value, bool_Save)
                pass
            pass
        pass             
        return int_Value

    '''
    ----------------------------
    Scenario - Life History Offspring distribution widgets
    ----------------------------
    '''    
    def func_QComboBox_Offspring_Distribution_Selected__Page_2 (self):

        int_Index = self.comboBox_4.currentIndex()
        self.func_Offspring_Distribution_Selection(int_Index)   
        return True

    def func_QHorizontalSlider__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__SetValue(self, int_Value):
    
        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        #int_Slider_Value = self.horizontalSlider_27.value()
        self.spinBox_23.setValue(int_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QSpinBox__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_27.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_23'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number(int_Value, bool_Save)
                pass
            pass
        pass         
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number(int_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return int_Value

    def func_QSpinBox__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_23.value()
        self.horizontalSlider_27.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:

                ''' If change is NOT detected then dont Save '''        
                if self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number(int_Value, bool_Save)
                pass            
            pass
        pass             
        return int_Value

    def func_QHorizontalSlider__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        floatScaled_Value = float(int_Value)/float(self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor)
        self.doubleSpinBox_9.setValue(floatScaled_Value)
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '; int_Value:' + str(int_Value) + '; floatScaled_Value: ' + str(floatScaled_Value))
        #DEBUG_OFF        
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QDoubleSpinBox__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__SetValue(self, float_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        intScaled_Value = int(float_Value*self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor)
        self.horizontalSlider_30.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'doubleSpinBox_9'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number(float_Value, bool_Save)
                pass
            pass
        pass   
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number(float_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return float_Value

    def func_QDoubleSpinBox__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        float_Value = self.doubleSpinBox_9.value()
        intScaled_Value = int(float_Value*self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor)
        self.horizontalSlider_30.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
            
                ''' If change is NOT detected then dont Save '''        
                if self.float_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number == float_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number(float_Value, bool_Save)
                pass               
            pass
        pass             
        return float_Value

    def func_QHorizontalSlider__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        floatScaled_Value = float(int_Value)/float(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor)
        self.doubleSpinBox_5.setValue(floatScaled_Value)
            
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '; int_Value:' + str(int_Value) + '; floatScaled_Value: ' + str(floatScaled_Value))
        #DEBUG_OFF        
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QDoubleSpinBox__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__SetValue(self, float_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        intScaled_Value = int(round(float_Value*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor,0))
        self.horizontalSlider_28.setValue(intScaled_Value)
    
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'doubleSpinBox_5'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number(float_Value, bool_Save)
                pass
            pass
        pass  
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number(float_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return float_Value

    def func_QDoubleSpinBox__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        float_Value = self.doubleSpinBox_5.value()        
        intScaled_Value = int(round(float_Value*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor,0))
        self.horizontalSlider_28.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:

                ''' If change is NOT detected then dont Save '''        
                if self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number == float_Value :
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number(float_Value, bool_Save)
                pass            
            pass
        pass             
        return float_Value

    def func_QHorizontalSlider__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        floatScaled_Value = float(int_Value)/float(self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor)
        self.doubleSpinBox_6.setValue(floatScaled_Value)
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '; int_Value:' + str(int_Value) + '; floatScaled_Value: ' + str(floatScaled_Value))
        #DEBUG_OFF        
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QDoubleSpinBox__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__SetValue(self, float_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        intScaled_Value = int(round(float_Value*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor,0))
        self.horizontalSlider_29.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'doubleSpinBox_6'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev(float_Value, bool_Save)
                pass
            pass
        pass  
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev(float_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return float_Value

    def func_QDoubleSpinBox__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        float_Value = self.doubleSpinBox_6.value()
        intScaled_Value = int(round(float_Value*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor,0))
        self.horizontalSlider_29.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:

                ''' If change is NOT detected then dont Save '''        
                if self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev == float_Value :
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev(float_Value, bool_Save)
                pass               
            pass
        pass             
        return float_Value

    def func_QHorizontalSlider__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Min__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        #int_Slider_Value = self.horizontalSlider_39.value()
        self.spinBox_26.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Min__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_39.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_26'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Species_Offspring_Distribution_UNIFORM_Offspring_Min(int_Value, bool_Save)
                pass
            pass
        pass          
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Species_Offspring_Distribution_UNIFORM_Offspring_Min(int_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return int_Value

    def func_QSpinBox__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Min__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_26.value()
        self.horizontalSlider_39.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
                ''' If change is NOT detected then dont Save '''        
                if self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Species_Offspring_Distribution_UNIFORM_Offspring_Min(int_Value, bool_Save)
                pass 
            pass
        pass             
        return int_Value

    def func_QHorizontalSlider__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Max__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        #int_Slider_Value = self.horizontalSlider_40.value()
        self.spinBox_31.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Max__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_40.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_31'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Species_Offspring_Distribution_UNIFORM_Offspring_Max(int_Value, bool_Save)
                pass
            pass
        pass          
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Species_Offspring_Distribution_UNIFORM_Offspring_Max(int_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return int_Value

    def func_QSpinBox__Species_Offspring_Distribution_UNIFORM_Offspring_Number_Max__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_31.value()
        self.horizontalSlider_40.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:

                ''' If change is NOT detected then dont Save '''        
                if self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Species_Offspring_Distribution_UNIFORM_Offspring_Max(int_Value, bool_Save)
                pass 
            pass
        pass             
        return int_Value

    def func_QHorizontalSlider__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean_Number__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        floatScaled_Value = float(int_Value)/float(self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor)
        self.doubleSpinBox_10.setValue(floatScaled_Value)
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '; int_Value:' + str(int_Value) + '; floatScaled_Value: ' + str(floatScaled_Value))
        #DEBUG_OFF        
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QDoubleSpinBox__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean_Number__SetValue(self, float_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        intScaled_Value = int(round(float_Value*self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor,0))
        self.horizontalSlider_41.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'doubleSpinBox_10'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean(float_Value, bool_Save)
                pass
            pass
        pass  
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean(float_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return float_Value

    def func_QDoubleSpinBox__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean_Number__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        float_Value = self.doubleSpinBox_10.value()
        intScaled_Value = int(round(float_Value*self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor,0))
        self.horizontalSlider_41.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
                ''' If change is NOT detected then dont Save '''        
                if self.float_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean == float_Value :
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean(float_Value, bool_Save)
                pass  
            pass
        pass             
        return float_Value

    '''
    ----------------------------
    Scenario - Demography widgets
    ----------------------------
    '''
    def func_QHorizontalSlider__Scenario_Demography_Population_Size__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        #int_Slider_Value = self.horizontalSlider_40.value()
        self.spinBox_28.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Scenario_Demography_Population_Size__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_34.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_28'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Demography_Population_Size(int_Value, bool_Save)
                pass
            pass
        pass         
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Demography_Population_Size(int_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return int_Value
    
    def func_QSpinBox__Scenario_Demography_Population_Size__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_28.value()
        self.horizontalSlider_34.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
                ''' If change is NOT detected then dont Save '''        
                if self.int_Population_Size == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes '''                 
                self.func_Update__Scenario_Demography_Population_Size(int_Value, bool_Save)
                pass
            pass
        pass             
        return int_Value

    '''
    ----------------------------
    Scenario - Genetics widgets
    ----------------------------
    '''  
    def func_QComboBox_Genome_Allele_Frequency_Distribution_Selected__Page_2 (self):

        int_Index = self.comboBox_6.currentIndex()
        self.func_Genome_Allele_Frequency_Distribution_Selection(int_Index)   

        return True

    def func_QComboBox_Alleles_Per_Locus_Distribution_Selected__Page_2 (self):

        int_Index = self.comboBox_5.currentIndex()
        self.func_Genome_Alleles_Per_Locus_Distribution_Distribution_Selection(int_Index)   
        return True
       
    def func_QFile_Dialog_Button_Genome_Allele_Frequency_Distribution_File_Clicked(self):
        
        str_Start_Path = os__path.expanduser('~') #self.str_Application_Projects_Path  
        
        if self.str_Genome_Allele_Frequency_Distribution == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES:

            str_Title, str_Start_Path, str_File_Type_Hint = "Open AllAlleleFrequencies File", str_Start_Path, "AllAlleleFrequencies files (*.txt)"
            self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name = self.func_Open_File_Dialog(str_Title, str_Start_Path, str_File_Type_Hint)

            if self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name != '':
                self.lineEdit_2.setText(str(self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name))
                ''' Save the selection '''
                #self.groupBox_24.setTitle(self.str_Genome_Allele_Frequency_Distribution__Label_Text)
                str_Path, str_File = os__path.split(str(self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name))
                self.lineEdit_11.setText(str_File)
                self.lineEdit_11.setCursorPosition(0)
                #self.lineEdit_11.selectAll()
                self.lineEdit_2.setText(self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name)
                self.lineEdit_2.setCursorPosition(0)
                self.str_Genome_Allele_Frequency_Distribution = object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES
                self.func_Update_Config__Genome_Allele_Frequency_Distribution()
            pass
        elif self.str_Genome_Allele_Frequency_Distribution == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP:

            str_Title, str_Start_Path, str_File_Type_Hint = "Open GENEPOP File", str_Start_Path, "GENEPOP files (*.txt)"
            self.str_Genome__Source_GENEPOP_File_Path_And_Name = self.func_Open_File_Dialog(str_Title, str_Start_Path, str_File_Type_Hint)

            if self.str_Genome__Source_GENEPOP_File_Path_And_Name != '':
                self.lineEdit_2.setText(str(self.str_Genome__Source_GENEPOP_File_Path_And_Name))
                ''' Save the selection '''
                #self.groupBox_24.setTitle(self.str_Genome_Allele_Frequency_Distribution__Label_Text)
                str_Path, str_File = os__path.split(str(self.str_Genome__Source_GENEPOP_File_Path_And_Name))
                self.lineEdit_11.setText(str_File)
                self.lineEdit_11.setCursorPosition(0)
                #self.lineEdit_11.selectAll()
                self.lineEdit_2.setText(self.str_Genome__Source_GENEPOP_File_Path_And_Name)
                self.lineEdit_2.setCursorPosition(0)
                self.str_Genome_Allele_Frequency_Distribution = object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP
                self.func_Update_Config__Genome_Allele_Frequency_Distribution()
            pass
        pass
    
    def func_QHorizontalSlider__Scenario_Genome_Locus_Number__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        #int_Slider_Value = self.horizontalSlider_40.value()
        self.spinBox_30.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Scenario_Genome_Locus_Number__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_38.setValue(int_Value)
        
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Genome_Locus_Number(int_Value, bool_Save)
#                 pass
#             pass
#         pass  
        if self.bool_Init_Finished:
            
            if self.str_Genome_Allele_Frequency_Distribution == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES and\
               int_Value != self.int_Genome__Source_ALL_ALLELE_FREQUENCIES__Total_Loci:
                ''' Reset the widget to the correct value '''
                int_Value = self.int_Genome__Source_ALL_ALLELE_FREQUENCIES__Total_Loci
                self.horizontalSlider_38.setValue(int_Value)
                if not self.bool_Slider_Engaged:
                    ''' Report the error '''
                    str_MessageBox_Text = 'With Allele Frequency Distribution = ' + object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES + ', the number of loci cannot be changed.\n\n' + 'To change the number of loci please select a different Allele Frequency Distribution.'
                    QtGui.QMessageBox.critical(self, 'Cannot change number of loci', str_MessageBox_Text, QtGui.QMessageBox.Ok)
                pass
                return int_Value
            elif self.str_Genome_Allele_Frequency_Distribution == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP and\
               int_Value != self.int_Genome__Source_GENEPOP__Total_Loci:
                ''' Reset the widget to the correct value '''
                int_Value = self.int_Genome__Source_GENEPOP__Total_Loci
                self.horizontalSlider_38.setValue(int_Value)
                if not self.bool_Slider_Engaged:
                    ''' Report the error '''
                    str_MessageBox_Text = 'With Allele Frequency Distribution = ' + object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP + ', the number of loci cannot be changed.\n\n' + 'To change the number of loci please select a different Allele Frequency Distribution.'
                    QtGui.QMessageBox.critical(self, 'Cannot change number of loci', str_MessageBox_Text, QtGui.QMessageBox.Ok)
                pass
                return int_Value
            pass
                
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_30'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Genome_Locus_Number(int_Value, bool_Save)
                pass
            pass
        pass           
        return int_Value
    
    def func_QSpinBox__Scenario_Genome_Locus_Number__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_30.value()
        self.horizontalSlider_38.setValue(int_Value)
         
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
                ''' If change is NOT detected then dont Save '''        
                if self.int_Genome_Locus_Number == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes '''                 
                self.func_Update__Genome_Locus_Number(int_Value, bool_Save)
                pass

            pass
        pass             
        return True

    def func_QHorizontalSlider__Scenario_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        #int_Slider_Value = self.horizontalSlider_40.value()
        self.spinBox_29.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_35.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_29'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus(int_Value, bool_Save)
                pass
            pass
        pass             
        return int_Value

    def func_QSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_29.value()
        self.horizontalSlider_35.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
#                 ''' If change is NOT detected then dont Save '''        
#                 if self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus == int_Value:
#                     bool_Save = False
#                 else:
#                     ''' Save '''                
#                     bool_Save = True
#                 pass
                bool_Save = True
                ''' Update widgets and config with changes ''' 
                self.func_Update__Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus(int_Value, bool_Save)
                pass 
            pass
        pass             
        return int_Value

    def func_QHorizontalSlider__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        floatScaled_Value = float(int_Value)/float(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Step_Divisor)
        self.doubleSpinBox_7.setValue(floatScaled_Value)
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '; int_Value:' + str(int_Value) + '; floatScaled_Value: ' + str(floatScaled_Value))
        #DEBUG_OFF        
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QDoubleSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__SetValue(self, float_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        intScaled_Value = int(round(float_Value*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Step_Divisor,0))
        self.horizontalSlider_37.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'doubleSpinBox_7'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus(float_Value, bool_Save)
                pass
            pass
        pass     
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     #self.func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus(intScaled_Value, bool_Save)
#                     self.func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus(float_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return float_Value

    def func_QDoubleSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        float_Value = self.doubleSpinBox_7.value()
        intScaled_Value = int(round(float_Value*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Step_Divisor,0))
        self.horizontalSlider_37.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
                ''' If change is NOT detected then dont Save '''        
                if self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus == float_Value :
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus(float_Value, bool_Save)
                pass 
            pass
        pass             
        return float_Value

    def func_QHorizontalSlider__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        floatScaled_Value = float(int_Value)/float(self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor)
        self.doubleSpinBox_8.setValue(floatScaled_Value)
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '; int_Value:' + str(int_Value) + '; floatScaled_Value: ' + str(floatScaled_Value))
        #DEBUG_OFF        
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QDoubleSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__SetValue(self, float_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        intScaled_Value = int(round(float_Value*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor,0))
        self.horizontalSlider_42.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'doubleSpinBox_8'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus(float_Value, bool_Save)
                pass
            pass
        pass    
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus(float_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return float_Value

    def func_QDoubleSpinBox__Scenario_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        float_Value = self.doubleSpinBox_8.value()
        intScaled_Value = int(round(float_Value*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor,0))
        self.horizontalSlider_42.setValue(intScaled_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
                ''' If change is NOT detected then dont Save '''        
                if self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus == float_Value :
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus(float_Value, bool_Save)
                pass
            pass
        pass             
        return float_Value

    '''
    ----------------------------
    QToolBox - Index 2
    ----------------------------
    '''    
    '''
    ----------------------------
    Scenario - Simulation widgets
    ----------------------------
    '''     
    def func_QHorizontalSlider__Scenario_Simulation_Batch_Replicates__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        #int_Slider_Value = self.horizontalSlider_31.value()
        self.spinBox_37.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Scenario_Simulation_Batch_Replicates__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_45.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_37'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Simulation_Batch_Replicates(int_Value, bool_Save)
                pass
            pass
        pass          
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Simulation_Batch_Replicates(int_Value, bool_Save)
#                 pass
#             pass
#         pass             
        return int_Value

    def func_QSpinBox__Scenario_Simulation_Batch_Replicates__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_37.value()
        self.horizontalSlider_45.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
                ''' If change is NOT detected then dont Save '''        
                if self.int_Simulation_Batch_Replicates == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Simulation_Batch_Replicates(int_Value, bool_Save)
                pass 
            pass
        pass             
        return int_Value

    def func_QHorizontalSlider__Scenario_Simulation_Batch_Replicate_Length_Burn_In__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        #int_Slider_Value = self.horizontalSlider_31.value()
        self.spinBox_38.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Scenario_Simulation_Batch_Replicate_Length_Burn_In__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:        
                ''' Substitute a multimple of the Max Age - num - (num%divisor) ie. rounded down to the nearest multiple of MaxAge'''
                int_Value = int_Value - (int_Value%self.int_Species_Life_History_Max_Age)
                self.spinBox_38.setValue(int_Value)
            pass
        pass
        self.horizontalSlider_46.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_38'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Simulation_Batch_Replicate_Length_Burn_In(int_Value, bool_Save)
                    if bool_Save:
                        int_Value__Temporal_Evolution = int(self.spinBox_39.value())
                        self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts(int_Value + int_Value__Temporal_Evolution, bool_Save)
                        self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count(int_Value + int_Value__Temporal_Evolution, bool_Save)                    
                    pass 
            pass
        pass          
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Simulation_Batch_Replicate_Length_Burn_In(int_Value, bool_Save)
#                     int_Value__Temporal_Evolution = int(self.spinBox_39.value())
#                     self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts(int_Value + int_Value__Temporal_Evolution, bool_Save)
#                     self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count(int_Value + int_Value__Temporal_Evolution, bool_Save)                    
#                 pass
#             pass
#         pass             
        return int_Value

    def func_QSpinBox__Scenario_Simulation_Batch_Replicate_Length_Burn_In__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_38.value()
        self.horizontalSlider_46.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
                ''' If change is NOT detected then dont Save '''        
                if self.int_Simulation_Batch_Replicate_Length_Burn_In == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Simulation_Batch_Replicate_Length_Burn_In(int_Value, bool_Save)
                if bool_Save:
                    int_Value__Temporal_Evolution = int(self.spinBox_39.value())
                    self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts(int_Value + int_Value__Temporal_Evolution, bool_Save)
                    self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count(int_Value + int_Value__Temporal_Evolution, bool_Save)                    
                pass 
            pass
        pass             
        return int_Value


    def func_QHorizontalSlider__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        #int_Slider_Value = self.horizontalSlider_31.value()
        self.spinBox_39.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:        
                ''' Substitute a multimple of the Max Age - num - (num%divisor) ie. rounded down to the nearest multiple of MaxAge'''
                int_Value = int_Value - (int_Value%self.int_Species_Life_History_Max_Age)
                self.spinBox_39.setValue(int_Value)
            pass
        pass        
        self.horizontalSlider_47.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                str_Object_Name = 'spinBox_39'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                #self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    #self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution(int_Value, bool_Save)
                    if bool_Save:
                        int_Value__Burn_In = int(self.spinBox_38.value())
                        self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts(int_Value + int_Value__Burn_In, bool_Save)
                        self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count(int_Value + int_Value__Burn_In, bool_Save) 
                    pass 
            pass
        pass          
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution(int_Value, bool_Save)
#                     int_Value__Burn_In = int(self.spinBox_38.value())
#                     self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts(int_Value + int_Value__Burn_In, bool_Save)
#                     self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count(int_Value + int_Value__Burn_In, bool_Save)                    
# 
#                 pass
#             pass
#         pass             
        return int_Value

    def func_QSpinBox__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution__EditingFinished(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Value = self.spinBox_39.value()
        self.horizontalSlider_47.setValue(int_Value)
        
        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                
                ''' If change is NOT detected then dont Save '''        
                if self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution == int_Value:
                    bool_Save = False
                else:
                    ''' Save '''                
                    bool_Save = True
                pass
                ''' Update widgets and config with changes ''' 
                self.func_Update__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution(int_Value, bool_Save)
                if bool_Save:
                    int_Value__Burn_In = int(self.spinBox_38.value())
                    self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts(int_Value + int_Value__Burn_In, bool_Save)
                    self.func_Update__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count(int_Value + int_Value__Burn_In, bool_Save) 
                pass 
            pass
        pass             
        return int_Value

    def func_QToolButton__Get_Scenario_Simulation_Output_Path__Clicked(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        bool_Continue = False
        str_Object_Name = 'toolButton_4'
        qWidget_Engaged = self.findChild(QtGui.QToolButton, str_Object_Name)
         
        ''' Verify if the change can proceed '''
        if self.bool_Reload_Widgets_Finished__Batch_Scenario:
            list_Parameter_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            ''' Verify if the change can proceed '''
            int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Parameter_Groups)
            if int_Verify_Change__Warning_Count < 1:
                ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                qWidget_Engaged.blockSignals(True)
                ''' Warn that other parameters that are dependent will have to be changed '''
                bool_Continue = self.func_Verify_Change__Can_Change_Proceed__ANY_Scenario_PARAMETER()
                qWidget_Engaged.blockSignals(False)
            else:
                bool_Continue = True
            pass
        else:
            bool_Continue = True
        pass
        if not bool_Continue:
            return True
        pass
    
        str_Start_Path = self.str_BackEnd_Working_Base_Path 
        if str_Start_Path != '':
            with FileHandler() as obj_FileOp:
                bool_Success = obj_FileOp.method_Path_Exists(str_Start_Path)
                if bool_Success:
                    pass
                else:
                    str_Start_Path = os__path.expanduser('~')
                pass
            pass
        pass
        
        str_Title = "Select the FOLDER that simulation output will be saved to:"
        bool_Cancelled, str_Path_Selected  = self.func_Select_Path_Dialog(str_Title, str_Start_Path)
        ''' Flag as User Edited '''
        if not bool_Cancelled:
            qWidget = self.label_31
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
        pass 
    
        self.str_BackEnd_Working_Base_Path = str(str_Path_Selected) #Convert QString to str
        
        ''' Workout max path length including the otput path '''
        str_Scenario_path = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current)
        self.str_BackEnd_Working_Path = os__path.join(self.str_BackEnd_Working_Base_Path, str_Scenario_path)

        int_Output_Path_Length = len(str_Scenario_path)
        int_Allowable_Length = 256 - (self.int_Settings_Run_BackEnd_Path_Max_Allowable_Length__Default_Value - int_Output_Path_Length)
        
        ''' Validate the size of the path - with respect to the max file length produced by the sim '''
        with FileHandler() as obj_FileOp:
            bool_Valid, int_Length_Difference = obj_FileOp.func_File_AndOr_Name_Length_Is_Valid(self.str_BackEnd_Working_Base_Path, int_Allowable_Length)
        pass
        
        if not bool_Valid:
            pass
            ''' msgbox saying invalid and by how much and restart the path sect dialog '''
            str_MessageBox_Text = str('Folder path is too long.' +
                                      '\n\n' +
                                      'The selected path will result in filenames that exceed the allowable length.'+
                                      '\n\n' +
                                      'Please reduce your path length by ' + str(int_Length_Difference) + ' characters by selecting a shorter path')
            qtmessagebox_Response = QtGui.QMessageBox.warning(self, 'Invalid folder selected', str_MessageBox_Text, buttons=QtGui.QMessageBox.Ok, defaultButton=QtGui.QMessageBox.NoButton)
            #(self, 'Invalid folder selected', str_MessageBox_Text, QtGui.QMessageBox.Ok, QtGui.QMessageBox.Ok)
            self.func_QToolButton__Get_Scenario_Simulation_Output_Path__Clicked()
        else:
        
            #self.str_BackEnd_Working_Path = str_Path_Selected
            self.str_Scenario_Run_Simulation_Working_Base_Path = self.str_BackEnd_Working_Base_Path
            self.str_Scenario_Run_Simulation_Output_Base_Path = self.str_BackEnd_Working_Path
            
            #self.lineEdit_16.setText(self.str_Scenario_Run_Simulation_Output_Base_Path)
            self.lineEdit_16.setText(self.str_BackEnd_Working_Base_Path)
             
            ''' Update the settings config file with the path '''
            self.func_Update_Config__Scenario_Run_Simulation_Working_Base_Path()
            self.func_Update_Config__Scenario_Run_Simulation_Output_Base_Path()
            self.bool_str_Scenario_Run_Simulation_Output_Base_Path__FOUND = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
        pass
        
        return True

    '''
    ----------------------------
    QToolBox - Index 6
    ----------------------------
    '''    
    '''
    ----------------------------
    Sampling Strategy - Create or Select Sampling Strategy
    ----------------------------
    '''
    def func_QRadioButton_EXISTING_SAMPLING_STRATEGY_FILE_Toggled(self):
        
        if self.radioButton_8.isChecked():
            self.lineEdit_21.setText('')
            self.lineEdit_22.setText('')
            
            self.checkBox.setChecked(False)
            
            self.stackedWidget_7.setCurrentIndex(0)
        return True
    
    def func_QRadioButton_NEW_SAMPLING_STRATEGY_FILE_Toggled(self):

        if self.radioButton_9.isChecked():
            ''' Prepare to edit the Sampling Strategy Name '''
            self.label_74.setText(self.str_Sampling_Strategy_Name__Label_Text + '*')
                    
            self.lineEdit_22.setText('')
            self.stackedWidget_7.setCurrentIndex(1)
            
            ''' Generate a default name for the new Sampling Strategy based on the current settings '''
            #str_Project_Name = self.str_Project_Name__Current
            str_Batch_Scenario_Name = self.str_Scenario_Name__Current
            int_Sampling_Strategy_Count = self.comboBox_310.count() + 1
            
            #str_Sampling_Strategy_Name_Default = str_Project_Name + '_' + str_Batch_Scenario_Name + '_' + globalsSSFE.Name.static_str__Name__Sampling_Strategy + str(int_Sampling_Strategy_Count)
            str_Sampling_Strategy_Name_Default = str_Batch_Scenario_Name + '_' + globalsSSFE.Name.static_str__Name__Sampling_Strategy + str(int_Sampling_Strategy_Count)
            self.lineEdit_21.setText(str_Sampling_Strategy_Name_Default)
            self.lineEdit_21.setFocus()
            self.lineEdit_21.selectAll()
            ''' Indicate that the text has changed - NOT NEEDED Beacuse the above setText sends this SIGNAL'''
            #self.func_QLineEdit__Sampling_Strategy_Name__Text_Changed()  

        pass

        return True
    
    def func_QRadioButton_CLONED_SAMPLING_STRATEGY_FILE_Toggled(self):

        if self.radioButton_10.isChecked():
            ''' Prepare to edit the Sampling Strategy Name '''        
            self.label_76.setText(self.str_Sampling_Strategy_Cloned_Name__Label_Text + '*')
            
            self.lineEdit_21.setText('')
            self.stackedWidget_7.setCurrentIndex(2)

            ''' Generate a default name for the new Sampling Strategy based on the current settings '''
            #str_Project_Name = self.str_Project_Name__Current
            str_Batch_Scenario_Name = self.str_Scenario_Name__Current
            int_Sampling_Strategy_Count = self.comboBox_310.count() + 1
            
            #str_Sampling_Strategy_Name_Default = str_Project_Name + '_' + str_Batch_Scenario_Name + '_' + globalsSSFE.Name.static_str__Name__Sampling_Strategy + str(int_Sampling_Strategy_Count)
            str_Sampling_Strategy_Name_Default = str_Batch_Scenario_Name + '_' + globalsSSFE.Name.static_str__Name__Sampling_Strategy + str(int_Sampling_Strategy_Count)
            self.lineEdit_22.setText(str_Sampling_Strategy_Name_Default)
            self.lineEdit_22.setFocus()
            self.lineEdit_22.selectAll()
            ''' Indicate that the text has changed '''
            self.func_QLineEdit__Sampling_Strategy_Name__Text_Changed()  
        
        pass
    
        return True

    def func_QCheckBox_DELETE_SAMPLING_STRATEGY_StateChanged(self, int_State):
        
        if self.checkBox.isChecked():
            self.radioButton_10.setEnabled(False)
            self.radioButton_9.setEnabled(False)
            self.radioButton_8.setEnabled(True)
            self.radioButton_8.setChecked(True)
            
            self.pushButton_5.setEnabled(True)
        else:
            self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex(), True)
            #self.pushButton_5.setEnabled(False) 
        pass
    
        return int_State
         
    def func_QComboBox_SAMPLING_STATEGIES_add(self, str_Batch_Scenario_Relative_Path_And_File__Current):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.list_Sampling_Strategy_Files = []
        self.list_Sampling_Strategy_Names = []
        
        if len(self.list_Scenario_Files) <= 0:
            self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex(),True)
            return False
        pass
    
        ''' Read BATCH SCENARIO file '''
        obj_Config = object_SSConfigBatchScenario()
        obj_Config = self.func_Read_Config_File(str_Batch_Scenario_Relative_Path_And_File__Current, obj_Config, True)

        '''NOTE: This assumes that the BATCH_SCENARIO config has just been read '''
        self.list_Sampling_Strategy_Files, self.list_Sampling_Strategy_Names = self.func_Get_Config_File_List_Of_SAMPLING_STRATEGIES_from_BATCH_SCENARIO(obj_Config)

        ''' Load the comboboxes with all the items '''
        ''' Block signals so that downstream events dont trigger '''
        bool_Block_Signals = True
        self.comboBox_311.blockSignals(bool_Block_Signals)
        self.comboBox_320.blockSignals(bool_Block_Signals)
        self.comboBox_300.blockSignals(bool_Block_Signals)
        self.comboBox_310.blockSignals(bool_Block_Signals)

        
        ''' THIS IS THE MASTER COMBOBOX that controls all other SLAVE comboboxes '''
        ''' Load Sampling Strategy FILE comboboxes '''
        self.comboBox_300.clear()
        self.comboBox_300.addItems(self.list_Sampling_Strategy_Files)

        ''' These are SLAVE comboboxes driven by what the MASTER does '''
        ''' Load Sampling Strategy Name comboboxes '''
        self.comboBox_310.clear()
        self.comboBox_310.addItems(self.list_Sampling_Strategy_Names)         
        self.comboBox_311.clear()
        self.comboBox_311.addItems(self.list_Sampling_Strategy_Names)

        ''' Load Sampling Strategy CLONE Name comboboxes '''
        self.comboBox_320.clear()
        self.comboBox_320.addItems(self.list_Sampling_Strategy_Names)        

        ''' Now the comboboxes have been loaded...'''
        ''' ...Allow signals and events to resume '''
        bool_Block_Signals = False
        self.comboBox_311.blockSignals(bool_Block_Signals)
        self.comboBox_320.blockSignals(bool_Block_Signals)
        self.comboBox_300.blockSignals(bool_Block_Signals)
        self.comboBox_310.blockSignals(bool_Block_Signals)
                
        ''' ...get the number of loaded items '''
        int_Index = self.comboBox_300.count() - 1
        
        ''' ...ensure the new / last item is selected '''
        if int_Index > 0:
            ''' 
            setCurrentIndex fires the currentIndexChanged signal
            but only when setting it to an index other than its current one
            
            Updates to associated comboboxes are then automatically triggered
            '''  
            self.comboBox_300.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one
            
        else:
            '''
            When there is only 1 item in the combo the setCurrentIndex doesnt fire
            because changing the index to the same index is ignored
            so run the desred events manually
            '''
            self.func_QComboBox_SAMPLING_STRATEGY_FILE_Selected(int_Index)
        pass 
    
        self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex(), True)
               
        return True    
   
    def func_QComboBox_SAMPLING_STRATEGY_FILE_Selected(self, int_Index):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        ''' THIS IS THE MASTER COMBOBOX that controls all other SLAVE comboboxes ''' 
        if self.comboBox_300.currentText():
            str_Sampling_Strategy_Relative_Path_And_File__Current = str(self.comboBox_300.currentText())
            _, str_Sampling_Strategy_Filename__Current = os__path.split(str_Sampling_Strategy_Relative_Path_And_File__Current)
            
            self.lineEdit_18.setText(str_Sampling_Strategy_Filename__Current)
            
            ''' These are SLAVE comboboxes driven by what the MASTER does '''
            ''' Trigger signal to update the Sampling_Strategy_Name comboBox with the same item'''
            self.comboBox_310.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one 
            self.comboBox_311.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one 
            self.comboBox_320.setCurrentIndex(int_Index) # setCurrentIndex fires the currentIndexChanged signal but only when setting it to an index other than its current one 

            ''' Load the appropriate data into all the widgets '''
            self.func_Populate_Widgits_With_Config_Data__SAMPLING_STRATEGY(str_Sampling_Strategy_Relative_Path_And_File__Current)

            if self.toolBox.currentIndex() == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Sampling_Strategy:
                self.func_Display_Results__Sampling_Strategy__View_Results__Refresh_Text_Browser()
            pass
        
            self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex(), True)
        pass
        return int_Index
 
    def func_Display_Results__Sampling_Strategy__View_Results__Refresh_Text_Browser_RETIRE(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        str_FrontEnd_Sampling_Strategy_Folder__Current = self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str(self.int_Sampling_Strategy_UID__Current)
        str_FrontEnd_Sampling_Strategy_Folder__Results = self.str_Settings_Run_Results_Folder_Prefix__Default_Value + '_' + self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str(self.int_Sampling_Strategy_UID__Current)
        str_FrontEnd_Results_Path = os__path.join(self.str_Batch_Scenario_Path__Current, str_FrontEnd_Sampling_Strategy_Folder__Current, str_FrontEnd_Sampling_Strategy_Folder__Results)
        
        bool_Files_Found, list_Path_And_Files__Plots, list_Captions__Plots = self.func_Display_Results__Get_Results_Plots(str_FrontEnd_Results_Path, bool_Error_On_Files_Not_Found = False, bool_Search_Sub_Folders = False)
        
        str_FrontEnd_Results_Thumbs_Path = os__path.join(str_FrontEnd_Results_Path, self.str_Settings_Run_Results_Thumbnail_Images_Folder_Prefix__Default_Value)
        bool_Files_Found, list_Path_And_Files__Thumbs, list_Captions__Thumbs = self.func_Display_Results__Get_Results_Plots(str_FrontEnd_Results_Thumbs_Path, bool_Error_On_Files_Not_Found = False, bool_Search_Sub_Folders = False)
        
        bool_Success = bool_Files_Found
        
        if bool_Files_Found:
            self.list_Path_And_Files__Sampling_Strategy__Results_Plots = list(list_Path_And_Files__Plots)
            self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Captions = list(list_Captions__Plots)
            self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Thumbs = list(list_Path_And_Files__Thumbs)
            
            ''' Embed desired thumbnail in textBrowser '''
            str_Path_And_Thumb = list_Path_And_Files__Thumbs[len(list_Path_And_Files__Thumbs)-1]
            textBrowser = self.textBrowser_3
            bool_Success = self.func_Display_Results__Insert_TextBrowser_Image(textBrowser, str_Path_And_Thumb)
            
            self.pushButton_14.setEnabled(True)             
            self.pushButton_13.setEnabled(True)             
            pass
        else:
            self.pushButton_14.setEnabled(False)
            self.pushButton_13.setEnabled(False)
        pass        
        
    def func_Display_Results__Sampling_Strategy__View_Results__Refresh_Text_Browser(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        str_FrontEnd_Sampling_Strategy_Folder__Current = self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str(self.int_Sampling_Strategy_UID__Current)
        str_FrontEnd_Sampling_Strategy_Folder__Results = self.str_Settings_Run_Results_Folder_Prefix__Default_Value + '_' + self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str(self.int_Sampling_Strategy_UID__Current)
        str_FrontEnd_Results_Path = os__path.join(self.str_Batch_Scenario_Path__Current, str_FrontEnd_Sampling_Strategy_Folder__Current, str_FrontEnd_Sampling_Strategy_Folder__Results)
        
        bool_Files_Found, list_Path_And_Files__Plots, list_Captions__Plots = self.func_Display_Results__Get_Results_Plots(str_FrontEnd_Results_Path, bool_Error_On_Files_Not_Found = False, bool_Search_Sub_Folders = False)
        
        str_FrontEnd_Results_Thumbs_Path = os__path.join(str_FrontEnd_Results_Path, self.str_Settings_Run_Results_Thumbnail_Images_Folder_Prefix__Default_Value)
        bool_Files_Found, list_Path_And_Files__Thumbs, list_Captions__Thumbs = self.func_Display_Results__Get_Results_Plots(str_FrontEnd_Results_Thumbs_Path, bool_Error_On_Files_Not_Found = False, bool_Search_Sub_Folders = False)
        
        bool_Success = bool_Files_Found
        
        if bool_Files_Found:
            self.list_Path_And_Files__Sampling_Strategy__Results_Plots = list(list_Path_And_Files__Plots)
            self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Captions = list(list_Captions__Plots)
            self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Thumbs = list(list_Path_And_Files__Thumbs)
            
            ''' Embed desired thumbnail in textBrowser '''
            self.str_Path_And_Thumb_Displayed__Sampling_Strategy = list_Path_And_Files__Thumbs[len(list_Path_And_Files__Thumbs)-1]
            textBrowser = self.textBrowser_3
            bool_Success = self.func_Display_Results__Insert_TextBrowser_Image(textBrowser, self.str_Path_And_Thumb_Displayed__Sampling_Strategy)
            
            if not self.bool_Results_Window_Displayed:
                self.pushButton_14.setEnabled(True)  
            pass           
            self.pushButton_13.setEnabled(True) 
            
            if len(list_Path_And_Files__Thumbs) > 1:
                self.pushButton_16.setEnabled(True)
                self.pushButton_17.setEnabled(True)
            pass
            self.pushButton_20.setEnabled(True)                                   
            pass
        else:
            if not self.bool_Results_Window_Displayed:
                self.pushButton_14.setEnabled(False)
            pass
            self.pushButton_13.setEnabled(False)
            
            self.pushButton_16.setEnabled(False)
            self.pushButton_17.setEnabled(False)
            self.pushButton_20.setEnabled(False)                    
        pass
        
        return True 
        
        
    def func_QComboBox_SAMPLING_STRATEGY_NAME_Selected(self, int_Index):

        if self.comboBox_310.currentText():
            self.str_Sampling_Strategy_Name__Current = str(self.comboBox_310.currentText())
            
            self.lineEdit_19.setText(self.str_Sampling_Strategy_Name__Current)
            self.bool_Changed_Config__Sampling_Strategy = True
                         
            ''' Trigger signal to update the Scenario_File comboBox with the same item'''
            self.comboBox_300.setCurrentIndex(int_Index)
        pass
           
        return int_Index

    def func_QComboBox_SAMPLING_STRATEGY_Clone_NAME_Selected(self, int_Index):
        
        if self.comboBox_320.currentText():
            self.str_Sampling_Strategy_Name__Current = unicode(self.comboBox_320.currentText())
            self.lineEdit_19.setText(self.str_Sampling_Strategy_Name__Current)
            self.bool_Changed_Config__Sampling_Strategy = True
                        
            ''' Trigger signal to update the Scenario_File comboBox with the same item'''
            #self.comboBox_300.setCurrentIndex(int_Index)
        pass
        pass
        return int_Index

#     def func_QComboBox_SAMPLING_STRATEGY_NAME_Page_Modify_Strategy_Selected(self, int_Index):
# 
#         if self.comboBox_310.currentText():
#             ''' Trigger signal to update the Scenario_File comboBox with the same item'''
#             self.comboBox_300.setCurrentIndex(int_Index)
#         pass
    
    def func_QLineEdit__Sampling_Strategy_Name__Text_Changed(self):
        
        if self.lineEdit_21.text():
            self.label_74.setText(self.str_Sampling_Strategy_Name__Label_Text)
        else:
            self.label_74.setText(self.str_Sampling_Strategy_Name__Label_Text + '*')
        pass    
            
        if self.lineEdit_22.text():
            self.label_76.setText(self.str_Sampling_Strategy_Cloned_Name__Label_Text)
        else:
            self.label_76.setText(self.str_Sampling_Strategy_Cloned_Name__Label_Text + '*')
        pass    
            
        if self.lineEdit_21.text() and self.radioButton_9.isChecked():
            #self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            self.pushButton_5.setEnabled(True)
        elif self.lineEdit_22.text() and self.radioButton_10.isChecked():
            #self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            self.pushButton_5.setEnabled(True)
        else:
            #self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
            self.pushButton_5.setEnabled(False)            
        pass
    
        return True    
    
    '''
    ----------------------------
    QToolBox - Index 6
    ----------------------------
    '''    
    '''
    ----------------------------
    Sampling Strategy - Sample Size widgets
    ----------------------------
    '''
    def func_QHorizontalSlider__Sampling_Strategy_Sample_Range_Min__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.spinBox_40.setValue(int_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QSpinBox__Sampling_Strategy_Sample_Range_Min__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_48.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
                str_Object_Name = 'spinBox_40'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    self.func_Debug_Logging(False, 2, '; MIN - DONT UPDATE')
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Sampling_Strategy_Sample_Range_Min(int_Value, bool_Save)
#                 else:
                    self.func_Change__Sampling_Strategy_Sample_Range_Min(int_Value)
                pass
            pass
        pass    
            
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Sampling_Strategy_Sample_Range_Min(int_Value, bool_Save)
#                 pass
#             pass
#         pass
            
        return int_Value

    def func_QHorizontalSlider__Sampling_Strategy_Sample_Range_Max__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.spinBox_41.setValue(int_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QSpinBox__Sampling_Strategy_Sample_Range_Max__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_49.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
                str_Object_Name = 'spinBox_41'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    self.func_Debug_Logging(False, 2, '; UPDATE')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Sampling_Strategy_Sample_Range_Max(int_Value, bool_Save)
                else:
                    ''' Set the ranges for related sliders '''
                    self.func_Change__Sampling_Strategy_Sample_Range_Max(int_Value)
                pass                    
            pass
        pass           
    
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Sampling_Strategy_Sample_Range_Max(int_Value, bool_Save)
#                 pass
#             pass
#         pass
            
        return int_Value

    def func_QHorizontalSlider__Sampling_Strategy_Sample_Range_Increment__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.spinBox_42.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Sampling_Strategy_Sample_Range_Increment__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_50.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
                str_Object_Name = 'spinBox_42'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    self.func_Debug_Logging(False, 2, '; UPDATE')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Sampling_Strategy_Sample_Range_Increment(int_Value, bool_Save)
                else:
                    self.func_Change__Sampling_Strategy_Sample_Range_Increment(int_Value)
                pass
            pass
        pass           
        
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Sampling_Strategy_Sample_Range_Increment(int_Value, bool_Save)
#                 pass
#             pass
#         pass
            
        return int_Value

    '''
    ----------------------------
    Sampling Strategy - Locus Number widgets
    ----------------------------
    '''
    def func_QHorizontalSlider__Sampling_Strategy_Locus_Range_Min__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.spinBox_43.setValue(int_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QSpinBox__Sampling_Strategy_Locus_Range_Min__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_51.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
                str_Object_Name = 'spinBox_43'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    self.func_Debug_Logging(False, 2, '; MIN - DONT UPDATE')
                    ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Sampling_Strategy_Locus_Range_Min(int_Value, bool_Save)
#                 else:
                    self.func_Change__Sampling_Strategy_Locus_Range_Min(int_Value)
                pass
            pass
        pass             
#         if self        
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Sampling_Strategy_Locus_Range_Min(int_Value, bool_Save)
#                 pass
#             pass
#         pass
            
        return int_Value

    def func_QHorizontalSlider__Sampling_Strategy_Locus_Range_Max__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.spinBox_44.setValue(int_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Value

    def func_QSpinBox__Sampling_Strategy_Locus_Range_Max__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_52.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
                str_Object_Name = 'spinBox_44'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    self.func_Debug_Logging(False, 2, '; UPDATE')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Sampling_Strategy_Locus_Range_Max(int_Value, bool_Save)
                else:
                    self.func_Change__Sampling_Strategy_Locus_Range_Max(int_Value)
                pass
            pass
        pass             
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Sampling_Strategy_Locus_Range_Max(int_Value, bool_Save)
#                 pass
#             pass
#         pass
            
        return int_Value

    def func_QHorizontalSlider__Sampling_Strategy_Locus_Range_Increment__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.spinBox_45.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Sampling_Strategy_Locus_Range_Increment__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_53.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
                str_Object_Name = 'spinBox_45'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    self.func_Debug_Logging(False, 2, '; UPDATE')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Sampling_Strategy_Locus_Range_Increment(int_Value, bool_Save)
                else:
                    self.func_Change__Sampling_Strategy_Locus_Range_Increment(int_Value)
                pass
            pass
        pass            
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Sampling_Strategy_Locus_Range_Increment(int_Value, bool_Save)
#                 pass
#             pass
#         pass
            
        return int_Value

    '''
    ----------------------------
    QToolBox - Index 5
    ----------------------------
    '''    
    '''
    ----------------------------
    Sampling Strategy - Run Parameters
    ----------------------------
    '''
    def func_QComboBox_Sampling_Strategy_LDNe_PCrit_To_Get__Selected (self):

        if self.bool_Init_Finished:
            int_Index = self.comboBox_13.currentIndex()
            self.func_Sampling_Strategy_LDNe_PCrit_To_Get_Selection(int_Index)   
        pass
        return True

    def func_QHorizontalSlider__Sampling_Strategy_LDNe_Replicates__SetValue(self, int_Slider_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.spinBox_46.setValue(int_Slider_Value)
        '''
        NOTE: use eventFilter for the majority of the logic for this widget.
        It cant seem to cope with extended logic here.
        '''
        return int_Slider_Value

    def func_QSpinBox__Sampling_Strategy_LDNe_Replicates__SetValue(self, int_Value):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.horizontalSlider_54.setValue(int_Value)

        if self.bool_Init_Finished:
            if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
                str_Object_Name = 'spinBox_46'
                str_Object_Companion = self.str_Slider_Engaged_Name
                bool_Companion_Engaged = self.func_Linked_Slider_And_Spinbox__Companion_Engaged(str_Object_Name, str_Object_Companion)
                self.func_Debug_Logging(False, 2, '; bool_Companion_Engaged: ' + str(bool_Companion_Engaged) + '; str_Object_Name: ' + str_Object_Name + '; str_Object_Companion: ' + str_Object_Companion)
                if not bool_Companion_Engaged:
                    self.func_Debug_Logging(False, 2, '; UPDATE CONFIG')
                    ''' Update widgets and config with changes '''
                    bool_Save = True
                    self.func_Update__Sampling_Strategy_LDNe_Replicates(int_Value, bool_Save)
                pass
            pass
        pass            
#         if self.bool_Init_Finished:
#             if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
#                 #self.func_Debug_Logging(False, 2, '; self.bool_Slider_Engaged: ' + str(self.bool_Slider_Engaged))
#                 if not self.bool_Slider_Engaged:
#                     ''' Update widgets and config with changes '''
#                     bool_Save = True
#                     self.func_Update__Sampling_Strategy_LDNe_Replicates(int_Value, bool_Save)
#                 pass
#             pass
#         pass
            
        return int_Value

    def func_QToolButton__Get_Sampling_Strategy_Simulation_Output_Path__Clicked(self):
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        bool_Continue = False
        str_Object_Name = 'toolButton_5'
        qWidget_Engaged = self.findChild(QtGui.QToolButton, str_Object_Name)
         
        ''' Verify if the change can proceed '''
        if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
            list_Parameter_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            ''' Verify if the change can proceed '''
            int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Parameter_Groups)
            if int_Verify_Change__Warning_Count < 1:
                ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                qWidget_Engaged.blockSignals(True)
                ''' Warn that other parameters that are dependent will have to be changed '''
                bool_Continue = self.func_Verify_Change__Can_Change_Proceed__ANY_Sampling_Strategy_PARAMETER()
                qWidget_Engaged.blockSignals(False)
            else:
                bool_Continue = True
            pass
        else:
            bool_Continue = True
        pass
        
        if not bool_Continue:
            return True
        pass
                
        str_Start_Path = self.str_BackEnd_Working_Base_Path 
        if str_Start_Path != '':
            with FileHandler() as obj_FileOp:
                bool_Success = obj_FileOp.method_Path_Exists(str_Start_Path)
                if bool_Success:
                    pass
                else:
                    str_Start_Path = os__path.expanduser('~')
                pass
            pass
        pass

    
        str_Title = "Select the FOLDER that simulation output will be saved to:"
        bool_Cancelled, str_Path_Selected  = self.func_Select_Path_Dialog(str_Title, str_Start_Path)
        self.str_BackEnd_Working_Base_Path = str(str_Path_Selected) #Convert QString to str
        ''' Workout max path length including the otput path '''
#         str_Scenario_path = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current)
#         str_Sampling_Strategy_path = self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str(self.int_Sampling_Strategy_UID__Current)
#         self.str_BackEnd_Working_Path = os__path.join(self.str_BackEnd_Working_Base_Path, str_Scenario_path, str_Sampling_Strategy_path)
        

        str_Scenario_path = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current)
        self.str_BackEnd_Working_Path = os__path.join(self.str_BackEnd_Working_Base_Path, str_Scenario_path)

        #int_Output_Path_Length = len(os__path.join(str_Scenario_path, str_Sampling_Strategy_path))
        _, str_Sampling_Strategy_File_Name = os__path.split(self.str_Sampling_Strategy_Path_And_File__Current)
        str_Sampling_Strategy_File_Name_WO_EXt, _ = os__path.splitext(str_Sampling_Strategy_File_Name)
        int_Output_Path_Length = len(os__path.join(str_Scenario_path, str_Sampling_Strategy_File_Name_WO_EXt))
        int_Allowable_Length = 256 - (self.int_Settings_Run_BackEnd_Path_Max_Allowable_Length__Default_Value - int_Output_Path_Length)
        
        ''' Validate the size of the path - with respect to the max file length produced by the sim '''
        int_Allowable_Length = 256 - self.int_Settings_Run_BackEnd_Path_Max_Allowable_Length__Default_Value
        with FileHandler() as obj_FileOp:
            bool_Valid, int_Length_Difference = obj_FileOp.func_File_AndOr_Name_Length_Is_Valid(str_Path_Selected, int_Allowable_Length)
        pass
        
        if not bool_Valid:
            pass
            ''' msgbox saying invalid and by how much and restart the path sect dialog '''
            str_MessageBox_Text = str('Folder path is too long.' +
                                      '\n\n' +
                                      'The selected path will result in filenames that exceed the allowable length.'+
                                      '\n\n' +
                                      'Please reduce your path length by ' + str(int_Length_Difference) + ' characters by selecting a shorter path')
            qtmessagebox_Response = QtGui.QMessageBox.warning(self, 'Invalid folder selected', str_MessageBox_Text, buttons=QtGui.QMessageBox.Ok, defaultButton=QtGui.QMessageBox.NoButton)
            #(self, 'Invalid folder selected', str_MessageBox_Text, QtGui.QMessageBox.Ok, QtGui.QMessageBox.Ok)
            self.func_QToolButton__Get_Sampling_Strategy_Simulation_Output_Path__Clicked()
        else:
        
            #self.str_BackEnd_Working_Path = str_Path_Selected
            self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path = self.str_BackEnd_Working_Base_Path
            self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path = self.str_BackEnd_Working_Path

            self.lineEdit_17.setText(self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path)
            
            ''' Update the settings config file with the path '''
            self.func_Update_Config__Sampling_Strategy_Run_Simulation_Working_Base_Path()
            self.func_Update_Config__Sampling_Strategy_Run_Simulation_Output_Base_Path()
            self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__FOUND = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
        pass
        
        return True


    def func_QHorizontalSlider_ActionTriggered_RETIRE(self, int_Action):
    
        #DEBUG_ON
        str_Signal = 'actionTriggered'
#         print(str_Signal + ' = ' + str(int_Action))
#         #DEBUG_OFF
#         if int_Action == QtGui.QAbstractSlider.SliderMove:
#             pos = QtGui.QStyle.sliderPositionFromValue(self.horizontalSlider_31.minimum(), self.horizontalSlider_31.maximum(), int_Action, self.horizontalSlider_31.width())
#             val = QtGui.QStyle.sliderValueFromPosition (self.horizontalSlider_31.minimum(), self.horizontalSlider_31.maximum(), int_Action, self.horizontalSlider_31.width())
#             print(str_Signal + ' = ' + str(int_Action) + ' = SliderMove' + '; pos = '+ str(pos))
#             
#         pass
    
        return True

    def func_QHorizontalSlider_SliderMoved_RETIRE(self):
    
        #DEBUG_ON
        str_Signal = 'sliderMoved'
        print(str_Signal)
        #DEBUG_OFF
        
        return True
    
    def func_QHorizontalSlider_ValueChanged_RETIRE(self):
    
        #DEBUG_ON
        str_Signal = 'valueChanged'
        print(str_Signal)
        #DEBUG_OFF
        
        return True
    
    def func_QHorizontalSlider_SliderPressed_RETRIE(self):
    
        #DEBUG_ON
        str_Signal = 'sliderPressed'
        print(str_Signal)
        #DEBUG_OFF
        
        return True
    
    def func_QHorizontalSlider_SliderReleased_RETIRE(self, event):
    
        #DEBUG_ON
        str_Signal = 'sliderReleased'
        print(str_Signal)
        #DEBUG_OFF

        val = QtGui.QStyle.sliderValueFromPosition (self.horizontalSlider_31.minimum(), self.horizontalSlider_31.maximum(), event.x(), self.horizontalSlider_31.width())
        print(str_Signal + ' = SliderMove' + '; val = '+ str(val))
        
        
        return True
    
    def func_QHorizontalSlider_MouseMoveEvent_RETIRE(self, event):
    
        #DEBUG_ON
        str_Signal = 'mouseMoveEvent'
        print(str_Signal)
        #DEBUG_OFF
        
        #QtGui.QCursor.pos()
        #self.emit(QtCore.SIGNAL("valueChanged(int)"),"hi from thread")
        #self.emit(QtCore.SIGNAL("valueChanged(int)"))

        val = QtGui.QStyle.sliderValueFromPosition (self.horizontalSlider_31.minimum(), self.horizontalSlider_31.maximum(), event.x(), self.horizontalSlider_31.width())
        print(str_Signal + ' = SliderMove' + '; val = '+ str(val))
        
        return True

    '''
    -------------------------------------------------------------------------------
    Save buttons
    -------------------------------------------------------------------------------
    '''
    def func_QPushButton_Clicked__Save_Project_And_Scenario(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        #self.pushButton.setEnabled(False) #<-- NOTE: Dont do this.  It causes the pushButton Clicked event to occur again!?
       
        ''' Create the Project and SCENARIO files as specified '''
        if self.radioButton.isChecked() and self.radioButton_5.isChecked():
            if self.checkBox_2.isChecked():
                str_Project_Relative_Path_And_File__To_Delete_From = str(self.comboBox_100.currentText())
                str_Batch_Scenario_Relative_Path_And_File__To_Delete = str(self.comboBox_200.currentText())
                str_Batch_Scenario_UID__To_Delete = str(self.int_Batch_Scenario_UID__Current)
                if len(self.list_Scenario_Files) > 1:
                    str_Message = "Deleting a Scenario is irriversible.\n\nThis will delete all the associated Sampling Strategies and results.\n\nAre you sure you want to delete this Scenario?" 
                    qmessagebox_Response = QtGui.QMessageBox.question(self, 'Delete Scenario', str_Message, buttons=QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, defaultButton=QtGui.QMessageBox.No)
                    if qmessagebox_Response == QtGui.QMessageBox.Yes:
                        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
                        self.func_Delete_Config__Batch_Scenario(str_Project_Relative_Path_And_File__To_Delete_From, str_Batch_Scenario_Relative_Path_And_File__To_Delete, str_Batch_Scenario_UID__To_Delete)
                        QtGui.QApplication.restoreOverrideCursor() 
                        ''' Read the Project file '''
                        str_Project_Relative_Path_And_File__Current = str(self.comboBox_100.currentText())
                        self.func_Populate_Widgits_With_Config_Data__PROJECT(str_Project_Relative_Path_And_File__Current)        
                        ''' Reload the SCENARIO comboboxes with the PROJECT-specific sceanrios '''
                        self.func_QComboBox_SCENARIOS_add(str_Project_Relative_Path_And_File__Current)
                    pass
                else:
                    str_Message = "Sorry, I'm not allowed to delete the last Scenario in the list.\n\nTo delete this particular Scenario, create a new one, and then delete this Scenario" 
                    QtGui.QMessageBox.information(self, 'Delete Scenario', str_Message, buttons=QtGui.QMessageBox.Ok, defaultButton=QtGui.QMessageBox.Ok)
                pass
            
                self.checkBox_2.setChecked(False)
                pass
            elif self.checkBox_3.isChecked():
                str_Projects_Path_And_File__To_Delete_From = self.str_Application_Projects_Path_And_File
                str_Project_Relative_Path_And_File__To_Delete_From = str(self.comboBox_100.currentText())
                str_Project_UID__To_Delete = str(self.int_Project_UID)
                if len(self.list_Project_Files) > 1:
                    str_Message = "Deleting a Project is irriversible.\n\nThis will delete all the associated Scenarios, Sampling Strategies and results.\n\nAre you sure you want to delete this Project?" 
                    qmessagebox_Response = QtGui.QMessageBox.question(self, 'Delete Project', str_Message, buttons=QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, defaultButton=QtGui.QMessageBox.No)
                    if qmessagebox_Response == QtGui.QMessageBox.Yes:
                        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
                        self.func_Delete_Config__Project(str_Projects_Path_And_File__To_Delete_From, str_Project_Relative_Path_And_File__To_Delete_From, str_Project_UID__To_Delete)
                        QtGui.QApplication.restoreOverrideCursor() 
                        ''' Reload the PROJECT comboboxes  '''
                        self.func_QComboBox_PROJECTS_add(str_Projects_Path_And_File__To_Delete_From)
                        ''' Read the Project file '''
                        str_Project_Relative_Path_And_File__Current = str(self.comboBox_100.currentText())
                        self.func_Populate_Widgits_With_Config_Data__PROJECT(str_Project_Relative_Path_And_File__Current)        
                        ''' Reload the SCENARIO comboboxes with the PROJECT-specific sceanrios '''
                        self.func_QComboBox_SCENARIOS_add(str_Project_Relative_Path_And_File__Current)
                    pass
                else:
                    str_Message = "Sorry, I'm not allowed to delete the last Project in the list.\n\nTo delete this particular Project, create a new one, and then delete this Project" 
                    QtGui.QMessageBox.information(self, 'Delete Project', str_Message, buttons=QtGui.QMessageBox.Ok, defaultButton=QtGui.QMessageBox.Ok)
                pass
                
                self.checkBox_3.setChecked(False)
                pass
            pass 
        elif self.radioButton_2.isChecked() and self.radioButton_4.isChecked():
            str_Project_Name = str(self.lineEdit_4.text())
            str_Project_Species_Name = str(self.lineEdit_13.text())
            str_Scenario_Name = str(self.lineEdit_5.text())
            QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
            self.func_Create_New_PROJECT_and_SCENARIO(str_Project_Name, str_Project_Species_Name, str_Scenario_Name)
            QtGui.QApplication.restoreOverrideCursor() 
            
        elif self.radioButton.isChecked() and self.radioButton_4.isChecked():
            str_Project__Relative_Path_And_File = str(self.comboBox_100.currentText())
            str_Scenario_Name = str(self.lineEdit_5.text())
            QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
            self.func_Create_New_SCENARIO(str_Project__Relative_Path_And_File, str_Scenario_Name)
            QtGui.QApplication.restoreOverrideCursor() 
            
        elif self.radioButton.isChecked() and self.radioButton_3.isChecked():
            str_Project__Relative_Path_And_File__Current = str(self.comboBox_100.currentText())
            str_Batch_Scenario__Relative_Path_And_File__To_Clone = str(self.comboBox_220.currentText())
            str_Scenario_Name = str(self.lineEdit_8.text())
            QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
            self.func_Create_New_Cloned_SCENARIO(str_Project__Relative_Path_And_File__Current, str_Batch_Scenario__Relative_Path_And_File__To_Clone, str_Scenario_Name)
            QtGui.QApplication.restoreOverrideCursor()  
            
        elif self.radioButton_2.isChecked() and self.radioButton_3.isChecked():
            str_Project_Name = str(self.lineEdit_4.text())
            str_Project_Species_Name = str(self.lineEdit_13.text())
            str_Scenario_Path_File = os__path.join(self.str_Application_Projects_Path, str(self.comboBox_220.currentText()))
            str_Scenario_Name = str(self.lineEdit_8.text())
            QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
            self.func_Create_New_PROJECT_And_Cloned_SCENARIO(str_Project_Name, str_Project_Species_Name, str_Scenario_Path_File, str_Scenario_Name)
            QtGui.QApplication.restoreOverrideCursor()  
        pass
    
        self.bool_Changed_Config__Batch_Scenario = True

        if len(self.list_Scenario_Files) > 0:
            str_Batch_Scenario_Relative_Path_And_File__Current = str(self.comboBox_200.currentText())  
            self.func_Populate_Widgits_With_Config_Data__BATCH_SCENARIO(str_Batch_Scenario_Relative_Path_And_File__Current)
        pass
    
        if len(self.list_Sampling_Strategy_Files) > 0:
            str_Sampling_Strategy_Relative_Path_And_File__Current = str(self.comboBox_300.currentText())             
            self.func_Populate_Widgits_With_Config_Data__SAMPLING_STRATEGY(str_Sampling_Strategy_Relative_Path_And_File__Current)
        pass
    
        return True
    
    def func_QPushButton_Clicked__Edit_Age_Cohort_Mortality_Rates(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        dialog = Ui_Dialog_Age_Cohort_Mortality_Rates(self)
        dialog.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        ''' Show MODAL dialog '''
        dialog.exec_()
    
        return True
    
    def func_QPushButton_Clicked__Save_Modified_Scenario(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        obj_Config = self.obj_Config_Batch_Scenario
        str_Config_File_Relative_Path_And_Name = str(self.comboBox_200.currentText())
        if obj_Config != None:
            config_parser_Config = obj_Config.config_parser_Config
        
            if config_parser_Config != None:
                str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name)
                bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, str_Config_File_FULL_Path_And_Name)
                if bool_Success:
                    self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False
                else:
                    str_Message_Text = 'config_parser_Config could not be written to config file'
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass                   
            else:
                str_Message_Text = 'config_parser_Config = None'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            pass
        else:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
        pass    
    
        bool_Success = False
        obj_Config = self.obj_Config_Batch_Settings
        str_Config_File_Relative_Path_And_Name = self.str_Batch_Settings_Relative_Path_And_File__Current
        if obj_Config != None:
            config_parser_Config = obj_Config.config_parser_Config
        
            if config_parser_Config != None:
                str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name)
                bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, str_Config_File_FULL_Path_And_Name)
                if bool_Success:
                    self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False
                else:
                    str_Message_Text = 'config_parser_Config could not be written to config file'
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass                   
            else:
                str_Message_Text = 'config_parser_Config = None'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            pass
        else:
            str_Message_Text = 'self.obj_Config_Batch_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
        pass       
                     
        return True

    def func_QPushButton_Clicked__Run_Scenario(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        #self.int_Job_Run_Current_Processing_Step = globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM

        ''' Check if Run can proceed - Is a job still in progress? '''
        if self.int_Run_Status_Error_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL:
            #if self.int_Run_Status_Flag__Current > globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL and self.int_Run_Status_Flag__Current < globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED:
            if self.int_Run_Status_Flag__Current > globalsDCBGen.Run_Status.static_int_Run_Status__NO_JOB and self.int_Run_Status_Flag__Current < globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED:
                str_MessageBox_Text = 'A Batch Simulation Run (process ID: ' + str(self.int_Process_JOB_SHELL__PID) + ') is still in progress.  \n\n Please wait until it is complete,... \n\n or if absolutely necessary, kill the Job Run by closing the Console window.'
                messageBox_Reponse = QtGui.QMessageBox.information(self, 'Run Job?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Ok, defaultButton=QtGui.QMessageBox.Ok)
                return False
            pass
        pass

        ''' Check if Run can proceed - Will this overwrite an existing run? '''
        bool_Continue = False
        str_Object_Name = 'pushButton_11'
        qWidget_Engaged = self.findChild(QtGui.QPushButton, str_Object_Name)
                 
        ''' Verify if the change can proceed '''
        if self.bool_Reload_Widgets_Finished__Batch_Scenario:
            list_Parameter_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
            ''' Verify if the change can proceed '''
            int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Parameter_Groups)
            if int_Verify_Change__Warning_Count < 1:
                ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                qWidget_Engaged.blockSignals(True)
                ''' Warn that other parameters that are dependent will have to be changed '''
                bool_Continue = self.func_Verify_Change__Can_Change_Proceed__ANY_Scenario_PARAMETER()
                qWidget_Engaged.blockSignals(False)
            else:
                bool_Continue = True
            pass
        else:
            bool_Continue = True
        pass
        if not bool_Continue:
            return True
        pass
        
        ''' Check if Run can proceed - Are all edits complete? '''
        bool_Edits_Required = False
        str_Parameters_To_Edit = ''
        for key_Dict, value_Dict in self.dict_Parameter_Status.items():
            str_Object_Status = value_Dict[globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Status]
            if str_Object_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT:
                bool_Edits_Required = True
                str_Parameter_Label = value_Dict[globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Label]
                str_Parameters_To_Edit += str_Parameter_Label + ', '
            pass
        pass
        if bool_Edits_Required:
            str_Parameters_To_Edit = str_Parameters_To_Edit[:-2]
            str_MessageBox_Text = 'Hold your horses.  Before the Scenario can be run, some parameters need to be supplied:\n\n' + str_Parameters_To_Edit + '\n\nPlease go back and edit these parameters (marked with ' + globalsSSFE.Parameter_Status.static_str__Parameter_Status__FLAG__REQUIRES_USER_EDIT + ')...\n\n...then Save and try to run it again.'
            messageBox_Reponse = QtGui.QMessageBox.information(self, 'Run Scenario', str_MessageBox_Text, buttons=QtGui.QMessageBox.Ok, defaultButton=QtGui.QMessageBox.Ok)
            return False
        pass
    
        ''' Check if Run can proceed - Is the working path supplied and valid? '''
        self.str_BackEnd_Working_Path = self.str_Scenario_Run_Simulation_Output_Base_Path
        #if self.str_BackEnd_Working_Path == '' or not self.bool_str_Scenario_Run_Simulation_Output_Base_Path__FOUND:
        if self.str_BackEnd_Working_Path == '':
            self.func_QToolButton__Get_Scenario_Simulation_Output_Path__Clicked()
            #self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True  
#         else:
#             with FileHandler() as obj_FileOp:
#                 bool_Path_Found = obj_FileOp.method_Path_Exists(self.str_BackEnd_Working_Path)
#                 if not bool_Path_Found:
#                     self.func_QToolButton__Get_Scenario_Simulation_Output_Path__Clicked()
#                     self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True 
#                 pass 
#             pass

        pass 

        ''' Set the global processing set flag -  Must be after Verify Change checks which might set this to something else '''        
        self.int_Job_Run_Current_Processing_Step = globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM
       
        bool_Continue = False
        bool_Continue = self.func_Save_Check__Should_I_Save_And_Continue__Scenario()
        if bool_Continue:
            str_MessageBox_Text = str(
                                      'This job may take some time to run...' +
                                      '\n\n' +
                                      'Patience is a virtue...' +
                                      '\n\n' +
                                      'Good things come to those who wait...' +
                                      '\n\n' +
                                      'The job will start in a new terminal window. Please dont exit that window untill the run ends' +
                                      '\n\n' +
                                      'You can continue with other things in the meantime but job speed may be slowed by running other intensive tasks.' +
                                      '\n\n' +
                                      'Run Job?')
            qtmessagebox_Response = QtGui.QMessageBox.question(self, 'Run SCENARIO job?', str_MessageBox_Text, QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, QtGui.QMessageBox.No)
            if qtmessagebox_Response == QtGui.QMessageBox.No:
                str_Job_Status__Status_Message = 'Chicken? Go on give it a go!'
                self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
            else:
                str_Processing_Steps_CSV = str(self.int_Job_Run_Current_Processing_Step)
                bool_Success = self.func_Run_Scenarios(str_Processing_Steps_CSV)
            pass
        else:
            
            #self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOT_REQUESTED
            str_Job_Status__Status_Message = 'Please save all changes before running job.'
            self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
            
        pass
                     
        return True

    def func_QPushButton_Clicked__Edit_Age_Cohort_Sampling_Proportions(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        #dialog = QtGui.QDialog()
#         ui_dialog = Form_UI.Custom_Dialog()
#         ui_dialog.setupUi(dialog)      
        
        
        dialog = Ui_Dialog_Age_Cohort_Sampling_Proportions(self)
# #         dialog.ui = Ui_Dialog()
# #         dialog.ui.setupUi(dialog)
        dialog.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        
        dialog.exec_()
        
        return True
    
    def func_QPushButton_Clicked__Run_Sampling_Strategy(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        #self.int_Job_Run_Current_Processing_Step = globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT

    
        ''' Check if Run can proceed - Is a job still in progress? '''
        if self.int_Run_Status_Error_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL:
            #if self.int_Run_Status_Flag__Current > globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL and self.int_Run_Status_Flag__Current < globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED:
            if self.int_Run_Status_Flag__Current > globalsDCBGen.Run_Status.static_int_Run_Status__NO_JOB and self.int_Run_Status_Flag__Current < globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED:
                str_MessageBox_Text = 'A Batch Simulation Run (process ID: ' + str(self.int_Process_JOB_SHELL__PID) + ') is still in progress.  \n\n Please wait until it is complete,... \n\n or if absolutely necessary, kill the Job Run by closing the Console window.'
                messageBox_Reponse = QtGui.QMessageBox.information(self, 'Run Job?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Ok, defaultButton=QtGui.QMessageBox.Ok)
                return False
            pass
        pass

        ''' Check if Run can proceed - Will this overwrite an existing run? '''
        bool_Continue = False
        str_Object_Name = 'pushButton_12'
        qWidget_Engaged = self.findChild(QtGui.QPushButton, str_Object_Name)
         
        ''' Verify if the change can proceed '''
        if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
            list_Parameter_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
            ''' Verify if the change can proceed '''
            int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Parameter_Groups)
            if int_Verify_Change__Warning_Count < 1:
                ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                qWidget_Engaged.blockSignals(True)
                ''' Warn that other parameters that are dependent will have to be changed '''
                bool_Continue = self.func_Verify_Change__Can_Change_Proceed__ANY_Sampling_Strategy_PARAMETER()
                qWidget_Engaged.blockSignals(False)
            else:
                bool_Continue = True
            pass
        else:
            bool_Continue = True
        pass
        
        if not bool_Continue:
            return True
        pass
        
        ''' Check if Run scenario can proceed - Are all edits complete? '''
        bool_Edits_Required = False
        str_Parameters_To_Edit = ''
        for key_Dict, value_Dict in self.dict_Parameter_Status.items():
            str_Object_Status = value_Dict[globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Status]
            if str_Object_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT:
                bool_Edits_Required = True
                str_Parameter_Label = value_Dict[globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Label]
                str_Parameters_To_Edit += str_Parameter_Label + ', '
            pass
        pass
        if bool_Edits_Required:
            str_Parameters_To_Edit = str_Parameters_To_Edit[:-2]
            str_MessageBox_Text = 'Hold your horses.  Before the Sampling Strategy can be run, some parameters need to be supplied:\n\n' + str_Parameters_To_Edit + '\n\nPlease go back and edit these parameters (marked with ' + globalsSSFE.Parameter_Status.static_str__Parameter_Status__FLAG__REQUIRES_USER_EDIT + ')...\n\n...then Save and try to run it again.'
            messageBox_Reponse = QtGui.QMessageBox.information(self, 'Run Sampling Strategy', str_MessageBox_Text, buttons=QtGui.QMessageBox.Ok, defaultButton=QtGui.QMessageBox.Ok)
            return False
        pass
                
        ''' Check if Run can proceed - Is the working path supplied and valid? '''
        self.str_BackEnd_Working_Path = self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path
        #if self.str_BackEnd_Working_Path == '' or not self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__FOUND:
        if self.str_BackEnd_Working_Path == '':
            self.func_QToolButton__Get_Sampling_Strategy_Simulation_Output_Path__Clicked()
            #self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True             
#         else:
#             with FileHandler() as obj_FileOp:
#                 bool_Path_Found = obj_FileOp.method_Path_Exists(self.str_BackEnd_Working_Path)
#                 if not bool_Path_Found:
#                     self.func_QToolButton__Get_Sampling_Strategy_Simulation_Output_Path__Clicked()
#                     self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True 
#                 pass 
#             pass
        pass        

        ''' Set the global processing set flag -  Must be after Verify Change checks which might set this to something else '''        
        self.int_Job_Run_Current_Processing_Step = globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT
    
        bool_Continue = False
        bool_Continue = self.func_Save_Check__Should_I_Save_And_Continue__Sampling_Strategy()
        if bool_Continue:
            str_MessageBox_Text = str(
                                      'This job may take some time to run...' +
                                      '\n\n' +
                                      'Patience is a virtue...' +
                                      '\n\n' +
                                      'Good things come to those who wait...' +
                                      '\n\n' +
                                      'The job will start in a new terminal window. Please dont exit that window untill the run ends' +
                                      '\n\n' +
                                      'You can continue with other things in the meantime but job speed may be slowed by running other intensive tasks.' +
                                      '\n\n' +
                                      'Run Job?')
            qtmessagebox_Response = QtGui.QMessageBox.question(self, 'Run SAMPLING STRATEGY job?', str_MessageBox_Text, QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, QtGui.QMessageBox.No)
            if qtmessagebox_Response == QtGui.QMessageBox.No:
                str_Job_Status__Status_Message = 'Chicken? Go on give it a go!'
                self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
            else:
                str_Processing_Steps_CSV = str(self.int_Job_Run_Current_Processing_Step)
                bool_Success = self.func_Run_Scenarios(str_Processing_Steps_CSV)
            pass
        else:
            str_Job_Status__Status_Message = 'Please save all changes before running job.'
            self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
        pass

        return True

    def func_QPushButton_Clicked__Save_New_Sampling_Strategy(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        #self.pushButton.setEnabled(False) #<-- NOTE: Dont do this.  It causes the pushButton Clicked event to occur again!?

        str_Project_Relative_Path_And_File__Current = str(self.comboBox_100.currentText())  
        str_Batch_Scenario_Relative_Path_And_File__Current = str(self.comboBox_200.currentText())
        str_Sampling_Strategy_Relative_Path_And_File__Current = str(self.comboBox_300.currentText())  
              
        ''' Create the Project and SCENARIO files as specified '''
        if self.radioButton_8.isChecked():
            if self.checkBox.isChecked():
                str_Message = "Deleting a Sampling Strategy is irriversible.\n\nThis will delete all the associated results.\n\nAre you sure you want to delete this Sampling Strategy?" 
                qmessagebox_Response = QtGui.QMessageBox.question(self, 'Delete Sampling Strategy', str_Message, buttons=QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, defaultButton=QtGui.QMessageBox.No)
                if qmessagebox_Response == QtGui.QMessageBox.Yes:
                    str_Batch_Scenario_Relative_Path_And_File__To_Delete_From = str_Batch_Scenario_Relative_Path_And_File__Current
                    str_Sampling_Strategy_Relative_Path_And_File__To_Delete = str_Sampling_Strategy_Relative_Path_And_File__Current
                    str_Sampling_Strategy_UID__To_Delete = str(self.int_Sampling_Strategy_UID__Current)

                    QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
                    self.func_Delete_Config__Sampling_Strategy(str_Batch_Scenario_Relative_Path_And_File__To_Delete_From, str_Sampling_Strategy_Relative_Path_And_File__To_Delete, str_Sampling_Strategy_UID__To_Delete)
                    QtGui.QApplication.restoreOverrideCursor() 
                pass
            pass
        
            self.checkBox.setChecked(False) 
             
        elif self.radioButton_9.isChecked():
            str_Sampling_Strategy_Name = str(self.lineEdit_21.text())
            QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
            str_Batch_Scenario_Relative_Path_And_File__Current = str(self.comboBox_200.currentText())
            self.func_Create_New_SAMPLING_STRATEGY(str_Project_Relative_Path_And_File__Current, str_Batch_Scenario_Relative_Path_And_File__Current, str_Sampling_Strategy_Name)
            QtGui.QApplication.restoreOverrideCursor() 
        elif self.radioButton_10.isChecked():
            '''
            Get the text of the sampling strat to clone by mating the index of the ss clone combobox
            with the index of the available ss combobox and then
            get the relative filename of that SS from the available SS combobox
            ''' 
            int_Index = self.comboBox_320.currentIndex() 
            str_Sampling_Strategy_To_Clone_Relative_Path_File = str(self.comboBox_300.itemText(int_Index))
            #str_Sampling_Strategy_Relative_Path_And_File__Current = str(self.comboBox_300.currentText())  
            #str_Sampling_Strategy_To_Clone_Relative_Path_File = str_Sampling_Strategy_Relative_Path_And_File__Current
            
            str_Sampling_Strategy_Name = str(self.lineEdit_22.text())
            QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
            str_Batch_Scenario_Relative_Path_And_File__Current = str(self.comboBox_200.currentText())
            self.func_Create_New_Cloned_SAMPLING_STRATEGY(str_Project_Relative_Path_And_File__Current, str_Batch_Scenario_Relative_Path_And_File__Current, str_Sampling_Strategy_To_Clone_Relative_Path_File, str_Sampling_Strategy_Name)
            QtGui.QApplication.restoreOverrideCursor() 
        pass
    
        self.bool_Changed_Config__Sampling_Strategy = True

        ''' Reload config files to initialise all widgets '''
        ''' Load the options from the config file into the widgets '''
        str_Batch_Scenario_Relative_Path_And_File__Current = str(self.comboBox_200.currentText())  
        self.func_Populate_Widgits_With_Config_Data__BATCH_SCENARIO(str_Batch_Scenario_Relative_Path_And_File__Current)
        self.func_QComboBox_SAMPLING_STATEGIES_add(str_Batch_Scenario_Relative_Path_And_File__Current)
        
        str_Sampling_Strategy_Relative_Path_And_File__Current = str(self.comboBox_300.currentText())  
        self.func_Populate_Widgits_With_Config_Data__SAMPLING_STRATEGY(str_Sampling_Strategy_Relative_Path_And_File__Current)  
        
        return True

    def func_Delete_Config__Project(self, str_Projects_FULL_Path_And_File__To_Delete_From, str_Project_Relative_Path_And_File__To_Delete, str_Project_UID__To_Delete):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        
        ''' Remove mention of config from Batch Scenario config file '''
        '''
        ------------------------------------------
        Get Batch Scenario data from Current Project File
        ------------------------------------------
        '''
        ''' Read the Project file '''
        obj_Config = object_SSConfigProjects()
        obj_Config = self.func_Read_Config_File(str_Projects_FULL_Path_And_File__To_Delete_From, obj_Config, False)
        if obj_Config.config_parser_Config != None:
            bool_Success = True
        pass        

        '''
        ---------------------------------------------------
        UPDATE PROJECTS file - Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' Remove from Projects list of Projects by UID '''
        if bool_Success:
            bool_Success = False
            ''' >>>>>>>>> Projects_File_List '''
            str_Section = obj_Config.static_str_Section__Project_File_List
            str_Option = obj_Config.static_str_Option__Project_File + '_' + str_Project_UID__To_Delete
            bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_OPTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section, str_Option)
        pass
    
        if bool_Success:
            bool_Success = False
            ''' >>>>>>>>> Project_Name_List '''
            str_Section = obj_Config.static_str_Section__Project_Name_List
            str_Option = obj_Config.static_str_Option__Project_Name + '_' + str_Project_UID__To_Delete
            bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_OPTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section, str_Option)
        pass

        ''' Remove the SECTION if there are no more Projects '''
        list_Files, list_Names = self.func_Get_Config_File_List_Of_PROJECT_from_PROJECTS(obj_Config)
     
        if bool_Success:
            bool_Success = False
            if len(list_Files) == 0:
                str_Section = obj_Config.static_str_Section__Project_File_List
                bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
            else:
                bool_Success = True
            pass
        pass
 
        if bool_Success:
            bool_Success = False
            if len(list_Names) == 0:
                str_Section = obj_Config.static_str_Section__Project_Name_List
                bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
            else:
                bool_Success = True
            pass
        pass
    
        '''
        -------------------------------------
        Write modified PROJECTS config file
        -------------------------------------
        '''
        ''' Save the Projects config file '''
        if bool_Success:
            bool_Success = False
            str_Config_File_FULL_Path_And_Name = str_Projects_FULL_Path_And_File__To_Delete_From
            bool_Success = obj_Config.func_Write_Config_File(obj_Config.config_parser_Config, str_Projects_FULL_Path_And_File__To_Delete_From)
#             bool_Success = obj_Config.func_Write_Config_File(obj_Config.config_parser_Config, str_Project_Path_And_File__To_Delete_From)
        pass
    
        '''
        -------------------------------------
        Delete Batch Scenario config path and files
        -------------------------------------
        '''       
        if bool_Success:
            bool_Success = False
            with FileHandler() as obj_FileOp:
                str_Config_File_FULL_Path_And_Name__To_Delete = os__path.join(self.str_Application_Projects_Path, str_Project_Relative_Path_And_File__To_Delete)
                bool_File_Exists = obj_FileOp.fileExists(str_Config_File_FULL_Path_And_Name__To_Delete)
                if bool_File_Exists:
                    str_Path, _ = os__path.split(str_Config_File_FULL_Path_And_Name__To_Delete)
                    bool_Success = obj_FileOp.method_Delete_Path(str_Path)
                    if not bool_Success:
                        str_Message_Text = 'Unable to delete path: ' + str_Path
                        int_Stack_Trace_Level = 2
                        self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                        return False
                    pass
                else:
                    str_Message_Text = 'Non-existant file or path.  Cannot delete: ' + str_Config_File_FULL_Path_And_Name__To_Delete
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                    return False
                pass                
            pass
        else:
            str_Message_Text = 'Unable to delete config file and path: ' + str_Config_File_FULL_Path_And_Name__To_Delete + ' and unlink associated config files: ' + str_Config_File_FULL_Path_And_Name
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        return bool_Success
    
    def func_Delete_Config__Batch_Scenario(self, str_Project_Relative_Path_And_File__To_Delete_From, str_Batch_Scenario_Relative_Path_And_File__To_Delete, str_Batch_Scenario_UID__To_Delete):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        
        ''' Remove mention of config from Batch Scenario config file '''
        '''
        ------------------------------------------
        Get Batch Scenario data from Current Project File
        ------------------------------------------
        '''
        ''' Read the Project file '''
        obj_Config = object_SSConfigProject()
        obj_Config = self.func_Read_Config_File(str_Project_Relative_Path_And_File__To_Delete_From, obj_Config, True)
        if obj_Config.config_parser_Config != None:
            bool_Success = True
        pass        

        '''
        ---------------------------------------------------
        UPDATE PROJECT file - Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' Remove from Project list of Batch_Scenarios by BS UID '''
        if bool_Success:
            bool_Success = False
            ''' >>>>>>>>> Scenario_File_List '''
            str_Section = obj_Config.static_str_Section__Scenario_File_List
            str_Option = obj_Config.static_str_Option__Scenario_File + '_' + str_Batch_Scenario_UID__To_Delete
            bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_OPTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section, str_Option)
        pass
    
        if bool_Success:
            bool_Success = False
            ''' >>>>>>>>> Scenario_Name_List '''
            str_Section = obj_Config.static_str_Section__Scenario_Name_List
            str_Option = obj_Config.static_str_Option__Scenario_Name + '_' + str_Batch_Scenario_UID__To_Delete
            bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_OPTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section, str_Option)
        pass
    
        ''' Remove the SECTION if there are no more Batch Scenarios '''
        list_Files, list_Names = self.func_Get_Config_File_List_Of_SCENARIOS_from_PROJECT(obj_Config)
    
        if bool_Success:
            bool_Success = False
            if len(list_Files) == 0:
                str_Section = obj_Config.static_str_Section__Scenario_File_List
                bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
            else:
                bool_Success = True
            pass
        pass

        if bool_Success:
            bool_Success = False
            if len(list_Names) == 0:
                str_Section = obj_Config.static_str_Section__Scenario_Name_List
                bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
            else:
                bool_Success = True
            pass
        pass
    
        '''
        -------------------------------------
        Write modified PROJECT config file
        -------------------------------------
        '''
        ''' Save the PROJECT config file '''
        if bool_Success:
            bool_Success = False
            str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Project_Relative_Path_And_File__To_Delete_From)
            bool_Success = obj_Config.func_Write_Config_File(obj_Config.config_parser_Config, str_Config_File_FULL_Path_And_Name)
        pass
    
        '''
        -------------------------------------
        Delete Batch Scenario config path and files
        -------------------------------------
        '''       
        if bool_Success:
            bool_Success = False
            with FileHandler() as obj_FileOp:
                str_Config_File_FULL_Path_And_Name__To_Delete = os__path.join(self.str_Application_Projects_Path, str_Batch_Scenario_Relative_Path_And_File__To_Delete)
                bool_File_Exists = obj_FileOp.fileExists(str_Config_File_FULL_Path_And_Name__To_Delete)
                if bool_File_Exists:
                    str_Path, _ = os__path.split(str_Config_File_FULL_Path_And_Name__To_Delete)
                    bool_Success = obj_FileOp.method_Delete_Path(str_Path)
                    if not bool_Success:
                        str_Message_Text = 'Unable to delete path: ' + str_Path
                        int_Stack_Trace_Level = 2
                        self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                        return False
                    pass
                else:
                    str_Message_Text = 'Non-existant file or path.  Cannot delete: ' + str_Config_File_FULL_Path_And_Name__To_Delete
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                    return False
                pass                
            pass
        else:
            str_Message_Text = 'Unable to delete config file and path: ' + str_Config_File_FULL_Path_And_Name__To_Delete + ' and unlink associated config files: ' + str_Config_File_FULL_Path_And_Name
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
        
        return bool_Success
    
    def func_Delete_Config__Sampling_Strategy(self, str_Batch_Scenario_Relative_Path_And_File__To_Delete_From, str_Sampling_Strategy_Relative_Path_And_File__To_Delete, str_Sampling_Strategy_UID__To_Delete):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        
        ''' Remove mention of config from Batch Scenario config file '''
        '''
        ------------------------------------------
        Get Batch Scenario data from Current Batch Scenario File
        ------------------------------------------
        '''
        ''' Read the Batch Scenario file '''
        obj_Config = object_SSConfigBatchScenario()
        obj_Config = self.func_Read_Config_File(str_Batch_Scenario_Relative_Path_And_File__To_Delete_From, obj_Config, True)
        ''' Read the Batch Settings file using the Path and Filename from Batch Scenario '''
        if obj_Config.config_parser_Config != None:
            bool_Success = True
        pass        

        '''
        ---------------------------------------------------
        UPDATE BATCH_SCENARIO file - Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' Remove from Batch Scenario list of Sampling Strategies by SS UID '''
        if bool_Success:
            bool_Success = False
            ''' >>>>>>>>> Scenario_Sampling_Strategy_File_List '''
            str_Section = obj_Config.static_str_Section__Scenario_Sampling_Strategy_File_List
            str_Option = obj_Config.static_str_Option__Scenario_Sampling_Strategy_File + '_' + str_Sampling_Strategy_UID__To_Delete
            bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_OPTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section, str_Option)
        pass
    
        if bool_Success:
            bool_Success = False
            ''' >>>>>>>>> Scenario_Sampling_Strategy_Name_List '''
            str_Section = obj_Config.static_str_Section__Scenario_Sampling_Strategy_Name_List
            str_Option = obj_Config.static_str_Option__Scenario_Sampling_Strategy_Name + '_' + str_Sampling_Strategy_UID__To_Delete
            bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_OPTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section, str_Option)
        pass
    
        ''' Remove the SECTION if there are no more Sampling Strategies '''
        list_Files, list_Names = self.func_Get_Config_File_List_Of_SAMPLING_STRATEGIES_from_BATCH_SCENARIO(obj_Config)
    
        if bool_Success:
            bool_Success = False
            if len(list_Files) == 0:
                str_Section = obj_Config.static_str_Section__Scenario_Sampling_Strategy_File_List
                bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
            else:
                bool_Success = True
            pass
        pass
    
        if bool_Success:
            bool_Success = False
            if len(list_Names) == 0:
                str_Section = obj_Config.static_str_Section__Scenario_Sampling_Strategy_Name_List
                bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
            else:
                bool_Success = True
            pass
        pass
        '''
        -------------------------------------
        Write modified BATCH_SCENARIO config file
        -------------------------------------
        '''
        ''' Save the Batch Scenario config file '''
        if bool_Success:
            bool_Success = False
            str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Batch_Scenario_Relative_Path_And_File__To_Delete_From)
            bool_Success = obj_Config.func_Write_Config_File(obj_Config.config_parser_Config, str_Config_File_FULL_Path_And_Name)
        pass
    
        '''
        -------------------------------------
        Delete Batch Scenario config path and files
        -------------------------------------
        '''       
        if bool_Success:
            bool_Success = False
            with FileHandler() as obj_FileOp:
                str_Config_File_FULL_Path_And_Name__To_Delete = os__path.join(self.str_Application_Projects_Path, str_Sampling_Strategy_Relative_Path_And_File__To_Delete)
                bool_File_Exists = obj_FileOp.fileExists(str_Config_File_FULL_Path_And_Name__To_Delete)
                if bool_File_Exists:
                    str_Path, _ = os__path.split(str_Config_File_FULL_Path_And_Name__To_Delete)
                    bool_Success = obj_FileOp.method_Delete_Path(str_Path)
                    if not bool_Success:
                        str_Message_Text = 'Unable to delete path: ' + str_Path
                        int_Stack_Trace_Level = 2
                        self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                        return False
                    pass
                else:
                    str_Message_Text = 'Non-existant file or path.  Cannot delete: ' + str_Config_File_FULL_Path_And_Name__To_Delete
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                    return False
                pass                
            pass
        else:
            str_Message_Text = 'Unable to delete config file and path: ' + str_Config_File_FULL_Path_And_Name__To_Delete + ' and unlink associated config files: ' + str_Config_File_FULL_Path_And_Name
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
        
        return bool_Success
    
    def func_QPushButton_Clicked__Save_Modified_Sampling_Strategy(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        obj_Config = self.obj_Config_Sampling_Strategy
        str_Config_File_Relative_Path_And_Name = str(self.comboBox_300.currentText())
        
        if obj_Config != None:
            config_parser_Config = obj_Config.config_parser_Config
        
            if config_parser_Config != None:
                str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name)
                bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, str_Config_File_FULL_Path_And_Name)
                if bool_Success:
                    self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                else:
                    str_Message_Text = 'config_parser_Config could not be written to config file'
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass                   
            else:
                str_Message_Text = 'config_parser_Config = None'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            pass
        else:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
        pass                 
        return True
    
    def func_QPushButton_Clicked__Show_Batch_Scenario_Result_Plots(self):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        list_Images = []
        list_Captions = [] 
                
        list_Images = self.list_Path_And_Files__Batch_Scenario__Results_Plots
        list_Captions = self.list_Path_And_Files__Batch_Scenario__Results_Plots_Captions
        
        if list_Images != []:

            ''' Disable the View button '''
            self.bool_Results_Window_Displayed = True
            self.pushButton_2.setEnabled(False)
            self.pushButton_14.setEnabled(False)
        
            self.func_Display_Results__Show_Results_In_Tk_Window(list_Images, list_Captions)     

            ''' Enable the View button '''
            self.bool_Results_Window_Displayed = False
            self.pushButton_2.setEnabled(True)
            self.pushButton_14.setEnabled(True)
        
        pass
    
        return True
    
    def func_QPushButton_Clicked__Show_Sampling_Strategy_Result_Plots(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                       
        list_Images = []
        list_Captions = []     
                 
        list_Images = sorted(self.list_Path_And_Files__Sampling_Strategy__Results_Plots, reverse=True)
        list_Captions = sorted(self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Captions, reverse=True)
        
        if list_Images != []:

            ''' Disable the View button '''
            self.bool_Results_Window_Displayed = True
            self.pushButton_2.setEnabled(False)
            self.pushButton_14.setEnabled(False)
            
            self.func_Display_Results__Show_Results_In_Tk_Window(list_Images, list_Captions)     

            ''' Enable the View button '''
            self.bool_Results_Window_Displayed = False
            self.pushButton_2.setEnabled(True)
            self.pushButton_14.setEnabled(True)
        pass
        
        return True
    
    def func_QPushButton_Clicked__Show_Batch_Scenario_Result_Plots_As_PDF(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        bool_Success = False                       
        
        bool_Display_PDF = True
        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
        bool_Success = self.func_Job_Results_Display__Batch_Scenario__Create_Results_PDF(bool_Display_PDF)
        
        if not bool_Success:
            QtGui.QApplication.restoreOverrideCursor()
        pass
             
        return True


    def func_Job_Results_Display__Batch_Scenario__Create_Results_PDF(self, bool_Display_PDF):   
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        bool_Success = False
        self.list_Path_And_Files__Batch_Scenario__Results_PDFs = []                       
        list_Images = []
        list_Captions = []     
                 
        list_Images = sorted(self.list_Path_And_Files__Batch_Scenario__Results_Plots, reverse=True)
        list_Captions = sorted(self.list_Path_And_Files__Batch_Scenario__Results_Plots_Captions, reverse=True)

        ''' Create HTML - NOTE: Head & Body are important to make the PDF print an image '''
        str_HTML = '<html>\n<head></head>\n<body>' 
        ''' NOTE: Page breaks not working when printing - But work when loding HTML in browser - Leave in for now '''
        str_HTML += '<STYLE TYPE="text/css"> \n P.breakhere {page-break-before: always} \n </STYLE>'

        
        int_Index = 0
        for str_Path_And_File in list_Images:
            str_Path, _ = os__path.split(str_Path_And_File)
            _, str_Results_Folder = os__path.split(str_Path)
            bool_Success = self.func_Check_If_File_Exists(str_Path_And_File)
            str_Caption = list_Captions[int_Index]
            if bool_Success:
                ''' Set the image size so that the images form a natural page break '''    
                str_HTML += '<img img border="1" width="910" height="430" src="file:///' + str_Path_And_File + '">' + '\n'
            else:
                str_HTML += 'Image could not be found :<br /><img src="' + str_Path_And_File + '"/>"' + '\n'
            pass
            
            ''' NOTE: Page breaks not working when printing - But work when loding HTML in browser - Leave in for now '''
            str_HTML +=  '<P CLASS="breakhere">'
            int_Index += 1
        pass
        str_HTML += '</body>\n</html>'
        
        
        '''NOTE: Must wait until the page has loaded (large images take time) befero trying to print otherwise you get a blank page '''
        def convertIt():
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, '')
            #DEBUG_OFF            
            qWebView.print_(qPrinter)
            self.list_Path_And_Files__Batch_Scenario__Results_PDFs = [str_PDF_Path_And_File]
            if bool_Display_PDF:
                subprocess__Popen([str_PDF_Path_And_File],shell=True)
            pass
            qWebView.loadFinished["bool"].disconnect()
            QtGui.QApplication.restoreOverrideCursor()
            
            #del qWebView
            return True
        pass

        ''' Set up printer to Print teh QWebView HTML to PDF when the HTML has been loaded '''
        #self.printer = QtGui.QPrinter(QtGui.QPrinterInfo.defaultPrinter(),QtGui.QPrinter.HighResolution)
        qPrinter = QtGui.QPrinter()
        qPrinter.setOutputFormat(QtGui.QPrinter.PdfFormat)
        #self.printer.setOrientation(QtGui.QPrinter.Landscape)
        #self.printer.setOrientation(QtGui.QPrinter.Portrait)
        qPrinter.setPaperSize(QtGui.QPrinter.A4)
        #self.printer.setFullPage(True)
        #self.printer.setResolution(50)
        str_PDF_Filename = self.str_Project_Name__Current + '_' + self.str_Scenario_Name__Current + '.pdf'
        str_PDF_Path_And_File =os__path.join(str_Path,str_PDF_Filename)
        qPrinter.setOutputFileName(str_PDF_Path_And_File)

        ''' Create the QWebView '''
        qWebView = QWebView()
        ''' Connect the loadFinished SIGNAL '''    
        qWebView.loadFinished["bool"].connect(convertIt)
        ''' Put the HTML into the QWebView '''
        qWebView.setHtml(str_HTML)
        
        #DEBUG_ON
#         fo = open(os__path.join(str_Path, 'test.html'), "w")
#         line = fo.write( str_HTML )
#         fo.close()
#         ''' View the html in the help browser '''
#         if self.dialog_Context_Help is not None:
#             for qWebView_Help_Text_Browser in self.dialog_Context_Help.findChildren(QWebView):
#                 break
#             pass
#         else:
#             return False
#         pass         
        ''' Load the URL '''
        #str_HTML_Path_And_File = os__path.join(str_Path, 'test.html')
        #qURL = QtCore.QUrl.fromLocalFile(QtCore.QString(str_HTML_Path_And_File))
        #web.load(qURL) 
        #qWebView_Help_Text_Browser.load(qURL) 
        ''' View dynamic HTML '''
#         qWebView_Help_Text_Browser.setHtml(str_HTML)
        #DEBUG_OFF
                
        return False

    def func_QPushButton_Clicked__Show_Sampling_Strategy_Result_Plots_As_PDF(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        bool_Success = False                       
        
        bool_Display_PDF = True
        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
        bool_Success = self.func_Job_Results_Display__Sampling_Strategy__Create_Results_PDF(bool_Display_PDF)
        
        if not bool_Success:
            QtGui.QApplication.restoreOverrideCursor()
        pass                 
    
        return True

    def func_Job_Results_Display__Sampling_Strategy__Create_Results_PDF(self, bool_Display_PDF):   
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        bool_Success = False
        self.list_Path_And_Files__Sampling_Strategy__Results_PDFs = []                       
        list_Images = []
        list_Captions = []     
                 
        list_Images = sorted(self.list_Path_And_Files__Sampling_Strategy__Results_Plots, reverse=True)
        list_Captions = sorted(self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Captions, reverse=True)

        ''' Create HTML - NOTE: Head & Body are important to make the PDF print an image '''
        str_HTML = '<html>\n<head></head>\n<body>' 
        ''' NOTE: Page breaks not working when printing - But work when loding HTML in browser - Leave in for now '''
        str_HTML += '<STYLE TYPE="text/css"> \n P.breakhere {page-break-before: always} \n </STYLE>'

        
        int_Index = 0
        for str_Path_And_File in list_Images:
            str_Path, _ = os__path.split(str_Path_And_File)
            _, str_Results_Folder = os__path.split(str_Path)
            bool_Success = self.func_Check_If_File_Exists(str_Path_And_File)
            str_Caption = list_Captions[int_Index]
            if bool_Success:
                ''' Set the image size so that the images form a natural page break '''    
                str_HTML += '<img img border="1" width="910" height="430" src="file:///' + str_Path_And_File + '">' + '\n'
            else:
                str_HTML += 'Image could not be found :<br /><img src="' + str_Path_And_File + '"/>"' + '\n'
            pass
            
            ''' NOTE: Page breaks not working when printing - But work when loding HTML in browser - Leave in for now '''
            str_HTML +=  '<P CLASS="breakhere">'
            int_Index += 1
        pass
        str_HTML += '</body>\n</html>'


        '''NOTE: Must wait until the page has loaded (large images take time) befero trying to print otherwise you get a blank page '''
        def convertIt():
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, '')
            #DEBUG_OFF            
            qWebView.print_(qPrinter)
            self.list_Path_And_Files__Sampling_Strategy__Results_PDFs = [str_PDF_Path_And_File]
            if bool_Display_PDF:
                subprocess__Popen([str_PDF_Path_And_File],shell=True)
            pass
            qWebView.loadFinished["bool"].disconnect()
            QtGui.QApplication.restoreOverrideCursor()
            
            #del qWebView
            return True
        pass

        ''' Set up printer to Print teh QWebView HTML to PDF when the HTML has been loaded '''
        #self.printer = QtGui.QPrinter(QtGui.QPrinterInfo.defaultPrinter(),QtGui.QPrinter.HighResolution)
        qPrinter = QtGui.QPrinter()
        qPrinter.setOutputFormat(QtGui.QPrinter.PdfFormat)
        #self.printer.setOrientation(QtGui.QPrinter.Landscape)
        #self.printer.setOrientation(QtGui.QPrinter.Portrait)
        qPrinter.setPaperSize(QtGui.QPrinter.A4)
        #self.printer.setFullPage(True)
        #self.printer.setResolution(50)
        str_PDF_Filename = self.str_Project_Name__Current + '_' + self.str_Scenario_Name__Current + '_' + self.str_Sampling_Strategy_Name__Current + '.pdf'
        str_PDF_Path_And_File =os__path.join(str_Path,str_PDF_Filename)
        qPrinter.setOutputFileName(str_PDF_Path_And_File)

        ''' Create the QWebView '''
        qWebView = QWebView()
        ''' Connect the loadFinished SIGNAL '''    
        qWebView.loadFinished["bool"].connect(convertIt)
        ''' Put the HTML into the QWebView '''
        qWebView.setHtml(str_HTML)
        
        #DEBUG_ON
#         fo = open(os__path.join(str_Path, 'test.html'), "w")
#         line = fo.write( str_HTML )
#         fo.close()
#         ''' View the html in the help browser '''
#         if self.dialog_Context_Help is not None:
#             for qWebView_Help_Text_Browser in self.dialog_Context_Help.findChildren(QWebView):
#                 break
#             pass
#         else:
#             return False
#         pass         
        ''' Load the URL '''
        #str_HTML_Path_And_File = os__path.join(str_Path, 'test.html')
        #qURL = QtCore.QUrl.fromLocalFile(QtCore.QString(str_HTML_Path_And_File))
        #web.load(qURL) 
        #qWebView_Help_Text_Browser.load(qURL) 
        ''' View dynamic HTML '''
#         qWebView_Help_Text_Browser.setHtml(str_HTML)
        #DEBUG_OFF

        return True
         
    def func_Display_Results__Show_Results_In_Tk_Window(self, list_Images, list_Captions):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        class cls_Image:
            int_Image_Index_Current = 0
        pass
        
        def move(delta):
            
            if not (0 <= cls_Image.int_Image_Index_Current + delta < len(list_Images)):
                tkMessageBox.showinfo('End', 'No more images.')
                return
            pass
            root.config(cursor="wait")
            root.update()            
            cls_Image.int_Image_Index_Current += delta
            str_Path__Image, _ = os__path.split(list_Images[cls_Image.int_Image_Index_Current])
            image = PIL__Image.open(os__path.join(str_Path__Image, list_Images[cls_Image.int_Image_Index_Current]))
            resized = image.resize((screen_width, screen_height),PIL__Image.ANTIALIAS)
            photo = PIL__ImageTk.PhotoImage(resized) # Keep a reference, prevent GC            
            label['text'] = list_Captions[cls_Image.int_Image_Index_Current]
            label['image'] = photo
            label.photo = photo
            root.config(cursor="")    
        pass
    
        def show():
            
            root.config(cursor="wait")
            root.update()            
            str_Path__Image, _ = os__path.split(list_Images[cls_Image.int_Image_Index_Current])
            image = PIL__Image.open(os__path.join(str_Path__Image, list_Images[cls_Image.int_Image_Index_Current]))
            image.show() 
            root.config(cursor="")    
        pass
        
        root = tkinter.Tk()
        
        label = tkinter.Label(root, compound=tkinter.TOP)
        label.pack()
        
        frame = tkinter.Frame(root)
        frame.pack()
        
        tkinter.Button(frame, text='Previous picture', command=lambda: move(-1)).pack(side=tkinter.LEFT)
        tkinter.Button(frame, text='Next picture', command=lambda: move(+1)).pack(side=tkinter.LEFT)
        tkinter.Button(frame, text='Show', command=lambda: show()).pack(side=tkinter.LEFT)
        tkinter.Button(frame, text='Quit', command=root.destroy).pack(side=tkinter.LEFT)
        
        int_Border_Width = 200
        int_Border_Height = 200
        
        screen_width = root.winfo_screenwidth() - int_Border_Width
        screen_height = root.winfo_screenheight()- int_Border_Height
        
        move(0)
        
        root.mainloop()        

        return True
        
    def func_Display_Results__Insert_TextBrowser_Image(self, textBrowser, str_Path_And_File):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        bool_Success = self.func_Check_If_File_Exists(str_Path_And_File)
        if bool_Success:
            if textBrowser is not None:
                        
                #self.textBrowser_4.document().setHtml('My image :<br /><img src="' + str_Path_And_Path + '"/>"')
                #self.textBrowser_4.document().setHtml('My image :<br /><img src="' + outfile + '" style="width: 10%; height: 10%"/>"')
                textBrowser.document().setHtml('<img src="' + str_Path_And_File + '"/>')
                textBrowser.show()
            else:
                textBrowser.document().setHtml('Image could not be displayed :<br /><img src="' + str_Path_And_File + '"/>"')
                bool_Success = False
            pass
        else:
            textBrowser.document().setHtml('Image could not be found :<br /><img src="' + str_Path_And_File + '"/>"')
            bool_Success = False
        pass
                
        return bool_Success             
    
    def func_QPushButton_Clicked__Batch_Scenario__Copy_Results_To_User_Location(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        ''' First create the PDF of results '''
        bool_Display_PDF = False
        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
        bool_Success = self.func_Job_Results_Display__Batch_Scenario__Create_Results_PDF(bool_Display_PDF)
        
        if not bool_Success:
            QtGui.QApplication.restoreOverrideCursor()
        pass

        ''' Open a Save AS dialog, get the destination path & copy results folders to new location '''
        str_FrontEnd_Results_Path = os__path.join(self.str_Batch_Scenario_Path__Current, self.str_Settings_Run_Results_Folder_Prefix__Default_Value + '_' + self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current))
        bool_Success = self.func_Copy_Results__Copy_Results_To_User_Location(str_FrontEnd_Results_Path)
        
        return True 
    
    def func_QPushButton_Clicked__Sampling_Strategy__Copy_Results_To_User_Location(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        bool_Display_PDF = False
        QtGui.QApplication.setOverrideCursor(QtGui.QCursor(QtCore.Qt.WaitCursor))
        bool_Success = self.func_Job_Results_Display__Sampling_Strategy__Create_Results_PDF(bool_Display_PDF)
        
        if not bool_Success:
            QtGui.QApplication.restoreOverrideCursor()
        pass                 
    
        ''' Open a Save AS dialog, get the destination path & copy results folders to new location '''
        str_FrontEnd_Results_Path = os__path.join(self.str_Sampling_Strategy_Path__Current, self.str_Settings_Run_Results_Folder_Prefix__Default_Value + '_' + self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str(self.int_Sampling_Strategy_UID__Current))
        bool_Success = self.func_Copy_Results__Copy_Results_To_User_Location(str_FrontEnd_Results_Path)
        
        return True 
                
        return True 

    def func_Copy_Results__Copy_Results_To_User_Location(self, str_Path__Origin):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        ''' Get the users "Home" folder irrelevant of OS '''
        str_Start_Path = os__path.expanduser('~')
        
        ''' Use the Save Path Dialog to get the destination path '''
        str_Title = "Select the FOLDER that the results will be copied to:"
        bool_Cancelled, str_Path__Selected  = self.func_Select_Path_Dialog(str_Title, str_Start_Path)
        
        if bool_Cancelled:
            return True
        pass
    
        ''' Add the results folder name to the selcted path '''
        _, str_Folder__Results = os__path.split(str_Path__Origin)
        str_Path__Destination = os__path.join(str(str_Path__Selected), str_Folder__Results) #Convert QString to str
        
        ''' Copy the results folder to the new location '''
        with FileHandler() as obj_FileOp:    
            
            bool_Purge_Results = True
            if bool_Purge_Results:
                ''' Checks if path exists and deletes it and all its sub-folders '''
                bool_Success = obj_FileOp.method_Delete_Path(str_Path__Destination)
                if not bool_Success:
                    str_Message_Text = 'Unable to delete path: ' + str_Path__Destination
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass 
            pass     
            if bool_Success:           
                bool_Success = obj_FileOp.method_Copy_Folder_Or_All_Files(str_Path__Origin, str_Path__Destination)
                if not bool_Success:
                    str_Message_Text = 'Could not copy folder from: ' + str_Path__Origin + '; to destination folder: ' + str_Path__Destination
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                    return False      
                pass  
            pass              
        pass       
        
        if bool_Success:
            str_MessageBox_Text = 'Results successfilly copied to:\n' + str(str_Path__Destination)
            messageBox_Reponse = QtGui.QMessageBox.information(self, 'Results Copy', str_MessageBox_Text, buttons=QtGui.QMessageBox.Ok, defaultButton=QtGui.QMessageBox.Ok)
        pass
    
        return bool_Success

    def func_QPushButton_Clicked__Show_Batch_Scenario_Next_Thumbnail_Result(self):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                       
        list_Images = []
        list_Captions = []     
                 
        list_Thumbs = sorted(self.list_Path_And_Files__Batch_Scenario__Results_Plots_Thumbs, reverse=True)         
        list_Captions = sorted(self.list_Path_And_Files__Batch_Scenario__Results_Plots_Captions, reverse=True)
        
        str_Path_And_Thumb_Displayed__Current = self.str_Path_And_Thumb_Displayed__Batch_Scenario
        textBrowser = self.textBrowser_3
        
        if list_Thumbs != []:
            str_Path_And_Thumb_Displayed__Next = self.func_QPushButton_Clicked__Show_Next_Thumbnail_Result(textBrowser, str_Path_And_Thumb_Displayed__Current, list_Thumbs)
            if str_Path_And_Thumb_Displayed__Next != '':
                self.str_Path_And_Thumb_Displayed__Batch_Scenario = str_Path_And_Thumb_Displayed__Next
            pass
        pass
        
        return True        

    def func_QPushButton_Clicked__Show_Batch_Scenario_Prev_Thumbnail_Result(self):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                       
        list_Images = []
        list_Captions = []     
                 
        list_Thumbs = sorted(self.list_Path_And_Files__Batch_Scenario__Results_Plots_Thumbs, reverse=True)         
        list_Captions = sorted(self.list_Path_And_Files__Batch_Scenario__Results_Plots_Captions, reverse=True)
        
        str_Path_And_Thumb_Displayed__Current = self.str_Path_And_Thumb_Displayed__Batch_Scenario
        textBrowser = self.textBrowser_4
        
        if list_Thumbs != []:
            str_Path_And_Thumb_Displayed__Prev = self.func_QPushButton_Clicked__Show_Prev_Thumbnail_Result(textBrowser, str_Path_And_Thumb_Displayed__Current, list_Thumbs)
            if str_Path_And_Thumb_Displayed__Prev != '':
                self.str_Path_And_Thumb_Displayed__Batch_Scenario = str_Path_And_Thumb_Displayed__Prev
            pass
        pass
        
        return True        

    def func_QPushButton_Clicked__Show_Sampling_Strategy_Next_Thumbnail_Result(self):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                       
        list_Images = []
        list_Captions = []     
                 
        list_Thumbs = sorted(self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Thumbs, reverse=True)         
        list_Captions = sorted(self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Captions, reverse=True)
        
        str_Path_And_Thumb_Displayed__Current = self.str_Path_And_Thumb_Displayed__Sampling_Strategy
        textBrowser = self.textBrowser_3
        
        if list_Thumbs != []:
            str_Path_And_Thumb_Displayed__Next = self.func_QPushButton_Clicked__Show_Next_Thumbnail_Result(textBrowser, str_Path_And_Thumb_Displayed__Current, list_Thumbs)
            if str_Path_And_Thumb_Displayed__Next != '':
                self.str_Path_And_Thumb_Displayed__Sampling_Strategy = str_Path_And_Thumb_Displayed__Next
            pass
        pass
        
        return True        

    def func_QPushButton_Clicked__Show_Sampling_Strategy_Prev_Thumbnail_Result(self):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                       
        list_Images = []
        list_Captions = []     
                 
        list_Thumbs = sorted(self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Thumbs, reverse=True)         
        list_Captions = sorted(self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Captions, reverse=True)
        
        str_Path_And_Thumb_Displayed__Current = self.str_Path_And_Thumb_Displayed__Sampling_Strategy
        textBrowser = self.textBrowser_3
        
        if list_Thumbs != []:
            str_Path_And_Thumb_Displayed__Prev = self.func_QPushButton_Clicked__Show_Prev_Thumbnail_Result(textBrowser, str_Path_And_Thumb_Displayed__Current, list_Thumbs)
            if str_Path_And_Thumb_Displayed__Prev != '':
                self.str_Path_And_Thumb_Displayed__Sampling_Strategy = str_Path_And_Thumb_Displayed__Prev
            pass
        pass
        
        return True        


    def func_QPushButton_Clicked__Show_Next_Thumbnail_Result(self, textBrowser, str_Path_And_Thumb_Displayed__Current, list_Thumbs):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        str_Path_And_Thumb_Displayed__Next = ''
                       
        int_List_Len = len(list_Thumbs)
        int_Index_Current = 0
        int_Index_Next = 0
        if int_List_Len > 0:
            if str_Path_And_Thumb_Displayed__Current != '':
                if str_Path_And_Thumb_Displayed__Current in list_Thumbs:
                    int_Index_Current = list_Thumbs.index(str_Path_And_Thumb_Displayed__Current)
                    int_Index_Next = int_Index_Current + 1
                    if int_Index_Next == int_List_Len:
                        int_Index_Next = 0
                    pass
                
                    ''' Embed desired thumbnail in textBrowser '''
                    str_Path_And_Thumb_Displayed__Next = list_Thumbs[int_Index_Next]
                    bool_Success = self.func_Display_Results__Insert_TextBrowser_Image(textBrowser, str_Path_And_Thumb_Displayed__Next)
                    if not bool_Success:
                        str_Path_And_Thumb_Displayed__Next = ''
                    pass
                pass
            pass
        pass
        
        return str_Path_And_Thumb_Displayed__Next        

    def func_QPushButton_Clicked__Show_Prev_Thumbnail_Result(self, textBrowser, str_Path_And_Thumb_Displayed__Current, list_Thumbs):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        str_Path_And_Thumb_Displayed__Prev = ''
                       
        int_List_Len = len(list_Thumbs)
        int_Index_Current = 0
        int_Index_Prev = 0
        if int_List_Len > 0:
            if str_Path_And_Thumb_Displayed__Current != '':
                if str_Path_And_Thumb_Displayed__Current in list_Thumbs:
                    int_Index_Current = list_Thumbs.index(str_Path_And_Thumb_Displayed__Current)
                    int_Index_Prev = int_Index_Current - 1
                    if int_Index_Prev < 0:
                        int_Index_Prev = int_List_Len - 1
                    pass
                
                    ''' Embed desired thumbnail in textBrowser '''
                    str_Path_And_Thumb_Displayed__Prev = list_Thumbs[int_Index_Prev]
                    bool_Success = self.func_Display_Results__Insert_TextBrowser_Image(textBrowser, str_Path_And_Thumb_Displayed__Prev)
                    if not bool_Success:
                        str_Path_And_Thumb_Displayed__Prev = ''
                    pass
                pass
            pass
        pass
        
        return str_Path_And_Thumb_Displayed__Prev        

    def func_QPushButton_Clicked__Zip(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
               
        src = 'C:\\DCB\\MUI\\MUI_Sync_Controlled\\MUI_SC_SharkSim\\v3_02\\20151212135009\\SS_3_02_Run_2016_01_20_16_58_46'
        dst = 'C:\\DCB\\MUI\\MUI_Sync_Controlled\\MUI_SC_SharkSim\\v3_02\\20151212135009\\SS_3_02_Run_2016_01_20_16_58_46'
        
        self.func_Zip(src, dst)
        
        
        return True
                
    '''
    -------------------------------------------------------------------------------
        Signal  downstream functions 
    -------------------------------------------------------------------------------
    ''' 
    '''
    ----------------------------
    QToolBox - Index 0
    ----------------------------
    '''    
    '''
    ----------------------------
    Project & Scenario Widgets
    ----------------------------
    '''     
    def func_Save_Check__Should_I_Save_And_Continue__Sampling_Strategy(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        #bool_Save_Required = False
        bool_Continue = False
        
        if not self.bool_Init_Finished:
            bool_Continue = False
            return bool_Continue
        pass 

        if not self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:
            bool_Continue = True
            return bool_Continue
        pass
    
        if self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:
            bool_Continue = False
            bool_Continue = self.func_Save_Check__Is_Save_ALLOWED__Sampling_Strategy()
            if not bool_Continue:
                return bool_Continue
            pass
        pass
    
        if self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:
            bool_Continue = False
            bool_Continue = self.func_Save_Check__Unsaved_Changes__Sampling_Strategy()
        pass
    
        if bool_Continue and self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:
            ''' Save the Sampling Strategy '''
            self.func_QPushButton_Clicked__Save_Modified_Sampling_Strategy()
        pass
        
        return bool_Continue

    def func_Save_Check__Is_Save_ALLOWED__Sampling_Strategy(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Continue = False
        
        if not self.bool_Init_Finished:
            bool_Continue = False
            return bool_Continue
        pass 

        if self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:               
            ''' Put data field specifc validation here '''
            pass
        pass
    
        bool_Continue = True
     
        return bool_Continue

    def func_Save_Check__Unsaved_Changes__Sampling_Strategy(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Continue = False
        
        if not self.bool_Init_Finished:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
            bool_Continue = False
            return bool_Continue
        pass 

        if self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy:               
            str_MessageBox_Text = 'Your changes to the Sampling Strategy must be saved before run can start.\n\nSave changes?'
            qtmessagebox_Response = QtGui.QMessageBox.question(self, 'Unsaved Sampling Strategy', str_MessageBox_Text, QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, QtGui.QMessageBox.Yes)
            if qtmessagebox_Response == QtGui.QMessageBox.No:
                ''' Load the options from the Batch_SCenario and Batch_Settings file into the controls on the Modify_Scenario page '''
                #self.func_Populate_Widgits_With_Config_Data__BATCH_SCENARIO()
                #self.func_Populate_Widgits_With_Config_Data__SAMPLING_STRATEGY()
                
                #self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                bool_Continue = False
                return bool_Continue                        
            else:
                ''' Save the scenario '''
                bool_Continue = True
            pass
        pass
     
        return bool_Continue
    
    def func_Save_Check__Should_I_Save_And_Continue__Scenario(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        #bool_Save_Required = False
        bool_Continue = False
        
        if not self.bool_Init_Finished:
            bool_Continue = False
            return bool_Continue
        pass 

        if not self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:
            bool_Continue = True
            return bool_Continue
        pass
    
        if self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:
            bool_Continue = False
            bool_Continue = self.func_Save_Check__Is_Save_ALLOWED__Scenario()
            if not bool_Continue:
                return bool_Continue
            pass
        pass
    
        if self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:
            bool_Continue = False
            bool_Continue = self.func_Save_Check__Unsaved_Changes__Scenario()
        pass
    
        if bool_Continue and self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:
            ''' Save the scenario '''
            self.func_QPushButton_Clicked__Save_Modified_Scenario()
        pass
        
        return bool_Continue
    
    def func_Save_Check__Is_Save_ALLOWED__Scenario(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Continue = False
        
        if not self.bool_Init_Finished:
            bool_Continue = False
            return bool_Continue
        pass 

        if self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:               
            bool_Continue = self.func_Save_Check__Scenario__Unspecified_Allele_Freq_File()
        pass
    
        bool_Continue = True
     
        return bool_Continue

    def func_Save_Check__Scenario__Unspecified_Allele_Freq_File(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Continue = False
        
        if not self.bool_Init_Finished:
            bool_Continue = False
            return bool_Continue
        pass 

        if self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:
            if self.str_Genome_Allele_Frequency_Distribution == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES:
                if self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name == '':
                    str_MessageBox_Text = 'Hold up!\n\nPlease select an allele frequency file first \nor\nselect a different allele frequency distribution'
                    qtmessagebox_Response = QtGui.QMessageBox.information(self, 'Unspecified allele frequency file', str_MessageBox_Text, QtGui.QMessageBox.Ok, QtGui.QMessageBox.Ok)
                    bool_Continue = False
                    return bool_Continue
                pass
            elif self.str_Genome_Allele_Frequency_Distribution == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP:
                if self.str_Genome__Source_GENEPOP_File_Path_And_Name == '':
                    str_MessageBox_Text = 'Hold up!\n\nPlease select an GENEPOP file first \nor\nselect a different allele frequency distribution'
                    qtmessagebox_Response = QtGui.QMessageBox.information(self, 'Unspecified GENEPOP file', str_MessageBox_Text, QtGui.QMessageBox.Ok, QtGui.QMessageBox.Ok)
                    bool_Continue = False
                    return bool_Continue
                pass
            pass
        pass
    
        bool_Continue = True
     
        return bool_Continue
    
    def func_Save_Check__Unsaved_Changes__Scenario(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Continue = False
        
        if not self.bool_Init_Finished:
            bool_Continue = False
            return bool_Continue
        pass 

        if self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario:               
            str_MessageBox_Text = 'Your changes to the Scenario will be lost if you dont save.\n\nSave changes?'
            qtmessagebox_Response = QtGui.QMessageBox.question(self, 'Unsaved Scenario', str_MessageBox_Text, QtGui.QMessageBox.Yes | QtGui.QMessageBox.No, QtGui.QMessageBox.Yes)
            if qtmessagebox_Response == QtGui.QMessageBox.No:
                ''' Load the options from the Batch_SCenario and Batch_Settings file into the controls on the Modify_Scenario page '''
                #self.func_Populate_Widgits_With_Config_Data__BATCH_SCENARIO()
                #self.func_Populate_Widgits_With_Config_Data__SAMPLING_STRATEGY()
                
                #self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False
                bool_Continue = False
            else:
                ''' Save the scenario '''
                bool_Continue = True
                self.func_QPushButton_Clicked__Save_Modified_Scenario()
                pass
            pass
        pass

        return bool_Continue
    
    
    def func_Set_SIM_LENGTH_Slider_Range_And_Value__horizontalslider_31(self):

        int_Value__Burn_In = 0
        int_Value__Temporal_Evolution = 0
        #int_Species_Life_History_Max_Age = 0
        
#         int_Max = self.int_Simulation_Batch_Replicate_Length_Muliplier__Max * self.int_Species_Life_History_Max_Age__Default_Value
#         int_Min = self.int_Simulation_Batch_Replicate_Length_Muliplier__Min * self.int_Species_Life_History_Max_Age__Default_Value
        int_Max = self.int_Simulation_Batch_Replicate_Length_Muliplier__Max * self.int_Species_Life_History_Max_Age
        int_Min = self.int_Simulation_Batch_Replicate_Length_Muliplier__Min * self.int_Species_Life_History_Max_Age
        
        ''' Set the ranges for related sliders '''
        if self.bool_int_Species_Life_History_Max_Age__FOUND and self.bool_int_Species_Life_History_Max_Age__CHANGED:
            ''' Set the widgets defaults '''
            int_Value = self.int_Simulation_Batch_Replicate_Length_Muliplier__Default_Value * self.int_Species_Life_History_Max_Age
            int_Value__Burn_In = int_Value
            int_Value__Temporal_Evolution = int_Value
            self.int_Simulation_Batch_Replicate_Length_Burn_In = int_Value__Burn_In
            self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution = int_Value__Temporal_Evolution
#             '''Remove the REQUIRED label from the widget '''
#             self.label_59.setText(self.str_Simulation_Batch_Replicate_Length_Burn_In__Label_Text)
            
            pass

        elif self.bool_int_Species_Life_History_Max_Age__FOUND and not self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__FOUND:
            ''' Set the widgets defaults '''
            int_Value = self.int_Simulation_Batch_Replicate_Length_Muliplier__Default_Value * self.int_Species_Life_History_Max_Age
            int_Value__Burn_In = int_Value
            int_Value__Temporal_Evolution = int_Value
            self.int_Simulation_Batch_Replicate_Length_Burn_In = int_Value__Burn_In
            self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution = int_Value__Temporal_Evolution
#             '''Remove the REQUIRED label from the widget '''
#             self.label_59.setText(self.str_Simulation_Batch_Replicate_Length_Burn_In__Label_Text)

            pass
        
        elif not self.bool_int_Species_Life_History_Max_Age__FOUND and not self.bool_int_Species_Life_History_Max_Age__CHANGED:
            #int_Species_Life_History_Max_Age = self.int_Species_Life_History_Max_Age__Default_Value
            self.int_Species_Life_History_Max_Age = self.int_Species_Life_History_Max_Age__Default_Value
            int_Value = self.int_Simulation_Batch_Replicate_Length_Muliplier__Default_Value * self.int_Species_Life_History_Max_Age__Default_Value
            int_Value__Burn_In = int_Value
            int_Value__Temporal_Evolution = int_Value
            self.int_Simulation_Batch_Replicate_Length_Burn_In = int_Value__Burn_In
            self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution = int_Value__Temporal_Evolution
#             '''Remove the REQUIRED label from the widget '''
#             self.label_59.setText(self.str_Simulation_Batch_Replicate_Length_Burn_In__Label_Text)

            pass
        pass
    
        if self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__FOUND:
            ''' Use the value from the Batch Scenario config '''
            int_Value__Burn_In = self.int_Simulation_Batch_Replicate_Length_Burn_In
        elif self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__CHANGED:
            ''' NO action needed '''
            pass
                        
        if self.bool_int_Simulation_Batch_Replicate_Length_Temporal_Evolution__FOUND:
            ''' Use the value from the Batch Scenario config '''
            int_Value__Temporal_Evolution = self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution
        elif self.bool_int_Simulation_Batch_Replicate_Length_Temporal_Evolution__CHANGED:
            ''' No action needed '''
            pass

#         ''' Calculate the ranges and defaults based on the Max and the lifespan multiplier defaults '''
#         if self.bool_int_Species_Life_History_Max_Age__FOUND or self.bool_int_Species_Life_History_Max_Age__CHANGED:
#             int_Value = self.int_Simulation_Batch_Replicate_Length_Muliplier__Default_Value * self.int_Species_Life_History_Max_Age
#             int_Max = self.int_Simulation_Batch_Replicate_Length_Muliplier__Max * self.int_Species_Life_History_Max_Age
#             int_Min = self.int_Simulation_Batch_Replicate_Length_Muliplier__Min * self.int_Species_Life_History_Max_Age
#             
#         else:
#             int_Value = self.int_Simulation_Batch_Replicate_Length_Muliplier__Default_Value * self.int_Species_Life_History_Max_Age__Default_Value
#             int_Max = self.int_Simulation_Batch_Replicate_Length_Muliplier__Max * self.int_Species_Life_History_Max_Age__Default_Value
#             int_Min = self.int_Simulation_Batch_Replicate_Length_Muliplier__Min * self.int_Species_Life_History_Max_Age__Default_Value
#         pass



        '''
        ----------------------------------------------------------------------------
        Set the defaults for the Simulation Burn-in Length Slider and linked spinBox
        ----------------------------------------------------------------------------
        '''
        self.spinBox_38.setRange(int_Min, int_Max)
        self.spinBox_38.setSingleStep(self.int_Species_Life_History_Max_Age) 
        self.spinBox_38.setValue(int_Value__Burn_In)
        
        self.horizontalSlider_46.setRange(int_Min, int_Max)
        self.horizontalSlider_46.setTickInterval(self.int_Species_Life_History_Max_Age)
        self.horizontalSlider_46.setSingleStep(self.int_Species_Life_History_Max_Age) 
        #self.horizontalSlider_46.setValue(int_Value__Burn_In)
        
#         self.int_Simulation_Batch_Replicate_Length_Burn_In = int_Value
        #self.func_Update_Config__Simulation_Batch_Replicate_Length_Burn_In()
        #self.func_Update_Config__Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count()
#         '''Remove the REQUIRED label from the widget '''
#         self.label_59.setText(self.str_Simulation_Batch_Replicate_Length_Burn_In__Label_Text)

        pass
    
        '''
        -----------------------------------------------------------------------------
        Set the defaults for the Simulation Temporal Evolution Length Slider  and linked spinBox
        -----------------------------------------------------------------------------
        '''
        self.spinBox_39.setRange(int_Min, int_Max)
        self.spinBox_39.setSingleStep(self.int_Species_Life_History_Max_Age)
        self.spinBox_39.setValue(int_Value__Temporal_Evolution) 
        
        self.horizontalSlider_47.setRange(int_Min, int_Max)
        #self.horizontalSlider_47.setTickInterval(self.int_Species_Life_History_Max_Age)
        #self.horizontalSlider_47.setSingleStep(self.int_Species_Life_History_Max_Age) 
        #self.horizontalSlider_47.setValue(int_Value__Temporal_Evolution) 

 
                  
#         self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution = int_Value

        #self.func_Update_Config__Simulation_Batch_Replicate_Length_Temporal_Evolution()
        #'''Remove the REQUIRED label from the widget '''
        #self.label_60.setText(self.str_Simulation_Batch_Replicate_Length_Temporal_Evolution__Label_Text)

        pass
        return True
               
    def func_Set_Associated_Slider_Range_And_Value__horizontalslider_31(self, int_Slider_Value):

        ''' Set the ranges for related sliders '''
        ''' Set the defaults for the Max Mating Age Slider '''
        self.int_Limit__MaximumMaxMatingAge = int_Slider_Value
        self.int_Species_Life_History_Max_Mating_Age__Max__Default_Value = self.int_Limit__MaximumMaxMatingAge
        if self.horizontalSlider_32.value() > self.int_Limit__MaximumMaxMatingAge:
            self.spinBox_25.setRange(self.int_Species_Life_History_Max_Mating_Age__Min__Default_Value, self.int_Limit__MaximumMaxMatingAge)
            self.horizontalSlider_32.setRange(self.int_Species_Life_History_Max_Mating_Age__Min__Default_Value, self.int_Limit__MaximumMaxMatingAge)
            ''' Set the value if below the acceptable limit '''
            self.horizontalSlider_32.setValue(self.int_Limit__MaximumMaxMatingAge)
        else:
            ''' Otherwise just set the range and dont set the value '''
            self.spinBox_25.setRange(self.int_Species_Life_History_Max_Mating_Age__Min__Default_Value, self.int_Limit__MaximumMaxMatingAge)
            self.horizontalSlider_32.setRange(self.int_Species_Life_History_Max_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Max_Mating_Age__Max__Default_Value)
        pass
        ''' Set the defaults for the Min Mating Age Slider '''
        self.int_Limit__MaximumMinMatingAge = self.int_Limit__MaximumMaxMatingAge - 1
        self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value = self.int_Limit__MaximumMinMatingAge 
        if self.horizontalSlider_33.value() >= self.horizontalSlider_32.value():
            self.spinBox_27.setRange(self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value)
            self.horizontalSlider_33.setRange(self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value)
            self.horizontalSlider_33.setValue(self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value)
        else:
            self.spinBox_27.setRange(self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value)
            self.horizontalSlider_33.setRange(self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value)
        pass    
    
        ''' Set the defaults for the Simulation Length Sliders '''
        self.func_Set_SIM_LENGTH_Slider_Range_And_Value__horizontalslider_31()
    
        self.bool_Changed_Config__Batch_Scenario = False
        
        return True
               
    def func_Set_Associated_Slider_Range_And_Value__horizontalslider_32(self, int_Slider_Value):

        ''' Set the ranges for related sliders '''
        self.int_Limit__MaximumMinMatingAge = int_Slider_Value - 1
        self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value = self.int_Limit__MaximumMinMatingAge
        if self.horizontalSlider_33.value() >= int_Slider_Value:
            ''' Set the value if below the acceptable limit '''
            self.spinBox_27.setRange(self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value)
            self.horizontalSlider_33.setRange(self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value)
            self.horizontalSlider_33.setValue(self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value)
        else:
            ''' Otherwise just set the range and dont set the value '''
            self.spinBox_27.setRange(self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value)
            self.horizontalSlider_33.setRange(self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value, self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value)
        pass        
        return True

#     def func_Update_Config__Simulation_Batch_Replicates(self):
# 
#         #DEBUG_ON
#         self.func_Debug_Logging(False, 2, '')
#         #DEBUG_OFF
#         
#         obj_Config = self.obj_Config_Batch_Scenario
#         
#         if obj_Config == None:
#             str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         pass
#     
#         config_parser_Config = obj_Config.config_parser_Config
#         
#         if config_parser_Config == None:
#             str_Message_Text = 'obj_Config.config_parser_Config = None'
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         pass
#     
#         ''' <<<<<<< SECTION: Life_History '''
#         ''' Specify SECTION to UPDATE '''
#         str_Section = obj_Config.static_str_Section__Simulation_Batch_Details
#         ''' Specify OPTION to UPDATE '''
#         str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicates
#         value_Option = self.int_Simulation_Batch_Replicates
#         ''' Update the OPTION '''
#         config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
#         if config_parser_Config == None:
#             str_Message_Text = 'obj_Config_Batch_Scenario = None'
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         else:
#             self.bool_int_Simulation_Batch_Replicates__CHANGED = True
#             self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
#         pass
#         return True 
#            
#     def func_Update_Config__Simulation_Batch_Replicate_Length_Burn_In(self):
# 
#         #DEBUG_ON
#         self.func_Debug_Logging(False, 2, '')
#         #DEBUG_OFF
#         
#         obj_Config = self.obj_Config_Batch_Scenario
#         
#         if obj_Config == None:
#             str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         pass
#     
#         config_parser_Config = obj_Config.config_parser_Config
#         
#         if config_parser_Config == None:
#             str_Message_Text = 'obj_Config.config_parser_Config = None'
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         pass
#     
#         ''' <<<<<<< SECTION: Life_History '''
#         ''' Specify SECTION to UPDATE '''
#         str_Section = obj_Config.static_str_Section__Simulation_Batch_Details
#         ''' Specify OPTION to UPDATE '''
#         str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Burn_In
#         value_Option = self.int_Simulation_Batch_Replicate_Length_Burn_In
#         ''' Update the OPTION '''
#         config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
#         if config_parser_Config == None:
#             str_Message_Text = 'obj_Config_Batch_Scenario = None'
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         else:
#             if self.bool_Init_Finished: #This is to prevent initial setRange and setValue from triggering a save
#                 if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                     self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__CHANGED = True
#                     self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
#                 pass
#             pass
#         pass
#         return True 
#            
#     def func_Update_Config__Simulation_Batch_Replicate_Length_Temporal_Evolution(self):
# 
#         #DEBUG_ON
#         self.func_Debug_Logging(False, 2, '')
#         #DEBUG_OFF
#         
#         obj_Config = self.obj_Config_Batch_Scenario
#         
#         if obj_Config == None:
#             str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         pass
#     
#         config_parser_Config = obj_Config.config_parser_Config
#         
#         if config_parser_Config == None:
#             str_Message_Text = 'obj_Config.config_parser_Config = None'
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         pass
#     
#         ''' <<<<<<< SECTION: Life_History '''
#         ''' Specify SECTION to UPDATE '''
#         str_Section = obj_Config.static_str_Section__Simulation_Batch_Details
#         ''' Specify OPTION to UPDATE '''
#         str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Temporal_Evolution
#         value_Option = self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution
#         ''' Update the OPTION '''
#         config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
#         if config_parser_Config == None:
#             str_Message_Text = 'obj_Config_Batch_Scenario = None'
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         else:
#             if self.bool_Init_Finished: #This is to prevent initial setRange and setValue from triggering a save
#                 if self.bool_Reload_Widgets_Finished__Batch_Scenario:
#                     self.bool_int_Simulation_Batch_Replicate_Length_Temporal_Evolution__CHANGED = True
#                     self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
#                 pass
#             pass
#         pass
#         return True 

           
    '''
    ----------------------------
    QToolBox - Index 1
    ----------------------------
    '''                  
    '''
    ----------------------------
    Scenario - Life history Ages
    ----------------------------
    '''
    def func_Update__Scenario_Life_History_Ages(self, str_Object_Name, value_Object, bool_Save):
        
        if str_Object_Name == 'horizontalSlider_31':
            self.func_Update__Scenario_Max_Age(value_Object, bool_Save)
        if str_Object_Name == 'spinBox_24':
            self.func_Update__Scenario_Max_Age(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_32':
            self.func_Update__Scenario_Max_Mating_Age(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_33':
            self.func_Update__Scenario_Min_Mating_Age(value_Object, bool_Save)
        pass
    
        return True

    def func_Update__Scenario_Max_Age(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        if bool_Save:
            
            ''' Update config but dont Save file...yet'''
            self.int_Species_Life_History_Max_Age = int_Value 
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF              
            self.func_Update_Config__Max_Age()  
#             if self.bool_int_Species_Life_History_Max_Age__FOUND:
#                 
#                 self.func_Update_Config__Max_Age()
#             else:
#                 self.func_Update_Config__Max_Age()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_42.setText(self.str_Max_Age__Label_Text)
#             pass
            ''' Set the ranges for related sliders '''
            self.func_Set_Associated_Slider_Range_And_Value__horizontalslider_31(int_Value)
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Max_Age(int_Value)
    
        return True
    
    def func_Verify_Change__Scenario_Max_Age(self, int_Value):

        bool_Allow_Change = False
         
        if self.int_Verify_Change__Scenario_Max_Age__Warning_Count > 0:
            self.int_Verify_Change__Scenario_Max_Age__Warning_Count += 1
            return True, self.int_Verify_Change__Scenario_Max_Age__Warning_Count
        pass
        
        if (self.bool_int_Species_Life_History_Max_Age__FOUND or self.bool_int_Species_Life_History_Max_Age__CHANGED) and (self.bool_Species_Offspring_Distribution__FOUND or self.bool_Species_Offspring_Distribution__CHANGED):
#                 messageBox_Reponse = None
#                 if (self.bool_Species_Offspring_Distribution__FOUND or self.bool_Species_Offspring_Distribution__CHANGED):
#                     ''' The Mortality Dist will have to be changed '''
#                     str_MessageBox_Text = 'Changing the Maximum Age will require that you redefine the Age Cohort Mortality Distribution.\n\nAre you sure you wish to continue?'
#                     messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Max Age?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
#                 elif (self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__FOUND or self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__CHANGED):
#                     ''' The Sampling Dist will have to be changed '''
#                     str_MessageBox_Text = 'Changing the Maximum Age will require that you redefine the Age Cohort Mortality Distribution.\n\nAre you sure you wish to continue?'
#                     messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Max Age?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
# 
#                 elif (self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__FOUND or self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__FOUND):
#                     ''' The Mortality Dist will have to be changed '''
#                     str_MessageBox_Text = 'Changing the Maximum Age will require that you redefine the Age Cohort Mortality Distribution.\n\nAre you sure you wish to continue?'
#                     messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Max Age?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)

            ''' The Mortality Dist will have to be changed '''
            str_MessageBox_Text = 'Changing the Maximum Age will require that you redefine the Age Cohort Mortality Distribution.\n\nAre you sure you wish to continue?'
            messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Max Age?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
            self.int_Verify_Change__Scenario_Max_Age__Warning_Count += 1
            
            if messageBox_Reponse == QtGui.QMessageBox.Yes:
                ''' Continue to change Max Age'''
                bool_Allow_Change = True
                ''' Change the Status for the Age Cohort Mortality Dist to force the user to alter and re-save it '''
                qWidget = self.pushButton_6
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                    
            else:
                ''' Abort Max Age change'''
                bool_Allow_Change = False
                self.int_Verify_Change__Scenario_Max_Age__Warning_Count = 0
            pass
        pass
    
        return bool_Allow_Change, self.int_Verify_Change__Scenario_Max_Age__Warning_Count

    def func_Verify_Change__Can_Change_Proceed__Scenario_Max_Age(self, qWidget, int_Value):

        bool_Allow_Change = False
        int_Edit_Warning_Count = 0
        int_Edit_Warning_Count_Total = 0
        
#         str_Object_Name = str(qWidget.name())
#         int_Verify_Change__Warning_Count = self.dict_Parameter_Status[str_Object_Name][globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Edit_Warning_Count]
        
#         bool_Allow_Change, int_Edit_Warning_Count = self.func_Verify_Change__Can_Change_Proceed__ANY_Scenario_PARAMETER()
        if self.int_Edit_Warning_Count__All_Batch_Scenario_Params < 1:
            bool_Allow_Change = self.func_Verify_Change__Can_Change_Proceed__ANY_Scenario_PARAMETER()
        else:
            bool_Allow_Change = True
        pass
        #int_Edit_Warning_Count_Total += int_Edit_Warning_Count
        
        if bool_Allow_Change:
            if (self.bool_int_Species_Life_History_Max_Age__FOUND or self.bool_int_Species_Life_History_Max_Age__CHANGED) and (self.bool_Species_Offspring_Distribution__FOUND or self.bool_Species_Offspring_Distribution__CHANGED):
    #                 messageBox_Reponse = None
    #                 if (self.bool_Species_Offspring_Distribution__FOUND or self.bool_Species_Offspring_Distribution__CHANGED):
    #                     ''' The Mortality Dist will have to be changed '''
    #                     str_MessageBox_Text = 'Changing the Maximum Age will require that you redefine the Age Cohort Mortality Distribution.\n\nAre you sure you wish to continue?'
    #                     messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Max Age?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
    #                 elif (self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__FOUND or self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__CHANGED):
    #                     ''' The Sampling Dist will have to be changed '''
    #                     str_MessageBox_Text = 'Changing the Maximum Age will require that you redefine the Age Cohort Mortality Distribution.\n\nAre you sure you wish to continue?'
    #                     messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Max Age?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
    # 
    #                 elif (self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__FOUND or self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__FOUND):
    #                     ''' The Mortality Dist will have to be changed '''
    #                     str_MessageBox_Text = 'Changing the Maximum Age will require that you redefine the Age Cohort Mortality Distribution.\n\nAre you sure you wish to continue?'
    #                     messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Max Age?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
    
                ''' The Mortality Dist will have to be changed '''
                str_MessageBox_Text = 'Changing the Maximum Age will require that you redefine the Age Cohort Mortality Distribution.\n\nAre you sure you wish to continue?'
                messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Max Age?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
                
                if messageBox_Reponse == QtGui.QMessageBox.Yes:
                    ''' Continue to change Max Age'''
                    bool_Allow_Change = True
                    ''' Add to Edit Warning Count '''
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_USER_ADD_EDIT_WARNING_COUNT__OBJECT_SPECIFIC
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status) 
#                     ''' Change the Status for the Age Cohort Mortality Dist to force the user to alter and re-save it '''
#                     qWidget = self.pushButton_6
#                     str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
#                     self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                    
                else:
                    ''' Abort Max Age change'''
                    bool_Allow_Change = False
                    ''' Zero the Edit Warning Count '''
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_USER_ZERO_EDIT_WARNING_COUNT__OBJECT_SPECIFIC
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status) 

                pass
            pass
        pass
    
        '''
        IMPORTANT: This setValue is required as a bool_Allow_Change = FALSE ...
        from function Can_Change_Proceed__ANY_Scenario_PARAMETER...
        will set the value incorrectly otherwise 
        NOTE: This is only required with multiple validation steps (as for MaxAge)...
        also involving function Can_Change_Proceed__ANY_Scenario_PARAMETER
        '''
        if not bool_Allow_Change:
            qWidget.setValue(int_Value)
        pass
    
        return bool_Allow_Change
    
    def func_Verify_Change__Can_Change_Proceed__ANY_Scenario_PARAMETER(self):

        bool_Allow_Change = False

        if self.int_Run_Status_Flag__Current__Scenario == globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED:
            ''' Warning is necessary - Continue to change'''
            ''' Changing any Scenario parameters will require that the job be re-run '''
            str_MessageBox_Text = 'Just a moment...\n\nChanging any of this Scenario parameters will require that the Scenario be run again to incorporate those changes.\n\nTo retain the Scenarios current results for later comparison, first clone this scenario and then change the cloned parameters.\n\nOtherwise, the results for this Scenario will be lost.\n\nAre you sure you wish to continue?'
            messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Scenario Parameters?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
                        
            if messageBox_Reponse == QtGui.QMessageBox.Yes:
                ''' Continue to change'''
                bool_Allow_Change = True
                self.int_Edit_Warning_Count__All_Batch_Scenario_Params += 1

                ''' Remove Job details from Batch Settings '''
                bool_Success = self.func_Run_Job__Job_Status_Change__User_Edits_Force_Rerun__Batch_Scenario()

                ''' Remove Job details from Sampling Scenarios '''
                bool_Success = self.func_Run_Job__Job_Status_Change__User_Edits_Force_Rerun__Sampling_Strategy()
                
                ''' Delete results? '''
                ''' Reload the Current Batch Scenario '''
                if bool_Success:
                    #''' Refresh the comboBox with new data ''' 
                    int_Index = self.comboBox_200.currentIndex()
                    self.func_QComboBox_SCENARIO_FILE_Selected(int_Index)
                    
                pass                
            else:
                ''' Abort change'''
                bool_Allow_Change = False
                self.int_Edit_Warning_Count__All_Batch_Scenario_Params = 0
            pass
        else:
            ''' No warning is necessary - Continue to change'''
            bool_Allow_Change = True
            self.int_Edit_Warning_Count__All_Batch_Scenario_Params += 1        
        pass
    
        return bool_Allow_Change
    
    def func_Verify_Change__Can_Change_Proceed__ANY_Sampling_Strategy_PARAMETER(self):

        bool_Allow_Change = False

        if self.int_Run_Status_Flag__Current__Sampling_Strategy == globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED:
            ''' Warning is necessary - Continue to change'''
            ''' Changing any Sampling Strategy parameters will require that the job be re-run '''
            str_MessageBox_Text = 'Just a moment...\n\nChanging any of this Sampling Strategy parameters will require that the Sampling Strategy be run again to incorporate those changes.\n\nTo retain the Sampling Strategy current results for later comparison, first clone this Sampling Strategy and then change the cloned parameters.\n\nOtherwise, the results for this Sampling Strategy will be lost.\n\nAre you sure you wish to continue?'
            messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Sampling Strategy Parameters?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
                        
            if messageBox_Reponse == QtGui.QMessageBox.Yes:
                ''' Continue to change'''
                bool_Allow_Change = True
                self.int_Edit_Warning_Count__All_Sampling_Strategy_Params += 1

                ''' Remove Job details from Batch Settings '''
                #bool_Success = self.func_Run_Job__Job_Status_Change__User_Edits_Force_Rerun__Batch_Scenario()

                ''' Remove Job details from Sampling Scenarios '''
                bool_Success = self.func_Run_Job__Job_Status_Change__User_Edits_Force_Rerun__Sampling_Strategy()
                
                ''' Delete results? '''
                ''' Reload the Current Sampling Strategy '''
                if bool_Success:
                    #''' Refresh the comboBox with new data ''' 
                    int_Index = self.comboBox_300.currentIndex()
                    self.func_QComboBox_SAMPLING_STRATEGY_FILE_Selected(int_Index)
                    
                pass                
            else:
                ''' Abort change'''
                bool_Allow_Change = False
                self.int_Edit_Warning_Count__All_Sampling_Strategy_Params = 0
            pass
        else:
            ''' No warning is necessary - Continue to change'''
            bool_Allow_Change = True
            self.int_Edit_Warning_Count__All_Sampling_Strategy_Params += 1        
        pass
    
        return bool_Allow_Change
    
    def func_Change__Scenario_Max_Age(self, int_Value):
        
        pass
        return True

    def func_Update__Scenario_Max_Mating_Age(self, int_Value, bool_Save):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Species_Life_History_Max_Mating_Age = int_Value 
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF                
            self.func_Update_Config__Max_Mating_Age()
#             if self.bool_int_Species_Life_History_Max_Mating_Age__FOUND:
#                 
#                 self.func_Update_Config__Max_Mating_Age()
#             else:
#                 self.func_Update_Config__Max_Mating_Age()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_43.setText(self.str_Max_Mating_Age__Label_Text)
#             pass
            ''' Set the ranges for related sliders '''
            self.func_Set_Associated_Slider_Range_And_Value__horizontalslider_32(int_Value)        
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Max_Mating_Age(int_Value)
    
        return True

    def func_Change__Scenario_Max_Mating_Age(self, int_Value):
        
        ''' Set the ranges for related sliders '''
        #self.func_Set_Associated_Slider_Range_And_Value__horizontalslider_32(int_Value) 
        return True

    def func_Update__Scenario_Min_Mating_Age(self, int_Value, bool_Save):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Species_Life_History_Min_Mating_Age = int_Value 
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF              
            self.func_Update_Config__Min_Mating_Age()  
#             if self.bool_int_Species_Life_History_Min_Mating_Age__FOUND:
#                 
#                 self.func_Update_Config__Min_Mating_Age()
#             else:
#                 self.func_Update_Config__Min_Mating_Age()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_44.setText(self.str_Min_Mating_Age__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Min_Mating_Age(int_Value)
    
        return True

    def func_Change__Scenario_Min_Mating_Age(self, int_Value):
        
        ''' Set the ranges for related sliders '''
        #self.func_Set_Associated_Slider_Range_And_Value__horizontalslider_31(int_Value) 
        return True

    def func_Update_Config__Max_Age(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass     

#         '''
#         ---------------------------------------------------
#         Remove unwanted SECTIONS & OPTIONS from config
#         ---------------------------------------------------
#         '''
#         ''' >>>>>>>>> Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE '''
#         str_Section = obj_Config.static_str_Section__Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE
#         obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
#         self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__FOUND = False
#         self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__CHANGED = False
#         ''' >>>>>>>>> Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE '''
#         str_Section = obj_Config.static_str_Section__Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE
#         obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
#         self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__FOUND = False
#         self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__CHANGED = False
#         ''' Force Edit on Age Cohort Mortality Dist '''
#         qWidget = self.pushButton_6
#         str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
#         self.func_Set_Parameter_Status(qWidget, str_Parameter_Status) 
                 
        '''
        ---------------------------------------------------
        Update SECTIONS & OPTIONS
        ---------------------------------------------------
        '''       
        ''' <<<<<<< SECTION: Life_History '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Species_Life_History_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Species_Life_History_Max_Age
        value_Option = self.int_Species_Life_History_Max_Age
        ''' Update the OPTION '''
        bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
        if bool_Success:
            self.bool_int_Species_Life_History_Max_Age__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
            qWidget = self.label_42
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
            ''' On MaxAge Change - Always requre edits on the Age Cohort Mortality Dist '''
            ''' Change the Status for the Age Cohort Mortality Dist to force the user to alter and re-save it '''
            qWidget = self.pushButton_6
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
        pass
        
        return True 
           
    def func_Update_Config__Max_Mating_Age(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        
        if obj_Config != None:
            config_parser_Config = obj_Config.config_parser_Config
        
            if config_parser_Config != None:
                
                ''' <<<<<<< SECTION: Life_History '''
                ''' Specify SECTION to UPDATE '''
                str_Section = obj_Config.static_str_Section__Species_Life_History_Details
                ''' Specify OPTION to UPDATE '''
                str_Option = obj_Config.static_str_Option__Species_Life_History_Max_Mating_Age
                value_Option = self.int_Species_Life_History_Max_Mating_Age
                ''' Update the OPTION '''
                config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
                self.bool_int_Species_Life_History_Max_Mating_Age__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.label_43
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)     
                pass
            else:
                str_Message_Text = 'config_parser_Config = None'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            pass
        else:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
        pass
        return True    
        
    def func_Update_Config__Min_Mating_Age(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        
        if obj_Config != None:
            config_parser_Config = obj_Config.config_parser_Config
        
            if config_parser_Config != None:
                
                ''' <<<<<<< SECTION: Life_History '''
                ''' Specify SECTION to UPDATE '''
                str_Section = obj_Config.static_str_Section__Species_Life_History_Details
                ''' Specify OPTION to UPDATE '''
                str_Option = obj_Config.static_str_Option__Species_Life_History_Min_Mating_Age
                value_Option = self.int_Species_Life_History_Min_Mating_Age
                ''' Update the OPTION '''
                config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
                self.bool_int_Species_Life_History_Min_Mating_Age__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.label_44
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)     
                pass
            else:
                str_Message_Text = 'config_parser_Config = None'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            pass
        else:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
        pass
        return True    

    '''
    ----------------------------
    Scenario - Life History Offspring distribution 
    ----------------------------
    '''    
    def func_Offspring_Distribution_Selection_RETIRE(self, int_Index): 
        
        #obj_Config_Batch_Scenario = self.obj_Config_Batch_Scenario
        obj_Config = self.obj_Config_Settings
        
        str_Section = obj_Config.static_str_Section__Settings_Species_Offspring_Distribution_List
        str_Option = object_SSConfigBatchScenario.static_str_Option__Species_Offspring_Distribution + '_' + str(int_Index)
        value_Type = ''
        value_Option = self.func_Get_Current_Config_Value(obj_Config, str_Section, str_Option, value_Type)
        
        self.str_Species_Offspring_Distribution = value_Option
        if value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_ABSOLUTE:
            self.stackedWidget.setCurrentIndex(1)
            self.horizontalSlider_27.setValue(self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number)
            self.label_39.setText(self.str_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Label_Text)
            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_POISSON:
            self.stackedWidget.setCurrentIndex(2)
            intScaled_Value = int(self.float_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number*self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor)
            self.horizontalSlider_30.setValue(intScaled_Value)
            self.label_68.setText(self.str_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Label_Text) 
            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_BINOMIAL:
            self.stackedWidget.setCurrentIndex(3)
            intScaled_Value = int(self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor)
            self.horizontalSlider_28.setValue(intScaled_Value)
            self.label_40.setText(self.str_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Label_Text)
            intScaled_Value = int(self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor)            
            self.horizontalSlider_29.setValue(intScaled_Value)
            self.label_41.setText(self.str_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Label_Text)            
            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_UNIFORM:
            self.stackedWidget.setCurrentIndex(4)
            self.horizontalSlider_39.setValue(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min)
            self.label_69.setText(self.str_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Label_Text)            
            self.horizontalSlider_40.setValue(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max)
            self.label_70.setText(self.str_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Label_Text)            
            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_GEOMETRIC:
            self.stackedWidget.setCurrentIndex(5)
            intScaled_Value = int(self.float_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean*self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor)
            self.horizontalSlider_41.setValue(intScaled_Value)
            self.label_71.setText(self.str_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Label_Text)            
            
        else:
            self.stackedWidget.setCurrentIndex(0)
        pass
        return True
    
    def func_Offspring_Distribution_Selection_PREV(self, int_Index): 
        
        obj_Config = self.obj_Config_Settings
        
        str_Section = obj_Config.static_str_Section__Settings_Species_Offspring_Distribution_List
        str_Option = object_SSConfigBatchScenario.static_str_Option__Species_Offspring_Distribution + '_' + str(int_Index)
        value_Type = ''
        value_Option = self.func_Get_Current_Config_Value(obj_Config, str_Section, str_Option, value_Type)

        bool_UnChanged = False
        if self.str_Species_Offspring_Distribution == value_Option:
            bool_UnChanged = True
        pass        
        self.str_Species_Offspring_Distribution = value_Option
        
        if value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_ABSOLUTE:
            
            self.stackedWidget.setCurrentIndex(1)

            if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                self.horizontalSlider_27.setValue(self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number)
            else:
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
            pass
                        
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_POISSON:
            self.stackedWidget.setCurrentIndex(2)

            if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                intScaled_Value = int(self.float_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number*self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor)
                self.horizontalSlider_30.setValue(intScaled_Value)
            else:
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
            pass            
            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_BINOMIAL:
            self.stackedWidget.setCurrentIndex(3)
            
            if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                intScaled_Value = int(self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor)
                self.horizontalSlider_28.setValue(intScaled_Value)
            else:
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
            pass            

            if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                intScaled_Value = int(self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor)            
                self.horizontalSlider_29.setValue(intScaled_Value)
            else:
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
            pass            
            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_UNIFORM:
            self.stackedWidget.setCurrentIndex(4)

            if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                self.horizontalSlider_39.setValue(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min)
            else:
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
            pass 

            if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                self.horizontalSlider_40.setValue(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max)
            else:
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
            pass                     
            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_GEOMETRIC:
            self.stackedWidget.setCurrentIndex(5)

            if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                intScaled_Value = int(self.float_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean*self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor)
                self.horizontalSlider_41.setValue(intScaled_Value)
            else:
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
            pass  
            
        else:
            self.stackedWidget.setCurrentIndex(0)
            qWidget = self.groupBox_19
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        

        pass
        return True
       
    def func_Offspring_Distribution_Selection(self, int_Index): 

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        obj_Config = self.obj_Config_Settings
        
        str_Section = obj_Config.static_str_Section__Settings_Species_Offspring_Distribution_List
        str_Option = object_SSConfigBatchScenario.static_str_Option__Species_Offspring_Distribution + '_' + str(int_Index)
        value_Type = ''
        value_Option = self.func_Get_Current_Config_Value(obj_Config, str_Section, str_Option, value_Type)

        str_Object_Name = 'comboBox_4'
        qWidget_Engaged = self.findChild(QtGui.QComboBox, str_Object_Name)
        bool_UnChanged = False
        
        bool_Continue = False
        if self.str_Species_Offspring_Distribution == value_Option:
            bool_UnChanged = True
            bool_Continue = True
        else:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
                ''' Verify if the change can proceed '''
                int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Object_Groups)
                if int_Verify_Change__Warning_Count < 1:
                    ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                    qWidget_Engaged.blockSignals(True)
                    ''' Warn that other parameters that are dependent will have to be changed '''
                    bool_Continue = self.func_Verify_Change__Can_Change_Proceed__ANY_Scenario_PARAMETER()
                    if bool_Continue:
                        int_Index_New = qWidget_Engaged.findText(value_Option)
                        qWidget_Engaged.setCurrentIndex(int_Index_New)
                    pass
                    qWidget_Engaged.blockSignals(False)
                else:
                    bool_Continue = True
                pass
            else:
                bool_Continue = True
            pass
        pass
    
        if bool_Continue:
            self.str_Species_Offspring_Distribution = value_Option
            
            if value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_ABSOLUTE:
                
                self.stackedWidget.setCurrentIndex(1)
    
                if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                    self.horizontalSlider_27.setValue(self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number)
                else:
                    qWidget = self.groupBox_19
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
                pass
                            
            elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_POISSON:
                self.stackedWidget.setCurrentIndex(2)
    
                if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                    intScaled_Value = int(self.float_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number*self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor)
                    self.horizontalSlider_30.setValue(intScaled_Value)
                else:
                    qWidget = self.groupBox_19
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
                pass            
                
            elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_BINOMIAL:
                self.stackedWidget.setCurrentIndex(3)
                
                if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                    intScaled_Value = int(self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor)
                    self.horizontalSlider_28.setValue(intScaled_Value)
                    intScaled_Value = int(self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor)            
                    self.horizontalSlider_29.setValue(intScaled_Value)                    
                else:
                    qWidget = self.groupBox_19
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
                pass            
    
#                 if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
#                     intScaled_Value = int(self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev*self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor)            
#                     self.horizontalSlider_29.setValue(intScaled_Value)
#                 else:
#                     qWidget = self.groupBox_19
#                     str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
#                     self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
#                 pass            
                
            elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_UNIFORM:
                self.stackedWidget.setCurrentIndex(4)
    
                if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                    self.horizontalSlider_39.setValue(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min)
                    self.horizontalSlider_40.setValue(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max)
                else:
                    qWidget = self.groupBox_19
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
                pass 
    
#                 if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
#                     self.horizontalSlider_40.setValue(self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max)
#                 else:
#                     qWidget = self.groupBox_19
#                     str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
#                     self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
#                 pass                     
                
            elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_GEOMETRIC:
                self.stackedWidget.setCurrentIndex(5)
    
                if (bool_UnChanged and self.bool_Species_Offspring_Distribution__FOUND):
                    intScaled_Value = int(self.float_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean*self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor)
                    self.horizontalSlider_41.setValue(intScaled_Value)
                else:
                    qWidget = self.groupBox_19
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
                pass  
                
            else:
                self.stackedWidget.setCurrentIndex(0)
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)        
    
            pass
        else:
            int_Index_Orig = qWidget_Engaged.findText(self.str_Species_Offspring_Distribution)
            qWidget_Engaged.setCurrentIndex(int_Index_Orig)
        pass
        return True
       
    def func_Offspring_Distribution_Display(self): 

        ''' Force the comboBox to update - Because it wont update if the new index is the same as the old index '''
        self.comboBox_4.blockSignals(True)
        self.comboBox_4.setCurrentIndex(-1)
        self.comboBox_4.blockSignals(False)
            
        value_Option = self.str_Species_Offspring_Distribution
        if value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_ABSOLUTE:
            self.comboBox_4.setCurrentIndex(1)
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_POISSON:
            self.comboBox_4.setCurrentIndex(2)
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_BINOMIAL:
            self.comboBox_4.setCurrentIndex(3)
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_UNIFORM:
            self.comboBox_4.setCurrentIndex(4)
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_GEOMETRIC:
            self.comboBox_4.setCurrentIndex(5)
        else:
            self.comboBox_4.setCurrentIndex(0)
        pass
    
        return True

    def func_Update__Scenario_Offspring_Distribution(self, str_Object_Name, value_Object, bool_Save):
        
        if str_Object_Name == 'horizontalSlider_27':
            self.func_Update__Scenario_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_30':
            self.func_Update__Scenario_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_28':
            self.func_Update__Scenario_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_29':
            self.func_Update__Scenario_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_39':
            self.func_Update__Scenario_Species_Offspring_Distribution_UNIFORM_Offspring_Min(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_40':
            self.func_Update__Scenario_Species_Offspring_Distribution_UNIFORM_Offspring_Max(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_41':
            self.func_Update__Scenario_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean(value_Object, bool_Save)
        pass
    
        return True

    def func_Update__Scenario_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF   
            
            self.str_Species_Offspring_Distribution = object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_ABSOLUTE 
            self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number = int_Value 
            self.func_Update_Config__Offspring_Distribution()
#             if self.bool_Species_Offspring_Distribution__FOUND:
#                 
#                 self.func_Update_Config__Offspring_Distribution()
#             else:
#                 self.func_Update_Config__Offspring_Distribution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Offspring_Distribution(int_Value)
    
        return True            
            
    def func_Update__Scenario_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number(self, float_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF   
            
            self.str_Species_Offspring_Distribution = object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_POISSON 
            self.float_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number = float_Value
            self.func_Update_Config__Offspring_Distribution() 
#             if self.bool_Species_Offspring_Distribution__FOUND:
#                 
#                 self.func_Update_Config__Offspring_Distribution()
#             else:
#                 self.func_Update_Config__Offspring_Distribution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Offspring_Distribution(float_Value)
    
        return True            
            
    def func_Update__Scenario_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number(self, float_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF   
            
            self.str_Species_Offspring_Distribution = object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_BINOMIAL 
            self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number = float_Value 
            self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev = self.doubleSpinBox_6.value() 
            self.func_Update_Config__Offspring_Distribution()
#             if self.bool_Species_Offspring_Distribution__FOUND:
#                 
#                 self.func_Update_Config__Offspring_Distribution()
#             else:
#                 self.func_Update_Config__Offspring_Distribution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Offspring_Distribution(float_Value)
    
        return True            
            
    def func_Update__Scenario_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev(self, float_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF   
            
            self.str_Species_Offspring_Distribution = object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_BINOMIAL 
            self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev = float_Value 
            self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number = self.doubleSpinBox_5.value()
            self.func_Update_Config__Offspring_Distribution()
#             if self.bool_Species_Offspring_Distribution__FOUND:
#                 
#                 self.func_Update_Config__Offspring_Distribution()
#             else:
#                 self.func_Update_Config__Offspring_Distribution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Offspring_Distribution(float_Value)
    
        return True            
            
    def func_Update__Scenario_Species_Offspring_Distribution_UNIFORM_Offspring_Min(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF   
            
            self.str_Species_Offspring_Distribution = object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_UNIFORM
            self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min = int_Value 
            self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max = self.spinBox_31.value()
            self.func_Update_Config__Offspring_Distribution()
#             if self.bool_Species_Offspring_Distribution__FOUND:
#                 
#                 self.func_Update_Config__Offspring_Distribution()
#             else:
#                 self.func_Update_Config__Offspring_Distribution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Offspring_Distribution(int_Value)
    
        return True            
            
    def func_Update__Scenario_Species_Offspring_Distribution_UNIFORM_Offspring_Max(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF   
            
            self.str_Species_Offspring_Distribution = object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_UNIFORM
            self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max = int_Value
            self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min = self.spinBox_26.value()
            self.func_Update_Config__Offspring_Distribution()
#             if self.bool_Species_Offspring_Distribution__FOUND:
#                 
#                 self.func_Update_Config__Offspring_Distribution()
#             else:
#                 self.func_Update_Config__Offspring_Distribution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Offspring_Distribution(int_Value)
    
        return True            
            
    def func_Update__Scenario_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean(self, float_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF   
            
            self.str_Species_Offspring_Distribution = object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_GEOMETRIC
            self.float_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean = float_Value 
            self.func_Update_Config__Offspring_Distribution()
#             if self.bool_Species_Offspring_Distribution__FOUND:
#                 
#                 self.func_Update_Config__Offspring_Distribution()
#             else:
#                 self.func_Update_Config__Offspring_Distribution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Offspring_Distribution(float_Value)
    
        return True            
            
    def func_Change__Scenario_Offspring_Distribution(self, value):
        
        pass
        return True

    def func_Update_Config__Offspring_Distribution(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            


        '''
        ---------------------------------------------------
        Update config
        ---------------------------------------------------
        '''       
            
        ''' <<<<<<< SECTION: Offspring_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Species_Offspring_Details

        ''' Define Sections/Options/Values dict '''
        dict_Section_Key_Option_Value = OrderedDict()
        list_Options_To_Purge = [
                                 obj_Config.static_str_Option__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number
                                 ,obj_Config.static_str_Option__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number
                                 ,obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number
                                 ,obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev
                                 ,obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Min
                                 ,obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Max
                                 ,obj_Config.static_str_Option__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean
                                 ]
        dict_Section_Key_Option_Value[str_Section] = list_Options_To_Purge
        ''' Purge the values from the dict '''
        bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_OPTIONS_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value)

        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution
        value_Option = self.str_Species_Offspring_Distribution
        ''' Update the OPTION '''
        bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
        if bool_Success:
            self.bool_Species_Offspring_Distribution__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
        pass

        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False
        ''' Specify OPTION to UPDATE '''
        if value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_ABSOLUTE:
            self.bool_int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__CHANGED = False
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number
            value_Option = self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                   
            pass
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_POISSON:
            self.bool_float_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__CHANGED = False
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number            
            value_Option = self.float_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                   
            pass            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_BINOMIAL:
            self.bool_float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__CHANGED = False
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number            
            value_Option = self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                   
            pass            
            self.bool_float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__CHANGED = False
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev            
            value_Option = self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                   
            pass            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_UNIFORM:
            self.bool_int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__CHANGED = False
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Min            
            value_Option = self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                   
            pass            
            self.bool_int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__CHANGED = False
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Max            
            value_Option = self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)   
            pass            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Species_Offspring_Distribution_GEOMETRIC:
            self.bool_float_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__CHANGED = False
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean            
            value_Option = self.float_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_float_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_19
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)   
            pass            
        else:
            pass
        pass        
        return True    
    
    '''
    ----------------------------
    Scenario - Demography 
    ----------------------------
    '''   
    def func_Update__Scenario_Demography(self, str_Object_Name, value_Object, bool_Save):
        
        if str_Object_Name == 'horizontalSlider_34':
            self.func_Update__Scenario_Demography_Population_Size(value_Object, bool_Save)
        pass
    
        return True

    def func_Update__Scenario_Demography_Population_Size(self, int_Value, bool_Save):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Population_Size = int_Value 
            self.func_Update_Config__Population_Size()
#             if self.bool_int_Population_Size__FOUND:
#                 
#                 self.func_Update_Config__Population_Size()
#             else:
#                 self.func_Update_Config__Population_Size()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_45.setText(self.str_Population_Size__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Demography_Population_Size(int_Value)
    
        return True

    def func_Verify_Change__Scenario_Population_Size(self, int_Value):

        bool_Allow_Change = False
         
        if self.int_Verify_Change__Scenario_Demography_Population_Size__Warning_Count > 0:
            self.int_Verify_Change__Scenario_Demography_Population_Size__Warning_Count += 1
            return True, self.int_Verify_Change__Scenario_Demography_Population_Size__Warning_Count
        pass
        
        if (self.bool_int_Population_Size__FOUND or self.bool_int_Population_Size__CHANGED) and (self.bool_int_Sampling_Strategy_Sample_Range_Max__FOUND or self.bool_int_Sampling_Strategy_Sample_Range_Max__CHANGED):

            ''' Associated parameters will have to be changed '''
            str_MessageBox_Text = 'Changing the Population Size will require that you redefine the Sampling Strategy Sample Size parameters.\n\nAre you sure you wish to continue?'
            messageBox_Reponse = QtGui.QMessageBox.question(self, 'Change Population Size?', str_MessageBox_Text, buttons=QtGui.QMessageBox.Yes, defaultButton=QtGui.QMessageBox.No)
            self.int_Verify_Change__Scenario_Demography_Population_Size__Warning_Count += 1
            
            if messageBox_Reponse == QtGui.QMessageBox.Yes:
                ''' Continue to change Max Age'''
                bool_Allow_Change = True
                ''' Change the Status for the Age Cohort Mortality Dist to force the user to alter and re-save it '''
                qWidget = self.pushButton_6
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                    
            else:
                ''' Abort Max Age change'''
                bool_Allow_Change = False
                self.int_Verify_Change__Scenario_Demography_Population_Size__Warning_Count = 0
            pass
        pass
    
        return bool_Allow_Change, self.int_Verify_Change__Scenario_Max_Age__Warning_Count

    def func_Set_Associated_Sliders_Range_And_Value__Scenario__Population_Size(self, int_Value):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        #int_Sampling_Strategy_Sample_Range_Max__New = int(self.int_Population_Size)
        int_Sampling_Strategy_Sample_Range_Max__New = int(self.int_Sampling_Strategy_Sample_Range_Max)
        int_Sampling_Strategy_Sample_Range_Max_Max__New = int(self.int_Population_Size)
 
        bool_Status_Change_Required = False
        
        if self.int_Population_Size < self.int_Sampling_Strategy_Sample_Range_Max:
            if self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value > self.int_Population_Size*10:
                int_Sampling_Strategy_Sample_Range_Max__New = int(self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value)
            else:
                int_Sampling_Strategy_Sample_Range_Max__New = int(round(float(self.int_Population_Size) / float(10),0))
            pass
            bool_Status_Change_Required = True
            pass
        elif self.int_Population_Size == self.int_Sampling_Strategy_Sample_Range_Max:
            int_Sampling_Strategy_Sample_Range_Max__New = self.int_Sampling_Strategy_Sample_Range_Max
            bool_Status_Change_Required = False
            pass
        else:
            int_Sampling_Strategy_Sample_Range_Max__New = self.int_Sampling_Strategy_Sample_Range_Max
            bool_Status_Change_Required = False
        pass

        self.int_Sampling_Strategy_Sample_Range_Max = int_Sampling_Strategy_Sample_Range_Max__New
        
        ''' Set the Range of the Sampling Strategy Locus Max based on the Total number of loci available for sampling '''
        self.spinBox_41.setRange(self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value, int_Sampling_Strategy_Sample_Range_Max_Max__New) 
        self.horizontalSlider_49.setRange(self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value, int_Sampling_Strategy_Sample_Range_Max_Max__New)
        self.spinBox_41.setValue(self.int_Sampling_Strategy_Sample_Range_Max)
        ''' Set the Range of the Sampling Strategy Locus Increment '''
        self.spinBox_45.setRange(1, self.int_Sampling_Strategy_Locus_Range_Max) 
        self.horizontalSlider_53.setRange(1, self.int_Sampling_Strategy_Locus_Range_Max) 
        
        if bool_Status_Change_Required:
            qWidget = self.label_61
            ''' NOTE: IF MIN IS ENABLED CHANGE THIS STATUS TO SS_REQUIRES_USER_EDIT '''
            #str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                    
            qWidget = self.label_62
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                    
            qWidget = self.label_63
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status) 
        pass
            
    def func_Change__Scenario_Demography_Population_Size(self, int_Value):

        ''' Set the ranges for related sliders '''
        self.func_Set_Associated_Sliders_Range_And_Value__Scenario__Population_Size(int_Value)
        self.func_Change__Sampling_Strategy_Locus_Range_Max(self.int_Sampling_Strategy_Locus_Range_Max)
        self.func_Change__Sampling_Strategy_Sample_Range_Max(self.int_Sampling_Strategy_Sample_Range_Max)                 
        pass
        return True
        
    def func_Update_Config__Population_Size(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            
    
        ''' <<<<<<< SECTION: Population_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Population_Demographic_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Population_Size
        value_Option = self.int_Population_Size
        ''' Update the OPTION '''
        bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
        if bool_Success:
            self.bool_int_Population_Size__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
            qWidget = self.label_45
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)    
        pass
        return True    

    def func_Update_Config__Age_And_Natural_Mortality_Rate__MALE(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
        
        '''
        ---------------------------------------------------
        Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' >>>>>>>>> Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE '''
        str_Section = obj_Config.static_str_Section__Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
       
        '''
        ---------------------------------------------------
        Update config
        ---------------------------------------------------
        '''    
        dict_Section_Key_Option_Value_Tuple = OrderedDict()
         
        ''' >>>>>>>>> CSV_Age_And_Natural_Mortality_Rate__MALE '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE
        list_tup_Option_Value = []
        
        for key_int_Age, value_float_ in self.dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE.items():
            ''' Specify OPTION to UPDATE ''' 
            str_Option = key_int_Age
            value_Option = value_float_
            list_tup_Option_Value.append((str_Option, value_Option))
        pass
    
        ''' Update the config parser '''
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
        obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
           
        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
            qWidget = self.pushButton_6
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
            self.int_Verify_Change__Scenario_Max_Age__Warning_Count = 0
        pass
        return True
    
    def func_Update_Config__Age_And_Natural_Mortality_Rate__FEMALE(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
                
        '''
        ---------------------------------------------------
        Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' >>>>>>>>> Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE '''
        str_Section = obj_Config.static_str_Section__Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
       
        '''
        ---------------------------------------------------
        Update config
        ---------------------------------------------------
        '''       
        dict_Section_Key_Option_Value_Tuple = OrderedDict()
         
        ''' >>>>>>>>> CSV_Age_And_Natural_Mortality_Rate__FEMALE '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE
        list_tup_Option_Value = []
        
        for key_int_Age, value_float_ in self.dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE.items():
            ''' Specify OPTION to UPDATE ''' 
            str_Option = key_int_Age
            value_Option = value_float_
            list_tup_Option_Value.append((str_Option, value_Option))
        pass
    
        ''' Update the config parser '''
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
        obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
           
        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
            qWidget = self.pushButton_6
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
            self.int_Verify_Change__Scenario_Max_Age__Warning_Count = 0
        pass
        return True

    
    '''
    ----------------------------
    Scenario - Genetics 
    ----------------------------
    ''' 
    def func_Genome_Alleles_Per_Locus_Distribution_Distribution_Selection(self, int_Index): 
        
        obj_Config = self.obj_Config_Settings
        
        str_Section = obj_Config.static_str_Section__Genome_Alleles_Per_Locus_Distribution_List
        str_Option = object_SSConfigBatchScenario.static_str_Option__Genome_Alleles_Per_Locus_Distribution + '_' + str(int_Index)
        value_Type = ''
        value_Option = self.func_Get_Current_Config_Value(obj_Config, str_Section, str_Option, value_Type)
        
        str_Object_Name = 'comboBox_5'
        qWidget_Engaged = self.findChild(QtGui.QComboBox, str_Object_Name)
        bool_UnChanged = False
        
        bool_Continue = False
        if self.str_Genome_Alleles_Per_Locus_Distribution == value_Option:
            bool_UnChanged = True
            bool_Continue = True
        else:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
                ''' Verify if the change can proceed '''
                int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Object_Groups)
                if int_Verify_Change__Warning_Count < 1:
                    ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                    qWidget_Engaged.blockSignals(True)
                    ''' Warn that other parameters that are dependent will have to be changed '''
                    bool_Continue = self.func_Verify_Change__Can_Change_Proceed__ANY_Scenario_PARAMETER()
                    if bool_Continue:
                        int_Index_New = qWidget_Engaged.findText(value_Option)
                        qWidget_Engaged.setCurrentIndex(int_Index_New)
                    pass
                    qWidget_Engaged.blockSignals(False)
                else:
                    bool_Continue = True
                pass
            else:
                bool_Continue = True
            pass
        pass
    
        if bool_Continue:  
            
            self.str_Genome_Alleles_Per_Locus_Distribution = value_Option
                          
            if value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Alleles_Per_Locus_Distribution_UNIFORM:
    
                if (bool_UnChanged and self.bool_Genome_Alleles_Per_Locus_Distribution__FOUND): #or self.bool_int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__CHANGED:
                    self.horizontalSlider_35.setValue(self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus)
                else:
                    qWidget = self.groupBox_23
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)       
                pass
                #self.label_47.setText(self.str_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Label_Text)
                self.stackedWidget_4.setCurrentIndex(1)
            elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Alleles_Per_Locus_Distribution_BINOMIAL:
                #self.groupBox_23.setTitle(self.str_Genome_Alleles_Per_Locus_Distribution__Label_Text + '*')
    
                if (bool_UnChanged and self.bool_Genome_Alleles_Per_Locus_Distribution__FOUND):# or self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__CHANGED: 
                    int_Scaled_Value = int(self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Step_Divisor)
                    self.horizontalSlider_37.setValue(int_Scaled_Value)
                    int_Scaled_Value = int(self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor)
                    self.horizontalSlider_42.setValue(int_Scaled_Value)

                else:
                    qWidget = self.groupBox_23
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)       
                pass
                #self.label_48.setText(self.str_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Label_Text) 
    
#                 if (bool_UnChanged and self.bool_Genome_Alleles_Per_Locus_Distribution__FOUND):# or self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__CHANGED: 
#                     int_Scaled_Value = int(self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus*self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor)
#                     self.horizontalSlider_42.setValue(int_Scaled_Value)
#                 else:
#                     qWidget = self.groupBox_23
#                     str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
#                     self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)       
#                 pass
                #self.label_49.setText(self.str_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Label_Text)
                self.stackedWidget_4.setCurrentIndex(2) 
            else:
                #self.groupBox_23.setTitle(self.str_Genome_Alleles_Per_Locus_Distribution__Label_Text + '*')
                qWidget = self.groupBox_23
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)       
    
                self.stackedWidget_4.setCurrentIndex(0)
            pass
        else:
            int_Index_Orig = qWidget_Engaged.findText(self.str_Genome_Alleles_Per_Locus_Distribution)
            qWidget_Engaged.setCurrentIndex(int_Index_Orig)
        pass
        return True

    def func_Genome_Alleles_Per_Locus_Distribution_Display(self): 
        
        ''' Force the comboBox to update - Because it wont update if the new index is the same as the old index '''
        self.comboBox_5.blockSignals(True)
        self.comboBox_5.setCurrentIndex(-1)
        self.comboBox_5.blockSignals(False)
        pass
    
        value_Option = self.str_Genome_Alleles_Per_Locus_Distribution
        if value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Alleles_Per_Locus_Distribution_UNIFORM:
            self.comboBox_5.setCurrentIndex(1)
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Alleles_Per_Locus_Distribution_BINOMIAL:
            self.comboBox_5.setCurrentIndex(2)
        else:
            self.comboBox_5.setCurrentIndex(0)
        pass
        return True   
        
    def func_Genome_Allele_Frequency_Distribution_Selection(self, int_Index): 

        ''' Get the selection '''
        obj_Config = self.obj_Config_Settings
        
        str_Section = obj_Config.static_str_Section__Genome_Allele_Frequency_Distribution_List
        str_Option = object_SSConfigBatchScenario.static_str_Option__Genome_Allele_Frequency_Distribution + '_' + str(int_Index)
        value_Type = ''
        value_Option = self.func_Get_Current_Config_Value(obj_Config, str_Section, str_Option, value_Type)

        str_Object_Name = 'comboBox_6'
        qWidget_Engaged = self.findChild(QtGui.QComboBox, str_Object_Name)
        bool_UnChanged = False
        set_LineEdit_Text_Prev = self.label_16.text()
        
        bool_Continue = False
        bool_Changed = False
        if self.str_Genome_Allele_Frequency_Distribution == value_Option:
            bool_UnChanged = True
            bool_Continue = True
        else:
            if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__BATCH_SCENARIO_PARAM]
                ''' Verify if the change can proceed '''
                int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Object_Groups)
                if int_Verify_Change__Warning_Count < 1:
                    ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                    qWidget_Engaged.blockSignals(True)
                    ''' Warn that other parameters that are dependent will have to be changed '''
                    bool_Continue = self.func_Verify_Change__Can_Change_Proceed__ANY_Scenario_PARAMETER()
                    if bool_Continue:
                        int_Index_New = qWidget_Engaged.findText(value_Option)
                        qWidget_Engaged.setCurrentIndex(int_Index_New)
                        '''NOTE: This is different to other comboBox Selection functions...
                        The Changed flag must be set here as for this comboBox just changing the index saves the new value '''
                        bool_Changed = True
                    else:
                        bool_Changed = False
                    pass
                    qWidget_Engaged.blockSignals(False)
                else:
                    bool_Continue = True
                    '''NOTE: This is different to other comboBox Selection functions...
                    The Changed flag must be set here as for this comboBox just changing the index saves the new value '''
                    bool_Changed = True
                pass
            else:
                bool_Continue = True
                bool_Changed = False
            pass
        pass
    
        if bool_Continue:  
        
            self.str_Genome_Allele_Frequency_Distribution = value_Option
        
            if value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_NON_RANDOM:
                self.stackedWidget_5.setCurrentIndex(1)
                            
                if bool_Changed or (bool_UnChanged and self.bool_Genome_Allele_Frequency_Distribution__FOUND):
                    self.label_16.setText(object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_NON_RANDOM)
                    
                    self.func_Update_Config__Genome_Allele_Frequency_Distribution()
                else:
                    qWidget = self.groupBox_24
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)    
                pass
            elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_DRICHLET:
                self.stackedWidget_5.setCurrentIndex(2)
                
                if bool_Changed or (bool_UnChanged and self.bool_Genome_Allele_Frequency_Distribution__FOUND):
                    self.label_17.setText(object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_DRICHLET)
                    
                    self.func_Update_Config__Genome_Allele_Frequency_Distribution()
                else:
                    qWidget = self.groupBox_24
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)    
                pass
            elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES:
                if self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name != '':
                    qWidget = self.groupBox_24
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)    
                    ''' Clear previous selection '''
                    self.lineEdit_2.setText(str(self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name))
                    str_Path, str_File = os__path.split(str(self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name))
                    self.lineEdit_11.setText(str_File)
                    self.lineEdit_11.setCursorPosition(0)
                else:
                    ''' Clear previous selection '''
                    self.lineEdit_2.setText('')
                    self.lineEdit_11.setText('Please select...')
                    self.lineEdit_11.setCursorPosition(0)
                    qWidget = self.groupBox_24
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                     
                pass
                #self.label_50.setText(self.str_Genome_Allele_Frequency_Distribution__Label_Text)
                self.lineEdit_2.setText(str(self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name))
                self.stackedWidget_5.setCurrentIndex(3)
                ''' DONT save the selection...Need user to choose a file first.  Save occurs when File dialog OK is clicked '''
            elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP:
                if self.str_Genome__Source_GENEPOP_File_Path_And_Name != '':
                    qWidget = self.groupBox_24
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)    
                    ''' Clear previous selection '''
                    self.lineEdit_2.setText(str(self.str_Genome__Source_GENEPOP_File_Path_And_Name))
                    str_Path, str_File = os__path.split(str(self.str_Genome__Source_GENEPOP_File_Path_And_Name))
                    self.lineEdit_11.setText(str_File)
                    self.lineEdit_11.setCursorPosition(0)
                else:
                    ''' Clear previous selection '''
                    self.lineEdit_2.setText('')
                    self.lineEdit_11.setText('Please select...')
                    self.lineEdit_11.setCursorPosition(0)
                    qWidget = self.groupBox_24
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                     
                pass
                #self.label_50.setText(self.str_Genome_Allele_Frequency_Distribution__Label_Text)
                self.lineEdit_2.setText(str(self.str_Genome__Source_GENEPOP_File_Path_And_Name))
                self.stackedWidget_5.setCurrentIndex(3)
                ''' DONT save the selection...Need user to choose a file first.  Save occurs when File dialog OK is clicked '''
            else:
                qWidget = self.groupBox_24
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)    
                self.stackedWidget_5.setCurrentIndex(0)
            pass
        else:
            int_Index_Orig = qWidget_Engaged.findText(self.str_Genome_Allele_Frequency_Distribution)
            qWidget_Engaged.setCurrentIndex(int_Index_Orig)
            self.label_16.setText(set_LineEdit_Text_Prev)
        pass        
        return True

    def func_Genome_Allele_Frequency_Distribution_Display(self): 

        ''' Force the comboBox to update - Because it wont update if the new index is the same as the old index '''
        self.comboBox_6.blockSignals(True)
        self.comboBox_6.setCurrentIndex(-1)
        self.comboBox_6.blockSignals(False)
                
        value_Option = self.str_Genome_Allele_Frequency_Distribution
        if value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_NON_RANDOM:
            self.comboBox_6.setCurrentIndex(1)
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_DRICHLET:
            self.comboBox_6.setCurrentIndex(2)
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES:
            self.comboBox_6.setCurrentIndex(3)
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP:
            self.comboBox_6.setCurrentIndex(4)
        else:
            self.comboBox_6.setCurrentIndex(0)
        pass
        return True   
        
    def func_Update__Scenario_Genome(self, str_Object_Name, value_Object, bool_Save):
        
        if str_Object_Name == 'horizontalSlider_38':
            self.func_Update__Genome_Locus_Number(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_35':
            self.func_Update__Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_37':
            self.func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_42':
            self.func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus(value_Object, bool_Save)
        pass
    
        return True

    def func_Update__Genome_Locus_Number(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Genome_Locus_Number = int_Value 
            self.func_Update_Config__Genome_Locus_Number()
#             if self.bool_int_Genome_Locus_Number__FOUND:
#                 
#                 self.func_Update_Config__Genome_Locus_Number()
#             else:
#                 self.func_Update_Config__Genome_Locus_Number()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_8.setText(self.str_Genome_Locus_Number__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario__Genome_Locus_Number(int_Value)
    
        return True

    def func_Set_Associated_Sliders_Range_And_Value__Scenario__Genome_Locus_Number(self, int_Value):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        int_Sampling_Strategy_Locus_Range_Max__New = int(self.int_Sampling_Strategy_Locus_Range_Max)
        int_Sampling_Strategy_Locus_Range_Max_Max__New = int(self.int_Genome_Locus_Number)
 
        bool_Status_Change_Required = False
        
        if self.int_Genome_Locus_Number < self.int_Sampling_Strategy_Locus_Range_Max:
            if self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value > self.int_Genome_Locus_Number*3:
                int_Sampling_Strategy_Locus_Range_Max__New = int(self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value)
            else:
                int_Sampling_Strategy_Locus_Range_Max__New = int(round(float(self.int_Genome_Locus_Number) / float(3),0))
            pass
            
            bool_Status_Change_Required = True
        elif self.int_Genome_Locus_Number == self.int_Sampling_Strategy_Locus_Range_Max:
            int_Sampling_Strategy_Locus_Range_Max__New = self.int_Sampling_Strategy_Locus_Range_Max
            bool_Status_Change_Required = False
            pass
        else:
            int_Sampling_Strategy_Locus_Range_Max__New = self.int_Sampling_Strategy_Locus_Range_Max
            bool_Status_Change_Required = False
        pass

        self.int_Sampling_Strategy_Locus_Range_Max = int_Sampling_Strategy_Locus_Range_Max__New
        
        ''' Set the Range of the Sampling Strategy Locus Max based on the Total number of loci available for sampling '''
        self.spinBox_44.setRange(self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value, int_Sampling_Strategy_Locus_Range_Max_Max__New) 
        self.horizontalSlider_52.setRange(self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value, int_Sampling_Strategy_Locus_Range_Max_Max__New)
        self.spinBox_44.setValue(self.int_Sampling_Strategy_Locus_Range_Max)

        if bool_Status_Change_Required:
            qWidget = self.label_64
            ''' NOTE: IF MIN IS ENABLED CHANGE THIS STATUS TO SS_REQUIRES_USER_EDIT '''
            #str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                    
            qWidget = self.label_65
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                    
            qWidget = self.label_66
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status) 
        pass
    
    def func_Change__Scenario__Genome_Locus_Number(self, int_Value):
        
        ''' Set the ranges for related sliders '''
        self.func_Set_Associated_Sliders_Range_And_Value__Scenario__Genome_Locus_Number(int_Value) 
        self.func_Change__Sampling_Strategy_Locus_Range_Max(self.int_Sampling_Strategy_Locus_Range_Max)
        self.func_Change__Sampling_Strategy_Sample_Range_Max(self.int_Sampling_Strategy_Sample_Range_Max)
        
        return True
            
    def func_Update__Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus = int_Value 
            self.func_Update_Config__Genome_Alleles_Per_Locus_Distribution()
#             if self.bool_int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__FOUND:
#                 
#                 self.func_Update_Config__Genome_Alleles_Per_Locus_Distribution()
#             else:
#                 self.func_Update_Config__Genome_Alleles_Per_Locus_Distribution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.groupBox_23.setTitle(self.str_Genome_Alleles_Per_Locus_Distribution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Genome(int_Value, bool_Save)
    
        return True

    def func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus(self, float_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus = float_Value 
            self.func_Update_Config__Genome_Alleles_Per_Locus_Distribution()
#             if self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__FOUND:
#                 
#                 self.func_Update_Config__Genome_Alleles_Per_Locus_Distribution()
#             else:
#                 self.func_Update_Config__Genome_Alleles_Per_Locus_Distribution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.groupBox_23.setTitle(self.str_Genome_Alleles_Per_Locus_Distribution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Genome(float_Value, bool_Save)
    
        return True

    def func_Update__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus(self, float_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus = float_Value
            self.func_Update_Config__Genome_Alleles_Per_Locus_Distribution() 
#             if self.bool_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__FOUND:
#                 
#                 self.func_Update_Config__Genome_Alleles_Per_Locus_Distribution()
#             else:
#                 self.func_Update_Config__Genome_Alleles_Per_Locus_Distribution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.groupBox_23.setTitle(self.str_Genome_Alleles_Per_Locus_Distribution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Genome(float_Value, bool_Save)
    
        return True

    def func_Change__Scenario_Genome(self, float_Value, bool_Save):

        return True
    
    def func_Update_Config__Genome_Locus_Number(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            
    
        ''' <<<<<<< SECTION: Genome_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Genome_Details

        ''' Specify OPTION to UPDATE '''
        self.bool_int_Genome_Locus_Number__CHANGED = False
        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False        
        str_Option = obj_Config.static_str_Option__Genome_Locus_Number
        value_Option = self.int_Genome_Locus_Number
        ''' Update the OPTION '''
        bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
        if bool_Success:
            self.bool_int_Genome_Locus_Number__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
            qWidget = self.label_8
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
        pass
        return True    

    def func_Update_Config__Genome_Allele_Frequency_Distribution(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        '''
        ---------------------------------------------------
        Update config
        ---------------------------------------------------
        '''       
            
        ''' <<<<<<< SECTION: Genome_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Genome_Details

        ''' Define Sections/Options/Values dict '''
        dict_Section_Key_Option_Value = OrderedDict()
        list_Options_To_Purge = [
                                 obj_Config.static_str_Option__Genome_Allele_Frequency_Distribution
                                 ,obj_Config.static_str_Option__Genome_Source
                                 ,obj_Config.static_str_Option__Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name
                                 ,obj_Config.static_str_Option__Genome__Source_GENEPOP_File_Path_And_Name
                                 ]
        dict_Section_Key_Option_Value[str_Section] = list_Options_To_Purge
        ''' Purge the values from the dict '''
        bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_OPTIONS_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value)

        ''' Specify OPTION to UPDATE '''
        self.bool_str_Genome_Allele_Frequency_Distribution__CHANGED = False
        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False        
        str_Option = obj_Config.static_str_Option__Genome_Allele_Frequency_Distribution
        value_Option = self.str_Genome_Allele_Frequency_Distribution
        ''' Update the OPTION '''
        bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
        if bool_Success:
            self.bool_str_Genome_Allele_Frequency_Distribution__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
        pass

        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False
        ''' Specify OPTION to UPDATE '''
        if value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_NON_RANDOM:
            ''' Already updated by previous OPTION '''
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
            qWidget = self.groupBox_24
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)              
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_DRICHLET:
            ''' Already updated by previous OPTION '''
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
            qWidget = self.groupBox_24
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)              
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES:
            ''' Get the number of loci from the file '''
            str_Input_File_Path, str_Input_File_Name = os__path.split(str(self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name))
            bool_Success, self.int_Genome__Source_ALL_ALLELE_FREQUENCIES__Total_Loci, str_Message = self.func_Validate_Loci_From_File(str_Input_File_Path, str_Input_File_Name)
            
            if not bool_Success:
                ''' Report the error '''
                str_MessageBox_Text = 'Could not read the specified allele frequencies file:\n\n' + str(self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name) + '\n\nPlease check that the file readable and in Arlequin AllAlleleFrequencies format and try again.'
                QtGui.QMessageBox.critical(self, 'Arlequin AllAlleleFrequencies File Import Error', str_MessageBox_Text, QtGui.QMessageBox.Ok)

                self.bool_str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_24
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                 
                
                return False
                ''' Dont update the config '''
            else:
                self.func_QSpinBox__Scenario_Genome_Locus_Number__SetValue(self.int_Genome__Source_ALL_ALLELE_FREQUENCIES__Total_Loci)
                #self.horizontalSlider_38.setValue(self.int_Genome__Source_GENEPOP__Total_Loci)    
                #self.horizontalSlider_38.enabled = False    
            pass
        
            self.bool_str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name__CHANGED = False
            str_Option = obj_Config.static_str_Option__Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name            
            value_Option = str(self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name)
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_24
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                  
            pass            
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP:
            ''' Get the number of loci from the file '''
            str_Input_File_Path, str_Input_File_Name = os__path.split(str(self.str_Genome__Source_GENEPOP_File_Path_And_Name))
            bool_Success, self.int_Genome__Source_GENEPOP__Total_Loci, str_Message = self.func_Validate_Loci_From_File(str_Input_File_Path, str_Input_File_Name)
            
            if not bool_Success:
                ''' Report the error '''
                str_MessageBox_Text = 'Could not read the specified GENEPOP file:\n\n' + str(self.str_Genome__Source_GENEPOP_File_Path_And_Name) + '\n\nPlease check that the file readable and in GENEPOP format and try again.\n\n' + str_Message
                QtGui.QMessageBox.critical(self, 'GENEPOP File Import Error', str_MessageBox_Text, QtGui.QMessageBox.Ok)

                self.bool_str_Genome__Source_GENEPOP_File_Path_And_Name__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_24
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                 
                
                return False
                ''' Dont update the config '''
            else:
                self.func_QSpinBox__Scenario_Genome_Locus_Number__SetValue(self.int_Genome__Source_GENEPOP__Total_Loci)
                #self.horizontalSlider_38.setValue(self.int_Genome__Source_GENEPOP__Total_Loci)    
                #self.horizontalSlider_38.enabled = False    
            pass
        
            self.bool_str_Genome__Source_GENEPOP_File_Path_And_Name__CHANGED = False
            str_Option = obj_Config.static_str_Option__Genome__Source_GENEPOP_File_Path_And_Name            
            value_Option = str(self.str_Genome__Source_GENEPOP_File_Path_And_Name)
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_str_Genome__Source_GENEPOP_File_Path_And_Name__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_24
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                  
            pass            
        else:
            pass
        pass        
        return True    

    def func_Validate_Loci_From_File(self, str_Input_File_Path, str_Input_File_Name):
        
        bool_Success = False
        int_Total_Loci = 0
        str_Message = ''
        
        str_Input_Path_And_FileName = os__path.join(str_Input_File_Path, str_Input_File_Name)
        
        ''' Check if file exists - I know that the objSSInputOperation will also do this but I want to handle the error here '''
        with FileHandler() as obj_FileOp:
            bool_Success = obj_FileOp.fileExists(str_Input_Path_And_FileName)
            if not bool_Success:
                str_Message = ''.join(['The required file does not exist: ', str_Input_Path_And_FileName])
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message)                
                return bool_Success, int_Total_Loci, str_Message
            pass
        pass
        
        if self.str_Genome_Allele_Frequency_Distribution == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES:
            
            ''' Get the locus number and the allele frequencies from the file '''
            bool_Success = False
            with SSInputHandler() as objSSInputOperation:
                str_Message = ''
                bool_Success, int_Total_Loci, dict_Locus_AlleleName_AlleleFreqs = objSSInputOperation.method_ImportAlleleFrequencies_FromARLEQUIN_AllAlleleFreqs_File(str_Input_Path_And_FileName)
    
                if not bool_Success:
                    str_Message = ''.join(['The required file could not be imported: ', str_Input_Path_And_FileName])
                    
                    return bool_Success, int_Total_Loci, str_Message
                pass
                        
                ''' Check if we get a valid locus number '''
                if int_Total_Loci > 0:
                    bool_Success = True
                pass
            pass
        elif self.str_Genome_Allele_Frequency_Distribution == object_SSConfigBatchScenario.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP:
            
            ''' Get the locus number and the allele frequencies from the file '''
            bool_Success = False
            with SSInputHandler() as objSSInputOperation:
                bool_Get_Locus_Number_Only = True
                bool_Success, int_Total_Loci, odict_Locus_Allele_Frequencies_Output, str_Message = objSSInputOperation.method_ImportAlleleFrequencies_From_GENEPOP_File(str_Input_Path_And_FileName, bool_Get_Locus_Number_Only)
    
                if not bool_Success:
                    str_Message = ''.join(['The required file could not be imported: ', str_Input_Path_And_FileName])
                    
                    return bool_Success, int_Total_Loci, str_Message
                pass
                        
                ''' Check if we get a valid locus number '''
                if int_Total_Loci > 0:
                    bool_Success = True
                pass
            pass
        pass
    
        return bool_Success, int_Total_Loci, str_Message
        
    def func_Update_Config__Genome_Alleles_Per_Locus_Distribution(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        '''
        ---------------------------------------------------
        Update config
        ---------------------------------------------------
        '''       
            
        ''' <<<<<<< SECTION: Alleles_Per_Locus_Distribution '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Genome_Details

        ''' Define Sections/Options/Values dict '''
        dict_Section_Key_Option_Value = OrderedDict()
        list_Options_To_Purge = [
                                 obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution
                                 ,obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus
                                 ,obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus
                                 ,obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus
                                 ]
        dict_Section_Key_Option_Value[str_Section] = list_Options_To_Purge
        ''' Purge the values from the dict '''
        bool_Success, obj_Config.config_parser_Config = obj_Config.func_Remove_OPTIONS_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value)

        ''' Specify OPTION to UPDATE '''
        self.bool_str_Genome_Alleles_Per_Locus_Distribution__CHANGED = False
        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False        
        str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution
        value_Option = self.str_Genome_Alleles_Per_Locus_Distribution
        ''' Update the OPTION '''
        bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
        if bool_Success:
            self.bool_str_Genome_Alleles_Per_Locus_Distribution__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
#             qWidget = self.groupBox_23
#             str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
#             self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)            
            self.bool_int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__CHANGED = False        
            self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__CHANGED = False
            self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__CHANGED = False
        pass

        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False
        ''' Specify OPTION to UPDATE '''
        if value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Alleles_Per_Locus_Distribution_UNIFORM:
            
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus
            value_Option = self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_23
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                
            pass
        elif value_Option == object_SSConfigBatchScenario.static_str_Value__Genome_Alleles_Per_Locus_Distribution_BINOMIAL:
            
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus            
            #self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus = self.doubleSpinBox_7.value()
            value_Option = self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_23
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                
            pass            
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus            
            #self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus = self.doubleSpinBox_8.value()
            value_Option = self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus
            bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
            if bool_Success:
                self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                qWidget = self.groupBox_23
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                
            pass            
        else:
            pass
        pass        
        return True    

    '''
    ----------------------------
    QToolBox - Index 2
    ----------------------------
    '''   
    '''
    ----------------------------
    Scenario - Simulation 
    ----------------------------
    ''' 
    def func_Update__Scenario_Simulation_Length(self, str_Object_Name, value_Object, bool_Save):
        
        if str_Object_Name == 'horizontalSlider_45':
            self.func_Update__Scenario_Simulation_Batch_Replicates(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_46':
            self.func_Update__Scenario_Simulation_Batch_Replicate_Length_Burn_In(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_47':
            self.func_Update__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution(value_Object, bool_Save)
        pass
    
        return True

    def func_Update__Scenario_Simulation_Batch_Replicates(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Simulation_Batch_Replicates = int_Value 
            self.func_Update_Config__Simulation_Batch_Replicates()
#             if self.bool_int_Simulation_Batch_Replicates__FOUND:
#                 
#                 self.func_Update_Config__Simulation_Batch_Replicates()
#             else:
#                 self.func_Update_Config__Simulation_Batch_Replicates()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_58.setText(self.str_Simulation_Batch_Replicates__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Simulation_Length(int_Value)
    
        return True

    def func_Update__Scenario_Simulation_Batch_Replicate_Length_Burn_In(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Simulation_Batch_Replicate_Length_Burn_In = int_Value 
            self.func_Update_Config__Simulation_Batch_Replicate_Length_Burn_In()
#             if self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__FOUND:
#                 
#                 self.func_Update_Config__Simulation_Batch_Replicate_Length_Burn_In()
#             else:
#                 self.func_Update_Config__Simulation_Batch_Replicate_Length_Burn_In()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_59.setText(self.str_Simulation_Batch_Replicate_Length_Burn_In__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Simulation_Length(int_Value)
    
        return True

    def func_Update__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts = int_Value 
            self.func_Update_Config__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts()
#             if self.bool_int_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts__FOUND:
#                 
#                 self.func_Update_Config__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts()
#             else:
#                 self.func_Update_Config__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts()
#             pass
        pass
    
        return True
    
    def func_Update__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count = int_Value
            self.func_Update_Config__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count()
#             if self.bool_int_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count__FOUND:
#                 
#                 self.func_Update_Config__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count()
#             else:
#                 self.func_Update_Config__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count()
#             pass
        pass
    
        return True

    def func_Update__Scenario_Simulation_Batch_Replicate_Length_Temporal_Evolution(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution = int_Value 
            self.func_Update_Config__Simulation_Batch_Replicate_Length_Temporal_Evolution()
#             if self.bool_int_Simulation_Batch_Replicate_Length_Temporal_Evolution__FOUND:
#                 
#                 self.func_Update_Config__Simulation_Batch_Replicate_Length_Temporal_Evolution()
#             else:
#                 self.func_Update_Config__Simulation_Batch_Replicate_Length_Temporal_Evolution()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_60.setText(self.str_Simulation_Batch_Replicate_Length_Temporal_Evolution__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Scenario_Simulation_Length(int_Value)
    
        return True

    def func_Change__Scenario_Simulation_Length(self, int_Value):
        
        pass
        return True

    def func_Update_Config__Simulation_Batch_Replicates(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Life_History '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Simulation_Batch_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicates
        value_Option = self.int_Simulation_Batch_Replicates
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            self.bool_int_Simulation_Batch_Replicates__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
            qWidget = self.label_58
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)   
        pass
        return True 
           
    def func_Update_Config__Simulation_Batch_Replicate_Length_Burn_In(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Life_History '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Simulation_Batch_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Burn_In
        value_Option = self.int_Simulation_Batch_Replicate_Length_Burn_In
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished: #This is to prevent initial setRange and setValue from triggering a save
                if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                    self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__CHANGED = True
                    self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                    qWidget = self.label_59
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)   
                pass
            pass
        pass
        return True 
           
    def func_Update_Config__Simulation_Batch_Replicate_Length_Temporal_Evolution(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Life_History '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Simulation_Batch_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Temporal_Evolution
        value_Option = self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished: #This is to prevent initial setRange and setValue from triggering a save
                if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                    self.bool_int_Simulation_Batch_Replicate_Length_Temporal_Evolution__CHANGED = True
                    self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                    qWidget = self.label_60
                    str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
                    self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)   
                pass
            pass
        pass
        return True 


    def func_Update_Config__Scenario_Simulation_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Settings
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Batch_Setting_Pop_Saving '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Batch_Setting__Pop_Saving
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts
        value_Option = self.int_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished: #This is to prevent initial setRange and setValue from triggering a save
                if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                    self.bool_int_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts__CHANGED = True
                    self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                pass
            pass
        pass
        return True 

    def func_Update_Config__Scenario_Simulation_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Settings
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Batch_Setting_Pop_Sampling '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Batch_Setting__Pop_Sampling
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count
        value_Option = self.int_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished: #This is to prevent initial setRange and setValue from triggering a save
                if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                    self.bool_int_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count__CHANGED = True
                    self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                pass
            pass
        pass
        return True 
           
    def func_Update_Config__Scenario_Run_Simulation_Working_Base_Path(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Scenario_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Scenario_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Scenario_Run_Simulation_Working_Base_Path
        value_Option = self.str_Scenario_Run_Simulation_Working_Base_Path
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished: #This is to prevent initial setRange and setValue from triggering a save
                if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                    self.bool_str_Scenario_Run_Simulation_Working_Base_Path__CHANGED = True
                    self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                pass
            pass
        pass
        return True 
    
    def func_Update_Config__Scenario_Run_Simulation_Output_Base_Path(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Batch_Scenario
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Scenario_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Scenario_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Scenario_Run_Simulation_Output_Base_Path
        value_Option = self.str_Scenario_Run_Simulation_Output_Base_Path
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished: #This is to prevent initial setRange and setValue from triggering a save
                if self.bool_Reload_Widgets_Finished__Batch_Scenario:
                    self.bool_str_Scenario_Run_Simulation_Output_Base_Path__CHANGED = True
                    self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = True
                pass
            pass
        pass
        return True 
    
    def func_Set_Values_in_Config_File_Section(self, obj_Config, str_Section, str_Option, value_Option):

        bool_Success = False
        
        if obj_Config != None:
            config_parser_Config = obj_Config.config_parser_Config
        
            if config_parser_Config != None:
                
                ''' Update the OPTION '''
                config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
                bool_Success = True
                pass
            else:
                str_Message_Text = 'config_parser_Config = None'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            pass
        else:
            str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
        pass
        return bool_Success    
        
    def func_Check_If_Config_SECTION_And_OPTION_Exist(self, obj_Config, str_Section, str_Option):
        
        bool_Section_Exists = False
        bool_Option_Exists = False
        
        if obj_Config != None:
            config_parser_Config = obj_Config.config_parser_Config
            
            if config_parser_Config != None:
    
                ''' <<<<<<< SECTION: Life_History '''
                bool_Section_Exists = False
                bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
                if bool_Section_Exists:
                    bool_Option_Exists = False
                    bool_Option_Exists = obj_Config.func_Check_If_Config_File_OPTION_Exists(config_parser_Config, str_Section, str_Option)
                pass
            else:
                str_Message_Text = 'config_parser_Config = None'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            pass
        else:
            str_Message_Text = 'self.obj_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
        pass
    
        return bool_Section_Exists, bool_Option_Exists          
    
    '''
    ----------------------------
    QToolBox - Index 4
    ----------------------------
    '''   
    '''
    ----------------------------
    Sampling Strategy - Sample Size 
    ----------------------------
    '''   
    def func_Update__Sampling_Strategy_Sample_Range(self, str_Object_Name, value_Object, bool_Save):
        
        if str_Object_Name == 'horizontalSlider_48':
            self.func_Update__Sampling_Strategy_Sample_Range_Min(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_49':
            self.func_Update__Sampling_Strategy_Sample_Range_Max(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_50':
            self.func_Update__Sampling_Strategy_Sample_Range_Increment(value_Object, bool_Save)
        pass
    
        return True
        
    def func_Update__Sampling_Strategy_Sample_Range_Min(self, int_Value, bool_Save):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Sampling_Strategy_Sample_Range_Min = int_Value 
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF                
            self.func_Update_Config__Sampling_Strategy_Sample_Range_Min()
#             if self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND:
# 
#                 self.func_Update_Config__Sampling_Strategy_Sample_Range_Min()
#             else:
#                 self.func_Update_Config__Sampling_Strategy_Sample_Range_Min()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_61.setText(self.str_int_Sampling_Strategy_Sample_Range_Min__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Sampling_Strategy_Sample_Range_Min(int_Value)
    
        return True

    def func_Change__Sampling_Strategy_Sample_Range_Min(self, int_Value):
        
        ''' Set the ranges for related sliders '''
        #self.func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Sample_Range_Min(int_Value) 
        #self.func_Validate_Sampling_Strategy__Display_Combinations()
        pass
        return True

    def func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Sample_Range_Min(self, int_Slider_Value):

        pass        
        return True
        
    def func_Update__Sampling_Strategy_Sample_Range_Max(self, int_Value, bool_Save):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Sampling_Strategy_Sample_Range_Max = int_Value 
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF                
            self.func_Update_Config__Sampling_Strategy_Sample_Range_Max()

            ''' Update the combos and ensure the Min is automatically changed appropriately '''
            self.func_Change__Sampling_Strategy_Sample_Range_Max(int_Value)
            
            ''' Whenever the values other than the Min are updated to the config...'''
            ''' the Min should also be automatically updated in the config file '''
            bool_Save = True
            self.func_Update__Sampling_Strategy_Sample_Range_Min(self.spinBox_40.value(), bool_Save)


#             if self.bool_int_Sampling_Strategy_Sample_Range_Max__FOUND:
# 
#                 self.func_Update_Config__Sampling_Strategy_Sample_Range_Max()
#             else:
#                 self.func_Update_Config__Sampling_Strategy_Sample_Range_Max()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_62.setText(self.str_int_Sampling_Strategy_Sample_Range_Max__Label_Text)
#             pass
        else:
    
            ''' Set the ranges for related sliders '''
    
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
            #DEBUG_OFF 
            self.func_Change__Sampling_Strategy_Sample_Range_Max(int_Value)
        pass
    
        return True
    
    def func_Change__Sampling_Strategy_Sample_Range_Max(self, int_Value):
        
        ''' Set the ranges for related sliders '''
        self.func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Sample_Range_Max(int_Value) 
        self.func_Validate_Sampling_Strategy__Display_Combinations()
        return True

    def func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Sample_Range_Max(self, int_Slider_Value):

        ''' Set the Range of the Sampling Strategy Sample Size Increment '''
        self.spinBox_42.setRange(1, self.int_Sampling_Strategy_Sample_Range_Max) 
        self.horizontalSlider_50.setRange(1, self.int_Sampling_Strategy_Sample_Range_Max) 
        
        int_Sampling_Strategy_Locus_Range_Min__Temp, int_Sampling_Strategy_Locus_Range_Max__Temp, int_Sampling_Strategy_Locus_Range_Increment__Temp = self.func_Validate_Sampling_Strategy__Get_Loci_Numbers()
        int_Bin_Count_Known = self.func_Validate_Sampling_Strategy__Get_Bin_Count(int_Sampling_Strategy_Locus_Range_Min__Temp, int_Sampling_Strategy_Locus_Range_Max__Temp, int_Sampling_Strategy_Locus_Range_Increment__Temp)

        int_Range_Min, Int_Range_Max, int_Range_Increment = self.func_Validate_Sampling_Strategy__Get_Sample_Sizes()
        int_Range_Min = self.func_Validate_Sampling_Strategy__Get_Range_Minimum(self.int_Sampling_Strategy_Sample_Range_Increment__Min__Default_Value, int_Range_Min, Int_Range_Max, int_Range_Increment, int_Bin_Count_Known)
                      
        ''' Set the value within the acceptable limits '''
        if int_Range_Min > 0:
            self.horizontalSlider_48.setValue(int_Range_Min)
            #self.func_QSpinBox__Sampling_Strategy_Sample_Range_Min__SetValue(int_Range_Min)
        pass
        return True

    def func_Update__Sampling_Strategy_Sample_Range_Increment(self, int_Value, bool_Save):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Sampling_Strategy_Sample_Range_Increment = int_Value 
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min) + '; self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND))
            #DEBUG_OFF                
            self.func_Update_Config__Sampling_Strategy_Sample_Range_Increment()

            ''' Update the combos and ensure the Min is automatically changed appropriately '''
            self.func_Change__Sampling_Strategy_Sample_Range_Increment(int_Value)
            
            ''' Whenever the values other than the Min are updated to the config...'''
            ''' the Min should also be automatically updated in the config file '''
            bool_Save = True
            self.func_Update__Sampling_Strategy_Sample_Range_Min(self.spinBox_40.value(), bool_Save)

#             if self.bool_int_Sampling_Strategy_Sample_Range_Increment__FOUND:
# 
#                 self.func_Update_Config__Sampling_Strategy_Sample_Range_Increment()
#             else:
#                 self.func_Update_Config__Sampling_Strategy_Sample_Range_Increment()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_63.setText(self.str_int_Sampling_Strategy_Sample_Range_Increment__Label_Text)
#             pass
        else:
    
            ''' Set the ranges for related sliders '''
    
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Sample_Range_Min: ' + str(self.int_Sampling_Strategy_Sample_Range_Min))
            #DEBUG_OFF 
            self.func_Change__Sampling_Strategy_Sample_Range_Increment(int_Value)
        pass
    
        return True
    
    def func_Change__Sampling_Strategy_Sample_Range_Increment(self, int_Value):
        
        ''' Set the ranges for related sliders '''
        self.func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Sample_Range_Increment(int_Value) 
        self.func_Validate_Sampling_Strategy__Display_Combinations()
        return True

    def func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Sample_Range_Increment(self, int_Slider_Value):

        int_Sampling_Strategy_Locus_Range_Min__Temp, int_Sampling_Strategy_Locus_Range_Max__Temp, int_Sampling_Strategy_Locus_Range_Increment__Temp = self.func_Validate_Sampling_Strategy__Get_Loci_Numbers()
        int_Bin_Count_Known = self.func_Validate_Sampling_Strategy__Get_Bin_Count(int_Sampling_Strategy_Locus_Range_Min__Temp, int_Sampling_Strategy_Locus_Range_Max__Temp, int_Sampling_Strategy_Locus_Range_Increment__Temp)

        int_Range_Min, Int_Range_Max, int_Range_Increment = self.func_Validate_Sampling_Strategy__Get_Sample_Sizes()
        int_Range_Min = self.func_Validate_Sampling_Strategy__Get_Range_Minimum(self.int_Sampling_Strategy_Sample_Range_Increment__Min__Default_Value, int_Range_Min, Int_Range_Max, int_Range_Increment, int_Bin_Count_Known)
                      
        ''' Set the value within the acceptable limits '''
        if int_Range_Min > 0:
            self.horizontalSlider_48.setValue(int_Range_Min)
            #self.func_QSpinBox__Sampling_Strategy_Sample_Range_Min__SetValue(int_Range_Min)
        pass
        return True

    def func_Update_Config__Sampling_Strategy_Sample_Range_Min(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sample_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Min
        value_Option = self.int_Sampling_Strategy_Sample_Range_Min
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_Sample_Range_Min__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
                qWidget = self.label_61
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                 
            pass
        pass
        return True 
           
    def func_Update_Config__Sampling_Strategy_Sample_Range_Max(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sample_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Max
        value_Option = self.int_Sampling_Strategy_Sample_Range_Max
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_Sample_Range_Max__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
                qWidget = self.label_62
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                
            pass
        pass
        return True 
           
    def func_Update_Config__Sampling_Strategy_Sample_Range_Increment(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sample_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Increment
        value_Option = self.int_Sampling_Strategy_Sample_Range_Increment
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_Sample_Range_Increment__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
                qWidget = self.label_63
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                 
            pass
        pass
        return True 
           
    '''
    ----------------------------
    Sampling Strategy - Locus Number 
    ----------------------------
    '''
    def func_Update__Sampling_Strategy_Locus_Range(self, str_Object_Name, value_Object, bool_Save):
        
        if str_Object_Name == 'horizontalSlider_51':
            self.func_Update__Sampling_Strategy_Locus_Range_Min(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_52':
            self.func_Update__Sampling_Strategy_Locus_Range_Max(value_Object, bool_Save)
        elif str_Object_Name == 'horizontalSlider_53':
            self.func_Update__Sampling_Strategy_Locus_Range_Increment(value_Object, bool_Save)
        pass
    
        return True

    def func_Update__Sampling_Strategy_Locus_Range_Min(self, int_Value, bool_Save):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Sampling_Strategy_Locus_Range_Min = int_Value 
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Locus_Range_Min: ' + str(self.int_Sampling_Strategy_Locus_Range_Min) + '; self.bool_int_Sampling_Strategy_Locus_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Locus_Range_Min__FOUND))
            #DEBUG_OFF                
            self.func_Update_Config__Sampling_Strategy_Locus_Range_Min()
#             if self.bool_int_Sampling_Strategy_Locus_Range_Min__FOUND:
# 
#                 self.func_Update_Config__Sampling_Strategy_Locus_Range_Min()
#             else:
#                 self.func_Update_Config__Sampling_Strategy_Locus_Range_Min()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_64.setText(self.str_int_Sampling_Strategy_Locus_Range_Min__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Locus_Range_Min: ' + str(self.int_Sampling_Strategy_Locus_Range_Min))
        #DEBUG_OFF 
        self.func_Change__Sampling_Strategy_Locus_Range_Min(int_Value)
    
        return True

    def func_Change__Sampling_Strategy_Locus_Range_Min(self, int_Value):
        
        ''' Set the ranges for related sliders '''
        
        #self.func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Locus_Range_Min(int_Value) 
        #self.func_Validate_Sampling_Strategy__Display_Combinations()
        pass
        return True

    def func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Locus_Range_Min(self, int_Slider_Value):

        pass        
        return True
        
    def func_Update__Sampling_Strategy_Locus_Range_Max(self, int_Value, bool_Save):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Sampling_Strategy_Locus_Range_Max = int_Value 
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Locus_Range_Min: ' + str(self.int_Sampling_Strategy_Locus_Range_Min) + '; self.bool_int_Sampling_Strategy_Locus_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Locus_Range_Min__FOUND))
            #DEBUG_OFF    
                        
#             ''' Set the Range of the Sampling Strategy Locus Increment '''
#             self.spinBox_45.setRange(1, self.int_Sampling_Strategy_Locus_Range_Max) 
#             self.horizontalSlider_53.setRange(1, self.int_Sampling_Strategy_Locus_Range_Max) 
            #self.horizontalSlider_53.setValue(int_Range_Min)
            
            self.func_Update_Config__Sampling_Strategy_Locus_Range_Max()

            ''' Update the combos and ensure the Min is automatically changed appropriately '''
            self.func_Change__Sampling_Strategy_Locus_Range_Max(int_Value)

            ''' Whenever the values other than the Min are updated to the config...'''
            ''' the Min should also be automatically updated in the config file '''            
            bool_Save = True
            self.func_Update__Sampling_Strategy_Locus_Range_Min(self.spinBox_43.value(), bool_Save)



#             if self.bool_int_Sampling_Strategy_Locus_Range_Max__FOUND:
# 
#                 self.func_Update_Config__Sampling_Strategy_Locus_Range_Max()
#             else:
#                 self.func_Update_Config__Sampling_Strategy_Locus_Range_Max()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_65.setText(self.str_int_Sampling_Strategy_Locus_Range_Max__Label_Text)
#             pass
        else:
    
            ''' Set the ranges for related sliders '''
    
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Locus_Range_Min: ' + str(self.int_Sampling_Strategy_Locus_Range_Min))
            #DEBUG_OFF 
            self.func_Change__Sampling_Strategy_Locus_Range_Max(int_Value)
        pass
    
        return True
    
    def func_Change__Sampling_Strategy_Locus_Range_Max(self, int_Value):
        
        ''' Set the ranges for related sliders '''
        self.func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Locus_Range_Max(int_Value) 
        self.func_Validate_Sampling_Strategy__Display_Combinations()
        return True

    def func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Locus_Range_Max(self, int_Slider_Value):

        ''' Set the Range of the Sampling Strategy Locus Increment '''
        self.spinBox_45.setRange(1, self.int_Sampling_Strategy_Locus_Range_Max) 
        self.horizontalSlider_53.setRange(1, self.int_Sampling_Strategy_Locus_Range_Max) 
            
        int_Sampling_Strategy_Sample_Range_Min__Temp, int_Sampling_Strategy_Sample_Range_Max__Temp, int_Sampling_Strategy_Sample_Range_Increment__Temp = self.func_Validate_Sampling_Strategy__Get_Sample_Sizes()
        int_Bin_Count_Known = self.func_Validate_Sampling_Strategy__Get_Bin_Count(int_Sampling_Strategy_Sample_Range_Min__Temp, int_Sampling_Strategy_Sample_Range_Max__Temp, int_Sampling_Strategy_Sample_Range_Increment__Temp)

        int_Range_Min, Int_Range_Max, int_Range_Increment = self.func_Validate_Sampling_Strategy__Get_Loci_Numbers()
        int_Range_Min = self.func_Validate_Sampling_Strategy__Get_Range_Minimum(self.int_Sampling_Strategy_Locus_Range_Increment__Min__Default_Value,int_Range_Min, Int_Range_Max, int_Range_Increment, int_Bin_Count_Known)
                      
        ''' Set the value within the acceptable limits '''
        if int_Range_Min > 0:
#             ''' Set the Range of the Sampling Strategy Locus Min '''
#             self.spinBox_43.setRange(int_Range_Min, Int_Range_Max) 
#             self.horizontalSlider_51.setRange(int_Range_Min, Int_Range_Max) 
            self.horizontalSlider_51.setValue(int_Range_Min)

        pass
    
        return True
    
    def func_Update__Sampling_Strategy_Locus_Range_Increment(self, int_Value, bool_Save):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Sampling_Strategy_Locus_Range_Increment = int_Value 
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_Locus_Range_Min: ' + str(self.int_Sampling_Strategy_Locus_Range_Min) + '; self.bool_int_Sampling_Strategy_Locus_Range_Min__FOUND: ' + str(self.bool_int_Sampling_Strategy_Locus_Range_Min__FOUND))
            #DEBUG_OFF      
            self.func_Update_Config__Sampling_Strategy_Locus_Range_Increment()

            ''' Update the combos and ensure the Min is automatically changed appropriately '''
            self.func_Change__Sampling_Strategy_Locus_Range_Increment(int_Value)
            
            ''' Whenever the values other than the Min are updated to the config...'''
            ''' the Min should also be automatically updated in the config file '''
            bool_Save = True
            self.func_Update__Sampling_Strategy_Locus_Range_Min(self.spinBox_43.value(), bool_Save)
#             if self.bool_int_Sampling_Strategy_Locus_Range_Increment__FOUND:
# 
#                 self.func_Update_Config__Sampling_Strategy_Locus_Range_Increment()
#             else:
#                 self.func_Update_Config__Sampling_Strategy_Locus_Range_Increment()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_66.setText(self.str_int_Sampling_Strategy_Locus_Range_Increment__Label_Text)
#             pass
        else:
    
            ''' Set the ranges for related sliders '''
    
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_Locus_Range_Min: ' + str(self.int_Sampling_Strategy_Locus_Range_Min))
            #DEBUG_OFF 
            self.func_Change__Sampling_Strategy_Locus_Range_Increment(int_Value)
        pass
    
        return True
    
    def func_Change__Sampling_Strategy_Locus_Range_Increment(self, int_Value):
        
        ''' Set the ranges for related sliders '''
        self.func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Locus_Range_Increment(int_Value) 
        self.func_Validate_Sampling_Strategy__Display_Combinations()       
        return True

    def func_Set_Associated_Sliders_Range_And_Value__Sampling_Strategy__Locus_Range_Increment(self, int_Slider_Value):

        int_Sampling_Strategy_Sample_Range_Min__Temp, int_Sampling_Strategy_Sample_Range_Max__Temp, int_Sampling_Strategy_Sample_Range_Increment__Temp = self.func_Validate_Sampling_Strategy__Get_Sample_Sizes()
        int_Bin_Count_Known = self.func_Validate_Sampling_Strategy__Get_Bin_Count(int_Sampling_Strategy_Sample_Range_Min__Temp, int_Sampling_Strategy_Sample_Range_Max__Temp, int_Sampling_Strategy_Sample_Range_Increment__Temp)

        int_Range_Min, Int_Range_Max, int_Range_Increment = self.func_Validate_Sampling_Strategy__Get_Loci_Numbers()
        int_Range_Min = self.func_Validate_Sampling_Strategy__Get_Range_Minimum(self.int_Sampling_Strategy_Locus_Range_Increment__Min__Default_Value, int_Range_Min, Int_Range_Max, int_Range_Increment, int_Bin_Count_Known)
                      
#         ''' Set the value within the acceptable limits '''
#         if int_Range_Min > 0:
#             self.horizontalSlider_51.setValue(int_Range_Min)
#         pass
        if int_Range_Min > 0:
#             ''' Set the Range of the Sampling Strategy Locus Min '''
#             self.spinBox_43.setRange(int_Range_Min, Int_Range_Max) 
#             self.horizontalSlider_51.setRange(int_Range_Min, Int_Range_Max) 
            self.horizontalSlider_51.setValue(int_Range_Min)
        pass
        return True

    def func_Update_Config__Sampling_Strategy_Locus_Range_Min(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Locus_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Locus_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Min
        value_Option = self.int_Sampling_Strategy_Locus_Range_Min
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_Locus_Range_Min__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
                qWidget = self.label_64
                ''' NOTE: IF MIN IS ENABLED CHANGE THIS STATUS TO SS_REQUIRES_USER_EDIT '''
                #str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                 
            pass
        pass
        return True 
           
    def func_Update_Config__Sampling_Strategy_Locus_Range_Max(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Locus_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Locus_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Max
        value_Option = self.int_Sampling_Strategy_Locus_Range_Max
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_Locus_Range_Max__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
                qWidget = self.label_65
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                
            pass
        pass
        return True 
           
    def func_Update_Config__Sampling_Strategy_Locus_Range_Increment(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Locus_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Locus_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Increment
        value_Option = self.int_Sampling_Strategy_Locus_Range_Increment
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_Locus_Range_Increment__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
                qWidget = self.label_66
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                  
            pass
        pass
        return True 

    '''
    ----------------------------
    Sampling Strategy - Validation
    ----------------------------
    '''    
    def func_Validate_Sampling_Strategy__Get_Sample_Sizes(self):
        
        int_Sampling_Strategy_Sample_Range_Min__Temp = self.horizontalSlider_48.value()
        int_Sampling_Strategy_Sample_Range_Max__Temp = self.horizontalSlider_49.value()
        int_Sampling_Strategy_Sample_Range_Increment__Temp = self.horizontalSlider_50.value()
        
        return int_Sampling_Strategy_Sample_Range_Min__Temp, int_Sampling_Strategy_Sample_Range_Max__Temp, int_Sampling_Strategy_Sample_Range_Increment__Temp
    
    def func_Validate_Sampling_Strategy__Get_Loci_Numbers(self):
        
        int_Sampling_Strategy_Locus_Range_Min__Temp = self.horizontalSlider_51.value()
        int_Sampling_Strategy_Locus_Range_Max__Temp = self.horizontalSlider_52.value()
        int_Sampling_Strategy_Locus_Range_Increment__Temp = self.horizontalSlider_53.value()
        
        return int_Sampling_Strategy_Locus_Range_Min__Temp, int_Sampling_Strategy_Locus_Range_Max__Temp, int_Sampling_Strategy_Locus_Range_Increment__Temp
    
    def func_Validate_Sampling_Strategy__Get_Bin_List(self, int_Range_Min, int_Range_Max, int_Range_Increment):
        
        list_Bins = [x for x in range(int_Range_Min, int_Range_Max, int_Range_Increment)]
        list_Bins.append(int_Range_Max)

        return list_Bins
    
    def func_Validate_Sampling_Strategy__Get_Bin_Count(self, int_Range_Min, int_Range_Max, int_Range_Increment):
        
        int_Bin_Count = 0
        
        list_Bins = self.func_Validate_Sampling_Strategy__Get_Bin_List(int_Range_Min, int_Range_Max, int_Range_Increment)
        int_Bin_Count = len(list_Bins)
        #int_Bin_Count = int(float(int_Range_Max - int_Range_Min) / float(int_Range_Increment))+1  #+1 beacuse the Max is also a bin we want
        #int_Bin_Count = int(float(int_Range_Max) / float(int_Range_Increment))  #+1 beacuse the Max is also a bin we want
    
        return int_Bin_Count
    
    def func_Validate_Sampling_Strategy__Get_Range_Minimum(self, int_Range_Increment_Default, int_Range_Min, int_Range_Max, int_Range_Increment, int_Bin_Count_Known):
        
        if int_Range_Increment > int_Range_Max:
            int_Range_Min = int_Range_Max
            return int_Range_Min
        pass
        if int_Range_Increment < int_Range_Increment_Default:
            return int_Range_Min
        pass
    
        int_Bin_Count_Allowance = 12 / int_Bin_Count_Known
        
        #int_Range_Min = int_Range_Max - ((int_Bin_Count_Allowance-1) * int_Range_Increment)
        int_Range_Min = int_Range_Max - ((int_Bin_Count_Allowance-1) * int_Range_Increment)
        if int_Range_Min <= 0:
            int_Range_Min = int_Range_Increment
            pass
        elif int_Range_Min > int_Range_Max:
            int_Range_Min = int_Range_Max
            pass
        elif int_Range_Min < int_Range_Increment:
            #int_Range_Min = int_Range_Increment
            pass
        pass
    
        #DEBUG_ON
        #int_Bin_Count_Unknown = self.func_Validate_Sampling_Strategy__Get_Bin_Count(int_Range_Min, int_Range_Max, int_Range_Increment)
        #list_Bin_Count_Unknown = self.func_Validate_Sampling_Strategy__Get_Bin_List(int_Range_Min, int_Range_Max, int_Range_Increment)
        #int_Total_Combos = int_Bin_Count_Unknown + int_Bin_Count_Known
        #DEBUG_OFF
        
        return int_Range_Min
    
    def func_Validate_Sampling_Strategy__Display_Combinations_OLD(self):
        
        int_Sampling_Strategy_Sample_Range_Min__Temp, int_Sampling_Strategy_Sample_Range_Max__Temp, int_Sampling_Strategy_Sample_Range_Increment__Temp = self.func_Validate_Sampling_Strategy__Get_Sample_Sizes()
        int_Sampling_Strategy_Locus_Range_Min__Temp, int_Sampling_Strategy_Locus_Range_Max__Temp, int_Sampling_Strategy_Locus_Range_Increment__Temp = self.func_Validate_Sampling_Strategy__Get_Loci_Numbers()
        
        int_Bin_Count_Samples = self.func_Validate_Sampling_Strategy__Get_Bin_Count(int_Sampling_Strategy_Sample_Range_Min__Temp, int_Sampling_Strategy_Sample_Range_Max__Temp, int_Sampling_Strategy_Sample_Range_Increment__Temp)
        int_Bin_Count_Loci = self.func_Validate_Sampling_Strategy__Get_Bin_Count(int_Sampling_Strategy_Locus_Range_Min__Temp, int_Sampling_Strategy_Locus_Range_Max__Temp, int_Sampling_Strategy_Locus_Range_Increment__Temp)
        int_Total_Combos = int_Bin_Count_Samples * int_Bin_Count_Loci

        self.label_25.setText(str(int_Bin_Count_Samples))
        self.label_26.setText(str(int_Bin_Count_Loci))
        self.label_27.setText(str(int_Total_Combos))
        
        list_Bin_Count_Samples = self.func_Validate_Sampling_Strategy__Get_Bin_List(int_Sampling_Strategy_Sample_Range_Min__Temp, int_Sampling_Strategy_Sample_Range_Max__Temp, int_Sampling_Strategy_Sample_Range_Increment__Temp)
        list_Bin_Count_Loci = self.func_Validate_Sampling_Strategy__Get_Bin_List(int_Sampling_Strategy_Locus_Range_Min__Temp, int_Sampling_Strategy_Locus_Range_Max__Temp, int_Sampling_Strategy_Locus_Range_Increment__Temp)
        
        str_Samples_List = ', '.join(map(str, list_Bin_Count_Samples)) 
        str_Loci_List = ', '.join(map(str, list_Bin_Count_Loci)) 
        
        self.label_23.setText(str(str_Samples_List))
        self.label_24.setText(str(str_Loci_List))
        return True
    
    def func_Validate_Sampling_Strategy__Display_Combinations(self):
        
        int_Sampling_Strategy_Sample_Range_Min__Temp, int_Sampling_Strategy_Sample_Range_Max__Temp, int_Sampling_Strategy_Sample_Range_Increment__Temp = self.func_Validate_Sampling_Strategy__Get_Sample_Sizes()
        int_Sampling_Strategy_Locus_Range_Min__Temp, int_Sampling_Strategy_Locus_Range_Max__Temp, int_Sampling_Strategy_Locus_Range_Increment__Temp = self.func_Validate_Sampling_Strategy__Get_Loci_Numbers()
        
        
        list_Bin_Count_Samples = self.func_Validate_Sampling_Strategy__Get_Bin_List(int_Sampling_Strategy_Sample_Range_Min__Temp, int_Sampling_Strategy_Sample_Range_Max__Temp, int_Sampling_Strategy_Sample_Range_Increment__Temp)
        list_Bin_Count_Loci = self.func_Validate_Sampling_Strategy__Get_Bin_List(int_Sampling_Strategy_Locus_Range_Min__Temp, int_Sampling_Strategy_Locus_Range_Max__Temp, int_Sampling_Strategy_Locus_Range_Increment__Temp)

        int_Bin_Count_Samples = len(list_Bin_Count_Samples)
        int_Bin_Count_Loci = len(list_Bin_Count_Loci)
        int_Total_Combos = int_Bin_Count_Samples * int_Bin_Count_Loci

        self.label_25.setText(str(int_Bin_Count_Samples))
        self.label_26.setText(str(int_Bin_Count_Loci))
        self.label_27.setText(str(int_Total_Combos))
        
        str_Samples_List = ', '.join(map(str, list_Bin_Count_Samples)) 
        str_Loci_List = ', '.join(map(str, list_Bin_Count_Loci)) 
        
        self.label_23.setText(str(str_Samples_List))
        self.label_24.setText(str(str_Loci_List))
        return True

    '''
    ----------------------------
    Sampling Strategy - Sampling Distribution
    ----------------------------
    ''' 
    def func_Update_Config__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
                
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass

        '''
        ---------------------------------------------------
        Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)        
       
        '''
        ---------------------------------------------------
        Update config
        ---------------------------------------------------
        '''         
        dict_Section_Key_Option_Value_Tuple = OrderedDict()
         
        ''' >>>>>>>>> CSV_Age_And_Natural_Mortality_Rate__MALE '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion
        list_tup_Option_Value = []
        
        for key_int_Age, value_float_Proportion in self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion.items():
            ''' Specify OPTION to UPDATE ''' 
            str_Option = key_int_Age
            value_Option = value_float_Proportion
            list_tup_Option_Value.append((str_Option, value_Option))
        pass
    
        ''' Update the config parser '''
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
        obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
           
        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            #self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__FOUND = True
            self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            qWidget = self.pushButton_15
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
        pass

        '''
        ---------------------------------------------------
        Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)   
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> Sample_Cohorts_By_Age '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
       
        return True

    def func_Update_Config__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
                
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass

        '''
        ---------------------------------------------------
        Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)        
       
        '''
        ---------------------------------------------------
        Update config
        ---------------------------------------------------
        '''         
        dict_Section_Key_Option_Value_Tuple = OrderedDict()
         
        ''' >>>>>>>>> CSV_Age_And_Natural_Mortality_Rate__MALE '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion
        list_tup_Option_Value = []
        
        for key_int_Age, value_float_Proportion in self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion.items():
            ''' Specify OPTION to UPDATE ''' 
            str_Option = key_int_Age
            value_Option = value_float_Proportion
            list_tup_Option_Value.append((str_Option, value_Option))
        pass
    
        ''' Update the config parser '''
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
        obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
           
        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            #self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__FOUND = True
            self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            qWidget = self.pushButton_15
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
        pass

        '''
        ---------------------------------------------------
        Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> Sample_Cohorts_By_Age '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
       
        return True

    def func_Update_Config__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
                
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass

        '''
        ---------------------------------------------------
        Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)        
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)        
       
        '''
        ---------------------------------------------------
        Update config
        ---------------------------------------------------
        '''         
        dict_Section_Key_Option_Value_Tuple = OrderedDict()
         
        ''' >>>>>>>>> CSV_Age_And_Natural_Mortality_Rate__MALE '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number
        list_tup_Option_Value = []
        
        for key_int_Age, value_float_Proportion in self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number.items():
            ''' Specify OPTION to UPDATE ''' 
            str_Option = key_int_Age
            value_Option = value_float_Proportion
            list_tup_Option_Value.append((str_Option, value_Option))
        pass
    
        ''' Update the config parser '''
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
        obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
           
        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            #self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__FOUND = True
            self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            qWidget = self.pushButton_15
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
        pass

        '''
        ---------------------------------------------------
        Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)        
        ''' >>>>>>>>> Sample_Cohorts_By_Age '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
       
        return True

    def func_Update_Config__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass

        '''
        ---------------------------------------------------
        Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)        
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)        
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
       
        '''
        ---------------------------------------------------
        Update config
        ---------------------------------------------------
        '''         
        dict_Section_Key_Option_Value_Tuple = OrderedDict()
         
        ''' >>>>>>>>> Sample_Cohorts_By_Age '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion
        list_tup_Option_Value = []
        
        for key_int_Age, value_float_Proportion in self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion.items():
            ''' Specify OPTION to UPDATE ''' 
            str_Option = key_int_Age
            value_Option = value_float_Proportion
            list_tup_Option_Value.append((str_Option, value_Option))
        pass
    
        ''' Update the config parser '''
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
        obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
           
        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            #self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__FOUND = True
            self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            qWidget = self.pushButton_15
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
        pass
    
    
        '''
        ---------------------------------------------------
        Remove unwanted SECTIONS & OPTIONS from config
        ---------------------------------------------------
        '''
        ''' >>>>>>>>> Sample_Proportions_By_Age '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)        
        ''' >>>>>>>>> static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number
        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section) 
        
        return True
    
    '''
    ----------------------------
    QToolBox - Index 5
    ----------------------------
    '''    
    '''
    ----------------------------
    Sampling Strategy - Run Parameters
    ----------------------------
    '''
    def func_Sampling_Strategy_LDNe_PCrit_To_Get_Selection(self, int_Index): 
        
        #obj_Config_Batch_Scenario = self.obj_Config_Batch_Scenario
        obj_Config = self.obj_Config_Settings
        
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_LDNe_PCrit_To_Get_List
        str_Option = object_SSConfigSamplingStrategy.static_str_Option__Sampling_Strategy_LDNe_PCrit_To_Get + '_' + str(int_Index)
        value_Type = ''
        value_Option = self.func_Get_Current_Config_Value(obj_Config, str_Section, str_Option, value_Type)

        str_Object_Name = 'comboBox_13'
        qWidget_Engaged = self.findChild(QtGui.QComboBox, str_Object_Name)
        bool_UnChanged = False
        
        bool_Continue = False
        bool_Changed = False
        if self.str_Sampling_Strategy_LDNe_PCrit_To_Get == value_Option:
            bool_UnChanged = True
            bool_Continue = True
        else:
            if self.bool_Reload_Widgets_Finished__Sampling_Strategy:
                list_Object_Groups = [globalsSSFE.Parameter_Group.static_str__Parameter_Group__SAMPLING_STRATEGY_PARAM]
                ''' Verify if the change can proceed '''
                int_Verify_Change__Warning_Count = self.func_Verify_Change__Get_Warning_Count__Bind_Event_Filter_Downstream_Actions(str_Object_Name, list_Object_Groups)
                if int_Verify_Change__Warning_Count < 1:
                    ''' Block signals to ensure editingChanged SIGNAL does not fire when MessageBox shown '''
                    qWidget_Engaged.blockSignals(True)
                    ''' Warn that other parameters that are dependent will have to be changed '''
                    bool_Continue = self.func_Verify_Change__Can_Change_Proceed__ANY_Sampling_Strategy_PARAMETER()
                    if bool_Continue:
                        int_Index_New = qWidget_Engaged.findText(value_Option)
                        qWidget_Engaged.setCurrentIndex(int_Index_New)
                        '''NOTE: This is different to other comboBox Selection functions...
                        The Changed flag must be set here as for this comboBox just changing the index saves the new value '''
                        bool_Changed = True
                    else:
                        bool_Changed = False
                    pass
                    qWidget_Engaged.blockSignals(False)
                else:
                    bool_Continue = True
                    '''NOTE: This is different to other comboBox Selection functions...
                    The Changed flag must be set here as for this comboBox just changing the index saves the new value '''
                    bool_Changed = True
                pass
            else:
                bool_Continue = True
                bool_Changed = False
            pass
        pass
        
        if bool_Continue:  
        
            self.str_Sampling_Strategy_LDNe_PCrit_To_Get = value_Option
            if value_Option == object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_LDNe_PCrit_To_Get__0_00:
                
                if bool_Changed or (not bool_UnChanged):
                    self.func_Update_Config__Sampling_Strategy_LDNe_PCrit_To_Get()
                pass
            elif value_Option == object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_LDNe_PCrit_To_Get__0_01:
                
                if bool_Changed or (not bool_UnChanged):
                    self.func_Update_Config__Sampling_Strategy_LDNe_PCrit_To_Get()
                pass
            elif value_Option == object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_LDNe_PCrit_To_Get__0_02:
                
                if bool_Changed or (not bool_UnChanged):
                    self.func_Update_Config__Sampling_Strategy_LDNe_PCrit_To_Get()
                pass
            elif value_Option == object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_LDNe_PCrit_To_Get__0_05:
                
                if bool_Changed or (not bool_UnChanged):
                    self.func_Update_Config__Sampling_Strategy_LDNe_PCrit_To_Get()
                pass
            elif value_Option == object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_LDNe_PCrit_To_Get__NoS:
                
                if bool_Changed or (not bool_UnChanged):
                    self.func_Update_Config__Sampling_Strategy_LDNe_PCrit_To_Get()
                pass
            else:
                #self.label_28.setText(self.str_str_Sampling_Strategy_LDNe_PCrit_To_Get__Label_Text + '*')
                qWidget = self.label_28
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
                #self.stackedWidget.setCurrentIndex(0)
            pass
        else:
            int_Index_Orig = qWidget_Engaged.findText(self.str_Sampling_Strategy_LDNe_PCrit_To_Get)
            qWidget_Engaged.setCurrentIndex(int_Index_Orig)
        pass        
        
        return True
              
    def func_Sampling_Strategy_LDNe_PCrit_To_Get_Display(self): 
        
        value_Option = self.str_Sampling_Strategy_LDNe_PCrit_To_Get
        if value_Option == object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_LDNe_PCrit_To_Get__0_00:
            self.comboBox_13.setCurrentIndex(1)
        elif value_Option == object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_LDNe_PCrit_To_Get__0_01:
            self.comboBox_13.setCurrentIndex(2)
        elif value_Option == object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_LDNe_PCrit_To_Get__0_02:
            self.comboBox_13.setCurrentIndex(3)
        elif value_Option == object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_LDNe_PCrit_To_Get__0_05:
            self.comboBox_13.setCurrentIndex(4)
        elif value_Option == object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_LDNe_PCrit_To_Get__NoS:
            self.comboBox_13.setCurrentIndex(5)
        else:
            self.comboBox_13.setCurrentIndex(0)
        pass
    
        return True

    def func_Update__Sampling_Strategy_Run_Parameters(self, str_Object_Name, value_Object, bool_Save):
        
        if str_Object_Name == 'horizontalSlider_54':
            self.func_Update__Sampling_Strategy_LDNe_Replicates(value_Object, bool_Save)
        pass
    
        return True


    def func_Update__Sampling_Strategy_LDNe_Replicates(self, int_Value, bool_Save):

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        if bool_Save:
            ''' Update config but dont Save file...yet'''
            self.int_Sampling_Strategy_LDNe_Replicates = int_Value 
            #DEBUG_ON
            #self.func_Debug_Logging(False, 2, '; SAVE ; self.int_Sampling_Strategy_LDNe_Replicates: ' + str(self.int_Sampling_Strategy_LDNe_Replicates) + '; self.bool_int_Sampling_Strategy_LDNe_Replicates__FOUND: ' + str(self.bool_int_Sampling_Strategy_LDNe_Replicates__FOUND))
            #DEBUG_OFF                
            self.func_Update_Config__Sampling_Strategy_LDNe_Replicates()
#             if self.bool_int_Sampling_Strategy_LDNe_Replicates__FOUND:
# 
#                 self.func_Update_Config__Sampling_Strategy_LDNe_Replicates()
#             else:
#                 self.func_Update_Config__Sampling_Strategy_LDNe_Replicates()
#                 '''Remove the REQUIRED label from the widget '''
#                 self.label_67.setText(self.str_int_Sampling_Strategy_LDNe_Replicates__Label_Text)
#             pass
        pass
    
        ''' Set the ranges for related sliders '''

        #DEBUG_ON
        #self.func_Debug_Logging(False, 2, '; CHANGE ; self.int_Sampling_Strategy_LDNe_Replicates: ' + str(self.int_Sampling_Strategy_LDNe_Replicates))
        #DEBUG_OFF 
        self.func_Change__Sampling_Strategy_LDNe_Replicates(int_Value)
    
        return True
    
    def func_Change__Sampling_Strategy_LDNe_Replicates(self, int_Value):
        
        pass
        return True

    def func_Update_Config__Sampling_Strategy_LDNe_Replicates(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: LDNe_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_LDNe_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_Replicates
        value_Option = self.int_Sampling_Strategy_LDNe_Replicates
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_LDNe_Replicates__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
                qWidget = self.label_67
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)   
            pass
        pass
    
        return True 

    def func_Update_Config__Sampling_Strategy_LDNe_PCrit_To_Get(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            
    
        ''' <<<<<<< SECTION: LDNe_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_LDNe_Details

        ''' Specify OPTION to UPDATE '''
        self.bool_str_Sampling_Strategy_LDNe_PCrit_To_Get__CHANGED = False
        #self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False        
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_PCrit_To_Get
        value_Option = self.str_Sampling_Strategy_LDNe_PCrit_To_Get
        ''' Update the OPTION '''
        bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
        if bool_Success:
            self.bool_str_Sampling_Strategy_LDNe_PCrit_To_Get__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            qWidget = self.label_28
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status) 
        pass

        return True    
                 
    def func_Update_Config__Sampling_Strategy_Sample_Proportions_Source(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.qForm_Main.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
        
        ''' <<<<<<< SECTION: Sample_Proportion_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportion_Details

        ''' Specify OPTION to UPDATE '''
        self.bool_str_Sampling_Strategy_Sample_Proportions_Source__CHANGED = False
        #self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False        
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Proportions_Source
        value_Option = self.str_Sampling_Strategy_Sample_Proportions_Source
        ''' Update the OPTION '''
        bool_Success = self.Update_OPTION(obj_Config, str_Section, str_Option, value_Option)
        if bool_Success:
            self.bool_str_Sampling_Strategy_Sample_Proportions_Source__FOUND = True
            self.bool_str_Sampling_Strategy_Sample_Proportions_Source__CHANGED = True
            self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
        pass

        return True    

    def func_Update_Config__Sampling_Strategy_Run_Ne_Estimator_External_Process_Version(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Ne_Estimator_External_Process_Version
        value_Option = self.str_Sampling_Strategy_Run_Ne_Estimator_External_Process_Version 
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_str_Sampling_Strategy_Run_Ne_Estimator_External_Process_Version__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            pass
        pass
        return True 
                 
    def func_Update_Config__Sampling_Strategy_Run_Simulation_Working_Base_Path(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Simulation_Working_Base_Path
        value_Option = self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path 
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_str_Sampling_Strategy_Run_Simulation_Working_Base_Path__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
                qWidget = self.label_32
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                   
            pass
        pass
        return True 
    
    def func_Update_Config__Sampling_Strategy_Run_Simulation_Output_Base_Path(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Simulation_Output_Base_Path
        value_Option = self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path 
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            pass
        pass
        return True 

    def func_Update_Config__Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds
        value_Option = self.int_Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds 
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            pass
        pass
        return True 
    
    def func_Update_Config__Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count
        value_Option = self.int_Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count 
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            pass
        pass
        return True 

    def func_Update_Config__Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed
        value_Option = self.int_Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed 
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            pass
        pass
        return True 

    def func_Update_Config__Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed
        value_Option = self.int_Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed 
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_int_Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            pass
        pass
        return True 

    def func_Update_Config__Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS
        value_Option = str(self.dict_Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS).replace('{','').replace('}','').replace("'", "").replace(' ', '')
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_dict_Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            pass
        pass
        return True 

    def func_Update_Config__Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        config_parser_Config = obj_Config.config_parser_Config
        
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS
        value_Option = str(self.dict_Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS).replace('{','').replace('}','').replace("'", "").replace(' ', '')
        ''' Update the OPTION '''
        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        else:
            if self.bool_Init_Finished:
                self.bool_dict_Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS__CHANGED = True
                self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = True
            pass
        pass
        return True 


    def func_Update_Config__Settings_Context_Help_Display_At_Start(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Settings
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.qForm_Main.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
        
        ''' <<<<<<< SECTION: Context_Help '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Settings_Context_Help

        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Settings_Context_Help_Display_At_Start
        value_Option = self.bool_Settings_Context_Help_Display_At_Start__Default_Value
        ''' Update the OPTION '''
        bool_Success, self.obj_Config_Settings = self.func_Update_Config_File(self.str_Application_Settings_Path_And_File, self.obj_Config_Settings, str_Section, str_Option, value_Option)
        
        return True 
       
    def func_Update_Config__Settings_Context_Help_Zoom_Factor(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = self.obj_Config_Settings
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.qForm_Main.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
        
        ''' <<<<<<< SECTION: Context_Help '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Settings_Context_Help

        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Settings_Context_Help_Zoom_Factor
        value_Option = self.float_Settings_Context_Help_Zoom_Factor__Default_Value
        ''' Update the OPTION '''
        bool_Success, self.obj_Config_Settings = self.func_Update_Config_File(self.str_Application_Settings_Path_And_File, self.obj_Config_Settings, str_Section, str_Option, value_Option)
        
        return True    
                 

    '''
    -------------------------------------------------------------------------------
     BACKEND JOB Runs
    -------------------------------------------------------------------------------
    '''           
    def func_Run_Scenarios(self, str_Processing_Steps_CSV):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
        self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL

        '''1 - Disable widgets to prevent interaction whilst job is running '''
        #self.func_Run_Job__Disable_Widgets_For_Run_Duration(self.toolBox.currentIndex())   
#         '''1 - Lock all controls to stop user interaction whilst job is running '''
#         if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
#             self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOMINAL
#             self.func_Enable_Widgets__QToolBox__MainToolBox(globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario, True)
#         elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT: 
#             self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOMINAL
#             self.func_Enable_Widgets__QToolBox__MainToolBox(globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy, True)
#         pass
#         self.func_Run_Job__Disable_Widgets_For_Run_Duration(self.toolBox.currentIndex())
                
        '''2 - Prepare Job files and transfer files required to run job '''
        bool_Success = self.func_Run_Scenario_Job__Prepare_Job(str_Processing_Steps_CSV)
                
        '''3 - Create Scenario Job environment'''
        if bool_Success: 
            bool_Success = False
            bool_Success = self.func_Run_Scenario_Job__Prepare_Job_Environment()
            if not bool_Success:
                str_Message_Text = 'Scenario Job environment could not be prepared'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
            pass                
        pass

        '''4 - Start Job with args: Batch_Scenario.ini & processing stage (i.e. Scenerio or Sampling Strategy)'''
        if bool_Success: 
            bool_Success = False
            bool_Success, self.int_Process_JOB_SHELL__PID = self.func_Run_Scenario_Job__Start_Job()

            if bool_Success:
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__REQUESTED
                str_Job_Status__Status_Message = 'Job is reporting as ' + self.str_Job_Status__Status + '. Monitoring...'
                
                self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)     
            pass       
        pass

#         '''1 - Lock all controls to stop user interaction whilst job is running '''
#         if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
#             self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOMINAL
#             self.func_Enable_Widgets__QToolBox__MainToolBox(globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario, True)
#             self.func_Run_Job__Disable_Widgets_For_Run_Duration(self.toolBox.currentIndex())
#         elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT: 
#             self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOMINAL
#             self.func_Enable_Widgets__QToolBox__MainToolBox(globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy, True)
#             self.func_Run_Job__Disable_Widgets_For_Run_Duration(self.toolBox.currentIndex())
#         pass
# 
        '''1 - Lock all controls to stop user interaction whilst job is running '''
        if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
            self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOMINAL
            self.func_Enable_Widgets__QToolBox__MainToolBox(globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario, True)
        elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT: 
            self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOMINAL
            self.func_Enable_Widgets__QToolBox__MainToolBox(globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy, True)
        pass
        self.func_Run_Job__Disable_Widgets_For_Run_Duration(self.toolBox.currentIndex())
                
        '''5 - Monitor job repeatedly until job completion'''
        if bool_Success:
            bool_Success = False
#             self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
#             self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL

            self.bool_Job_Status__Terminated = False
            self.bool_Job_Status__Complete = False
            bool_Success = self.func_Run_Job__Monitor_Job(self.int_Process_JOB_SHELL__PID) 
        pass
               
        '''5a - Write Job Status to config file so even if FrontEnd fails the Job progress can still be tracked'''
        
        '''5b - Track Job by PID and check for the prescense of a .SUCCESS or .FAILED files from BackEnd '''
        
        '''6 - Job run end processing '''
        
        '''6a - On job failure - report error '''
        
        '''6b - On job success - report success. Process results for user review '''

#         ''' Show the appropriate results page '''
#         if bool_Success and self.bool_Job_Status__Complete:
#             if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
#                 self.toolBox.setCurrentIndex(globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Scenario)
#             elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT:
#                 self.toolBox.setCurrentIndex(globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Sampling_Strategy)
#             pass
#         pass 
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, 'RUN SCENARIOS FINISHED')
        #DEBUG_OFF
                
        return bool_Success

    def func_Run_Job__Disable_Widgets_For_Run_Duration(self, int_Page__Current):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        if self.int_Run_Status_Error_Flag__Current != globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL:
            return True
        pass
    
        bool_Block_Signals = True
        list_Pages_Enabled = []
        
        self.toolBox.blockSignals(bool_Block_Signals) 
        pass

        bool_Enabled = False
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        
        
        if int_Page__Current == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario or \
           int_Page__Current == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy:
            
            qWidget_Toolbox_Page = QtGui.QToolBox.widget(self.toolBox, int_Page__Current)
            
            list_QWidget_Children = qWidget_Toolbox_Page.findChildren((QtGui.QPushButton,QtGui.QSlider,QtGui.QSpinBox, QtGui.QToolButton, QtGui.QComboBox))

            self.comboBox_110.blockSignals(True)
            self.comboBox_210.blockSignals(True)
            self.comboBox_310.blockSignals(True)
            
            self.comboBox_110.setEnabled(False)
            self.comboBox_210.setEnabled(False)
            self.comboBox_310.setEnabled(False)

            self.comboBox_110.blockSignals(False)
            self.comboBox_210.blockSignals(False)
            self.comboBox_310.blockSignals(False)
                        
            self.bool_ComboBox_Events_Disabled = True
            self.bool_Slider_Events_Disabled = True
            
            #qWidget_Toolbox_Page.setDisabled(True)
            for qWidget in list_QWidget_Children:
                try:
                    qWidget.blockSignals(True)
                    qWidget.setDisabled(True)
                    qWidget.blockSignals(False)
                except:
                    pass
                pass
            pass
        pass

        bool_Block_Signals = False
        self.toolBox.blockSignals(bool_Block_Signals) 
        pass
    
        return True
    
    def func_Run_Job__Enable_Widgets_After_Run(self, int_Page__Current):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
#         if self.int_Run_Status_Error_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL:
#             return True
#         pass
    
        bool_Block_Signals = True
        list_Pages_Enabled = []
        
        self.toolBox.blockSignals(bool_Block_Signals) 
        pass

        bool_Enabled = True
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Select_Project_And_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Scenario
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Create_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Modify_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        int_Page__To_Enable = globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__View_Results_Sampling_Strategy
        self.toolBox.setItemEnabled(int_Page__To_Enable, bool_Enabled) if int_Page__Current != int_Page__To_Enable else 0
        
        
        if int_Page__Current == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Scenario or \
           int_Page__Current == globalsSSFE.Main_Form_QToolBox_Tab_Index.static_int_Main_Form_QToolBox_Tab_Index__Run_Sampling_Strategy:
            
            qWidget_Toolbox_Page = QtGui.QToolBox.widget(self.toolBox, int_Page__Current)
            
            list_QWidget_Children = qWidget_Toolbox_Page.findChildren((QtGui.QPushButton,QtGui.QSlider,QtGui.QSpinBox, QtGui.QToolButton, QtGui.QComboBox))

            self.comboBox_110.blockSignals(True)
            self.comboBox_210.blockSignals(True)
            self.comboBox_310.blockSignals(True)
            
            self.comboBox_110.setEnabled(True)
            self.comboBox_210.setEnabled(True)
            self.comboBox_310.setEnabled(True)

            self.comboBox_110.blockSignals(False)
            self.comboBox_210.blockSignals(False)
            self.comboBox_310.blockSignals(False)
            
            self.bool_ComboBox_Events_Disabled = False                        
            self.bool_Slider_Events_Disabled = False
            #qWidget_Toolbox_Page.setDisabled(True)
            for qWidget in list_QWidget_Children:
                try:
                    qWidget.blockSignals(True)
                    qWidget.setDisabled(False)
                    qWidget.setEnabled(True)
                    qWidget.blockSignals(False)
                except:
                    pass
                pass
            pass
        pass

        bool_Block_Signals = False
        self.toolBox.blockSignals(bool_Block_Signals) 
        pass
    
        return True
    
    def func_Run_Scenario_Job__Prepare_Job(self, str_Processing_Steps_CSV):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        bool_Success = False
        self.str_BackEnd_Run_UID__STARTED = ''
        self.str_BackEnd_Run_UID__ENDED = ''

        '''Start Job with args: Batch_Scenario.ini & processing stage (i.e. Scenerio or Sampling Strategy)'''
        str_BackEnd_Job_Base_Path = self.str_BackEnd_Working_Path
        if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
            #_, str_BackEnd_Job_Config_File = os__path.split(self.str_Batch_Scenario_Path_And_File__Current)
            str_BackEnd_Job_Config_Path_And_File = self.str_Batch_Scenario_Path_And_File__Current
        elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT: 
            #_, str_BackEnd_Job_Config_File = os__path.split(self.str_Sampling_Strategy_Path_And_File__Current)
            str_BackEnd_Job_Config_Path_And_File = self.str_Sampling_Strategy_Path_And_File__Current
        pass
        
        #DEBUB_ON
        #str_Processing_Steps_CSV = str(globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM)  #'0,1'
        #DEBUG_OFF

        if self.bool_Settings_Run_BackEnd_BINARY_Executable__Default_Value:
            str_BackEnd_Executable_Path = self.str_Settings_Run_BackEnd_BINARY_Executable_Path__Default_Value
            str_BackEnd_Executable_File = self.str_Settings_Run_BackEnd_BINARY_Executable_Name__Default_Value #Main.exe'
            str_BackEnd_Executable_Path_And_File = os__path.join(str_BackEnd_Executable_Path, str_BackEnd_Executable_File)
            
            str_Commands_To_Execute = '"' + str_BackEnd_Executable_Path_And_File + '"' + ' -i ' + '"' + str_BackEnd_Job_Config_Path_And_File + '"' + ' -o ' + '"' + str_BackEnd_Job_Base_Path + '"' + ' -p ' + str_Processing_Steps_CSV
            str_Commands_To_Execute += '\npause'
        else:

            str_BackEnd_Executable_Path = self.str_Settings_Run_BackEnd_Path__Default_Value
            str_BackEnd_Executable_File = self.str_Settings_Run_BackEnd_ExecutableName__Default_Value
            str_BackEnd_Executable_Path_And_File = os__path.join(str_BackEnd_Executable_Path, str_BackEnd_Executable_File)

            str_Python_Executable_Path = self.str_Settings_Run_Python_Executable_Path__Default_Value
            str_Python_Executable_File = self.str_Settings_Run_Python_Executable_Name__Default_Value
            str_Python_Executable_Path_And_File = os__path.join(str_Python_Executable_Path, str_Python_Executable_File)
                    
            str_Commands_To_Execute = '"' + str_Python_Executable_Path_And_File + '"' + ' ' + '"' + str_BackEnd_Executable_Path_And_File + '"' + ' -i ' + '"' + str_BackEnd_Job_Config_Path_And_File + '"' + ' -o ' + '"' + str_BackEnd_Job_Base_Path + '"' + ' -p ' + str_Processing_Steps_CSV
            str_Commands_To_Execute += '\npause'
        pass
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, str_Commands_To_Execute)
        #DEBUG_OFF
       
        self.str_Path__Save_Shell_Script = self.str_Batch_Scenario_Path__Current
        if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
            str_File__Save_Shell_Script = 'Run_SharkSim_' + os__path.split(os__path.splitext(self.str_Batch_Scenario_File__Current)[0])[1] + '.bat'
        elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT: 
            str_File__Save_Shell_Script = 'Run_SharkSim_' + os__path.split(os__path.splitext(self.str_Sampling_Strategy_File__Current)[0])[1] + '.bat' 
        pass              
        self.str_Path_And_File__Save_Shell_Script = os__path.join(self.str_Path__Save_Shell_Script, str_File__Save_Shell_Script)
        
        ''' Write shell script file '''
        bool_Success = self.func_Write_Shell_Script_File(self.str_Path_And_File__Save_Shell_Script, str_Commands_To_Execute)
        
        return bool_Success 
    
    def func_Run_Scenario_Job__Prepare_Job_Environment(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        bool_Success = False


        str_Path__Origin = self.str_Batch_Scenario_Path__Current
        str_Path__Destination = self.str_BackEnd_Working_Path
        
        str_File_Name__Copy_Pattern = '*' + os__extsep + self.str_Settings_Run_File_Extension_Config_File__Default_Value
        bool_Success = self.func_Create_Backend_Local_Copy_Of_Required_Files(str_Path__Origin, str_Path__Destination, str_File_Name__Copy_Pattern, bool_Delete_Files=True)
        
        str_File_Name__Copy_Pattern = '*' + os__extsep + globalsSSFE.Exe_File.static_str__App_File_Extension__Windows_DOS_Batch_File
        bool_Success = self.func_Create_Backend_Local_Copy_Of_Required_Files(str_Path__Origin, str_Path__Destination, str_File_Name__Copy_Pattern, bool_Delete_Files=True)
        
        if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT:
            str_Path__Origin = self.str_Sampling_Strategy_Path__Current
            str_Path__Destination = self.str_BackEnd_Working_Path            
            str_File_Name__Copy_Pattern = '*' + os__extsep + self.str_Settings_Run_File_Extension_Config_File__Default_Value
            bool_Success = self.func_Create_Backend_Local_Copy_Of_Required_Files(str_Path__Origin, str_Path__Destination, str_File_Name__Copy_Pattern, bool_Delete_Files=False)
            pass
        pass
            
        ''' Delete the job status folder...
        The backEnd also does this but..
        This will allow for error management at the frontend if not successful...
        also prevent a ststus from a previous job being read before backend can delete it '''
        bool_Job_STATUS_PATH_FOUND = False
        str_Run_Status_Path = os__path.join(self.str_BackEnd_Working_Path, globalsDCBGen.Run_Status.static_str_Run_Status__Path)
        bool_Delete_Run_Status_Path = True
        if bool_Delete_Run_Status_Path:
            bool_Success = False
            with FileHandler() as obj_FileOp:
                 
                bool_Job_STATUS_PATH_FOUND = obj_FileOp.method_Path_Exists(str_Run_Status_Path)
                if bool_Job_STATUS_PATH_FOUND:
                    bool_Success = False
                    try:
                        shutil__rmtree(str_Run_Status_Path) #removes all the subdirectories!
                        bool_Success = True
                    except (OSError, IOError):
                        str_Message_Text = 'Unable to delete the run status path: ' + str_Run_Status_Path
                        int_Stack_Trace_Level = 2
                        self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
                    pass 
                else:
                    bool_Success = True
                pass 
                
            pass
        pass        
            
        if bool_Success:
            if bool_Job_STATUS_PATH_FOUND:
                ''' Delay spawning of job to allow for OS to purge this path '''
                bool_Job_STATUS_PATH_FOUND = False
                with FileHandler() as obj_FileOp:
                    for int_Check in range(0, self.int_Settings_Job_Run_Scenario_Job__Time_Delay_In_Secs_Before_Monitoring__Default_Value):
                        time__sleep(1)
                        bool_Job_STATUS_PATH_FOUND = obj_FileOp.method_Path_Exists(str_Run_Status_Path)
                        if bool_Job_STATUS_PATH_FOUND:
                            #self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__REQUESTED
                            str_Job_Status__Status_Message = str(int_Check) + ' Waiting for confirmation of run environment cleansing. Monitoring...'
                            self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                            QtGui.QApplication.processEvents() 
                            bool_Success = False                       
                        else:
                            bool_Success = True
                            break
                        pass                                         
                    pass
                pass
            pass
        pass        

        if bool_Success:
            #self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.
            str_Job_Status__Status_Message = 'Scenario working path clean. Run status files will be created. Monitoring...'
            self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
            QtGui.QApplication.processEvents()
        pass

        bool_Success = False
        str_Run_Status = globalsDCBGen.Run_Status.static_str_Run_Status__REQUESTED
        str_Run_Status_Base_Path = self.str_BackEnd_Working_Path #self.str_Batch_Scenario_Path__Current
        bool_Delete_Run_Status_Path = False
        bool_Success = self.func_Job_Status__Create_Status_File(str_Run_Status_Base_Path, str_Run_Status, bool_Delete_Run_Status_Path)
#         str_Run_Status_Path__CWD = self.str_Settings_Run_BackEnd_Path__Default_Value
#         bool_Delete_Run_Status_Path = False
#         bool_Success = self.func_Job_Status__Create_Status_File(str_Run_Status_Path__CWD, str_Run_Status, bool_Delete_Run_Status_Path)

        bool_Job_REQUESTED = False
        
        with FileHandler() as obj_FileOp:
            ''' Delay spawning of job to allow for OS to purge this path '''
            bool_Job_STATUS_PATH_FOUND = False
            with FileHandler() as obj_FileOp:
                for int_Check in range(0, self.int_Settings_Job_Run_Scenario_Job__Time_Delay_In_Secs_Before_Monitoring__Default_Value):
                    time__sleep(1)
                    str_Search_Path = os__path.join(self.str_BackEnd_Working_Path, globalsDCBGen.Run_Status.static_str_Run_Status__Path)
                    bool_Job_STATUS_PATH_FOUND = obj_FileOp.method_Path_Exists(str_Search_Path)
                    if bool_Job_STATUS_PATH_FOUND:
                    
                        ''' Check if REQUESTED file has been created'''
                        str_File_Search_Pattern = '*.' + globalsDCBGen.Run_Status.static_str_Run_Status__REQUESTED
                        bool_Job_REQUESTED, list_Path_And_Files = self.func_Check_If_Files_Exist(str_Search_Path, str_File_Search_Pattern)
                    else:
                        bool_Job_REQUESTED = False
                    pass
                
#                     str_Run_Status_Path__CWD = self.str_Settings_Run_BackEnd_Path__Default_Value
#                     bool_Job_STATUS_PATH_FOUND = obj_FileOp.method_Path_Exists(str_Run_Status_Path__CWD)
#                     if bool_Job_STATUS_PATH_FOUND:
#                         ''' Check if CWD REQUESTED file has been created'''
#                         str_File_Search_Pattern = '*.' + globalsDCBGen.Run_Status.static_str_Run_Status__REQUESTED
#                         bool_Job_CWD_REQUESTED, list_Path_And_Files = self.func_Check_If_Files_Exist(str_Run_Status_Path__CWD, str_File_Search_Pattern)
#                     else:
#                         bool_Job_CWD_REQUESTED = False
#                     pass
                
                    #if bool_Job_REQUESTED and bool_Job_CWD_REQUESTED:
                    if bool_Job_REQUESTED:
                        bool_Success = True
                        break
                    else:
                        #self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__REQUESTED
                        str_Job_Status__Status_Message = str(int_Check) + ' Waiting for confirmation of run status file creation. Monitoring...'
                        self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                        QtGui.QApplication.processEvents() 
                        bool_Success = False  
                    pass 
                pass
            pass                                                              
        pass

        if bool_Success:
            #self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.
            str_Job_Status__Status_Message = 'Scenario run status files established. Job will be spawned. Monitoring...'
            self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
            QtGui.QApplication.processEvents()
        pass     
    
        return bool_Success
    
    def func_Run_Scenario_Job__Start_Job(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        bool_Success = False


        str_Path__Run_Shell_Script = self.str_BackEnd_Working_Path
        _, str_File__Run_Shell_Script = os__path.split(self.str_Path_And_File__Save_Shell_Script)         
        str_Path_And_File__Run_Shell_Script = os__path.join(str_Path__Run_Shell_Script, str_File__Run_Shell_Script)
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, 'Shell script to start: ' + str_Path_And_File__Run_Shell_Script)
        #DEBUG_OFF
                
        list_Executable_And_Args = [str_Path_And_File__Run_Shell_Script]
        bool_Prevent_External_Function_Console_Output = False
        
        ''' Start the Job '''
        process_JOB_SHELL = None
        process_JOB_SHELL = self.func_Run_Scenario_Job__Execute_External_Program(list_Executable_And_Args, str_Path__Run_Shell_Script, bool_Prevent_External_Function_Console_Output)       

        if process_JOB_SHELL != None:
            self.int_Process_JOB_SHELL__PID = process_JOB_SHELL.pid
            bool_Success = True
        else:
            str_Message_Text = 'Process not created. Could not execute external job: ' + str_Path_And_File__Run_Shell_Script + ' From path: ' + str_Path__Run_Shell_Script
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
            pass            
        pass
    
        if bool_Success:
            bool_Success = self.func_Run_Scenario_Job__Set_CPU_Affinity_For_Process(self.int_Process_JOB_SHELL__PID)
        pass
        
        return bool_Success, self.int_Process_JOB_SHELL__PID #process_JOB_SHELL
    
    def func_Job_Status__Create_Status_File(self, str_Run_Status_Base_Path, str_Run_Status, bool_Delete_Run_Status_Path):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        str_Run_Status_Path_And_File = ''
        str_Run_Status_Path = os__path.join(str_Run_Status_Base_Path, globalsDCBGen.Run_Status.static_str_Run_Status__Path)

        with FileHandler() as obj_FileOp:
            if bool_Delete_Run_Status_Path:
                
                bool_Job_STATUS_PATH_FOUND = obj_FileOp.method_Path_Exists(str_Run_Status_Path)
                if bool_Job_STATUS_PATH_FOUND:
                    try:
                        shutil__rmtree(str_Run_Status_Path) #removes all the subdirectories!
                        bool_Success = True
                    except (OSError, IOError):
                        str_Message_Text = 'Unable to delete the run status path: ' + str_Run_Status_Path
                        int_Stack_Trace_Level = 2
                        self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
                    pass 
                else:
                    bool_Success = True
                pass 
            pass
            
            str_Run_Status_Path_And_File = os__path.join(str_Run_Status_Path, globalsSSFE.Run_Status.static_str_Run_Status_File_Prefix + os__extsep + str_Run_Status)
            bool_Success = obj_FileOp.method_FileSystem_Prep_For_File_Save(str_Run_Status_Path_And_File, bool_Delete=True)
            
            if bool_Success:
                bool_Success = False
                fileHandle = obj_FileOp.fileOpen(str_Run_Status_Path_And_File, 'write')
                if fileHandle != None:
                    bool_Success = True
                else:
                    str_Message_Text = 'Unable to create Run Status File : ' + str_Run_Status_Path_And_File
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
                    pass              
                pass
            pass
        pass
            
        return bool_Success
    
    def func_Run_Scenario_Job__Execute_External_Program(self, list_Executable_And_Args, strFilePath_Working, bool_Prevent_External_Function_Console_Output):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
            
        '''
        Runs an external process
        !!!NOTE: Assumes requisite execution and input files are already present
        '''
        bool_Prevent_External_Function_Console_Output = False
        if bool_Prevent_External_Function_Console_Output:
            fh = open('NUL', "w")
        else:
            fh = None
        pass
    
        #Run batch file as subprocess
        #DEBUG_ON
        #os.chdir(strFilePath_Working)
        #process = subprocess__Popen(['0-TEST_Run_Main_py_With_Args.bat'], stdout = fh, stderr = fh, creationflags=subprocess__CREATE_NEW_CONSOLE)
        #DEBUG_OFF
        str_Current_Working_Path = os__getcwd()
        
        os__chdir(strFilePath_Working)
        #process = subprocess__Popen(list_Executable_And_Args, stdout = fh, stderr = fh, shell=True)
        process = subprocess__Popen(list_Executable_And_Args, stdout = fh, stderr = fh, creationflags=subprocess__CREATE_NEW_CONSOLE)
        
        ''' Change back to previous working folder to close handles on the current one '''
        os__chdir(str_Current_Working_Path)
        
        ''' This line ensures that this process completes before proceeding to the next one '''
        #stdout, stderr = process.communicate()
        
        if bool_Prevent_External_Function_Console_Output:
            fh.close()
        pass
    

        
        return process
   
    def func_Run_Scenario_Job__Set_CPU_Affinity_For_Process(self, int_Process_JOB_SHELL__PID):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        bool_Success = False
                
        ''' Set the CPU affinity for the process'''
        int_CPUs_To_Keep_Free = 0
        
        bool_Use_Affinity = True
        if bool_Use_Affinity:
            int_CPUs = multiprocessing__cpu_count()
            if int_CPUs > self.int_Settings_Run_BackEnd_Job_CPUs_To_Leave_In_Reserve__Default_Value:
                int_CPUs_To_Keep_Free = self.int_Settings_Run_BackEnd_Job_CPUs_To_Leave_In_Reserve__Default_Value
            else:
                if int_CPUs > 1:
                    int_CPUs_To_Keep_Free = 1
                else:
                    int_CPUs_To_Keep_Free = 0
                pass
            pass
        
            if int_CPUs > int_CPUs_To_Keep_Free: 
                int_CPUs_To_Use = int_CPUs - int_CPUs_To_Keep_Free
                list_CPUs = [x for x in range(0,int_CPUs_To_Use)]                    
                
                try:
                    pidLastSpawnedProcess = self.int_Process_JOB_SHELL__PID #process.pid
                    if psutil.pid_exists(pidLastSpawnedProcess):
                        psutil_Process = psutil.Process(pidLastSpawnedProcess) 
                        psutil_Process.cpu_affinity(list_CPUs)
                    pass
                    bool_Success = True
                except psutil.NoSuchProcess, psutil.AccessDenied:
                    ''' Process has probably finished '''
                    pass
                except OSError, exception_Exception:
                    if sys.platform.startswith('win'):
                        if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                            ''' Process has probably finished '''
                        pass
                    pass
                pass
            pass
        pass
    
        return bool_Success        

    def func_Run_Job__Monitor_Job(self, int_Process_JOB_SHELL__PID): 

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, 'Starting Job monitor (PID) ' + str(self.int_Process_JOB_SHELL__PID))
        #DEBUG_OFF
                
        ''' As args cant be passed to the scheduled functions use a glbal '''
        #self.process_Job = process_Job
        self.int_Process_JOB_SHELL__PID = int_Process_JOB_SHELL__PID
#         
#         ''' Delay monitoring to allow for spawned job to become active '''
#         time__sleep(10)
        #print(time.ctime())
        
        '''
        ---------------------------------------------------------------------
        Monitor job by starting two timers:
        t1 - Check the job process existance and the job run status file for a termination
        t2 - Check the termination flag and cancels the timers if job termination has occured, or...
         re-runs this function to re-start the monitoring process
        ---------------------------------------------------------------------
        '''
        #self.bool_Job_Status__Terminated = False
        if not self.bool_Job_Status__Terminated:
            int_Delay = self.int_Settings_Run_FrontEnd_Job_Run_Monitor_Job_Status_Time_Delay_Secs__Default_Value
            self.t1 = threading__Timer(3, self.func_Run_Job__Check_Job_Status)
            self.t1.start()
        pass

#         int_Delay = self.int_Settings_Run_FrontEnd_Job_Run_Monitor_Job_Status_Time_Delay_Secs__Default_Value
#         self.t1 = threading__Timer(3, self.func_Run_Job__Check_Job_Status)
#         self.t1.start()
#         pass

        pass
        
#         if not self.bool_Job_Status__Complete:
#             int_Delay = self.int_Settings_Run_FrontEnd_Job_Run_Monitor_Job_Termination_Status_Time_Delay_Secs__Default_Value
#             self.t2 = threading__Timer(int_Delay, self.func_Run_Job__Check_Job_Termination_Status)
#             self.t2.start()
#         pass
    
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, 'MONITOR JOB FINISHED')
        #DEBUG_OFF 
                
        return True
    
    
    def func_Run_Job__Check_Job_Status(self): 

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, 'Checking job run status. PID: ' + str(self.int_Process_JOB_SHELL__PID))
        #DEBUG_OFF
                
        bool_Success = False
        
        
        self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOT_TERMINATED
        self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_STATUS_REQUESTED
        str_Job_Run_Status_Flag__Current = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_STATUS_REQUESTED
        bool_Job_STATUS_PATH_NOT_FOUND = False
        bool_Job_FAILED_CAUGHT = False
        bool_Job_FAILED_UNCAUGHT = False
        bool_Job_ENDED = False

        
        ''' Check if PARENT process PID exists and is therefore SHELL is still current '''
        bool_PARENT_Process_PID_Exists = False
        bool_Job_JOB_SHELL_PID_NOT_FOUND = False
        
        try:
            pid_Spawned_PARENT_Process = self.int_Process_JOB_SHELL__PID #self.process_Job.pid
            bool_PARENT_Process_PID_Exists = psutil.pid_exists(pid_Spawned_PARENT_Process)
            if bool_PARENT_Process_PID_Exists:
                psutil_PARENT_Process = psutil.Process(pid_Spawned_PARENT_Process)
                bool_Job_JOB_SHELL_PID_NOT_FOUND = False
                self.pid_Spawned_PARENT_Process = pid_Spawned_PARENT_Process
            else:
                bool_Job_JOB_SHELL_PID_NOT_FOUND = True
            pass
        except psutil.NoSuchProcess, psutil.AccessDenied:
            '''process has probably already ended '''
            bool_PARENT_Process_PID_Exists = False
            bool_Job_JOB_SHELL_PID_NOT_FOUND = True
            pass
        except OSError, exception_Exception:
            if sys.platform.startswith('win'):
                if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                    '''process has probably already ended '''
                    bool_PARENT_Process_PID_Exists = False
                    bool_Job_JOB_SHELL_PID_NOT_FOUND = True
                pass
            pass
        pass
        
        pass        

        ''' Check if CHILD process PID exist and therefore JOB is still current '''
        bool_CHILD_Process_PID_Exists__Python = False
        bool_Job_JOB_PID_NOT_FOUND = False

        if self.bool_Settings_Run_BackEnd_BINARY_Executable__Default_Value:
            str_BackEnd_Executable_File = self.str_Settings_Run_BackEnd_BINARY_Executable_Name__Default_Value #Main.exe'       
        else:                 
            str_BackEnd_Executable_File = self.str_Settings_Run_Python_Executable_Name__Default_Value #python.exe'                        
        pass
        
        if bool_PARENT_Process_PID_Exists:
            if psutil_PARENT_Process != None:
                list_psutil_CHILDREN_Processes = psutil_PARENT_Process.children(recursive=True)
                int_pid_Spawned_CHILDREN_Processes_Count = 0
                for procees_Spawned_CHILD_Process in list_psutil_CHILDREN_Processes:
                    try:
                        ''' Get the PID '''
                        pid_Spawned_CHILD_Process = procees_Spawned_CHILD_Process.pid
                        ''' Check that the process still exists '''
                        bool_CHILD_Process_PID_Exists = psutil.pid_exists(pid_Spawned_CHILD_Process)
                        '''
                        -----------------------------------------------------
                        Check the process name is python
                        On Windows, if python.exe is not installed or not in the PATH environment variable...
                        an error will be thrown by "conhost.exe".
                        ------------------------------------------------------
                        ''' 
                        str_Spawned_CHILD_Process_Name = procees_Spawned_CHILD_Process.name()
                        
                        ''' If a child process exits and is python then the job has started '''
                        if bool_CHILD_Process_PID_Exists and str_Spawned_CHILD_Process_Name.lower() == str_BackEnd_Executable_File.lower():
                            bool_CHILD_Process_PID_Exists = psutil.pid_exists(pid_Spawned_CHILD_Process)
                            if bool_CHILD_Process_PID_Exists:
                                #psutil_CHILD_Process = psutil.Process(pid_Spawned_CHILD_Process)
                                int_pid_Spawned_CHILDREN_Processes_Count += 1
                                #tup_CHILD_Process_CPU_Usage = psutil_CHILD_Process.cpu_times()
                                tup_CHILD_Process_CPU_Usage = procees_Spawned_CHILD_Process.cpu_times()
                                bool_CHILD_Process_PID_Exists__Python = True
                                bool_Job_JOB_PID_NOT_FOUND = False
                                self.pid_Spawned_CHILD_Process = pid_Spawned_CHILD_Process
                            else:
                                bool_CHILD_Process_PID_Exists__Python = False
                                bool_Job_JOB_PID_NOT_FOUND = False
                            pass
                        else:
                            bool_CHILD_Process_PID_Exists = False
                            bool_Job_JOB_PID_NOT_FOUND = True
                        pass
                    except psutil.NoSuchProcess, psutil.AccessDenied:
                        '''process has probably already ended '''
                        bool_CHILD_Process_PID_Exists = False
                        bool_Job_JOB_PID_NOT_FOUND = True
                        pass  
                    except OSError, exception_Exception:
                        if sys.platform.startswith('win'):
                            if isinstance(exception_Exception, WindowsError) and exception_Exception.winerror == 299:
                                '''process has probably already ended '''
                                bool_CHILD_Process_PID_Exists = False
                                bool_Job_JOB_PID_NOT_FOUND = True
                                pass  
                            pass
                        pass
                    pass
                pass
            pass
        pass

        str_Search_Path = os__path.join(self.str_BackEnd_Working_Path, globalsDCBGen.Run_Status.static_str_Run_Status__Path)
        with FileHandler() as obj_FileOp:
            #str_Search_Path = os__path.join(self.str_Batch_Scenario_Path__Current, globalsDCBGen.Run_Status.static_str_Run_Status__Path)
            bool_Job_STATUS_PATH_FOUND = obj_FileOp.method_Path_Exists(str_Search_Path)
            if bool_Job_STATUS_PATH_FOUND:
            
                bool_Job_STATUS_PATH_NOT_FOUND = False

                '''
                -------------------------------------------
                CHECK JOB STATUS BY FILE - But only ones that have not already been detected
                -------------------------------------------
                '''
                ''' Check if job has been REQUESTED '''
                if self.int_Run_Status_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL:
                    #str_Search_Path = os__path.join(self.str_Batch_Scenario_Path__Current, globalsDCBGen.Run_Status.static_str_Run_Status__Path) 
                    str_File_Search_Pattern = '*.' + globalsDCBGen.Run_Status.static_str_Run_Status__REQUESTED
                    bool_Job_REQUESTED, list_Path_And_Files = self.func_Check_If_Files_Exist(str_Search_Path, str_File_Search_Pattern)
                    if bool_Job_REQUESTED:
                        self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__REQUESTED
                        str_Job_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_str_Run_Status__REQUESTED
                    pass
                pass
            
                ''' Check if job has been INITIATED '''
                if self.int_Run_Status_Flag__Current < globalsDCBGen.Run_Status.static_int_Run_Status__INITIATED:
                    
                    #str_Search_Path = os__path.join(self.str_BackEnd_Working_Path, globalsDCBGen.Run_Status.static_str_Run_Status__Path) 
                    str_File_Search_Pattern = '*.' + globalsDCBGen.Run_Status.static_str_Run_Status__INITIATED
                    bool_Job_INITIATED, list_Path_And_Files = self.func_Check_If_Files_Exist(str_Search_Path, str_File_Search_Pattern)
                    if bool_Job_INITIATED:
                        self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__INITIATED
                        str_Job_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_str_Run_Status__INITIATED
                    pass
                pass
            
                ''' Check if job has been STARTED '''
                if self.int_Run_Status_Flag__Current < globalsDCBGen.Run_Status.static_int_Run_Status__STARTED:
                    
                    #str_Search_Path = os__path.join(self.str_BackEnd_Working_Path, globalsDCBGen.Run_Status.static_str_Run_Status__Path) 
                    str_File_Search_Pattern = '*.' + globalsDCBGen.Run_Status.static_str_Run_Status__STARTED
                    bool_Job_STARTED, list_Path_And_Files = self.func_Check_If_Files_Exist(str_Search_Path, str_File_Search_Pattern)
                    if bool_Job_STARTED:
                        self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__STARTED
                        str_Job_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_str_Run_Status__STARTED
                    pass
                    ''' Get the run id from the filename '''
                    if bool_Job_STARTED and self.str_BackEnd_Run_UID__STARTED == '':
                        if len(list_Path_And_Files) == 1:
                            str_BackEnd_Run_UID__Path_And_File = list_Path_And_Files[0]
                            str_BackEnd_Run_UID__Path_And_File_WO_Ext, str_BackEnd_Run_UID__Ext = os__path.splitext(str_BackEnd_Run_UID__Path_And_File)
                            _, self.str_BackEnd_Run_UID__STARTED = os__path.split(str_BackEnd_Run_UID__Path_And_File_WO_Ext)
                            
                        else:
                            str_Message_Text = 'Job status error. Cannot determine Run UID. More than one job status file exists of search pattern: ' + str_File_Search_Pattern + '; on path: ' + str_Search_Path + '; files found : \n' + '\n'.join(list_Path_And_Files)
                            int_Stack_Trace_Level = 2
                            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
                            pass   
                        pass                     
                    pass           
                pass
                 
                ''' Check if job has ENDED '''
                if self.int_Run_Status_Flag__Current < globalsDCBGen.Run_Status.static_int_Run_Status__ENDED:
                    str_Search_Path = os__path.join(self.str_BackEnd_Working_Path, globalsDCBGen.Run_Status.static_str_Run_Status__Path) 
                    str_File_Search_Pattern = '*.' + globalsDCBGen.Run_Status.static_str_Run_Status__ENDED
                    bool_Job_ENDED, list_Path_And_Files = self.func_Check_If_Files_Exist(str_Search_Path, str_File_Search_Pattern)
                    if bool_Job_ENDED:
                        self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__ENDED
                        str_Job_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_str_Run_Status__ENDED 
                    pass               
                    ''' Get the run id from the filename '''
                    if bool_Job_ENDED and self.str_BackEnd_Run_UID__ENDED == '':
                        if len(list_Path_And_Files) == 1:
                            str_BackEnd_Run_UID__Path_And_File = list_Path_And_Files[0]
                            str_BackEnd_Run_UID__Path_And_File_WO_Ext, str_BackEnd_Run_UID__Ext = os__path.splitext(str_BackEnd_Run_UID__Path_And_File)
                            _, self.str_BackEnd_Run_UID__ENDED = os__path.split(str_BackEnd_Run_UID__Path_And_File_WO_Ext)
                            
                        else:
                            str_Message_Text = 'Job status error. Cannot determine Run UID. More than one job status file exists of search pattern: ' + str_File_Search_Pattern + '; on path: ' + str_Search_Path + '; files found : \n' + '\n'.join(list_Path_And_Files)
                            int_Stack_Trace_Level = 2
                            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
                            pass   
                        pass                     
                    pass 
                pass

                '''
                -------------------------------------------
                CHECK JOB STATUS BY FILE - ALWAYS check for these Job Run Statuses 
                -------------------------------------------
                '''
                ''' Check if job has FAILED_CAUGHT '''
                str_File_Search_Pattern = '*.' + globalsDCBGen.Run_Status.static_str_Run_Status__FAILED_CAUGHT
                bool_Job_FAILED_CAUGHT, list_Path_And_Files = self.func_Check_If_Files_Exist(str_Search_Path, str_File_Search_Pattern)
                if bool_Job_FAILED_CAUGHT:
                    self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                    str_Job_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_str_Run_Status__FAILED_CAUGHT
                pass                
            
                ''' Check if job has FAILED_UNCAUGHT '''
                str_File_Search_Pattern = '*.' + globalsDCBGen.Run_Status.static_str_Run_Status__FAILED_UNCAUGHT
                bool_Job_FAILED_UNCAUGHT, list_Path_And_Files = self.func_Check_If_Files_Exist(str_Search_Path, str_File_Search_Pattern)
                if bool_Job_FAILED_UNCAUGHT:
                    self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                    str_Job_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_str_Run_Status__FAILED_UNCAUGHT
                pass                        
            
            else:
                bool_Job_STATUS_PATH_NOT_FOUND = True
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
            pass
        pass
   
   
        if bool_Job_STATUS_PATH_NOT_FOUND:
            self.bool_Job_Status__Terminated = True
            self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__STATUS_PATH_NOT_FOUND
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, 'JOB_SHELL PID: ' + str(self.int_Process_JOB_SHELL__PID) + '; Job Termination Flag : ' + str(self.bool_Job_Status__Terminated) + '; Reason: ' + self.str_Job_Status__Terminated_Reason) 
            #DEBUG_OFF
            ''' Record job status in BATCH_SETTINGS file '''
            str_Job_Run_Status_Flag__Current = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED 
            self.func_Run_Job__Record_Job_Status(str_Job_Run_Status_Flag__Current)
            self.func_Run_Job__Check_Job_Termination_Status()
            return False
        pass
    
        if bool_Job_FAILED_CAUGHT:
            self.bool_Job_Status__Terminated = True
            self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__FAILED_CAUGHT
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, 'JOB_SHELL PID: ' + str(self.int_Process_JOB_SHELL__PID) + '; Job Termination Flag : ' + str(self.bool_Job_Status__Terminated) + '; Reason: ' + self.str_Job_Status__Terminated_Reason) 
            #DEBUG_OFF
            ''' Record job status in BATCH_SETTINGS file '''
            str_Job_Run_Status_Flag__Current = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED 
            self.func_Run_Job__Record_Job_Status(str_Job_Run_Status_Flag__Current)
            self.func_Run_Job__Check_Job_Termination_Status()            
            return False
        pass
    
        if bool_Job_FAILED_UNCAUGHT:
            self.bool_Job_Status__Terminated = True
            self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__FAILED_UNCAUGHT
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, 'JOB_SHELL PID: ' + str(self.int_Process_JOB_SHELL__PID) + '; Job Termination Flag : ' + str(self.bool_Job_Status__Terminated) + '; Reason: ' + self.str_Job_Status__Terminated_Reason) 
            #DEBUG_OFF
            ''' Record job status in BATCH_SETTINGS file '''
            str_Job_Run_Status_Flag__Current = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED 
            self.func_Run_Job__Record_Job_Status(str_Job_Run_Status_Flag__Current)
            self.func_Run_Job__Check_Job_Termination_Status()            
            return False
        pass

        if bool_Job_ENDED:
            self.bool_Job_Status__Terminated = True
            self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__ENDED
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, 'JOB_SHELL PID: ' + str(self.int_Process_JOB_SHELL__PID) + '; Job Termination Flag : ' + str(self.bool_Job_Status__Terminated) + '; Reason: ' + self.str_Job_Status__Terminated_Reason) 
            #DEBUG_OFF
            ''' Record job status in BATCH_SETTINGS file '''
            str_Job_Run_Status_Flag__Current = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED 
            self.func_Run_Job__Record_Job_Status(str_Job_Run_Status_Flag__Current)
            self.func_Run_Job__Check_Job_Termination_Status()            
            return False
        pass

    
        if not self.bool_Job_Status__Terminated:
            if not bool_PARENT_Process_PID_Exists:
                self.bool_Job_Status__Terminated = True
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_SHELL_PID_NOT_FOUND
                #DEBUG_ON
                self.func_Debug_Logging(False, 2, 'JOB_SHELL PID: ' + str(self.int_Process_JOB_SHELL__PID) + '; Job Termination Flag : ' + str(self.bool_Job_Status__Terminated) + '; Reason: ' + self.str_Job_Status__Terminated_Reason) 
                #DEBUG_OFF      
                ''' Record job status in BATCH_SETTINGS file '''
                str_Job_Run_Status_Flag__Current = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED 
                self.func_Run_Job__Record_Job_Status(str_Job_Run_Status_Flag__Current)
                self.func_Run_Job__Check_Job_Termination_Status()
                return False
            pass
        pass
            
        if not self.bool_Job_Status__Terminated:
            if not bool_CHILD_Process_PID_Exists__Python:
                self.bool_Job_Status__Terminated = True
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_PID_NOT_FOUND
                #DEBUG_ON
                self.func_Debug_Logging(False, 2, 'JOB_SHELL PID: ' + str(self.int_Process_JOB_SHELL__PID) + '; Job Termination Flag : ' + str(self.bool_Job_Status__Terminated) + '; Reason: ' + self.str_Job_Status__Terminated_Reason) 
                #DEBUG_OFF
                ''' Record job status in BATCH_SETTINGS file '''
                str_Job_Run_Status_Flag__Current = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED 
                self.func_Run_Job__Record_Job_Status(str_Job_Run_Status_Flag__Current) 
                self.func_Run_Job__Check_Job_Termination_Status()               
                return False
            pass
        pass
    
        ''' Record job status in BATCH_SETTINGS file '''
        self.func_Run_Job__Record_Job_Status(str_Job_Run_Status_Flag__Current)
        self.func_Run_Job__Check_Job_Termination_Status()

        return bool_Success, self.bool_Job_Status__Terminated, self.str_Job_Status__Terminated_Reason            

    def func_Run_Job__Check_Job_Termination_Status(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, 'Checking job termination status. Terminated?: ' + str(self.bool_Job_Status__Terminated))
        #DEBUG_OFF
                
        if self.bool_Job_Status__Terminated:
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, 'JOB STATUS REPORTED: TERMINATED: ' + str(self.bool_Job_Status__Terminated))
            #DEBUG_OFF

            if self.t1 != None:
                self.t1.cancel()
            pass

            ''' Enable Page widgets irrelevant of Job outcome '''
            #DEBUG_OFF
            self.func_Run_Job__Enable_Widgets_After_Run(self.toolBox.currentIndex())                         
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, 'All Widgets enabled')

            ''' Update status display '''                        
            self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            str_Job_Status__Status_Message = 'Job is reporting as ' + self.str_Job_Status__Status + ' and ' + self.str_Job_Status__Terminated_Reason
            self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, 'JOB STATUS REPORTED: ' + str_Job_Status__Status_Message)
            #DEBUG_OFF
                        
            ''' Run post-processing as appropriate '''
            ''' Check no error has occured '''
            if self.int_Run_Status_Error_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL:
                ''' Check that the job has ENDED '''
                if self.int_Run_Status_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__ENDED:
                    self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
                    str_Job_Status__Status_Message = 'Job is reporting as ' + self.str_Job_Status__Terminated_Reason + '. Post-job run proccessing is occuring...'
                    self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                    #DEBUG_ON
                    self.func_Debug_Logging(False, 2, 'JOB STATUS REPORTED: ' + str_Job_Status__Status_Message)
                    #DEBUG_OFF
                    self.func_Run_Job__Record_Job_Status(self.str_Job_Status__Status)                    
                    #DEBUG_ON
                    self.func_Debug_Logging(False, 2, 'JOB STATUS Recorded: ' + str_Job_Status__Status_Message)
                    #DEBUG_OFF                    
                    bool_Success = self.func_Job_Results_Processing()

                    #DEBUG_ON
                    self.func_Debug_Logging(False, 2, 'self.func_Job_Results_Processing() = ' + str(bool_Success))
                    #DEBUG_OFF 
                                       
                    if bool_Success:
                        if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
                            self.int_Run_Status_Flag__Current__Scenario = globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED
                        elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT:
                            self.int_Run_Status_Flag__Current__Sampling_Strategy = globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED
                        pass
                        self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED
                        self.str_Job_Status__Terminated_Reason = globalsDCBGen.Run_Status.static_str_Run_Status__COMPLETED
                        self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
                        str_Job_Status__Status_Message = 'Post-job run proccessing has completed. Job now ' + self.str_Job_Status__Terminated_Reason + '. You can review the results now.'
                        self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                        #DEBUG_ON
                        self.func_Debug_Logging(False, 2, 'JOB STATUS REPORTED: ' + str_Job_Status__Status_Message)
                        #DEBUG_OFF                        
                        self.func_Run_Job__Record_Job_Status(self.str_Job_Status__Status)
                        #DEBUG_ON
                        self.func_Debug_Logging(False, 2, 'JOB STATUS Recorded: ' + str_Job_Status__Status_Message)
                        #DEBUG_OFF
                        self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex(), False)
                        #DEBUG_ON
                        self.func_Debug_Logging(False, 2, 'Selected Widgets enabled')
                        #DEBUG_OFF
                        self.int_Edit_Warning_Count__All_Batch_Scenario_Params = 0
                        self.int_Edit_Warning_Count__All_Sampling_Strategy_Params = 0
                        #DEBUG_ON
                        self.func_Debug_Logging(False, 2, 'Re-set Group Edit Warning Counters')
                        #DEBUG_OFF
                        ''' Zero the Edit Warning Count '''
                        qWidget = self.horizontalSlider_31
                        str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_USER_ZERO_EDIT_WARNING_COUNT__OBJECT_SPECIFIC
                        self.func_Set_Parameter_Status(qWidget, str_Parameter_Status) 
                        ''' Zero the Edit Warning Count '''
                        qWidget = self.spinBox_24
                        str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_USER_ZERO_EDIT_WARNING_COUNT__OBJECT_SPECIFIC
                        self.func_Set_Parameter_Status(qWidget, str_Parameter_Status) 
                        #DEBUG_ON
                        self.func_Debug_Logging(False, 2, 'Zero the MaxAge Edit Warning Count')
                        #DEBUG_OFF
                        self.bool_Job_Status__Complete = True
                    pass                        
                pass
            else:
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
                str_Job_Status__Status_Message = 'Job has FAILED. Please re-run. Job is reporting as ' + self.str_Job_Status__Status + ' and ' + self.str_Job_Status__Terminated_Reason
                self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)

                #DEBUG_OFF
                self.func_Enable_Widgets__QToolBox__MainToolBox(self.toolBox.currentIndex(), False)
                #DEBUG_ON
                self.func_Debug_Logging(False, 2, 'Selected Widgets enabled')
                #DEBUG_OFF
            pass                
        else:
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, 'JOB Status reported: Not terminated.  RE-Starting Job monitor (PID) ' + str(self.int_Process_JOB_SHELL__PID))
            #DEBUG_OFF
            
            self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__IN_PROGRESS
            str_Job_Status__Status_Message = 'Job is reporting as ' + self.str_Job_Status__Status + ' and ' + self.str_Job_Status__Terminated_Reason + '. Monitoring...'
            self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
            
            self.func_Run_Job__Monitor_Job(self.int_Process_JOB_SHELL__PID)
        pass

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, 'JOB TERMINATION STATUS CHECK FINISHED')
        #DEBUG_OFF 
                 
        return True  

    def func_Run_Job__Record_Job_Status(self, str_Job_Run_Status_Flag__Current): 

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        bool_Success = False
        
        '''
        ------------------------------------------
        UPDATE files with Job Run Status
        ------------------------------------------
        '''       
        if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:

            '''
            ----------------------------------------------
            Update BATCH SETTINGS File
            ----------------------------------------------
            '''
            
            obj_Config =  self.obj_Config_Batch_Settings
            
            dict_Section_Key_Option_Value_Tuple = OrderedDict()

            ''' >>>>>>>>> Batch_Scenario_Run_Details '''
            str_Section = obj_Config.static_str_Section__Batch_Setting_Last_Batch_Scenario_Run_Details
            list_tup_Option_Value = []
    
            ''' Backend Run UID '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_UID
            value_Option = self.str_Batch_Setting_Last_Batch_Scenario_Run_UID = self.str_BackEnd_Run_UID__STARTED
            list_tup_Option_Value.append((str_Option, value_Option))
                        
            ''' Job status '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_Job_Status
            value_Option = self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status = str_Job_Run_Status_Flag__Current     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job status after termination '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason
            value_Option = self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason = self.str_Job_Status__Terminated_Reason     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job run SHELL PID '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_Shell_PID
            value_Option = self.int_Batch_Setting_Last_Batch_Scenario_Run_Shell_PID = self.pid_Spawned_PARENT_Process     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job run python PID '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_Python_PID
            value_Option = self.int_Batch_Setting_Last_Batch_Scenario_Run_Python_PID = self.pid_Spawned_CHILD_Process     
            list_tup_Option_Value.append((str_Option, value_Option))

            ''' Update the config parser '''
            dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
            obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
            
            ''' Write to the config file '''
            str_Config_Relative_Path_File = self.str_Batch_Settings_Relative_Path_And_File__Current
            str_Config_FULL_Path_File = os__path.join(self.str_Application_Projects_Path, str_Config_Relative_Path_File)
            bool_Success = obj_Config.func_Write_Config_File(obj_Config.config_parser_Config, str_Config_FULL_Path_File)
        pass

        if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT:

            '''
            ----------------------------------------------
            Update BATCH SETTINGS File
            ----------------------------------------------
            '''
            obj_Config =  self.obj_Config_Batch_Settings
            
            dict_Section_Key_Option_Value_Tuple = OrderedDict()

            ''' >>>>>>>>> Sampling_Strategy_Run_Details '''
            str_Section = obj_Config.static_str_Section__Batch_Setting_Last_Sampling_Strategy_Run_Details
            list_tup_Option_Value = []
                
            ''' Backend Run UID '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_UID
            value_Option = self.str_Batch_Setting_Last_Sampling_Strategy_Run_UID = self.str_BackEnd_Run_UID__STARTED     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job status '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_Job_Status
            value_Option = self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status = str_Job_Run_Status_Flag__Current     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job status after termination '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason
            value_Option = self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason = self.str_Job_Status__Terminated_Reason     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job run SHELL PID '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_Shell_PID
            value_Option = self.int_Batch_Setting_Last_Sampling_Strategy_Run_Shell_PID = self.pid_Spawned_PARENT_Process     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job run python PID '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_Python_PID
            value_Option = self.int_Batch_Setting_Last_Sampling_Strategy_Run_Python_PID = self.pid_Spawned_CHILD_Process     
            list_tup_Option_Value.append((str_Option, value_Option))

            ''' Update the config parser '''            
            dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
            obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
            
            ''' Write to the BATCH SETTINGS config file '''
            str_Config_Relative_Path_File = self.str_Batch_Settings_Relative_Path_And_File__Current
            str_Config_FULL_Path_File = os__path.join(self.str_Application_Projects_Path, str_Config_Relative_Path_File)
            bool_Success = obj_Config.func_Write_Config_File(obj_Config.config_parser_Config, str_Config_FULL_Path_File)

            '''
            ----------------------------------------------
            Update SAMPLING STRATEGY File
            ----------------------------------------------
            '''
            obj_Config =  self.obj_Config_Sampling_Strategy

            dict_Section_Key_Option_Value_Tuple = OrderedDict()
            
            ''' >>>>>>>>> Sampling_Strategy_Run_Details '''
            str_Section = obj_Config.static_str_Section__Sampling_Strategy_Last_Run_Details
            list_tup_Option_Value = []
                
            ''' Backend Run UID '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_UID
            value_Option = self.str_Sampling_Strategy_Last_Run_UID = self.str_BackEnd_Run_UID__STARTED     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job status '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Job_Status
            value_Option = self.str_Sampling_Strategy_Last_Run_Job_Status = str_Job_Run_Status_Flag__Current     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job status after termination '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason
            value_Option = self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason = self.str_Job_Status__Terminated_Reason     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job run SHELL PID '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Shell_PID
            value_Option = self.int_Sampling_Strategy_Last_Run_Shell_PID = self.pid_Spawned_PARENT_Process     
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job run python PID '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Python_PID
            value_Option = self.int_Sampling_Strategy_Last_Run_Python_PID = self.pid_Spawned_CHILD_Process     
            list_tup_Option_Value.append((str_Option, value_Option))

            ''' Update the config parser '''            
            dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
            obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
            
            ''' Write to the config file '''
            str_Config_Relative_Path_File = self.str_Sampling_Strategy_Relative_Path_And_File__Current
            str_Config_FULL_Path_File = os__path.join(self.str_Application_Projects_Path, str_Config_Relative_Path_File)
            bool_Success = obj_Config.func_Write_Config_File(obj_Config.config_parser_Config, str_Config_FULL_Path_File)

        pass
        
        return bool_Success

    def func_Run_Job__Job_Status_Change__User_Edits_Force_Rerun__Batch_Scenario(self):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        bool_Success = False
        
        obj_Config = self.obj_Config_Batch_Settings
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Batch_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
# 
#         '''
#         ---------------------------------------------------
#         Remove unwanted SECTIONS & OPTIONS from config
#         ---------------------------------------------------
#         '''
#         ''' >>>>>>>>> Batch_Scenario_Run_Details '''
#         str_Section = obj_Config.static_str_Section__Batch_Setting_Last_Batch_Scenario_Run_Details
#         bool_Success = obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)

        self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__USER_EDITS_FORCE_RERUN
        self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__USER_EDITS_FORCE_RERUN
        self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
        self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__USER_EDITS_FORCE_RERUN
        self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED

        self.int_Run_Status_Flag__Current__Scenario = globalsDCBGen.Run_Status.static_int_Run_Status__USER_EDITS_FORCE_RERUN
        str_Job_Run_Status_Flag__Current = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED

        '''
        ----------------------------------------------
        Update BATCH SETTINGS File
        ----------------------------------------------
        '''
        
        dict_Section_Key_Option_Value_Tuple = OrderedDict()

        ''' >>>>>>>>> Batch_Scenario_Run_Details '''
        str_Section = obj_Config.static_str_Section__Batch_Setting_Last_Batch_Scenario_Run_Details
        list_tup_Option_Value = []

        ''' Job status '''
        str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_Job_Status
        value_Option = self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status = str_Job_Run_Status_Flag__Current     
        list_tup_Option_Value.append((str_Option, value_Option))
        
        ''' Job status after termination '''
        str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason
        value_Option = self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason = self.str_Job_Status__Terminated_Reason     
        list_tup_Option_Value.append((str_Option, value_Option))
        
        ''' Update the config parser '''
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
        obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_From_Dict(obj_Config.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
        
        ''' Write to the config file '''
        str_Config_Relative_Path_File = self.str_Batch_Settings_Relative_Path_And_File__Current
        str_Config_FULL_Path_File = os__path.join(self.str_Application_Projects_Path, str_Config_Relative_Path_File)
        bool_Success = obj_Config.func_Write_Config_File(obj_Config.config_parser_Config, str_Config_FULL_Path_File)
    
        return bool_Success

    def func_Run_Job__Job_Status_Change__User_Edits_Force_Rerun__Sampling_Strategy(self):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        bool_Success = False

        '''
        ----------------------------------------------
        Update the Current BATCH SETTINGS File
        ----------------------------------------------
        '''
                
        obj_Config_Batch_Settings = self.obj_Config_Batch_Settings
        
        if obj_Config_Batch_Settings == None:
            str_Message_Text = 'self.obj_Config_Batch_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        if obj_Config_Batch_Settings.config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Settings.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass

#         self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__USER_EDITS_FORCE_RERUN
#         self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__USER_EDITS_FORCE_RERUN
#         self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
#         self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__USER_EDITS_FORCE_RERUN
#         self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED

        self.int_Run_Status_Flag__Current__Sampling_Strategy = globalsDCBGen.Run_Status.static_int_Run_Status__USER_EDITS_FORCE_RERUN

        self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__USER_EDITS_FORCE_RERUN
        self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED

        
        dict_Section_Key_Option_Value_Tuple = OrderedDict()

        ''' >>>>>>>>> Batch_Setting_Last_Sampling_Strategy_Run_Details '''
        str_Section = obj_Config_Batch_Settings.static_str_Section__Batch_Setting_Last_Sampling_Strategy_Run_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config_Batch_Settings.func_Check_If_Config_File_SECTION_Exists(obj_Config_Batch_Settings.config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, write the options '''
        if bool_Section_Exists:
        
            list_tup_Option_Value = []
    
            ''' Job status '''
            str_Option = obj_Config_Batch_Settings.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_Job_Status
            value_Option = self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job status after termination '''
            str_Option = obj_Config_Batch_Settings.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason
            value_Option = self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Update the config parser '''
            dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
            obj_Config_Batch_Settings.config_parser_Config = obj_Config_Batch_Settings.func_Set_Values_in_Config_File_From_Dict(obj_Config_Batch_Settings.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
            
            ''' Write to the config file '''
            str_Config_Relative_Path_File = self.str_Batch_Settings_Relative_Path_And_File__Current
            str_Config_FULL_Path_File = os__path.join(self.str_Application_Projects_Path, str_Config_Relative_Path_File)
            bool_Success = obj_Config_Batch_Settings.func_Write_Config_File(obj_Config_Batch_Settings.config_parser_Config, str_Config_FULL_Path_File)
        else:
            bool_Success = True
        pass

        '''
        ----------------------------------------------
        Update current SAMPLING_STRATEGY File
        ----------------------------------------------
        '''

        obj_Config_Sampling_Strategy = self.obj_Config_Sampling_Strategy
        
        if obj_Config_Sampling_Strategy == None:
            str_Message_Text = 'self.obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass            

        if obj_Config_Sampling_Strategy.config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass
    
        bool_Success = False

        dict_Section_Key_Option_Value_Tuple = OrderedDict()

        ''' >>>>>>>>> Sampling_Strategy_Run_Details '''
        str_Section = obj_Config_Sampling_Strategy.static_str_Section__Sampling_Strategy_Last_Run_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config_Batch_Settings.func_Check_If_Config_File_SECTION_Exists(obj_Config_Sampling_Strategy.config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, write the options '''
        if bool_Section_Exists:
        
            list_tup_Option_Value = []
    
            ''' Job status '''
            str_Option = obj_Config_Sampling_Strategy.static_str_Option__Sampling_Strategy_Last_Run_Job_Status
            value_Option = self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status    
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Job status after termination '''
            str_Option = obj_Config_Sampling_Strategy.static_str_Option__Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason
            value_Option = self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason
            list_tup_Option_Value.append((str_Option, value_Option))
            
            ''' Update the config parser '''
            dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
            obj_Config_Sampling_Strategy.config_parser_Config = obj_Config_Sampling_Strategy.func_Set_Values_in_Config_File_From_Dict(obj_Config_Sampling_Strategy.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
        
            ''' Write to the config file '''
            str_Config_Relative_Path_File = self.str_Sampling_Strategy_Relative_Path_And_File__Current
            str_Config_FULL_Path_File = os__path.join(self.str_Application_Projects_Path, str_Config_Relative_Path_File)
            bool_Success = obj_Config_Sampling_Strategy.func_Write_Config_File(obj_Config_Sampling_Strategy.config_parser_Config, str_Config_FULL_Path_File)
        else:
            bool_Success = True
        pass
    
        bool_Propergate_Job_Status_To_All_SS_Files = False
        if bool_Propergate_Job_Status_To_All_SS_Files:

            '''
            ----------------------------------------------
            Need to get the Sampling Strategy filenames (if they exist) from Batch Scenario
            ----------------------------------------------
            '''
            obj_Config_Batch_Scenario = self.obj_Config_Batch_Scenario
            
            if obj_Config_Batch_Scenario == None:
                str_Message_Text = 'self.obj_Config_Batch_Scenario = None'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                return False
            pass            
    
            if obj_Config_Batch_Scenario.config_parser_Config == None:
                str_Message_Text = 'obj_Config_Batch_Scenario.config_parser_Config = None'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                return False
            pass
        
            '''NOTE: Need to get the Sampling Strategy filenames (if they exist) from Batch Scenario '''
            if bool_Success:
                list_Sampling_Strategy_Files, _ = self.func_Get_Config_File_List_Of_SAMPLING_STRATEGIES_from_BATCH_SCENARIO(obj_Config_Batch_Scenario)
            pass

            '''
            ----------------------------------------------
            Update associated SAMPLING_STRATEGY Files
            ----------------------------------------------
            '''
    
            if bool_Success:
                bool_Success = False
                if len(list_Sampling_Strategy_Files) > 0:
                    for str_Sampling_Strategy_File_Relative_Path_And_Name__To_Update in list_Sampling_Strategy_Files:
                        bool_Success = False
                        ''' Read the Sampling Strategy file '''
                        obj_Config_Sampling_Strategy = object_SSConfigSamplingStrategy()
                        obj_Config_Sampling_Strategy = self.func_Read_Config_File(str_Sampling_Strategy_File_Relative_Path_And_Name__To_Update, obj_Config_Sampling_Strategy, True)
                        
                        if obj_Config_Sampling_Strategy == None:
                            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
                            int_Stack_Trace_Level = 2
                            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                            return False
                        pass            
                
                        if obj_Config_Sampling_Strategy.config_parser_Config == None:
                            str_Message_Text = 'obj_Config_Sampling_Strategy.config_parser_Config = None'
                            int_Stack_Trace_Level = 2
                            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                            return False
                        else:
                            bool_Success = True
                        pass                    
                        
                        if bool_Success:
                            bool_Success = False
    
                            dict_Section_Key_Option_Value_Tuple = OrderedDict()
                    
                            ''' >>>>>>>>> Sampling_Strategy_Run_Details '''
                            str_Section = obj_Config_Sampling_Strategy.static_str_Section__Sampling_Strategy_Last_Run_Details
                            ''' Check if SECTION exists in config file '''
                            bool_Section_Exists = obj_Config_Batch_Settings.func_Check_If_Config_File_SECTION_Exists(obj_Config_Sampling_Strategy.config_parser_Config, str_Section)
                            '''Its OK if the SECTION does not exist, however if the SECTION exists, write the options '''
                            if bool_Section_Exists:
                            
                                list_tup_Option_Value = []
                        
                                ''' Job status '''
                                str_Option = obj_Config_Sampling_Strategy.static_str_Option__Sampling_Strategy_Last_Run_Job_Status
                                value_Option = self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status    
                                list_tup_Option_Value.append((str_Option, value_Option))
                                
                                ''' Job status after termination '''
                                str_Option = obj_Config_Sampling_Strategy.static_str_Option__Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason
                                value_Option = self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason
                                list_tup_Option_Value.append((str_Option, value_Option))
                                
                                ''' Update the config parser '''
                                dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value
                                obj_Config_Sampling_Strategy.config_parser_Config = obj_Config_Sampling_Strategy.func_Set_Values_in_Config_File_From_Dict(obj_Config_Sampling_Strategy.config_parser_Config, dict_Section_Key_Option_Value_Tuple)
                            
                                ''' Write to the config file '''
                                str_Config_Relative_Path_File = str_Sampling_Strategy_File_Relative_Path_And_Name__To_Update
                                str_Config_FULL_Path_File = os__path.join(self.str_Application_Projects_Path, str_Config_Relative_Path_File)
                                bool_Success = obj_Config_Sampling_Strategy.func_Write_Config_File(obj_Config_Sampling_Strategy.config_parser_Config, str_Config_FULL_Path_File)
                            else:
                                bool_Success = True
                            pass
                        else:
                            bool_Success = True
                        pass  
    
                    pass
                else:
                    bool_Success = True
                pass
            pass
        pass
    
        return bool_Success


    def func_Run_Job__Display_Job_Status_RETIRE(self, str_Job_Status__Status_Message, int_Destination):
        
    
        if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
            self.lineEdit_14.setText(str_Job_Status__Status_Message)
        elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT:
            self.lineEdit_15.setText(str_Job_Status__Status_Message)
        else:
            self.lineEdit_14.setText(str_Job_Status__Status_Message)
            self.lineEdit_15.setText(str_Job_Status__Status_Message)
        pass
                                     
    def func_Run_Job__Display_Job_Status(self, str_Job_Status__Status_Message, int_Destination):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
            
        if int_Destination == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
            self.lineEdit_14.setText(str_Job_Status__Status_Message)
        elif int_Destination == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT:
            self.lineEdit_15.setText(str_Job_Status__Status_Message)
        else:
            self.lineEdit_14.setText(str_Job_Status__Status_Message)
            self.lineEdit_15.setText(str_Job_Status__Status_Message)
        pass
                                     
            
        return True
    
 
    '''
    -------------------------------------------------------------------------------
    BACKEND JOB - Results Processing Post-BackEnd Job Run
    -------------------------------------------------------------------------------
    '''  
    def func_Job_Results_Processing(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        #DEBUG_ON
        #self.int_Run_Status_Error_Flag__Current =  globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
        #self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__ENDED
        #DEBUG_OFF
        
        ''' Check no Job run error has occured '''
        if self.int_Run_Status_Error_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL:
            ''' Check that the job has ENDED '''
            if self.int_Run_Status_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__ENDED:
                pass
            else:
                #DEBUG_ON
                self.func_Debug_Logging(False, 2, 'func_Job_Results_Processing cannot be run. Inappropriate run status flag' + str(self.int_Run_Status_Error_Flag__Current) + '; Job Termination Flag : ' + str(self.bool_Job_Status__Terminated) + '; Reason: ' + self.str_Job_Status__Terminated_Reason) 
                #DEBUG_OFF             
                return False
            pass
        else:
            #DEBUG_ON
            self.func_Debug_Logging(False, 2, 'func_Job_Results_Processing cannot be run. Inappropriate run status flag' + str(self.int_Run_Status_Error_Flag__Current) + '; Job Termination Flag : ' + str(self.bool_Job_Status__Terminated) + '; Reason: ' + self.str_Job_Status__Terminated_Reason) 
            #DEBUG_OFF             
            return False
        pass
        
        str_BackEnd_Results_Path = ''
        str_FrontEnd_Results_Path = ''

        bool_Files_Found = False
        list_Path_And_Files = []
        str_Path_And_File__Out = ''
        list_Captions = []
        list_Path_And_Thumbs = []

        #DEBUG_ON
        #self.int_Job_Run_Current_Processing_Step = 0
        #DEBUG_OFF
                    
        ''' Get the results from the job run UID folder '''
        if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
            #DEBUG_ON
            #self.str_BackEnd_Working_Path = 'C:\\DCB\\MUI\\MUI_Sync_Controlled\\MUI_SC_SharkSim\\v3_03\\BS_20151212135009'
            #self.str_BackEnd_Run_UID__ENDED = 'SS_3_03_Run_2016_01_26_10_39_07'
            #DEBUG_OFF
            str_BackEnd_Results_Path = os__path.join(self.str_BackEnd_Working_Path, self.str_BackEnd_Run_UID__ENDED)
            str_FrontEnd_Results_Path = os__path.join(self.str_Batch_Scenario_Path__Current, self.str_Settings_Run_Results_Folder_Prefix__Default_Value + '_' + self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current))

            str_File_Copy_Pattern = '*' + globalsSS.Excel_Results_File_Details.static_Excel_Colname_Prefix__AgeNe_Sim_Summarise_ALL_EOR__Summary_Results + '*'
            bool_Purge_Results = True                          
            bool_Success = self.func_Job_Results_Processing__Get_Results(str_File_Copy_Pattern, str_BackEnd_Results_Path, str_FrontEnd_Results_Path, bool_Purge_Results)
            
        elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT:
            #DEBUG_ON
            #self.str_BackEnd_Working_Path = 'C:\\DCB\\MUI\\MUI_Sync_Controlled\\MUI_SC_SharkSim\\v3_03\\BS_20151212135009'
            #self.str_BackEnd_Run_UID__ENDED = 'SS_3_03_Run_2016_01_26_11_49_35'
            #DEBUG_OFF
            #_, str_Sampling_Strategy_File__Current = os__path.split(self.str_Sampling_Strategy_Path_And_File__Current)

            #str_Sampling_Strategy_File_Name__Current, _ = os__path.splitext(self.str_Sampling_Strategy_File__Current)
            #str_BackEnd_Results_Path = os__path.join(self.str_BackEnd_Working_Path, str_Sampling_Strategy_File_Name__Current, self.str_BackEnd_Run_UID__ENDED) 
            
            str_BackEnd_Results_Path = os__path.join(self.str_BackEnd_Working_Path, self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str(self.int_Sampling_Strategy_UID__Current), self.str_BackEnd_Run_UID__ENDED) 
            
            str_FrontEnd_Batch_Scenario_Folder__Current = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current)
            str_FrontEnd_Sampling_Strategy_Folder__Current = self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str(self.int_Sampling_Strategy_UID__Current)
            str_FrontEnd_Sampling_Strategy_Folder__Results = self.str_Settings_Run_Results_Folder_Prefix__Default_Value + '_' + self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str(self.int_Sampling_Strategy_UID__Current)
            str_FrontEnd_Results_Path = os__path.join(self.str_Batch_Scenario_Path__Current, str_FrontEnd_Sampling_Strategy_Folder__Current, str_FrontEnd_Sampling_Strategy_Folder__Results)
            
            str_File_Copy_Pattern = '*' + globalsSS.Excel_Results_File_Details.static_Excel_Colname_Prefix__SAMPLING_INDIVS_Summary__Aggregate_Results + '*' 
            bool_Purge_Results = True          
            bool_Success = self.func_Job_Results_Processing__Get_Results(str_File_Copy_Pattern, str_BackEnd_Results_Path, str_FrontEnd_Results_Path, bool_Purge_Results)
            
            str_File_Copy_Pattern = '*' + globalsSS.Excel_Results_File_Details.static_Excel_Colname_Prefix__Ne2_LDNe__Summary_EOR_Results + '*'           
            bool_Purge_Results = False
            bool_Success = self.func_Job_Results_Processing__Get_Results(str_File_Copy_Pattern, str_BackEnd_Results_Path, str_FrontEnd_Results_Path, bool_Purge_Results)
            
        pass
    
        ''' Process the results '''
        
        ''' Get list for images for processing and display '''
#         if bool_Success:
#             bool_Success = False
# 
#             str_Search_Path = str_FrontEnd_Results_Path
#             str_File_Search_Pattern = '*' + os__extsep + self.str_Settings_Run_File_Extension_Image_File__Default_Value
#             bool_Files_Found, list_Path_And_Files = self.func_Check_If_Files_Exist(str_Search_Path, str_File_Search_Pattern)
#             if bool_Files_Found:
#                 bool_Success = True
#             pass
#         pass
#     
#         ''' Create a list of Captions for the images '''
#         if bool_Success:
#             if bool_Files_Found:
#                 for str_Path_And_File in list_Path_And_Files:
#                     _, str_File = os__path.split(str_Path_And_File)
#                     str_Caption = str_File
#                     list_Captions.append(str_Caption)
#                 pass
#             pass
#         pass

        if bool_Success:
            bool_Success = False    
            bool_Files_Found, list_Path_And_Files, list_Captions = self.func_Display_Results__Get_Results_Plots(str_FrontEnd_Results_Path, bool_Error_On_Files_Not_Found = True)
            bool_Success = bool_Files_Found
        pass
    
        if bool_Success:
            if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
                self.list_Path_And_Files__Batch_Scenario__Results_Plots = list(list_Path_And_Files)
                self.list_Path_And_Files__Batch_Scenario__Results_Plots_Captions = list(list_Captions)
            elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT:            
                self.list_Path_And_Files__Sampling_Strategy__Results_Plots = list(list_Path_And_Files)
                self.list_Path_And_Files__Sampling_Strategy__Results_Plots_Captions = list(list_Captions)
            pass
        pass
    
        ''' Create thumbnail images of plots '''
        if bool_Success:
            
            for str_Path_And_File__In in list_Path_And_Files:
                bool_Success = False
                
                str_Path__In, str_File__In = os__path.split(str_Path_And_File__In)
                str_File_Name__In, str_File_Ext__In = os__path.splitext(str_File__In)
                str_File_Name__Out = str_File_Name__In + '_' + globalsSSFE.App_File.static_str__App_File_Name__Thumbnail + str_File_Ext__In
                str_Path__Out =  os__path.join(str_Path__In, self.str_Settings_Run_Results_Thumbnail_Images_Folder_Prefix__Default_Value)
                str_Path_And_File__Out = os__path.join(str_Path__Out, str_File_Name__Out)
                
                bool_Success = self.func_Job_Results_Processing__Create_Plot_Thumbnail_Image(str_Path_And_File__In, str_Path_And_File__Out)
                if bool_Success:
                    list_Path_And_Thumbs.append(str_Path_And_File__Out)
                else:
                    str_Message_Text = 'Cannot create thumbnail image from: ' + str_Path_And_File__In + ' as thumbnail: ' + str_Path_And_File__Out
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                    return False
                pass
                pass
            pass            
        pass
# 
#         if self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM:
#             bool_Success = self.func_Job_Results_Processing__Scenario__Create_Results_PDF()
#             
#         elif self.int_Job_Run_Current_Processing_Step == globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT:
#             bool_Success = self.func_Job_Results_Processing__Sampling_Strategy__Create_Results_PDF()
#         pass
    
        return bool_Success
    
    def func_Job_Results_Processing__Get_Results(self, str_File_Copy_Pattern, str_BackEnd_Results_Path, str_FrontEnd_Results_Path, bool_Purge_Results):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        bool_Success = False
        
        ''' Get results from Job Run folder '''
        with FileHandler() as obj_FileOp:
            bool_Success = obj_FileOp.method_Path_Exists(str_BackEnd_Results_Path)
            
            if bool_Success:
                bool_Success = False
                #str_FrontEnd_Results_Path = os__path.join(self.str_Batch_Scenario_Path__Current, self.str_Settings_Run_Results_Folder_Prefix__Default_Value + '_' + self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current))
                
                str_Results_Path__Origin = str_BackEnd_Results_Path
                str_Results_Path__Destination = str_FrontEnd_Results_Path
                
                #bool_Success = obj_FileOp.method_Path_Exists(str_Results_Path__Destination)
                #if bool_Success:
                if bool_Purge_Results:
                    ''' Checks if path exists and deletes it and all its sub-folders '''
                    bool_Success = obj_FileOp.method_Delete_Path(str_Results_Path__Destination)
                    if not bool_Success:
                        str_Message_Text = 'Unable to delete path: ' + str_Results_Path__Destination
                        int_Stack_Trace_Level = 2
                        self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                    pass 
                pass
            
                ''' Create FrontEnd results path '''
                bool_Success = obj_FileOp.method_Create_Path(str_Results_Path__Destination)
                if not bool_Success:
                    str_Message_Text = 'Unable to create path: ' + str_Results_Path__Destination
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
                pass
                #pass
            
                ''' Copy files to FrontEnd results path '''
                bool_Success = obj_FileOp.method_Copy_Files_By_Search_Pattern(str_Results_Path__Origin, str_Results_Path__Destination, str_File_Copy_Pattern, bool_Search_SubFolders=True)
                if not bool_Success:
                    str_Message_Text = 'Unable to get result files of file pattern: ' + str_File_Copy_Pattern + '\n\nfrom origin path :\n' + str_Results_Path__Origin + '\n\nto destination path:\n'+ str_Results_Path__Destination
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
                pass
            else:
                str_Message_Text = 'Path does not exist: ' + str_BackEnd_Results_Path
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)     
            pass           
        pass
        
        return bool_Success

    def func_Job_Results_Processing__Create_Plot_Thumbnail_Image(self, str_Path_And_File__In, str_Path_And_File__Out):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        ''' Create path if it doesnt exist '''
        with FileHandler() as obj_FileOp:
            bool_Success = obj_FileOp.method_FileSystem_Prep_For_File_Save(str_Path_And_File__Out, bool_Delete=True)
            if not bool_Success:
                str_Message_Text = 'Filesystem could not be prepared for file save: ' + str_Path_And_File__Out
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                return False
            pass                                                     
        pass
                     
        tup_Size_Thumb = 384,384
        tup_Size_Thumb = 1028, 1028
        tup_Size_Thumb = 384, 384
        tup_Size_Thumb = 512, 512
        #tup_Size_Thumb = 640, 640
        #tup_Size_Thumb = 720, 720
        #tup_Size_Thumb = 1028, 1028
        try:
            image_Plot = PIL__Image.open(str_Path_And_File__In)
            image_Plot.thumbnail(tup_Size_Thumb, PIL__Image.ANTIALIAS)
            image_Plot.save(str_Path_And_File__Out, "PNG")
            bool_Success = True
        except IOError:
            str_Message_Text = 'Cannot create thumbnail image from: ' + str_Path_And_File__In + ' as thumbnail: ' + str_Path_And_File__Out
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)    
            bool_Success = False        
        pass
            
        return bool_Success
    
    def func_Check_If_File_Exists(self, str_Path_And_File):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        str_Path, str_File = os__path.split(str_Path_And_File)
        
        with FileHandler() as obj_FileOp:
            bool_Success = obj_FileOp.method_Path_Exists(str_Path)
            if bool_Success:
                bool_Success = False
                bool_Success = obj_FileOp.fileExists(str_Path_And_File)
            else:
                str_Message_Text = 'Path does not exist: ' + str_Path
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
                pass
            pass   
        pass

        return bool_Success
    
    def func_Check_If_Files_Exist(self, str_Search_Path, str_File_Search_Pattern, bool_Error_On_Files_Not_Found = True, bool_Search_Sub_Folders = True):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        bool_Files_Located = False 
        list_Path_And_ALL_Files = []
        list_Path_And_Files = []
        
        with FileHandler() as obj_FileOp:
            bool_Success = obj_FileOp.method_Path_Exists(str_Search_Path)
            if bool_Success:
                bool_Success = False

                list_Search_Paths = []
                list_Search_Paths.append(str_Search_Path)
                
                ''' Get ALL the files to plot from list of search paths '''
                with FileHandler() as obj_FileHandler:
                    bool_Files_Located = False
                    for str_Search_Path in list_Search_Paths:
                        bool_Print_Search_Result = False
                        bool_Files_Located, list_Path_And_Files = obj_FileHandler.func_Locate_Files(str_Search_Path, str_File_Search_Pattern, bool_Print_Search_Result, bool_Search_Sub_Folders)
                        list_Path_And_ALL_Files.extend(list_Path_And_Files)
                    pass
                pass
            else:
                if bool_Error_On_Files_Not_Found:
                    str_Message_Text = 'Search Path does not exist: ' + str_Search_Path
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)  
                pass
            pass   
        pass

        return bool_Files_Located, list_Path_And_Files

    def func_Display_Results__Get_Results_Plots(self, str_Results_Path, bool_Error_On_Files_Not_Found = True, bool_Search_Sub_Folders = True):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        list_Path_And_Files = []
        list_Captions = []
        
        ''' Get list for images for processing and display '''
        str_Search_Path = str_Results_Path
        str_File_Search_Pattern = '*' + os__extsep + self.str_Settings_Run_File_Extension_Image_File__Default_Value
        bool_Files_Found, list_Path_And_Files = self.func_Check_If_Files_Exist(str_Search_Path, str_File_Search_Pattern, bool_Error_On_Files_Not_Found, bool_Search_Sub_Folders)
        if bool_Files_Found:
            bool_Success = True
        pass
    
        ''' Create a list of Captions for the images '''
        if bool_Success:
            if bool_Files_Found:
                for str_Path_And_File in list_Path_And_Files:
                    _, str_File = os__path.split(str_Path_And_File)
                    str_Caption = str_File
                    list_Captions.append(str_Caption)
                pass
            pass
        pass
        
        return bool_Success, list_Path_And_Files, list_Captions
    
    '''
    -------------------------------------------------------------------------------
        Populate Widgets 
    -------------------------------------------------------------------------------
    ''' 
    def func_Populate_Widgits_With_Config_Data__PROJECT(self, str_Project_Relative_Path_And_File__Current):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.bool_Reload_Widgets_Finished__Project = False
        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False  
                
        ''' Read PROJECT file '''
        obj_Config = object_SSConfigProject()
        self.obj_Config_Project = self.func_Read_Config_File(str_Project_Relative_Path_And_File__Current, obj_Config, True)
                
        ''' Get the data from the config_parser_Config '''
        self.func_Get_Config_Data__PROJECT(self.obj_Config_Project)

        bool_Exists = self.bool_int_Project_UID__FOUND
        if bool_Exists:
            str_Text = str(self.int_Project_UID)
            
        else:
            str_Text = 'Not specified'
        pass
        self.lineEdit_25.setText(str_Text)
        
        bool_Exists = self.bool_str_Project_Species_Name__FOUND
        if bool_Exists:
            str_Text = self.str_Project_Species_Name
        else:
            str_Text = ''
        pass
        self.lineEdit_12.setText(str_Text)
        self.lineEdit_20.setText(str_Text)
        
        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False
        self.bool_Reload_Widgets_Finished__Batch_Scenario = True    
        return True

    def func_Populate_Widgits_With_Config_Data__BATCH_SETTINGS(self, str_Batch_Settings_Relative_Path_And_File__Current):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        self.bool_Reload_Widgets_Finished__Batch_Settings = False
        #self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False  

        self.str_Batch_Settings_Relative_Path_And_File__Current = str_Batch_Settings_Relative_Path_And_File__Current
        str_Batch_Settings_Relative_Path__Current, self.str_Batch_Settings_File__Current = os__path.split(str_Batch_Settings_Relative_Path_And_File__Current)
        self.str_Batch_Settings_Path_And_File__Current = os__path.join(self.str_Application_Projects_Path, str_Batch_Settings_Relative_Path_And_File__Current)
        self.str_Batch_Settings_Path__Current = os__path.join(self.str_Application_Projects_Path, str_Batch_Settings_Relative_Path__Current)
              
        ''' Read the Batch_Settings file '''
        obj_Config = object_SSConfigBatchSettings()
        #self.obj_Config_Batch_Settings = self.func_Read_Config_File(self.str_Batch_Settings_Path_And_File__Current, obj_Config) 
        self.obj_Config_Batch_Settings = self.func_Read_Config_File(os__path.join(self.str_Application_Projects_Path, self.str_Batch_Settings_Path_And_File__Current), obj_Config)              
  
        ''' Get the data from the config_parser_Config '''
        self.func_Get_Config_Data__BATCH_SETTINGS(self.obj_Config_Batch_Settings)

        self.bool_Batch_Scenario__Batch_Settings_Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED = False
        self.int_Job_Run_Current_Processing_Step = globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__POP_SIM
            
        bool_Exists = self.bool_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason__FOUND
        if bool_Exists:
            
            if self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_STATUS_REQUESTED:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_STATUS_REQUESTED
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOT_TERMINATED 
            elif self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__STATUS_PATH_NOT_FOUND:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__STATUS_PATH_NOT_FOUND
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED 
            elif self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__FAILED_CAUGHT:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__FAILED_CAUGHT
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__FAILED_UNCAUGHT:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__FAILED_UNCAUGHT
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__ENDED:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__ENDED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__ENDED
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__USER_EDITS_FORCE_RERUN:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__USER_EDITS_FORCE_RERUN
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__USER_EDITS_FORCE_RERUN
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_PID_NOT_FOUND:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_PID_NOT_FOUND
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED                    
            elif self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_SHELL_PID_NOT_FOUND:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_SHELL_PID_NOT_FOUND
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOT_TERMINATED:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__REQUESTED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOT_TERMINATED
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOT_TERMINATED
            pass  
              
            ''' Check no error has occured '''
            if self.int_Run_Status_Error_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL:
                if self.int_Run_Status_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED:
                    ''' Check that the job has COMPLETED '''
                    str_Job_Status__Status_Message = 'Post-job run proccessing has completed. Job now ' + self.str_Job_Status__Terminated_Reason + '. You can review the results now.'
                    self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                    pass  
                elif self.int_Run_Status_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__USER_EDITS_FORCE_RERUN:
                    str_Job_Status__Status_Message = 'User changed parameters. Re-run the scenario to get the simulated demographic results.' 
                    self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                    pass
                else:
                    self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                    self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                    self.bool_Batch_Scenario__Batch_Settings_Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED = False
                    str_Job_Status__Status_Message = 'Prior Job has FAILED. Please Re-run. Job is reporting as ' + self.str_Job_Status__Status + ' and ' + self.str_Job_Status__Terminated_Reason
                    self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)

                    ''' NOTE: Disabling this auto-recover from failed job for now as it can cause complications '''
                    #self.bool_Batch_Scenario__Batch_Settings_Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED = True
                    #str_Job_Status__Status_Message = 'Prior Job is INCOMPLETE but not in error. ' + ' Job is reporting as ' + self.str_Job_Status__Status + ' and ' + self.str_Job_Status__Terminated_Reason + '. Attempting to re-establish status of job...' 
                    #self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                    pass
                pass  
            else:
                str_Job_Status__Status_Message = 'Prior Job has FAILED. Please Re-run. Job is reporting as ' + self.str_Job_Status__Status + ' and ' + self.str_Job_Status__Terminated_Reason
                self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                pass
            pass  
        else:
            self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason = ''
            self.int_Run_Status_Flag__Current = 0
            self.int_Run_Status_Error_Flag__Current = 0
            self.str_Job_Status__Terminated_Reason = ''
            self.str_Job_Status__Status = ''    
                    
            str_Job_Status__Status_Message = 'Run the scenario to get the simulated demographic results'
            self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
        pass
        self.int_Run_Status_Flag__Current__Scenario = self.int_Run_Status_Flag__Current
        #self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False
        self.bool_Reload_Widgets_Finished__Batch_Settings = True    
        return True

    def func_Populate_Widgits_With_Config_Data__BATCH_SCENARIO(self, str_Batch_Scenario_Relative_Path_And_File__Current):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        ''' Reset Variables associated with the previous Batch Scenario '''
        self.bool_Reload_Widgets_Finished__Batch_Scenario = False
        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False  
        self.dict_Parameter_Status = OrderedDict()
        self.int_Edit_Warning_Count__All_Batch_Scenario_Params = 0
        self.int_Edit_Warning_Count__All_Sampling_Strategy_Params = 0
        
        self.str_Batch_Scenario_Relative_Path_And_File__Current = str_Batch_Scenario_Relative_Path_And_File__Current
        str_Batch_Scenario_Relative_Path__Current, self.str_Batch_Scenario_File__Current = os__path.split(str_Batch_Scenario_Relative_Path_And_File__Current)
        self.str_Batch_Scenario_Path_And_File__Current = os__path.join(self.str_Application_Projects_Path, str_Batch_Scenario_Relative_Path_And_File__Current)
        self.str_Batch_Scenario_Path__Current = os__path.join(self.str_Application_Projects_Path, str_Batch_Scenario_Relative_Path__Current)
        
        if len(self.list_Scenario_Files) > 0:
            if str_Batch_Scenario_Relative_Path_And_File__Current != '':        
                ''' Read BATCH SCENARIO file '''
                obj_Config = object_SSConfigBatchScenario()
                self.obj_Config_Batch_Scenario = self.func_Read_Config_File(str_Batch_Scenario_Relative_Path_And_File__Current, obj_Config, True)
            else:
                return True
            pass
        else:
            return True
        pass
        ''' Read the Batch_Scenario file '''
        ''' Get the data from the config_parser_Config '''
        self.func_Get_Config_Data__BATCH_SCENARIO(self.obj_Config_Batch_Scenario)
                
        bool_Exists = self.bool_int_Scenario_UID__FOUND
        if bool_Exists:
            str_Text = str(self.int_Batch_Scenario_UID__Current)
        else:
            str_Text = 'Not specified'
        pass
        self.lineEdit_23.setText(str_Text)


        '''
        ----------------------------
        QToolBox - Modify Scenario
        ----------------------------
        '''                  
        '''
        ----------------------------
        Tab 1 - Modify Scenario - Life history Ages & Offspring Dist
        ----------------------------
        '''
        
        bool_Exists = self.bool_int_Species_Life_History_Max_Age__FOUND
        if bool_Exists:
            self.horizontalSlider_31.setValue(self.int_Species_Life_History_Max_Age)
            #self.label_42.setText(self.str_Max_Age__Label_Text)
            qWidget = self.label_42
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)   
                     
        else:
            self.int_Species_Life_History_Max_Age = self.int_Species_Life_History_Max_Age__Default_Value 
            self.horizontalSlider_31.setValue(self.int_Species_Life_History_Max_Age__Default_Value)
            #self.label_42.setText(self.str_Max_Age__Label_Text + '*')
            qWidget = self.label_42
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)       
            ''' Also require the Age Cohort Mortality Dist to be Edited '''
            qWidget = self.pushButton_6
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)   
        pass
        self.func_Set_Associated_Slider_Range_And_Value__horizontalslider_31(self.horizontalSlider_31.value())
        self.bool_int_Species_Life_History_Max_Age__CHANGED = False
        self.int_Verify_Change__Scenario_Max_Age__Warning_Count = 0
        
        bool_Exists = self.bool_int_Species_Life_History_Max_Mating_Age__FOUND
        if bool_Exists:
            self.horizontalSlider_32.setValue(self.int_Species_Life_History_Max_Mating_Age)
            #self.label_43.setText(self.str_Max_Mating_Age__Label_Text)
            qWidget = self.label_43
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)            
        else:
            self.int_Species_Life_History_Max_Mating_Age = self.int_Species_Life_History_Max_Mating_Age__Default_Value
            self.horizontalSlider_32.setValue(self.int_Species_Life_History_Max_Mating_Age)
            #self.label_43.setText(self.str_Max_Mating_Age__Label_Text + '*')
            qWidget = self.label_43
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)              
        pass
        self.func_Set_Associated_Slider_Range_And_Value__horizontalslider_32(self.horizontalSlider_32.value())
        self.bool_int_Species_Life_History_Max_Mating_Age__CHANGED = False
        
        bool_Exists = self.bool_int_Species_Life_History_Min_Mating_Age__FOUND
        if bool_Exists:
            self.horizontalSlider_33.setValue(self.int_Species_Life_History_Min_Mating_Age)
            #self.label_44.setText(self.str_Min_Mating_Age__Label_Text)
            qWidget = self.label_44
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)            
        else:
            self.int_Species_Life_History_Min_Mating_Age = self.int_Species_Life_History_Min_Mating_Age__Default_Value
            self.horizontalSlider_33.setValue(self.int_Species_Life_History_Min_Mating_Age)
            #self.label_44.setText(self.str_Min_Mating_Age__Label_Text + '*')
            qWidget = self.label_44
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)              
        pass
        self.bool_int_Species_Life_History_Min_Mating_Age__CHANGED = False
        

        bool_Exists = self.bool_Species_Offspring_Distribution__FOUND
        if bool_Exists:
            self.func_Offspring_Distribution_Display()
            #self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text)
            #self.groupBox_19.setTitle(self.str_Species_Offspring_Distribution__Label_Text)
            qWidget = self.groupBox_19
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)            
        else:
            self.comboBox_4.setCurrentIndex(0)
            #self.stackedWidget.setCurrentIndex(0)
            #self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text + '*')
            #self.groupBox_19.setTitle(self.str_Species_Offspring_Distribution__Label_Text + '*')
            qWidget = self.groupBox_19
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)              
        pass
        self.bool_Species_Offspring_Distribution__CHANGED = False

        '''
        ----------------------------
        Tab 1 - Modify Scenario - Demography and Mortality Dist
        ----------------------------
        '''                 
        bool_Exists = self.bool_int_Population_Size__FOUND
        if bool_Exists:
            self.horizontalSlider_34.setValue(self.int_Population_Size)
            #self.label_45.setText(self.str_Population_Size__Label_Text)
            qWidget = self.label_45
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)    
        else:
            self.horizontalSlider_34.setValue(self.int_Population_Size__Default_Value)
            #self.label_45.setText(self.str_Population_Size__Label_Text + '*')
            qWidget = self.label_45
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        pass

        bool_Exists = \
            self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__FOUND and \
            self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__FOUND
        if bool_Exists:
            #self.pushButton_6.setText(self.str_Edit_Natural_Mortality_Rates__Label_Text)
            qWidget = self.pushButton_6
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)            
        else:
            #self.pushButton_6.setText(self.str_Edit_Natural_Mortality_Rates__Label_Text + '*')
            qWidget = self.pushButton_6
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                
        pass
        self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__CHANGED = False
        self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__CHANGED = False

        ''' Validate that the Mortality Dist is equivalent to the max age ''' 
        bool_Exists = \
            self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__FOUND or \
            self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__FOUND
        if bool_Exists :        
            #if self.bool_int_Species_Life_History_Max_Age__FOUND:
            int_Len_dict__MALE = len(self.dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE)
            int_Len_dict__FEMALE = len(self.dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE)
            if (int_Len_dict__MALE != self.int_Species_Life_History_Max_Age) or (int_Len_dict__FEMALE != self.int_Species_Life_History_Max_Age): 
                ''' If the dist doesnt match the MAxAGe, force the user to update it '''
                qWidget = self.pushButton_6
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
            pass
        pass               
        '''
        ----------------------------
        Tab 1 - Modify Scenario - Genetics 
        ----------------------------
        '''    
        bool_Exists = self.bool_int_Genome_Locus_Number__FOUND
        if bool_Exists:
            self.horizontalSlider_38.setValue(self.int_Genome_Locus_Number)
            #self.label_8.setText(self.str_Genome_Locus_Number__Label_Text)
            qWidget = self.label_8
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)
        else:
            self.int_Genome_Locus_Number = self.int_Genome_Locus_Number__Default_Value
            self.horizontalSlider_38.setValue(self.int_Genome_Locus_Number__Default_Value)
            #self.label_8.setText(self.str_Genome_Locus_Number__Label_Text + '*')
            qWidget = self.label_8
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)            
        pass
        self.bool_int_Genome_Locus_Number__CHANGED = False
        
        ''' Set the Range of the Sampling Strategy Locus Max based on the Total number of loci available for sampling '''
        self.spinBox_44.setRange(self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value, self.int_Genome_Locus_Number) 
        self.horizontalSlider_52.setRange(self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value, self.int_Genome_Locus_Number) 
        #self.horizontalSlider_52.setValue(self.int_Sampling_Strategy_Locus_Range_Max__Default_Value)         
        ''' Set the Range of the Sampling Strategy Locus Increment '''
        self.spinBox_45.setRange(1, self.int_Sampling_Strategy_Locus_Range_Max) 
        self.horizontalSlider_53.setRange(1, self.int_Sampling_Strategy_Locus_Range_Max) 
        #self.horizontalSlider_53.setValue(int_Range_Min)        
        
        bool_Exists = self.bool_Genome_Alleles_Per_Locus_Distribution__FOUND
        if bool_Exists:
            self.func_Genome_Alleles_Per_Locus_Distribution_Display()
            #self.groupBox_23.setTitle(self.str_Genome_Alleles_Per_Locus_Distribution__Label_Text)
            qWidget = self.groupBox_23
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)            
        else:
            self.comboBox_5.setCurrentIndex(0)
            #self.stackedWidget_4.setCurrentIndex(0)
            #self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text + '*')
            qWidget = self.groupBox_23
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)            
        pass
        self.bool_Genome_Alleles_Per_Locus_Distribution__CHANGED = False
        self.bool_int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__CHANGED = False        
        self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__CHANGED = False
        self.bool_float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__CHANGED = False
        
        
                
        bool_Exists = self.bool_Genome_Allele_Frequency_Distribution__FOUND
        if bool_Exists:
            self.func_Genome_Allele_Frequency_Distribution_Display()
            #self.groupBox_24.setTitle(self.str_Genome_Allele_Frequency_Distribution__Label_Text)
            qWidget = self.groupBox_24
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        else:
            self.comboBox_6.setCurrentIndex(0)
            #self.stackedWidget_4.setCurrentIndex(0)
            #self.label_38.setText(self.str_Species_Offspring_Distribution__Label_Text + '*')
            qWidget = self.groupBox_24
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)            
        pass
        self.bool_Genome_Allele_Frequency_Distribution__CHANGED = False
        
        

        '''
        ----------------------------
        QToolBox - Run Scenario
        ----------------------------
        '''                  
        '''
        ----------------------------
        Tab 1 - Run Scenario - Simulation length
        ----------------------------
        '''        
        bool_Exists = self.bool_int_Simulation_Batch_Replicates__FOUND
        if bool_Exists:
            self.horizontalSlider_45.setValue(self.int_Simulation_Batch_Replicates)
            #self.label_58.setText(self.str_Simulation_Batch_Replicates__Label_Text)
            qWidget = self.label_58
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        else:
            self.horizontalSlider_45.setValue(self.int_Simulation_Batch_Replicates__Default_Value)
            #self.label_58.setText(self.str_Simulation_Batch_Replicates__Label_Text + '*')
            qWidget = self.label_58
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)              
        pass
        self.bool_int_Simulation_Batch_Replicates__CHANGED - False
        
        bool_Exists = self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__FOUND
        if bool_Exists:
            self.horizontalSlider_46.setValue(self.int_Simulation_Batch_Replicate_Length_Burn_In)
            qWidget = self.label_59
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             

        else:
            ''' Defaults have been set based on MaxAge so dont set Default '''
            #self.horizontalSlider_46.setValue(self.int_Simulation_Batch_Replicate_Length_Burn_In__Default_Value)
            qWidget = self.label_59
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)              
        pass
        self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__CHANGED = False
        
        bool_Exists = self.bool_int_Simulation_Batch_Replicate_Length_Temporal_Evolution__FOUND
        if bool_Exists:
            self.horizontalSlider_47.setValue(self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution)
            qWidget = self.label_60
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             

        else:
            ''' Defaults have been set based on MaxAge so dont set Default '''
            #self.horizontalSlider_47.setValue(self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Default_Value)
            qWidget = self.label_60
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)              
        pass
        self.bool_int_Simulation_Batch_Replicate_Length_Temporal_Evolution__CHANGED = False

        ''' Set the ranges of associated sliders '''
        self.func_Set_SIM_LENGTH_Slider_Range_And_Value__horizontalslider_31()
        
#         bool_Exists = self.bool_str_Scenario_Run_Simulation_Output_Base_Path__FOUND 
#         if self.bool_str_Scenario_Run_Simulation_Output_Base_Path__FOUND:
#             self.lineEdit_16.setText(self.str_Scenario_Run_Simulation_Output_Base_Path)
#         else:
#             self.str_Scenario_Run_Simulation_Output_Base_Path = ''
#             self.lineEdit_16.setText('Please specify')
#         pass
#         self.bool_str_Scenario_Run_Simulation_Output_Base_Path__CHANGED = False

        bool_Exists = self.bool_str_Scenario_Run_Simulation_Working_Base_Path__FOUND 
        if self.bool_str_Scenario_Run_Simulation_Working_Base_Path__FOUND:
            self.lineEdit_16.setText(self.str_Scenario_Run_Simulation_Working_Base_Path)
            qWidget = self.label_31
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        else:
            
#             str_Start_Path = self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value
#             if str_Start_Path != '':
#                 with FileHandler() as obj_FileOp:
#                     bool_Success = obj_FileOp.method_Path_Exists(str_Start_Path)
#                     if bool_Success:
#                         self.str_Scenario_Run_Simulation_Working_Base_Path = self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value
#                         self.lineEdit_16.setText(self.str_Scenario_Run_Simulation_Working_Base_Path)
#                         qWidget = self.label_31
#                         str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
#                         self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                         
#                     else:
#                         #str_Start_Path = os__path.expanduser('~')
#                         self.str_Scenario_Run_Simulation_Working_Base_Path = ''
#                         self.lineEdit_16.setText('Please specify')
#                         qWidget = self.label_31
#                         str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT
#                         self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                        
#                     pass
#                 pass
            self.str_Scenario_Run_Simulation_Working_Base_Path = self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value
            self.lineEdit_16.setText(self.str_Scenario_Run_Simulation_Working_Base_Path)
            qWidget = self.label_31
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)                         
            pass            
              
        pass
        self.bool_str_Scenario_Run_Simulation_Working_Base_Path__CHANGED = False
        _, str_Batch_Scenario_Relative_Path__Current_WO_Project = os__path.split(str_Batch_Scenario_Relative_Path__Current)
        self.str_Scenario_Run_Simulation_Output_Base_Path = os__path.join(self.str_Scenario_Run_Simulation_Working_Base_Path, str_Batch_Scenario_Relative_Path__Current_WO_Project)
        self.bool_str_Scenario_Run_Simulation_Output_Base_Path__CHANGED = False
        
        self.func_Enable_Widgets__Tab__Batch_Scenario()
        
        self.bool_CHANGED_fields_are_unsaved__Project_And_Scenario = False
        self.bool_Reload_Widgets_Finished__Batch_Scenario = True    
        
        self.func_Populate_Widgits_With_Config_Data__BATCH_SETTINGS(self.str_Batch_Settings_Relative_Path_And_File)
        
        return True

    def func_Populate_Widgits_With_Config_Data__SAMPLING_STRATEGY(self, str_Sampling_Strategy_Relative_Path_And_File__Current):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        ''' Reset Variables associated with the previous Batch Scenario '''
        self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False  
        self.bool_Reload_Widgets_Finished__Sampling_Strategy = False
        self.int_Edit_Warning_Count__All_Sampling_Strategy_Params = 0
        
        dict_Parameter_Status_New = OrderedDict()

        ''' Rebuild the dict_Parameter_Status withought the previous Sampling Strategy objects '''
        for key, dict_Value in self.dict_Parameter_Status.items():
            if globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Status in dict_Value.keys():
                
                str_Parameter_Status = dict_Value[globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Status]
                
                if str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT or \
                   str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER or \
                   str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_USER_ADD_EDIT_WARNING_COUNT__OBJECT_SPECIFIC or \
                   str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_USER_ZERO_EDIT_WARNING_COUNT__OBJECT_SPECIFIC:
                    ''' Leave out this item '''
                    pass
                else:
                    ''' This is not a Sampling Strategy item, so keep it '''
                    dict_Parameter_Status_New[key] = OrderedDict(dict_Value)
            else:
                ''' This is not a Sampling Strategy item, so keep it '''
                dict_Parameter_Status_New[key] = OrderedDict(dict_Value)
            pass       
        pass
    
        self.dict_Parameter_Status = OrderedDict(dict_Parameter_Status_New)      
        
        self.str_Sampling_Strategy_Relative_Path_And_File__Current = str_Sampling_Strategy_Relative_Path_And_File__Current
        str_Sampling_Strategy_Relative_Path__Current, self.str_Sampling_Strategy_File__Current = os__path.split(str_Sampling_Strategy_Relative_Path_And_File__Current)
        self.str_Sampling_Strategy_Path_And_File__Current = os__path.join(self.str_Application_Projects_Path, str_Sampling_Strategy_Relative_Path_And_File__Current)
        self.str_Sampling_Strategy_Path__Current = os__path.join(self.str_Application_Projects_Path, str_Sampling_Strategy_Relative_Path__Current)
                
        if len(self.list_Sampling_Strategy_Files) > 0:
            if str_Sampling_Strategy_Relative_Path_And_File__Current != '':        
                ''' Read SAMPLING STRATEGY file '''
                obj_Config = object_SSConfigSamplingStrategy()
                self.obj_Config_Sampling_Strategy = self.func_Read_Config_File(str_Sampling_Strategy_Relative_Path_And_File__Current, obj_Config, True)
            else:
                return True
            pass
        else:
            return True
        pass        
    
        ''' Get the data from the config_parser_Config '''
        self.func_Get_Config_Data__SAMPLING_STRATEGY(self.obj_Config_Sampling_Strategy)

        bool_Exists = self.bool_int_Sampling_Strategy_UID__FOUND
        if bool_Exists:
            str_Text = str(self.int_Sampling_Strategy_UID__Current)
        else:
            str_Text = 'Not specified'
        pass
        self.lineEdit_24.setText(str_Text)


        '''
        ----------------------------
        QToolBox - Modify Sampling Strategy
        ----------------------------
        '''   
        '''
        ----------------------------
        Modify Sampling Strategy - Sample Size 
        ----------------------------
        '''
        bool_Exists = self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND
        if bool_Exists:
            self.horizontalSlider_48.setValue(self.int_Sampling_Strategy_Sample_Range_Min)
            #self.label_61.setText(self.str_int_Sampling_Strategy_Sample_Range_Min__Label_Text)
            qWidget = self.label_61
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)               
        else:
            self.horizontalSlider_48.setValue(self.int_Sampling_Strategy_Sample_Range_Min__Default_Value)
            #self.label_61.setText(self.str_int_Sampling_Strategy_Sample_Range_Min__Label_Text + '*')
            qWidget = self.label_61
            ''' NOTE: IF MIN IS ENABLED CHANGE THIS STATUS TO SS_REQUIRES_USER_EDIT '''
            #str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        pass
        self.bool_int_Sampling_Strategy_Sample_Range_Min__CHANGED = False
        
        bool_Exists = self.bool_int_Sampling_Strategy_Sample_Range_Max__FOUND
        if bool_Exists:
            
            self.horizontalSlider_49.setValue(self.int_Sampling_Strategy_Sample_Range_Max)
            #self.label_62.setText(self.str_int_Sampling_Strategy_Sample_Range_Max__Label_Text)
            qWidget = self.label_62
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)               
        else:
            self.int_Sampling_Strategy_Sample_Range_Max = self.int_Sampling_Strategy_Sample_Range_Max__Default_Value
            self.horizontalSlider_49.setValue(self.int_Sampling_Strategy_Sample_Range_Max)
            #self.horizontalSlider_49.setValue(self.int_Sampling_Strategy_Sample_Range_Max__Default_Value)
            #self.label_62.setText(self.str_int_Sampling_Strategy_Sample_Range_Max__Label_Text + '*')
            qWidget = self.label_62
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        pass
        self.bool_int_Sampling_Strategy_Sample_Range_Max__CHANGED = False
        
        bool_Exists = self.bool_int_Sampling_Strategy_Sample_Range_Increment__FOUND
        if bool_Exists:
            self.horizontalSlider_50.setValue(self.int_Sampling_Strategy_Sample_Range_Increment)
            #self.label_63.setText(self.str_int_Sampling_Strategy_Sample_Range_Increment__Label_Text)
            qWidget = self.label_63
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)      
        else:
            self.int_Sampling_Strategy_Sample_Range_Increment = self.int_Sampling_Strategy_Sample_Range_Increment__Default_Value
            self.horizontalSlider_50.setValue(self.int_Sampling_Strategy_Sample_Range_Increment)
            #self.label_63.setText(self.str_int_Sampling_Strategy_Sample_Range_Increment__Label_Text + '*')
            qWidget = self.label_63
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        pass
        self.bool_int_Sampling_Strategy_Sample_Range_Increment__CHANGED = False

        '''
        ----------------------------
        Set the Ranges and Values of associated widgets
        ----------------------------
        '''
#         ''' Set the ranges for related sliders '''
#         self.func_Set_Associated_Sliders_Range_And_Value__Scenario__Population_Size(self.int_Population_Size)
#         
        '''
        ----------------------------
        Modify Sampling Strategy - Locus Number
        ----------------------------
        '''    
        bool_Exists = self.bool_int_Sampling_Strategy_Locus_Range_Min__FOUND
        if bool_Exists:
            self.horizontalSlider_51.setValue(self.int_Sampling_Strategy_Locus_Range_Min)
            #self.label_64.setText(self.str_int_Sampling_Strategy_Locus_Range_Min__Label_Text)
            qWidget = self.label_64
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)               
        else:
            self.horizontalSlider_51.setValue(self.int_Sampling_Strategy_Locus_Range_Min__Default_Value)
            #self.label_64.setText(self.str_int_Sampling_Strategy_Locus_Range_Min__Label_Text + '*')
            qWidget = self.label_64
            ''' NOTE: IF MIN IS ENABLED CHANGE THIS STATUS TO SS_REQUIRES_USER_EDIT '''
            #str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        pass
        self.bool_int_Sampling_Strategy_Locus_Range_Min__CHANGED = False
        
        bool_Exists = self.bool_int_Sampling_Strategy_Locus_Range_Increment__FOUND
        if bool_Exists:
            self.horizontalSlider_53.setValue(self.int_Sampling_Strategy_Locus_Range_Increment)
            #self.label_66.setText(self.str_int_Sampling_Strategy_Locus_Range_Increment__Label_Text)
            qWidget = self.label_66
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)               
        else:
            self.horizontalSlider_53.setValue(self.int_Sampling_Strategy_Locus_Range_Increment__Default_Value)
            #self.label_66.setText(self.str_int_Sampling_Strategy_Locus_Range_Increment__Label_Text + '*')
            qWidget = self.label_66
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        pass
        self.bool_int_Sampling_Strategy_Locus_Range_Increment__CHANGED = False

        bool_Exists = self.bool_int_Sampling_Strategy_Locus_Range_Max__FOUND
        if bool_Exists:
            self.horizontalSlider_52.setValue(self.int_Sampling_Strategy_Locus_Range_Max)
            #self.label_65.setText(self.str_int_Sampling_Strategy_Locus_Range_Max__Label_Text)
            qWidget = self.label_65
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)      
            pass         
        else:
            self.int_Sampling_Strategy_Locus_Range_Max = self.int_Sampling_Strategy_Locus_Range_Max__Default_Value
            self.horizontalSlider_52.setValue(self.int_Sampling_Strategy_Locus_Range_Max)
            #self.label_65.setText(self.str_int_Sampling_Strategy_Locus_Range_Max__Label_Text + '*')
            qWidget = self.label_65
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        pass
        self.bool_int_Sampling_Strategy_Locus_Range_Max__CHANGED = False

        '''
        ----------------------------
        Set the Ranges and Values of associated widgets
        ----------------------------
        '''
        ''' Set the ranges for related sliders '''
        self.func_Set_Associated_Sliders_Range_And_Value__Scenario__Genome_Locus_Number(self.int_Genome_Locus_Number)
        self.func_Change__Sampling_Strategy_Locus_Range_Max(self.int_Sampling_Strategy_Locus_Range_Max)
        self.func_Set_Associated_Sliders_Range_And_Value__Scenario__Population_Size(self.int_Population_Size)
        self.func_Change__Sampling_Strategy_Sample_Range_Max(self.int_Sampling_Strategy_Sample_Range_Max)        
        '''
        ----------------------------
        Modify Sampling Strategy - Sampling Distribution
        ----------------------------
        '''  
        bool_Exists = self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__FOUND or \
                      self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion__FOUND or \
                      self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number__FOUND or \
                      self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__FOUND
        if bool_Exists:
            qWidget = self.pushButton_15
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)               
        else:
            qWidget = self.pushButton_15
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        pass
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__CHANGED = False
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion__CHANGED = False
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number__CHANGED = False
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__CHANGED = False

        '''
        ----------------------------
        Modify Sampling Strategy - Simulation length 
        ----------------------------
        '''        
        bool_Exists = self.bool_int_Sampling_Strategy_LDNe_Replicates__FOUND
        if bool_Exists:
            self.horizontalSlider_54.setValue(self.int_Sampling_Strategy_LDNe_Replicates)
            #self.label_67.setText(self.str_int_Sampling_Strategy_LDNe_Replicates__Label_Text)
            qWidget = self.label_67
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)               
        else:
            self.horizontalSlider_54.setValue(self.int_Sampling_Strategy_LDNe_Replicates__Default_Value)
            #self.label_67.setText(self.str_int_Sampling_Strategy_LDNe_Replicates__Label_Text + '*')
            qWidget = self.label_67
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status) 
        pass
        self.bool_int_Sampling_Strategy_LDNe_Replicates__CHANGED = False
        
        bool_Exists = self.bool_str_Sampling_Strategy_LDNe_PCrit_To_Get__FOUND
        if bool_Exists:
            self.comboBox_13.blockSignals(True)
            self.func_Sampling_Strategy_LDNe_PCrit_To_Get_Display()
            self.comboBox_13.blockSignals(False)
            #self.label_28.setText(self.str_str_Sampling_Strategy_LDNe_PCrit_To_Get__Label_Text)
            qWidget = self.label_28
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)               
        else:
            self.comboBox_13.setCurrentIndex(0)
            #self.stackedWidget.setCurrentIndex(0)
            #self.label_28.setText(self.str_str_Sampling_Strategy_LDNe_PCrit_To_Get__Label_Text + '*')
            qWidget = self.label_28
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
        pass
        self.bool_str_Sampling_Strategy_LDNe_PCrit_To_Get__CHANGED = False
        
#         bool_Exists = self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__FOUND  
#         if self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__FOUND:
#             self.lineEdit_17.setText(self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path)
#         else:
#             self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path  = ''
#             self.lineEdit_17.setText('Please specify')     
#         pass        
#     

        bool_SS_Path_Same_As_BS_Path = True
        if bool_SS_Path_Same_As_BS_Path:
            self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path = self.str_Scenario_Run_Simulation_Working_Base_Path
            self.lineEdit_17.setText(self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path)
            qWidget = self.label_32
            str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
            self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)           
        else:
            bool_Exists = self.bool_str_Sampling_Strategy_Run_Simulation_Working_Base_Path__FOUND  
            if self.bool_str_Sampling_Strategy_Run_Simulation_Working_Base_Path__FOUND:
                self.lineEdit_17.setText(self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path)
                qWidget = self.label_32
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)               
            else:
                self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path  = ''
                self.lineEdit_17.setText('Please specify')     
                qWidget = self.label_32
                str_Parameter_Status = globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT
                self.func_Set_Parameter_Status(qWidget, str_Parameter_Status)             
            pass
        pass
        self.bool_str_Sampling_Strategy_Run_Simulation_Working_Base_Path__CHANGED = False
        #_, str_Sampling_Strategy_Relative_Path__Current_WO_Project = os__path.split(str_Sampling_Strategy_Relative_Path__Current)
        #self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path = os__path.join(self.str_Scenario_Run_Simulation_Working_Base_Path, str_Sampling_Strategy_Relative_Path__Current_WO_Project)
        self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path = self.str_Scenario_Run_Simulation_Output_Base_Path
        self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__CHANGED = False        
        
        
        self.bool_Sampling_Strategy__Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED = False
        self.int_Job_Run_Current_Processing_Step = globalsSS.Run_Processing_Step.static_int_Run_Processing_Step__SAMP_STRAT
            
        bool_Exists = self.bool_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason__FOUND
        if bool_Exists:
            
            if self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_STATUS_REQUESTED:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_STATUS_REQUESTED
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOT_TERMINATED 
            elif self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__STATUS_PATH_NOT_FOUND:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__STATUS_PATH_NOT_FOUND
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED 
            elif self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__FAILED_CAUGHT:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__FAILED_CAUGHT
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__FAILED_UNCAUGHT:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__FAILED_UNCAUGHT
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__ENDED:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__ENDED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__ENDED
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__COMPLETED
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__USER_EDITS_FORCE_RERUN:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__USER_EDITS_FORCE_RERUN
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__USER_EDITS_FORCE_RERUN
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_PID_NOT_FOUND:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_PID_NOT_FOUND
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED                    
            elif self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_SHELL_PID_NOT_FOUND:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__JOB_SHELL_PID_NOT_FOUND
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__TERMINATED
            elif self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason == globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOT_TERMINATED:
                self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__REQUESTED
                self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL
                self.str_Job_Status__Terminated_Reason = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOT_TERMINATED
                self.str_Job_Status__Status = globalsDCBGen.Job_Status_Flag.static_str_Job_Status_Flags__NOT_TERMINATED
            pass
        
            ''' Check no error has occured '''
            if self.int_Run_Status_Error_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__NOMINAL:
                if self.int_Run_Status_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__COMPLETED:
                    ''' Check that the job has COMPLETED '''
                    str_Job_Status__Status_Message = 'Post-job run proccessing has completed. Job now ' + self.str_Job_Status__Terminated_Reason + '. You can review the results now.'
                    self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                    pass  
                elif self.int_Run_Status_Flag__Current == globalsDCBGen.Run_Status.static_int_Run_Status__USER_EDITS_FORCE_RERUN:
                    str_Job_Status__Status_Message = 'User changed parameters. Re-run the scenario to get the simulated demographic results.' 
                    self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                    pass
                else:
                    self.int_Run_Status_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED
                    self.int_Run_Status_Error_Flag__Current = globalsDCBGen.Run_Status.static_int_Run_Status__FAILED                    
                    self.bool_Sampling_Strategy__Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED = False
                    str_Job_Status__Status_Message = 'Prior Job has FAILED. Please Re-run. Job is reporting as ' + self.str_Job_Status__Status + ' and ' + self.str_Job_Status__Terminated_Reason
                    self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)

                    ''' NOTE: Disabling this auto-recover from failed job for now as it can cause complications '''
                    #self.bool_Sampling_Strategy__Run_Status__Prior_Job_INCOMPLETE_And_NOT_FAILED = True
                    #str_Job_Status__Status_Message = 'Prior Job is INCOMPLETE but not in error. ' + ' Job is reporting as ' + self.str_Job_Status__Status + ' and ' + self.str_Job_Status__Terminated_Reason + '. Attempting to re-establish status of job...' 
                    #self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                    pass
                pass  
            else:
                str_Job_Status__Status_Message = 'Prior Job has FAILED. Please Re-run. Job is reporting as ' + self.str_Job_Status__Status + ' and ' + self.str_Job_Status__Terminated_Reason
                self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
                pass
            pass  
        else:
            self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason = ''
            self.int_Run_Status_Flag__Current = 0
            self.int_Run_Status_Error_Flag__Current = 0
            self.str_Job_Status__Terminated_Reason = ''
            self.str_Job_Status__Status = ''    

            str_Job_Status__Status_Message = 'Run a Sampling_Strategy to get the simulated sampling results'
            self.func_Run_Job__Display_Job_Status(str_Job_Status__Status_Message, self.int_Job_Run_Current_Processing_Step)
        pass
        self.int_Run_Status_Flag__Current__Sampling_Strategy = self.int_Run_Status_Flag__Current
        self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False  
        self.bool_Reload_Widgets_Finished__Sampling_Strategy = True

        return True

    def func_Set_Parameter_Status(self, qWidget, str_Parameter_Status):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        if qWidget is not None:
            ''' Get the widget type '''
            str_Object_Name = str(qWidget.objectName())
            ''' Get the wodget name '''
            str_Object_Type = type(qWidget)
            bool_Success = True
        else:
            bool_Success = False
        pass
    
        if bool_Success:
            if str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT or \
               str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT or \
               str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER or \
               str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER:            
                bool_Success = False
                if isinstance(qWidget, QtGui.QGroupBox):
                    str_Object_Label = str(qWidget.title())
                    bool_Success = True
                elif isinstance(qWidget, QtGui.QLabel):
                    str_Object_Label = str(qWidget.text())
                    bool_Success = True
                elif isinstance(qWidget, QtGui.QPushButton):
                    str_Object_Label = str(qWidget.text())
                    bool_Success = True
                pass
            pass
        pass
    
        if bool_Success:
            bool_Change_Label = False
            if str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT or \
                str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT:
                if globalsSSFE.Parameter_Status.static_str__Parameter_Status__FLAG__REQUIRES_USER_EDIT in str_Object_Label:
                    ''' Already flagged as requiring edit '''
                    bool_Change_Label = False
                else:
                    str_Object_Label = str_Object_Label + globalsSSFE.Parameter_Status.static_str__Parameter_Status__FLAG__REQUIRES_USER_EDIT
                    bool_Change_Label = True
                pass
            elif str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER or \
                str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER:
                if globalsSSFE.Parameter_Status.static_str__Parameter_Status__FLAG__REQUIRES_USER_EDIT in str_Object_Label:
                    ''' Remove flag '''
                    str_Object_Label = str_Object_Label.replace(globalsSSFE.Parameter_Status.static_str__Parameter_Status__FLAG__REQUIRES_USER_EDIT,'')
                    bool_Change_Label = True
                else:
                    bool_Change_Label = False
                pass            
            pass
        pass
    
        ''' Change label '''
        if bool_Success and bool_Change_Label:
            bool_Success = False
            if isinstance(qWidget, QtGui.QGroupBox):
                qWidget.setTitle(str_Object_Label)
                bool_Success = True
            elif isinstance(qWidget, QtGui.QLabel):
                qWidget.setText(str_Object_Label)
                bool_Success = True
            elif isinstance(qWidget, QtGui.QPushButton):
                qWidget.setText(str_Object_Label)
                bool_Success = True
            pass
        pass
        
        ''' Record the parameter status '''
        if bool_Success:
            if str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT or \
               str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT or \
               str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER or \
               str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER:
                ''' Update the Edit Status '''
                if str_Object_Name in self.dict_Parameter_Status:
                    self.dict_Parameter_Status[str_Object_Name].update(OrderedDict([(globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Label, str_Object_Label)]))
                else:
                    self.dict_Parameter_Status[str_Object_Name] = OrderedDict([(globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Label, str_Object_Label)])
                pass
                #self.dict_Parameter_Status[str_Object_Name].update(OrderedDict([(globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Status, str_Parameter_Status)]))
            elif str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_USER_ADD_EDIT_WARNING_COUNT__OBJECT_SPECIFIC or \
                str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_USER_ADD_EDIT_WARNING_COUNT__OBJECT_SPECIFIC:            
                ''' Update the OBJECT_SPECIFIC Edit Warning Count '''
                if str_Object_Name in self.dict_Parameter_Status:
                    int_Edit_Warning_Count__Object_Specific = self.dict_Parameter_Status[str_Object_Name][globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Edit_Warning_Count__Object_Specific]
                    int_Edit_Warning_Count__Object_Specific += 1
                    self.dict_Parameter_Status[str_Object_Name].update(OrderedDict([(globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Edit_Warning_Count__Object_Specific, int_Edit_Warning_Count__Object_Specific)]))
                else:
                    int_Edit_Warning_Count__Object_Specific = 1
                    self.dict_Parameter_Status[str_Object_Name] = OrderedDict([(globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Edit_Warning_Count__Object_Specific, int_Edit_Warning_Count__Object_Specific)])
                pass
            elif str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_USER_ZERO_EDIT_WARNING_COUNT__OBJECT_SPECIFIC or \
                str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_USER_ZERO_EDIT_WARNING_COUNT__OBJECT_SPECIFIC:            
                ''' Update the OBJECT_SPECIFIC Edit Warning Count '''
                if str_Object_Name in self.dict_Parameter_Status:
                    int_Edit_Warning_Count__Object_Specific = 0
                    self.dict_Parameter_Status[str_Object_Name].update(OrderedDict([(globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Edit_Warning_Count__Object_Specific, int_Edit_Warning_Count__Object_Specific)]))
                else:
                    int_Edit_Warning_Count__Object_Specific = 0
                    self.dict_Parameter_Status[str_Object_Name] = OrderedDict([(globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Edit_Warning_Count__Object_Specific, int_Edit_Warning_Count__Object_Specific)])
                pass
            pass

            ''' Update the Status '''
            if str_Object_Name in self.dict_Parameter_Status:
                self.dict_Parameter_Status[str_Object_Name].update(OrderedDict([(globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Status, str_Parameter_Status)]))
            else:
                self.dict_Parameter_Status[str_Object_Name] = OrderedDict([(globalsSSFE.Parameter_Status.static_str__Parameter_Status__Key__Status, str_Parameter_Status)])
            pass        
            
        pass
    
        if bool_Success:
            if str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_REQUIRES_USER_EDIT or \
               str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_REQUIRES_USER_EDIT or \
               str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__BS_EDITED_BY_USER or \
               str_Parameter_Status == globalsSSFE.Parameter_Status.static_str__Parameter_Status__SS_EDITED_BY_USER:

                self.func_Enable_Widgets__Tab__Batch_Scenario()
            pass
        pass
    
        return bool_Success
    
    def func_Enable_Widgets__Tab__Batch_Scenario(self):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF

        bool_Enable_1 = \
            (self.bool_int_Species_Life_History_Max_Age__FOUND or self.bool_int_Species_Life_History_Max_Age__CHANGED) and \
            (self.bool_int_Species_Life_History_Max_Mating_Age__FOUND or self.bool_int_Species_Life_History_Max_Mating_Age__CHANGED) and \
            (self.bool_int_Species_Life_History_Min_Mating_Age__FOUND or self.bool_int_Species_Life_History_Min_Mating_Age__CHANGED) and \
            (self.bool_Species_Offspring_Distribution__FOUND or self.bool_Species_Offspring_Distribution__CHANGED)
        
        if bool_Enable_1:
            self.tabWidget_3.setTabEnabled(1, True)
        else:
            self.tabWidget_3.setTabEnabled(1, False)
        pass
        
        bool_Enable_2 = \
            (self.bool_int_Population_Size__FOUND or self.bool_int_Population_Size__CHANGED) and \
            (self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__FOUND or self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__CHANGED) and \
            (self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__FOUND or self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__CHANGED)        
        
        if bool_Enable_1 and bool_Enable_2:
            self.tabWidget_3.setTabEnabled(2, True)
        else:
            self.tabWidget_3.setTabEnabled(2, False)
        pass
        
        return True
    
    '''
    -------------------------------------------------------------------------------
        Config data & file handling
    -------------------------------------------------------------------------------
    '''    
    def func_Get_Config_Data__SETTINGS(self, obj_Config_Settings):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        obj_Config = obj_Config_Settings
        
        if obj_Config == None:
            str_Message_Text = 'obj_Config_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False  
        pass         
    
        config_parser_Config = obj_Config.config_parser_Config
    
        if config_parser_Config == None:
            str_Message_Text = 'config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass    
                
        ''' <<<<<<< SECTION: Settings_Run_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Settings_Run_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass   
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_App_Version
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_App_Version__Default_Value = value_Option
            pass            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_App_Name
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_App_Name__Default_Value = value_Option
            pass  
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_FrontEnd_DEBUG_Show_Settings_Menu
            value_Type = False
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.bool_Settings_Run_FrontEnd_DEBUG_Show_Settings_Menu__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_FrontEnd_DEBUG_Logging
            value_Type = False
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.bool_Settings_Run_FrontEnd_DEBUG_Logging__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_FrontEnd_FirstTime
            value_Type = False
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.bool_Settings_Run_FirstTime = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_FrontEnd_Job_Run_Monitor_Job_Status_Time_Delay_Secs
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Settings_Run_FrontEnd_Job_Run_Monitor_Job_Status_Time_Delay_Secs__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_FrontEnd_Job_Run_Monitor_Job_Termination_Status_Time_Delay_Secs
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Settings_Run_FrontEnd_Job_Run_Monitor_Job_Termination_Status_Time_Delay_Secs__Default_Value = value_Option
            pass
     
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Config_Folder
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Config_Folder__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Docs_Folder
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Docs_Folder__Default_Value = value_Option
            pass        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Projects_Folder
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Projects_Folder__Default_Value = value_Option
            pass        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Project_Folder_Prefix
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Project_Folder_Prefix__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Batch_Scenario_Folder_Prefix
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Sampling_Strategy_Folder_Prefix
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Results_Folder_Prefix
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Results_Folder_Prefix__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Results_Plots_Folder_Prefix
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Results_Plots_Folder_Prefix__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Results_Thumbnail_Images_Folder_Prefix
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Results_Thumbnail_Images_Folder_Prefix__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_File_Extension_Config_File
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_File_Extension_Config_File__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_File_Extension_Image_File
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_File_Extension_Image_File__Default_Value = value_Option
            pass
      
  
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Use_Relative_Paths
            value_Type = False
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.bool_Settings_Run_Use_Relative_Paths__Default_Value = value_Option
            pass
            if self.bool_Settings_Run_Use_Relative_Paths__Default_Value:
                ''' GET THE CURRENT FRONTEND EXECUTABLE PATH '''
#                 self.str_App_Run_Path_And_File = __file__
#                 self.str_App_Run_Path, self.str_App_Run_File = os__path.split(self.str_App_Run_Path_And_File)
                
                self.str_Settings_Run_FrontEnd_Path__Default_Value = self.str_Application_Working_Path #self.str_App_Run_Path

                ''' Specify OPTION to get '''
                str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_Relative_Path
                value_Type = ''
                ''' Read the OPTION if it exists in config file '''
                bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
                if bool_Option_Exists:
                    self.str_Settings_Run_BackEnd_Relative_Path__Default_Value = value_Option
                    #self.str_Settings_Run_BackEnd_Path__Default_Value = os__path.join(self.str_App_Run_Path, value_Option)
                    self.str_Settings_Run_BackEnd_Path__Default_Value = os__path.join(self.str_Application_Working_Path, value_Option)
                pass
                ''' Specify OPTION to get '''
                str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_Working_Relative_Path
                value_Type = ''
                ''' Read the OPTION if it exists in config file '''
                bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
                if bool_Option_Exists:
                    self.str_Settings_Run_BackEnd_Working_Base_Relative_Path__Default_Value = value_Option
                    #self.str_BackEnd_Working_Path = self.str_BackEnd_Working_Base_Path
                    #self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value = os__path.join(self.str_App_Run_Path, value_Option)
                    self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value = os__path.join(self.str_Application_Working_Path, value_Option)
                pass
                ''' Specify OPTION to get '''
                str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_BINARY_Executable_Relative_Path
                value_Type = ''
                ''' Read the OPTION if it exists in config file '''
                bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
                if bool_Option_Exists:
                    self.str_Settings_Run_BackEnd_BINARY_Executable_Relative_Path__Default_Value = value_Option
                    #self.str_Settings_Run_BackEnd_BINARY_Executable_Path__Default_Value = os__path.join(self.str_App_Run_Path, value_Option)
                    self.str_Settings_Run_BackEnd_BINARY_Executable_Path__Default_Value = os__path.join(self.str_Application_Working_Path, value_Option)
                pass
            else:
                ''' Specify OPTION to get '''
                str_Option = obj_Config.static_str_Option__Settings_Run_FrontEnd_Path
                value_Type = ''
                ''' Read the OPTION if it exists in config file '''
                bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
                if bool_Option_Exists:
                    self.str_Settings_Run_FrontEnd_Path__Default_Value = value_Option
                pass
                ''' Specify OPTION to get '''
                str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_Path
                value_Type = ''
                ''' Read the OPTION if it exists in config file '''
                bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
                if bool_Option_Exists:
                    self.str_Settings_Run_BackEnd_Path__Default_Value = value_Option
                pass
                ''' Specify OPTION to get '''
                str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_Working_Path
                value_Type = ''
                ''' Read the OPTION if it exists in config file '''
                bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
                if bool_Option_Exists:
                    self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value = value_Option
                    #self.str_BackEnd_Working_Path = self.str_BackEnd_Working_Base_Path
                pass
                ''' Specify OPTION to get '''
                str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_BINARY_Executable_Path
                value_Type = ''
                ''' Read the OPTION if it exists in config file '''
                bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
                if bool_Option_Exists:
                    self.str_Settings_Run_BackEnd_BINARY_Executable_Path__Default_Value = value_Option
                pass

            pass
        
                
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_ExecutableName
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_BackEnd_ExecutableName__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_Job_CPUs_To_Leave_In_Reserve
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Settings_Run_BackEnd_Job_CPUs_To_Leave_In_Reserve__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_Path_Max_Allowable_Length
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Settings_Run_BackEnd_Path_Max_Allowable_Length__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Python_Executable_Path
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Python_Executable_Path__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_Python_Executable_Name
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_Python_Executable_Name__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_BINARY_Executable_Name
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Settings_Run_BackEnd_BINARY_Executable_Name__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Run_BackEnd_BINARY_Executable
            value_Type = False
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.bool_Settings_Run_BackEnd_BINARY_Executable__Default_Value = value_Option
            pass
        pass

        ''' <<<<<<< SECTION: Settings_Job_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Settings_Job_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass   
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Job_Run_Scenario_Job__Time_Delay_In_Secs_Before_Monitoring
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Settings_Job_Run_Scenario_Job__Time_Delay_In_Secs_Before_Monitoring__Default_Value = value_Option
            pass
        pass
    
        ''' <<<<<<< SECTION: Simulation_Batch_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Simulation_Batch_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicates__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicates__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicates__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicates__Max = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicates__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicates__Min = value_Option
            pass
        pass
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Muliplier__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Muliplier__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Muliplier__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Muliplier__Max = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Muliplier__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Muliplier__Min = value_Option
            pass
        pass
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Burn_In__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Burn_In__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Burn_In__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Burn_In__Max = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Burn_In__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Burn_In__Min = value_Option
            pass
        pass
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Temporal_Evolution__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Temporal_Evolution__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Max = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Temporal_Evolution__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution__Min = value_Option
            pass
        pass
        
        ''' <<<<<<< SECTION: Population_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Population_Demographic_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Population_Size__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Population_Size__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Population_Size__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Population_Size__Max = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Population_Size__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Population_Size__Min = value_Option
            pass
        pass
    
        ''' <<<<<<< SECTION: Genome_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Genome_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Mutation_Allowed__Default_Value
            value_Type = False
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.bool_Genome_Mutation_Allowed__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Mutation_Rate__Default_Value
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.float_Genome_Mutation_Rate__Default_Value = value_Option
            pass
        pass 
      
        ''' <<<<<<< SECTION: Genome_Source_List '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Genome_Source_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass                   
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = object_SSConfigBatchScenario.static_str_Option__Genome_Source + '_0'
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.list_Settings__Genome_Source = [value_Opt for key_Option, value_Opt in value_Option.items()]
            pass
        pass        
    
        ''' <<<<<<< SECTION: Genome_Source_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Genome_Source_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Source__Default_Value
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Genome_Source__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Source_File__Default_Value
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Genome_Source_File__Default_Value = value_Option
            pass
        pass         
    
        ''' <<<<<<< SECTION: Genome_Locus_Number_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Genome_Locus_Number_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Locus_Number__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Locus_Number__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Locus_Number__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Locus_Number__Max = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Locus_Number__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Locus_Number__Min = value_Option
            pass
        pass         
        
        ''' <<<<<<< SECTION: Genome_Alleles_Per_Locus_Distribution_List '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Genome_Alleles_Per_Locus_Distribution_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass                   
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = object_SSConfigBatchScenario.static_str_Option__Genome_Alleles_Per_Locus_Distribution + '_0'
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.list_Settings__Genome_Alleles_Per_Locus_Distribution = [value_Opt for key_Option, value_Opt in value_Option.items()]
            pass
        pass        

        ''' <<<<<<< SECTION: Genome_Alleles_Per_Locus_Distribution_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Genome_Alleles_Per_Locus_Distribution_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Max = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus__Min = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Max = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Min = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Decimals
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Decimals = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Step_Divisor
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus__Step_Divisor = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Max = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Min = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Decimals
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_GGenome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Decimals = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus__Step_Divisor = value_Option
            pass
        pass         

        
        ''' <<<<<<< SECTION: Genome_Allele_Frequency_Distribution_List '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Genome_Allele_Frequency_Distribution_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass                   
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = object_SSConfigBatchScenario.static_str_Option__Genome_Allele_Frequency_Distribution + '_0'
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.list_Settings__Genome_Allele_Frequency_Distribution = [value_Opt for key_Option, value_Opt in value_Option.items()]
            pass
        pass        

        ''' <<<<<<< SECTION: Genome_Allele_Frequency_Distribution_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Genome_Allele_Frequency_Distribution_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Allele_Frequency_Distribution__Default_Value
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Allele_Frequency_Distribution__Default_Value = value_Option
            pass
        pass 
                        
        ''' <<<<<<< SECTION: Life_History_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Species_Life_History_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Max_Age__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Max_Age__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Max_Age__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Max_Age__Max__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Max_Age__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Max_Age__Min__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Max_Mating_Age__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Max_Mating_Age__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Max_Mating_Age__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Max_Mating_Age__Max__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Max_Mating_Age__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Max_Mating_Age__Min__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Min_Mating_Age__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Min_Mating_Age__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Min_Mating_Age__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Min_Mating_Age__Max__Default_Value = value_Option
            pass
            
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Min_Mating_Age__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Min_Mating_Age__Min__Default_Value = value_Option
            pass
        pass
        
        ''' <<<<<<< SECTION: Offspring_Distribution_List '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Settings_Species_Offspring_Distribution_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass                   
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution + '_0'
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.list_Settings_Species_Offspring_Distribution = [value_Opt for key_Option, value_Opt in value_Option.items()]
            pass
        pass
        
        ''' <<<<<<< SECTION: Offspring_Distribution_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Species_Offspring_Distribution_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass                   
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Max = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number__Min = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Default_Value
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Max
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Max = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Min
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Min = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Decimals
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Decimals = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number__Step_Divisor = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Max = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Min = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Decimals
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Decimals = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number__Step_Divisor = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Default_Value
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Max
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Max = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Min
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Min = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Decimals
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Decimals = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev__Step_Divisor = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Min__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Min__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Max = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Min__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min__Min = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Max__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Max__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Max = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Max__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max__Min = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Default_Value
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Default_Value = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Max
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Max = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Min
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Min = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Decimals
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Decimals = value_Option
            pass
        
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean__Step_Divisor = value_Option
            pass
        pass
            
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass 
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Settings_Ne_Estimator_External_Process_Version__Default_Value
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Sampling_Strategy_Run_Settings_Ne_Estimator_External_Process_Version__Default_Value = value_Option
            pass
        pass  
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Settings_LDNe_External_Process_Run_Time_Max_Seconds__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Run_Time_Max_Seconds__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Settings_LDNe_External_Process_Repeat_FAILED_Max_Count__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Repeat_FAILED_Max_Count__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Settings_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Settings_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Settings_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS__Default_Value
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                ''' Use this sampling plan to determine the DEFAULT LDNe power analysis accuracy guideline '''
                list_Options = value_Option.split(':')
                self.dict_Sampling_Strategy_Run_Settings_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS__Default_Value = {list_Options[0]:int(list_Options[1])}
            else:
                ''' Default to Fully Sampled Cohorts & 1 Rep '''
                self.dict_Sampling_Strategy_Run_Settings_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS__Default_Value = {object_SSConfigSamplingStrategy.static_str_Value__Sampling_Strategy_Run_LDNe_Sampling_Plan_Code_FAC:1}
            pass

            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Settings_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS__Default_Value
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                ''' Use this sampling plan to determine the LDNe power analysis accuracy guideline '''
                self.dict_Sampling_Strategy_Run_Settings_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS__Default_Value = {}
                list_Options = value_Option.split(',')
                for str_Option in list_Options:
                    list_Option = str_Option.split(':')
                    if list_Option[0] not in self.dict_Sampling_Strategy_Run_Settings_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS__Default_Value.keys():
                        self.dict_Sampling_Strategy_Run_Settings_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS__Default_Value[list_Option[0]] = int(list_Option[1])
                    pass
                pass
            else:
                ''' Default to nothing - no other sampling plans '''
                self.dict_Sampling_Strategy_Run_Settings_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS__Default_Value = {}
            pass
        pass         
            
        ''' <<<<<<< SECTION: Sample_Stategy__Sample_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Min__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Min__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Min__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Min__Max__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Min__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Min__Min__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Max__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Max__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Max__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Max__Max__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Max__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Max__Min__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Increment__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Increment__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Increment__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Increment__Max__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Increment__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Increment__Min__Default_Value = value_Option
            pass
        pass         
            
        ''' <<<<<<< SECTION: Sample_Stategy__Locus_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Locus_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Min__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Min__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Min__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Min__Max__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Min__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Min__Min__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Max__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Max__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Max__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Max__Max__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Max__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Max__Min__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Increment__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Increment__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Increment__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Increment__Max__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Increment__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Increment__Min__Default_Value = value_Option
            pass
        pass         

        ''' <<<<<<< SECTION: LDNe_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_LDNe_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.float_Settings_Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_Replicates__Default_Value
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_LDNe_Replicates__Default_Value = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_Replicates__Max
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_LDNe_Replicates__Max = value_Option
            pass
        pass         
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_Replicates__Min
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_LDNe_Replicates__Min = value_Option
            pass
        pass         

        ''' <<<<<<< SECTION: LDNe_PCrit_To_Get_List '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_LDNe_PCrit_To_Get_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass                   
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_PCrit_To_Get + '_0'
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.list_Settings_Sampling_Strategy_LDNe_PCrit_To_Get = [value_Opt for key_Option, value_Opt in value_Option.items()]
            pass
        pass
    
        ''' <<<<<<< SECTION: Sample_Proportions_Source_List '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_Source_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass                   
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Proportions_Source + '_0'
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.list_Settings_Sampling_Strategy_Sample_Proportions_Source = [value_Opt for key_Option, value_Opt in value_Option.items()]
            pass
        pass

        ''' <<<<<<< SECTION: Context_Help '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Settings_Context_Help
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Context_Help_Display_At_Start
            value_Type = False
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.bool_Settings_Context_Help_Display_At_Start__Default_Value = value_Option
            pass
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Settings_Context_Help_Zoom_Factor
            value_Type = 0.0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.float_Settings_Context_Help_Zoom_Factor__Default_Value = value_Option
            pass

        pass         
    
        return True        

    def func_Get_Config_Data__PROJECT(self, obj_Config_Project):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        #obj_Config = self.obj_Config_Project
        obj_Config = obj_Config_Project
        
        if obj_Config == None:
            str_Message_Text = 'obj_Config_Project = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False  
        pass         
    
        config_parser_Config = obj_Config.config_parser_Config
    
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Project.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass    
                
        ''' <<<<<<< SECTION: Project_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Project_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass             
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Project_Name
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Project_Name = value_Option
            pass
        pass    
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Project_Name__FOUND = bool_Exists
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Project_UID
            value_Type = 0
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Project_UID = value_Option
            pass
        pass    
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Project_UID__FOUND = bool_Exists
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Project_Species_Name
            value_Type = ''
            ''' Read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Project_Species_Name = value_Option
            pass
        pass    
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Project_Species_Name__FOUND = bool_Exists
                
#         ''' <<<<<<< SECTION: Scenario_File_List '''
#         ''' Specify SECTION to get '''
#         str_Section = obj_Config.static_str_Section__Scenario_File_List
#         ''' Check if SECTION exists in config file '''
#         bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
#         '''Check if the SECTION exists'''
#         if not bool_Section_Exists:
#             str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         pass                   

        
        return True        

    def func_Get_Config_Data__BATCH_SETTINGS(self, obj_Config_Batch_Settings):
        
        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        #obj_Config = self.obj_Config_Batch_Settings
        obj_Config = obj_Config_Batch_Settings
        
        if obj_Config == None:
            str_Message_Text = 'obj_Config_Batch_Settings = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False  
        pass         
    
        config_parser_Config = obj_Config.config_parser_Config
    
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Settings.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass    

        ''' <<<<<<< SECTION: Batch_Setting_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Batch_Setting_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass               
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Details__Scenario_Name
            value_Type = ''
            '''Its NOT OK if the SECTION does not exist'''
            '''Read the OPTION'''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Batch_Settings_Scenario_Name = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Batch_Settings_Scenario_Name__FOUND = bool_Exists
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Details__Scenario_UID
            value_Type = 0
            '''Its NOT OK if the SECTION does not exist'''
            '''Read the OPTION'''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Batch_Settings_Batch_Scenario_UID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Batch_Settings_Batch_Scenario_UID__FOUND = bool_Exists

        ''' <<<<<<< SECTION: Batch_Setting_Last_Batch_Scenario_Run_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Batch_Setting_Last_Batch_Scenario_Run_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_UID
            value_Type = ''
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Batch_Setting_Last_Batch_Scenario_Run_UID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Batch_Setting_Last_Batch_Scenario_Run_UID__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_Job_Status
            value_Type = ''
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_Batch_Setting_Last_Batch_Scenario_Run_Job_Status__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason
            value_Type = ''
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_Batch_Setting_Last_Batch_Scenario_Run_Job_Status_Terminated_Reason__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_Shell_PID
            value_Type = 0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Batch_Setting_Last_Batch_Scenario_Run_Shell_PID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Batch_Setting_Last_Batch_Scenario_Run_Shell_PID__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Batch_Scenario_Run_Python_PID
            value_Type = 0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Batch_Setting_Last_Batch_Scenario_Run_Python_PID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Batch_Setting_Last_Batch_Scenario_Run_Python_PID__FOUND = bool_Exists            

#         ''' <<<<<<< SECTION: Batch_Setting_Last_Sampling_Strategy_Run_Details '''
#         ''' Specify SECTION to get '''
#         str_Section = obj_Config.static_str_Section__Batch_Setting_Last_Sampling_Strategy_Run_Details
#         ''' Check if SECTION exists in config file '''
#         bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
#         '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
#         if bool_Section_Exists:
#             ''' Specify OPTION to get '''
#             str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_UID
#             value_Type = ''
#             '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
#             bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
#             if bool_Option_Exists:
#                 self.str_Batch_Setting_Last_Sampling_Strategy_Run_UID = value_Option
#             pass
#         pass
#         bool_Exists = bool_Section_Exists and bool_Option_Exists
#         self.bool_str_Batch_Setting_Last_Sampling_Strategy_Run_UID__FOUND = bool_Exists            
#         '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
#         if bool_Section_Exists:
#             ''' Specify OPTION to get '''
#             str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_Job_Status
#             value_Type = ''
#             '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
#             bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
#             if bool_Option_Exists:
#                 self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status = value_Option
#             pass
#         pass
#         bool_Exists = bool_Section_Exists and bool_Option_Exists
#         self.bool_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status__FOUND = bool_Exists            
#         '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
#         if bool_Section_Exists:
#             ''' Specify OPTION to get '''
#             str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason
#             value_Type = ''
#             '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
#             bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
#             if bool_Option_Exists:
#                 self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason = value_Option
#             pass
#         pass
#         bool_Exists = bool_Section_Exists and bool_Option_Exists
#         self.bool_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason__FOUND = bool_Exists            
#         '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
#         if bool_Section_Exists:
#             ''' Specify OPTION to get '''
#             str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_Shell_PID
#             value_Type = 0
#             '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
#             bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
#             if bool_Option_Exists:
#                 self.int_Batch_Setting_Last_Sampling_Strategy_Run_Shell_PID = value_Option
#             pass
#         pass
#         bool_Exists = bool_Section_Exists and bool_Option_Exists
#         self.bool_int_Batch_Setting_Last_Sampling_Strategy_Run_Shell_PID__FOUND = bool_Exists            
#         '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
#         if bool_Section_Exists:
#             ''' Specify OPTION to get '''
#             str_Option = obj_Config.static_str_Option__Batch_Setting_Last_Sampling_Strategy_Run_Python_PID
#             value_Type = 0
#             '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
#             bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
#             if bool_Option_Exists:
#                 self.int_Batch_Setting_Last_Sampling_Strategy_Run_Python_PID = value_Option
#             pass
#         pass
#         bool_Exists = bool_Section_Exists and bool_Option_Exists
#         self.bool_int_Batch_Setting_Last_Sampling_Strategy_Run_Python_PID__FOUND = bool_Exists            

        ''' <<<<<<< SECTION: Batch_Setting_Pop_Saving '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Batch_Setting__Pop_Saving
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts
            value_Type = 0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Batch_Setting__Pop_Saving__Replicate_Mating_Count_At_Which_Pop_Saving_Starts__FOUND = bool_Exists   
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting__Pop_Saving__Save_Pop_Every_Replicate_Mating_Count
            value_Type = 0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Batch_Setting__Pop_Saving__Save_Pop_Every_Replicate_Mating_Count = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Batch_Setting__Pop_Saving__Save_Pop_Every_Replicate_Mating_Count__FOUND = bool_Exists   

        ''' <<<<<<< SECTION: Batch_Setting_Pop_Sampling '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Batch_Setting__Pop_Sampling
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting__Pop_Sampling__Sample_Pop_Every_Mating_Count
            value_Type = 0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Batch_Setting__Pop_Sampling__Sample_Pop_Every_Mating_Count = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Batch_Setting__Pop_Sampling__Sample_Pop_Every_Mating_Count__FOUND = bool_Exists   
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count
            value_Type = 0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Batch_Setting__Pop_Sampling__Post_Sim_Pop_Sampling_Start_At_Replicate_Mating_Count__FOUND = bool_Exists   
                
        return True
    
    def func_Get_Config_Data__BATCH_SCENARIO(self, obj_Config_Batch_Scenario):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        #obj_Config = self.obj_Config_Batch_Scenario
        obj_Config = obj_Config_Batch_Scenario
        
        if obj_Config == None:
            str_Message_Text = 'obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False  
        pass         
    
        config_parser_Config = obj_Config.config_parser_Config
    
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Scenario.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass    

        ''' <<<<<<< SECTION: Project_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Scenario_Project_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass               
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Scenario_Project_Name
            value_Type = ''
            '''Its NOT OK if the SECTION does not exist'''
            '''Read the OPTION'''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Scenario_Project_Name = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Scenario_Project_Name__FOUND = bool_Exists            
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Scenario_Project_UID
            value_Type = 0
            '''Its NOT OK if the SECTION does not exist'''
            '''Read the OPTION'''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Scenario_Project_UID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Scenario_Project_UID__FOUND = bool_Exists  
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Scenario_Project_Species_Name
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Scenario_Project_Species_Name = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Scenario_Project_Species_Name__FOUND = bool_Exists
                                        
        ''' <<<<<<< SECTION: Scenario_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Scenario_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Check if the SECTION exists'''
        if not bool_Section_Exists:
            str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass               
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Scenario_Name
            value_Type = ''
            '''Its NOT OK if the SECTION does not exist'''
            '''Read the OPTION'''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Scenario_Name__Current = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Scenario_Name__FOUND = bool_Exists
        '''If the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Scenario_UID
            value_Type = 0
            '''Its NOT OK if the SECTION does not exist'''
            '''Read the OPTION'''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Batch_Scenario_UID__Current = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Scenario_UID__FOUND = bool_Exists

        ''' <<<<<<< SECTION: Batch_Settings '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Scenario_Batch_Settings
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Scenario_Batch_Settings_File
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Scenario_Batch_Settings_File = value_Option
                self.str_Batch_Settings_Relative_Path_And_File = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Scenario_Batch_Settings_File__FOUND = bool_Exists
        
        ''' <<<<<<< SECTION: Scenario_Run_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Scenario_Run_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Scenario_Run_Simulation_Working_Base_Path
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Scenario_Run_Simulation_Working_Base_Path = value_Option
            else:
                self.str_Scenario_Run_Simulation_Working_Base_Path = self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value
            pass
        else:
            self.str_Scenario_Run_Simulation_Working_Base_Path = self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value
        pass
        self.str_BackEnd_Working_Base_Path = self.str_Scenario_Run_Simulation_Working_Base_Path
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Scenario_Run_Simulation_Working_Base_Path__FOUND = bool_Exists
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Scenario_Run_Simulation_Output_Base_Path
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Scenario_Run_Simulation_Output_Base_Path = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Scenario_Run_Simulation_Output_Base_Path__FOUND = bool_Exists
        
        ''' <<<<<<< SECTION: Simulation_Batch_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Simulation_Batch_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicates
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicates = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Simulation_Batch_Replicates__FOUND = bool_Exists
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Burn_In
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Burn_In = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Simulation_Batch_Replicate_Length_Burn_In__FOUND = bool_Exists
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Simulation_Batch_Replicate_Length_Temporal_Evolution
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Simulation_Batch_Replicate_Length_Temporal_Evolution = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Simulation_Batch_Replicate_Length_Temporal_Evolution__FOUND = bool_Exists
        

        ''' <<<<<<< SECTION: Population_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Population_Demographic_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Population_Size
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Population_Size = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Population_Size__FOUND = bool_Exists


        ''' <<<<<<< SECTION: Genome_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Genome_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Locus_Number
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Genome_Locus_Number = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Genome_Locus_Number__FOUND = bool_Exists
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Genome_Alleles_Per_Locus_Distribution = value_Option
                if self.str_Genome_Alleles_Per_Locus_Distribution == obj_Config.static_str_Value__Genome_Alleles_Per_Locus_Distribution_UNIFORM:
                    str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus 
                    value_Type = 0
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.int_Genome_Alleles_Per_Locus_Distribution_UNIFORM_Number_Alleles_Per_Locus = value_Option
                    pass
                elif self.str_Genome_Alleles_Per_Locus_Distribution == obj_Config.static_str_Value__Genome_Alleles_Per_Locus_Distribution_BINOMIAL:
                    str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus 
                    value_Type = 0.0
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_Mean_Number_Alleles_Per_Locus = value_Option
                    pass
                    str_Option = obj_Config.static_str_Option__Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus 
                    value_Type = 0.0
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.float_Genome_Alleles_Per_Locus_Distribution_BINOMIAL_StdDev_Alleles_Per_Locus = value_Option
                    pass
                else:
                    str_Message_Text = 'Non-existent OPTION: ' + str_Option + ' for SECTION: ' + str_Section + ' in config_parser_Config: obj_Config_Batch_Scenario' 
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                pass
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_Genome_Alleles_Per_Locus_Distribution__FOUND = bool_Exists
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Genome_Allele_Frequency_Distribution
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Genome_Allele_Frequency_Distribution = value_Option
                if self.str_Genome_Allele_Frequency_Distribution == obj_Config.static_str_Value__Genome_Allele_Frequency_Distribution_NON_RANDOM:
                    '''Already read this OPTION '''
                    self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name = ''
                    self.str_Genome__Source_GENEPOP_File_Path_And_Name = ''
                    pass
                elif self.str_Genome_Allele_Frequency_Distribution == obj_Config.static_str_Value__Genome_Allele_Frequency_Distribution_UNIFORM:
                    '''
                    Phase out static_str_Value__Genome_Allele_Frequency_Distribution_UNIFORM
                    '''
                    self.str_Genome_Allele_Frequency_Distribution = obj_Config.static_str_Value__Genome_Allele_Frequency_Distribution_NON_RANDOM
                    self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name = ''
                    self.str_Genome__Source_GENEPOP_File_Path_And_Name = ''
                    pass
                elif self.str_Genome_Allele_Frequency_Distribution == obj_Config.static_str_Value__Genome_Allele_Frequency_Distribution_DRICHLET:
                    '''Already read this OPTION '''
                    self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name = ''
                    self.str_Genome__Source_GENEPOP_File_Path_And_Name = ''
                    pass
                elif self.str_Genome_Allele_Frequency_Distribution == obj_Config.static_str_Value__Genome_Allele_Frequency_Distribution_ALL_ALLELE_FREQUENCIES:
                    str_Option = obj_Config.static_str_Option__Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name 
                    value_Type = ''
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name = value_Option
                        ''' Get the number of loci from the file '''
                        str_Input_File_Path, str_Input_File_Name = os__path.split(str(self.str_Genome__Source_ALL_ALLELE_FREQUENCIES_File_Path_And_Name))
                        bool_Success, self.int_Genome__Source_ALL_ALLELE_FREQUENCIES__Total_Loci, str_Message = self.func_Validate_Loci_From_File(str_Input_File_Path, str_Input_File_Name)
                        if bool_Success:
                            ''' Set the Genome Locus Number to equal the loci number from the file '''  
                            self.int_Genome_Locus_Number = self.int_Genome__Source_ALL_ALLELE_FREQUENCIES__Total_Loci
                        pass
                    pass
                elif self.str_Genome_Allele_Frequency_Distribution == obj_Config.static_str_Value__Genome_Allele_Frequency_Distribution_GENEPOP:
                    str_Option = obj_Config.static_str_Option__Genome__Source_GENEPOP_File_Path_And_Name 
                    value_Type = ''
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.str_Genome__Source_GENEPOP_File_Path_And_Name = value_Option
                        ''' Get the number of loci from the file '''
                        str_Input_File_Path, str_Input_File_Name = os__path.split(str(self.str_Genome__Source_GENEPOP_File_Path_And_Name))
                        bool_Success, self.int_Genome__Source_GENEPOP__Total_Loci, str_Message = self.func_Validate_Loci_From_File(str_Input_File_Path, str_Input_File_Name)
                        if bool_Success:
                            ''' Set the Genome Locus Number to equal the loci number from the file '''  
                            self.int_Genome_Locus_Number = self.int_Genome__Source_GENEPOP__Total_Loci
                        pass
                    pass
                else:
                    str_Message_Text = 'Non-existent OPTION: ' + str_Option + ' for SECTION: ' + str_Section + ' in config_parser_Config: obj_Config_Batch_Scenario' 
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                pass
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_Genome_Allele_Frequency_Distribution__FOUND = bool_Exists


        ''' <<<<<<< SECTION: Species_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Species_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Name
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Scenario_Species_Name = value_Option
                self.Arg_Scenario_Species_Name = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Scenario_Species_Name__FOUND = bool_Exists
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Code_Long
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Species_Code_Long = value_Option
                self.Arg_Species_Code_Long = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Species_Code_Long__FOUND = bool_Exists
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Code_Short
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Species_Code_Short = value_Option
                self.Arg_Species_Code_Short = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Species_Code_Short__FOUND = bool_Exists
                                        
        ''' <<<<<<< SECTION: Life_History '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Species_Life_History_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Max_Age
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Max_Age = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Species_Life_History_Max_Age__FOUND = bool_Exists
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Max_Mating_Age
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Max_Mating_Age = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Species_Life_History_Max_Mating_Age__FOUND = bool_Exists
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Life_History_Min_Mating_Age
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Species_Life_History_Min_Mating_Age = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Species_Life_History_Min_Mating_Age__FOUND = bool_Exists



        ''' <<<<<<< SECTION: Offspring_Details '''
        bool_Section_Exists = False
        bool_Option_Exists = False                
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Species_Offspring_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
#         if not bool_Section_Exists:
#             str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         pass             
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Species_Offspring_Distribution = value_Option
                if self.str_Species_Offspring_Distribution == obj_Config.static_str_Value__Species_Offspring_Distribution_ABSOLUTE:
                    str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_ABSOLUTE_Offspring_Number 
                    value_Type = 0
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.int_Species_Offspring_Distribution_ABSOLUTE_Offspring_Number  = value_Option
                    pass
                elif self.str_Species_Offspring_Distribution == obj_Config.static_str_Value__Species_Offspring_Distribution_POISSON:
                    str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_POISSON_Offspring_Mean_Number 
                    value_Type = 0.0
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.float_Species_Offspring_Distribution_POISSON_Offspring_Mean_Number  = value_Option
                    pass
                elif self.str_Species_Offspring_Distribution == obj_Config.static_str_Value__Species_Offspring_Distribution_BINOMIAL:
                    str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number 
                    value_Type = 0.0
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_Mean_Number  = value_Option
                    pass
                    str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev 
                    value_Type = 0.0
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.float_Species_Offspring_Distribution_BINOMIAL_Offspring_StdDev  = value_Option
                    pass
                elif self.str_Species_Offspring_Distribution == obj_Config.static_str_Value__Species_Offspring_Distribution_UNIFORM:
                    str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Min 
                    value_Type = 0
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Min  = value_Option
                    pass
                    str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_UNIFORM_Offspring_Max 
                    value_Type = 0
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.int_Species_Offspring_Distribution_UNIFORM_Offspring_Max  = value_Option
                    pass
                elif self.str_Species_Offspring_Distribution == obj_Config.static_str_Value__Species_Offspring_Distribution_GEOMETRIC:
                    str_Option = obj_Config.static_str_Option__Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean 
                    value_Type = 0.0
                    '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
                    bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
                    if bool_Option_Exists:
                        self.float_Species_Offspring_Distribution_GEOMETRIC_Offspring_Mean  = value_Option
                    pass
                else:
                    str_Message_Text = 'Non-existent OPTION: ' + str_Option + ' for SECTION: ' + str_Section + ' in config_parser_Config: obj_Config_Batch_Scenario' 
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                pass
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_Species_Offspring_Distribution__FOUND = bool_Exists
    
        ''' <<<<<<< SECTION: CSV_Age_And_Natural_Mortality_Rate__MALE '''
        bool_Section_Exists = False
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = str(1) #First Age_In_years option which should always be present
            value_Type = 0.0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read it '''
            bool_Option_Exists = False 
            bool_Option_Exists, dict_Option = obj_Config.func_Read_OPTION(False, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE = OrderedDict([(int(key_str_Age), float(value_str_Rate)) for key_str_Age, value_str_Rate in dict_Option.items()])
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__MALE__FOUND = bool_Exists

    
        ''' <<<<<<< SECTION: CSV_Age_And_Natural_Mortality_Rate__FEMALE '''
        bool_Section_Exists = False
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = str(1) #First Age_In_years option which should always be present
            value_Type = 0.0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read it '''
            bool_Option_Exists = False 
            bool_Option_Exists, dict_Option = obj_Config.func_Read_OPTION(False, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE = OrderedDict([(int(key_str_Age), float(value_str_Rate)) for key_str_Age, value_str_Rate in dict_Option.items()])
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_dict_Species_Demographic_Natural_Mortality_CSV_Age_And_Mortality_Rate__FEMALE__FOUND = bool_Exists

    
        #self.func_Get_Config_Data__BATCH_SETTINGS()
        
        return True        

    def func_Get_Config_Data__SAMPLING_STRATEGY(self, obj_Config_Sampling_Strategy):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        #obj_Config = self.obj_Config_Sampling_Strategy
        obj_Config = obj_Config_Sampling_Strategy
        
        if obj_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False  
        pass         
    
        config_parser_Config = obj_Config.config_parser_Config
    
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Sampling_Strategy.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass    
        
        ''' <<<<<<< SECTION: Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Ne_Estimator_External_Process_Version
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            ''' The OPTION should exist but may not.  Create it if it doesnt exist '''
            if bool_Option_Exists:
                self.str_Sampling_Strategy_Run_Ne_Estimator_External_Process_Version = value_Option
            else:
                self.str_Sampling_Strategy_Run_Ne_Estimator_External_Process_Version = self.str_Sampling_Strategy_Run_Settings_Ne_Estimator_External_Process_Version__Default_Value
                ''' 
                TEMPORARY FIX - Do this until this OPTION becomes standard in config file
                '''
                ''' Create Option if SECTION exists but OPTION doesnt''' 
                self.func_Update_Config__Sampling_Strategy_Run_Ne_Estimator_External_Process_Version()
                ''' Write OPTION to the config file '''
                bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, self.str_Sampling_Strategy_Path_And_File__Current)
                if bool_Success:
                    self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                    bool_Option_Exists = True
                else:
                    str_Message_Text = 'config_parser_Config could not be written to config file'
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass                   
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Sampling_Strategy_Run_Ne_Estimator_External_Process_Version__FOUND = bool_Exists
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Simulation_Working_Base_Path
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path = value_Option
            else:
                self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path = self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value
            pass
        else:
            self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path = self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value
        pass
        self.str_BackEnd_Working_Base_Path = self.str_Sampling_Strategy_Run_Simulation_Working_Base_Path
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Sampling_Strategy_Run_Simulation_Working_Base_Path__FOUND = bool_Exists
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Simulation_Output_Base_Path
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Sampling_Strategy_Run_Simulation_Output_Base_Path = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Sampling_Strategy_Run_Simulation_Output_Base_Path__FOUND = bool_Exists
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            ''' The OPTION should exist but may not.  Create it if it doesnt exist '''
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds = value_Option
            else:
                self.int_Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds = self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Run_Time_Max_Seconds__Default_Value
                ''' 
                TEMPORARY FIX - Do this until this OPTION becomes standard in config file
                '''
                ''' Create Option if SECTION exists but OPTION doesnt''' 
                self.func_Update_Config__Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds()
                ''' Write OPTION to the config file '''
                bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, self.str_Sampling_Strategy_Path_And_File__Current)
                if bool_Success:
                    self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                    bool_Option_Exists = True
                else:
                    str_Message_Text = 'config_parser_Config could not be written to config file'
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass                   
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds__FOUND = bool_Exists
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count = value_Option
            else:
                self.int_Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count = self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Repeat_FAILED_Max_Count__Default_Value
                ''' 
                TEMPORARY FIX - Do this until this OPTION becomes standard in config file
                '''
                ''' Create Option if SECTION exists but OPTION doesnt''' 
                self.func_Update_Config__Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count()
                ''' Write OPTION to the config file '''
                bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, self.str_Sampling_Strategy_Path_And_File__Current)
                if bool_Success:
                    self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                    bool_Option_Exists = True
                else:
                    str_Message_Text = 'config_parser_Config could not be written to config file'
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass                   
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count__FOUND = bool_Exists
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed = value_Option
            else:
                self.int_Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed = self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed__Default_Value
                ''' 
                TEMPORARY FIX - Do this until this OPTION becomes standard in config file
                '''
                ''' Create Option if SECTION exists but OPTION doesnt''' 
                self.func_Update_Config__Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed()
                ''' Write OPTION to the config file '''
                bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, self.str_Sampling_Strategy_Path_And_File__Current)
                if bool_Success:
                    self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                    bool_Option_Exists = True
                else:
                    str_Message_Text = 'config_parser_Config could not be written to config file'
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass                   
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed__FOUND = bool_Exists
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed = value_Option
            else:
                self.int_Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed = self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed__Default_Value
                ''' 
                TEMPORARY FIX - Do this until this OPTION becomes standard in config file
                '''
                ''' Create Option if SECTION exists but OPTION doesnt''' 
                self.func_Update_Config__Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed()
                ''' Write OPTION to the config file '''
                bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, self.str_Sampling_Strategy_Path_And_File__Current)
                if bool_Success:
                    self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                    bool_Option_Exists = True
                else:
                    str_Message_Text = 'config_parser_Config could not be written to config file'
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass                   
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed__FOUND = bool_Exists
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                list_Options = value_Option.split(':')
                self.dict_Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS = {list_Options[0]:int(list_Options[1])}
            else:
                self.dict_Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS = self.dict_Sampling_Strategy_Run_Settings_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS__Default_Value
                ''' 
                TEMPORARY FIX - Do this until this OPTION becomes standard in config file
                '''
                ''' Create Option if SECTION exists but OPTION doesnt''' 
                self.func_Update_Config__Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS()
                ''' Write OPTION to the config file '''
                bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, self.str_Sampling_Strategy_Path_And_File__Current)
                if bool_Success:
                    self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                    bool_Option_Exists = True
                else:
                    str_Message_Text = 'config_parser_Config could not be written to config file'
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass                   
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_dict_Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS__FOUND = bool_Exists
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.dict_Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS = {}
                list_Options = value_Option.split(',')
                for str_Option in list_Options:
                    list_Option = str_Option.split(':')
                    if list_Option[0] not in self.dict_Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS.keys():
                        self.dict_Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS[list_Option[0]] = int(list_Option[1])
                    pass
                pass
            else:
                self.dict_Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS = self.dict_Sampling_Strategy_Run_Settings_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS__Default_Value
                if self.dict_Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS != {}:
                    ''' 
                    TEMPORARY FIX - Do this until this OPTION becomes standard in config file
                    '''
                    ''' Create Option if SECTION exists but OPTION doesnt''' 
                    self.func_Update_Config__Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS()
                    ''' Write OPTION to the config file '''
                    bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, self.str_Sampling_Strategy_Path_And_File__Current)
                    if bool_Success:
                        self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                        bool_Option_Exists = True
                    else:
                        str_Message_Text = 'config_parser_Config could not be written to config file'
                        int_Stack_Trace_Level = 2
                        self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                    pass
                pass                   
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_dict_Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS__FOUND = bool_Exists

        ''' <<<<<<< SECTION: Sampling_Strategy_Last_Run_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Last_Run_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
#         '''Check if the SECTION exists'''
#         if not bool_Section_Exists:
#             str_Message_Text = 'Non-existant SECTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section
#             int_Stack_Trace_Level = 2
#             self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
#             return False
#         pass               
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_UID
            value_Type = ''
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Sampling_Strategy_Last_Run_UID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Sampling_Strategy_Last_Run_UID__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Job_Status
            value_Type = ''
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Sampling_Strategy_Last_Run_Job_Status = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_Sampling_Strategy_Last_Run_Job_Status__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason
            value_Type = ''
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Shell_PID
            value_Type = 0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Last_Run_Shell_PID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Last_Run_Shell_PID__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Python_PID
            value_Type = 0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Last_Run_Python_PID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Last_Run_Python_PID__FOUND = bool_Exists            

        ''' <<<<<<< SECTION: Sampling_Strategy_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its Not OK if the SECTION does not exist '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Name
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Sampling_Strategy_Name__Current = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Sampling_Strategy_Name__FOUND = bool_Exists
        '''Its Not OK if the SECTION does not exist '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_UID
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_UID__Current = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_UID__FOUND = bool_Exists
        
        
        ''' <<<<<<< SECTION: Sample_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Min
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Min = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Sample_Range_Min__FOUND = bool_Exists
        
        ''' <<<<<<< SECTION: Sample_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Max
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Max = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Sample_Range_Max__FOUND = bool_Exists
        
        ''' <<<<<<< SECTION: Sample_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Range_Increment
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Sample_Range_Increment = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Sample_Range_Increment__FOUND = bool_Exists
        
        ''' <<<<<<< SECTION: Locus_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Locus_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Min
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Min = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Locus_Range_Min__FOUND = bool_Exists
        
        ''' <<<<<<< SECTION: Locus_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Locus_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Max
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Max = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Locus_Range_Max__FOUND = bool_Exists
        
        ''' <<<<<<< SECTION: Locus_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Locus_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Locus_Range_Increment
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_Locus_Range_Increment = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_Locus_Range_Increment__FOUND = bool_Exists
        
        ''' <<<<<<< SECTION: LDNe_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_LDNe_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option ''' 
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
            value_Type = 0.0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.float_Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_float_Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep__FOUND = bool_Exists

        ''' <<<<<<< SECTION: LDNe_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_LDNe_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''        
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_Replicates
            value_Type = 0
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Sampling_Strategy_LDNe_Replicates = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Sampling_Strategy_LDNe_Replicates__FOUND = bool_Exists
        
        ''' <<<<<<< SECTION: LDNe_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_LDNe_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_PCrit_To_Get
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Sampling_Strategy_LDNe_PCrit_To_Get = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Sampling_Strategy_LDNe_PCrit_To_Get__FOUND = bool_Exists

        ''' <<<<<<< SECTION: Sample_Proportion_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportion_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Sample_Proportions_Source
            value_Type = ''
            '''Its OK if the SECTION does not exist, however read the OPTION if it exists in config file '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Sampling_Strategy_Sample_Proportions_Source = value_Option

                '''
                Phase out USER_PROPORTIONS in favour of USER_SAMPLE_PROPORTIONS
                This cause the correct value to be used and subsequently saved
                '''
                if self.str_Sampling_Strategy_Sample_Proportions_Source == obj_Config.static_str_Value__Sampling_Strategy_Sample_Proportions_Source__USER_PROPORTIONS:
                    self.str_Sampling_Strategy_Sample_Proportions_Source = obj_Config.static_str_Value__Sampling_Strategy_Sample_Proportions_Source__USER_SAMPLE_PROPORTIONS
                    ''' 
                    TEMPORARY FIX - Do this until this OPTION becomes standard in config file
                    '''
                    ''' Create Option if SECTION exists but OPTION doesnt''' 
                    self.func_Update_Config__Sampling_Strategy_Sample_Proportions_Source()
                    ''' Write OPTION to the config file '''
                    bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, self.str_Sampling_Strategy_Path_And_File__Current)
                    if bool_Success:
                        self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                        bool_Option_Exists = True
                    else:
                        str_Message_Text = 'config_parser_Config could not be written to config file'
                        int_Stack_Trace_Level = 2
                        self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                    pass 
                pass                  
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Sampling_Strategy_Sample_Proportions_Source__FOUND = bool_Exists
       
        ''' <<<<<<< SECTION: Sample_Proportions_By_Age '''
        bool_Section_Exists = False
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = str(1) #First Age_In_years option which should always be present
            value_Type = 0.0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read it '''
            bool_Option_Exists = False 
            bool_Option_Exists, dict_Option = obj_Config.func_Read_OPTION(False, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                #self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion = OrderedDict([(int(key_str_Age), float(value_str_Rate)) for key_str_Age, value_str_Rate in dict_Option.items()])
                '''
                Phase out Sample_Proportions_By_Age in favour of Total_Sample_Size_By_Age_Proportion
                This cause the correct value to be used and subsequently saved
                '''
                self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion = OrderedDict([(int(key_str_Age), float(value_str_Rate)) for key_str_Age, value_str_Rate in dict_Option.items()])
                ''' 
                TEMPORARY FIX - Do this until this OPTION becomes standard in config file
                '''
                ''' Create Option if SECTION exists but OPTION doesnt''' 
                self.func_Update_Config__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion()
                ''' Write OPTION to the config file '''
                bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, self.str_Sampling_Strategy_Path_And_File__Current)
                if bool_Success:
                    self.bool_CHANGED_fields_are_unsaved__Sampling_Strategy = False
                    bool_Option_Exists = True
                else:
                    str_Message_Text = 'config_parser_Config could not be written to config file'
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                pass                   

            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        #self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Proportion__FOUND = bool_Exists
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion__FOUND = bool_Exists

        '''
        Phase out Sample_Proportions_By_Age in favour of Total_Sample_Size_By_Age_Proportion
        Dont go and get the parameters if FOUND set to True previously (it giveas an error cos the values are float but str is expecdted from the config file)
        '''
        if self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion__FOUND != True:
            ''' <<<<<<< SECTION: Sample_Proportions_By_Age '''
            bool_Section_Exists = False
            ''' Specify SECTION to get '''
            str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion
            ''' Check if SECTION exists in config file '''
            bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
            '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
            if bool_Section_Exists:
                ''' Specify OPTION to get '''
                str_Option = str(1) #First Age_In_years option which should always be present
                value_Type = 0.0
                '''Its OK if the OPTION does not exist, however if the OPTION exists, read it '''
                bool_Option_Exists = False 
                bool_Option_Exists, dict_Option = obj_Config.func_Read_OPTION(False, True, obj_Config, str_Section, str_Option, value_Type)
                if bool_Option_Exists:
                    self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion = OrderedDict([(int(key_str_Age), float(value_str_Rate)) for key_str_Age, value_str_Rate in dict_Option.items()])
                pass
            pass
            bool_Exists = bool_Section_Exists and bool_Option_Exists
            self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Total_Sample_Size_By_Age_Proportion__FOUND = bool_Exists
        pass
        
        ''' <<<<<<< SECTION: Sample_Proportions_By_Age '''
        bool_Section_Exists = False
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = str(1) #First Age_In_years option which should always be present
            value_Type = 0.0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read it '''
            bool_Option_Exists = False 
            bool_Option_Exists, dict_Option = obj_Config.func_Read_OPTION(False, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number = OrderedDict([(int(key_str_Age), float(value_str_Rate)) for key_str_Age, value_str_Rate in dict_Option.items()])
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Sample_Number__FOUND = bool_Exists

        ''' <<<<<<< SECTION: Sample_Cohorts_By_Age '''
        bool_Section_Exists = False
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = str(1) #First Age_In_years option which should always be present
            value_Type = 0.0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read it '''
            bool_Option_Exists = False 
            bool_Option_Exists, dict_Option = obj_Config.func_Read_OPTION(False, True, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion = OrderedDict([(int(key_str_Age), float(value_str_Rate)) for key_str_Age, value_str_Rate in dict_Option.items()])
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_dict_Sampling_Strategy_Sample_Proportions_By_Age__Age_And_Cohort_Proportion__FOUND = bool_Exists


        ''' <<<<<<< SECTION: Batch_Setting_Last_Sampling_Strategy_Run_Details '''
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Last_Run_Details
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_UID
            value_Type = ''
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(False, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Batch_Setting_Last_Sampling_Strategy_Run_UID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_str_Batch_Setting_Last_Sampling_Strategy_Run_UID__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Job_Status
            value_Type = ''
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Job_Status_Terminated_Reason
            value_Type = ''
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.str_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_Batch_Setting_Last_Sampling_Strategy_Run_Job_Status_Terminated_Reason__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Shell_PID
            value_Type = 0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Batch_Setting_Last_Sampling_Strategy_Run_Shell_PID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Batch_Setting_Last_Sampling_Strategy_Run_Shell_PID__FOUND = bool_Exists            
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' Specify OPTION to get '''
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Last_Run_Python_PID
            value_Type = 0
            '''Its OK if the OPTION does not exist, however if the OPTION exists, read the option '''
            bool_Option_Exists, value_Option = self.func_Read_OPTION(True, False, obj_Config, str_Section, str_Option, value_Type)
            if bool_Option_Exists:
                self.int_Batch_Setting_Last_Sampling_Strategy_Run_Python_PID = value_Option
            pass
        pass
        bool_Exists = bool_Section_Exists and bool_Option_Exists
        self.bool_int_Batch_Setting_Last_Sampling_Strategy_Run_Python_PID__FOUND = bool_Exists            


        return True        


    def func_Read_OPTION(self, bool_OPTION_is_expected, bool_OPTION_is_List, obj_Config, str_Section, str_Option, value_Type):
        ''' Check if OPTION exists in config file '''
        value_Option = None
        bool_Option_Exists = False
        ''' Remove any whitespaces, CRLF, TAB etc '''
        if isinstance(str_Section, str):
            str_Section = str_Section.join(str_Section.split())
        pass
        if isinstance(str_Section, str):
            str_Option = str_Option.join(str_Option.split())
        pass
        bool_Option_Exists = obj_Config.func_Check_If_Config_File_OPTION_Exists(obj_Config.config_parser_Config, str_Section, str_Option)
        if bool_OPTION_is_expected:
            if not bool_Option_Exists:
                str_Message_Text = 'Non-existant OPTION error READING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') ; SECTION:' + str_Section + '; OPTION :' + str_Option
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                return False
            pass
        pass
        if bool_Option_Exists:
            if bool_OPTION_is_List:
                value_Option = OrderedDict(obj_Config.config_parser_Config.items(str_Section))
            else:
                value_Option = obj_Config.func_Read_Config_File_OPTION(str_Section, str_Option, value_Type)
            pass
        pass
        ''' Remove any whitespaces, CRLF, TAB etc '''
        if isinstance(value_Option, str):
            value_Option = self.func_Clean_String__Of_Control_Characters(value_Option)
        pass
        return bool_Option_Exists, value_Option  

    def func_Clean_String__Of_Control_Characters(self, str_UnClean):
        
        '''
        Examples of unicode categories:
        >>> from unicodedata import category
        >>> category('\r')      # carriage return --> Cc : control character
        'Cc'
        >>> category('\0')      # null character ---> Cc : control character
        'Cc'
        >>> category('\t')      # tab --------------> Cc : control character
        'Cc'
        >>> category(' ')       # space ------------> Zs : separator, space
        'Zs'
        >>> category(u'\u200A') # hair space -------> Zs : separator, space
        'Zs'
        >>> category(u'\u200b') # zero width space -> Cf : control character, formatting
        'Cf'
        >>> category('A')       # letter "A" -------> Lu : letter, uppercase
        'Lu'
        >>> category(u'\u4e21') #  ---------------> Lo : letter, other
        'Lo'
        >>> category(',')       # comma  -----------> Po : punctuation
        'Po'
        >>>        
        '''
        
        str_Clean = ''
        
        if isinstance(str_UnClean, str): 
            
            ''' Convert to unicode to detect categories '''
            str_UnClean = unicode(str_UnClean)
            str_Clean = "".join(ch for ch in str_UnClean if unicodedata__category(ch)[0]!="C")
            ''' Convert to back to str '''
            str_Clean = str(str_Clean)
        pass
    
        return str_Clean
    
    def Update_OPTION(self, obj_Config, str_Section, str_Option, value_Option):
        ''' Update the OPTION '''
        bool_Success = self.func_Set_Values_in_Config_File_Section(obj_Config, str_Section, str_Option, value_Option)
        if not bool_Success:
            str_Message_Text = 'Unexpected error SETTING config_parser (' + obj_Config.static_str_Value__INI_Filename + ') value; SECTION:' + str_Section + '; OPTION :' + str_Option + '; value_Option' + str(value_Option)
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
        pass
        return bool_Success

    def func_Get_New_PROJECT_UID(self):

        datetime_New_Project_UID = datetime.now()
        ''' Unique Run ID '''
        str_Datetime_Stamp_New_Project_UID = str(datetime_New_Project_UID.strftime("%Y%m%d%H%M%S"))
        
        return str_Datetime_Stamp_New_Project_UID

        
    def func_Create_New_PROJECT_And_Cloned_SCENARIO(self, str_Project_Name, str_Project_Species_Name, str_Scenario__Relative_Path_And_File, str_Scenario_Name):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        ''' Get UID for the new project '''
        str_Datetime_Stamp_New_Project_UID = self.func_Get_New_PROJECT_UID()
        str_Project_UID = str_Datetime_Stamp_New_Project_UID
        
        ''' Specify new project folder '''
        str_Project_Relative_Path__New = self.str_Settings_Run_Project_Folder_Prefix__Default_Value + '_' + str_Datetime_Stamp_New_Project_UID
        str_Batch_Scenario_Relative_Path__New = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str_Datetime_Stamp_New_Project_UID
        
        '''
        ------------------------------------------
        Create new filenames
        ------------------------------------------
        '''
        ''' Project '''
        str_Path = str_Project_Relative_Path__New
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Project
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Project = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Project_UID, os__extsep, str_Extension]))        
                                                     
        ''' Batch scenario '''
        str_Path = os__path.join(str_Project_Relative_Path__New, str_Batch_Scenario_Relative_Path__New)
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Batch_Scenario
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Batch_Scenario = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Project_UID, os__extsep, str_Extension]))        
        
        
        ''' Batch settings '''
        str_Path = os__path.join(str_Project_Relative_Path__New, str_Batch_Scenario_Relative_Path__New)
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Batch_Settings
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Batch_Settings = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Project_UID, os__extsep, str_Extension]))        

        '''
        ------------------------------------------
        Create new BATCH SCENARIOS Files
        ------------------------------------------
        '''
        self.func_Create_FRESH_BATCH_Cloned_SCENARIO_Files(str_Project_UID, str_Datetime_Stamp_New_Project_UID, str_Config_File_Relative_Path_And_Name__Batch_Scenario, str_Config_File_Relative_Path_And_Name__Batch_Settings, str_Project_Name, str_Project_Species_Name, str_Scenario__Relative_Path_And_File, str_Scenario_Name)

        '''
        ------------------------------------------
        Create new Project File
        ------------------------------------------
        '''
        self.func_Create_New_PROJECT_File(str_Datetime_Stamp_New_Project_UID, str_Config_File_Relative_Path_And_Name__Project, str_Project_Name, str_Project_Species_Name, str_Config_File_Relative_Path_And_Name__Batch_Scenario, str_Scenario_Name)
        
                
        return True
    
    def func_Create_New_Cloned_SCENARIO(self, str_Project__Relative_Path_And_File, str_Scenario__Relative_Path_And_File, str_Scenario_Name):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        ''' Get UID for the new project '''
        str_Datetime_Stamp_New_Scenario_UID = self.func_Get_New_PROJECT_UID()
        
        '''
        ------------------------------------------
        Create new filenames
        ------------------------------------------
        '''
        str_Project_Relative_Path, _ = os__path.split(str_Project__Relative_Path_And_File)
        str_Batch_Scenario_Relative_Path__New = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str_Datetime_Stamp_New_Scenario_UID

        ''' Batch scenario '''
        str_Path = os__path.join(str_Project_Relative_Path, str_Batch_Scenario_Relative_Path__New)
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Batch_Scenario
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Batch_Scenario = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Scenario_UID, os__extsep, str_Extension]))        
        
        
        ''' Batch settings '''
        str_Path = os__path.join(str_Project_Relative_Path, str_Batch_Scenario_Relative_Path__New)
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Batch_Settings
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Batch_Settings = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Scenario_UID, os__extsep, str_Extension]))        

        '''
        ------------------------------------------
        Get Project Details from Current Project File
        ------------------------------------------
        '''
        ''' Read PROJECT file '''
        obj_Config = object_SSConfigProject()
        obj_Config = self.func_Read_Config_File(str_Project__Relative_Path_And_File, obj_Config, True)
            
        str_Project_Name = self.str_Project_Name
        str_Project_UID = str(self.int_Project_UID)
        str_Project_Species_Name = self.str_Project_Species_Name        
        
        '''
        ------------------------------------------
        Create new BATCH SCENARIOS Files
        ------------------------------------------
        '''
        self.func_Create_FRESH_BATCH_Cloned_SCENARIO_Files(str_Project_UID, str_Datetime_Stamp_New_Scenario_UID, str_Config_File_Relative_Path_And_Name__Batch_Scenario, str_Config_File_Relative_Path_And_Name__Batch_Settings, str_Project_Name, str_Project_Species_Name, str_Scenario__Relative_Path_And_File, str_Scenario_Name)
        
        '''
        ------------------------------------------
        UPDATE PROJECT file with new SCENARIO
        ------------------------------------------
        '''       
        ''' <<<<<<< SECTION: Project_Scenario_File_List '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Scenario_File_List
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Scenario_File + '_' + str_Datetime_Stamp_New_Scenario_UID
        value_Option = str_Config_File_Relative_Path_And_Name__Batch_Scenario
        ''' Update the OPTION '''
        bool_Success, obj_Config = self.func_Update_Config_File(str_Project__Relative_Path_And_File, obj_Config, str_Section, str_Option, value_Option, True)


        ''' <<<<<<< SECTION: Project_Scenario_Name_List '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Scenario_Name_List
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Scenario_Name + '_' + str_Datetime_Stamp_New_Scenario_UID
        value_Option = str_Scenario_Name
        ''' Update the OPTION '''
        bool_Success, obj_Config = self.func_Update_Config_File(str_Project__Relative_Path_And_File, obj_Config, str_Section, str_Option, value_Option, True)

        if bool_Success:
            ''' Refresh the comboBox with new data ''' 
            self.func_QComboBox_SCENARIOS_add(str_Project__Relative_Path_And_File)
        pass
                    
        return True
    
    def func_Create_New_SCENARIO(self, str_Project__Relative_Path_And_File, str_Scenario_Name):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        ''' Get UID for the new project '''
        str_Datetime_Stamp_New_Scenario_UID = self.func_Get_New_PROJECT_UID()
        
        '''
        ------------------------------------------
        Create new filenames
        ------------------------------------------
        '''
        str_Project__Relative_Path, _ = os__path.split(str_Project__Relative_Path_And_File)
        str_Batch_Scenario_Relative_Path__New = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str_Datetime_Stamp_New_Scenario_UID

        ''' Batch scenario '''
        str_Path = os__path.join(str_Project__Relative_Path, str_Batch_Scenario_Relative_Path__New)
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Batch_Scenario
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Batch_Scenario = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Scenario_UID, os__extsep, str_Extension]))        
        
        
        ''' Batch settings '''
        str_Path = os__path.join(str_Project__Relative_Path, str_Batch_Scenario_Relative_Path__New)
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Batch_Settings
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Batch_Settings = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Scenario_UID, os__extsep, str_Extension]))        

        '''
        ------------------------------------------
        Get Project Details from Current Project File
        ------------------------------------------
        '''
        ''' Read PROJECT file '''
        obj_Config = object_SSConfigProject()
        obj_Config = self.func_Read_Config_File(str_Project__Relative_Path_And_File, obj_Config, True)
        
        ''' Get the data from the config_parser_Config '''
        self.func_Get_Config_Data__PROJECT(obj_Config)
    
        str_Project_Name = self.str_Project_Name__Current
        str_Project_UID = str(self.int_Project_UID)
        str_Project_Species_Name = self.str_Project_Species_Name        
        
        str_Scenario_path = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(str_Datetime_Stamp_New_Scenario_UID)
        ''' For new Scenarios always prime with the default work path '''
        self.str_BackEnd_Working_Base_Path = self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value
        str_Scenario_Run_Simulation_Output_Base_Path = os__path.join(self.str_BackEnd_Working_Base_Path, str_Scenario_path)
        
        '''
        ------------------------------------------
        Create new BATCH SCENARIOS Files
        ------------------------------------------
        '''
        self.func_Create_FRESH_BATCH_SCENARIO_Files(str_Project_UID, str_Datetime_Stamp_New_Scenario_UID, str_Config_File_Relative_Path_And_Name__Batch_Scenario, str_Config_File_Relative_Path_And_Name__Batch_Settings, str_Project_Name, str_Project_Species_Name, str_Scenario_Name, str_Scenario_Run_Simulation_Output_Base_Path)
        
        '''
        ------------------------------------------
        UPDATE PROJECT file with new SCENARIO
        ------------------------------------------
        '''       
        ''' <<<<<<< SECTION: Project_Scenario_File_List '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Scenario_File_List
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Scenario_File + '_' + str_Datetime_Stamp_New_Scenario_UID
        value_Option = str_Config_File_Relative_Path_And_Name__Batch_Scenario
        ''' Update the OPTION '''
        bool_Success, obj_Config = self.func_Update_Config_File(str_Project__Relative_Path_And_File, obj_Config, str_Section, str_Option, value_Option, True)


        ''' <<<<<<< SECTION: Project_Scenario_Name_List '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Scenario_Name_List
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Scenario_Name + '_' + str_Datetime_Stamp_New_Scenario_UID
        value_Option = str_Scenario_Name
        ''' Update the OPTION '''
        bool_Success, obj_Config = self.func_Update_Config_File(str_Project__Relative_Path_And_File, obj_Config, str_Section, str_Option, value_Option, True)

        if bool_Success:
            ''' Refresh the comboBox with new data ''' 
            self.func_QComboBox_SCENARIOS_add(str_Project__Relative_Path_And_File)
        pass
                    
        return True
    
    def func_Create_New_SAMPLING_STRATEGY(self, str_Project__Relative_Path_And_File, str_Batch_Scenario__Relative_Path_And_File, str_Sampling_Strategy_Name):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        ''' Get UID for the new project '''
        str_Datetime_Stamp_New_Sampling_Strategy_UID = self.func_Get_New_PROJECT_UID()
        
        '''
        ------------------------------------------
        Create new filenames
        ------------------------------------------
        '''
        str_Batch_Scenario_Relative_Path, _ = os__path.split(str_Batch_Scenario__Relative_Path_And_File)
        str_Sampling_Strategy_Relative_Path = os__path.join(str_Batch_Scenario_Relative_Path, self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID)
        ''' Sampling Strategy '''
        str_Path = str_Sampling_Strategy_Relative_Path
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Sampling_Strategy
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Sampling_Strategy = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID, os__extsep, str_Extension]))        

        '''
        ------------------------------------------
        Get Project Details from Current Project File
        ------------------------------------------
        '''
        ''' Read PROJECT file '''
        obj_Config = object_SSConfigProject()
        obj_Config = self.func_Read_Config_File(str_Project__Relative_Path_And_File, obj_Config, True)
        ''' Get the data from the config_parser_Config '''
        self.func_Get_Config_Data__PROJECT(obj_Config)
            
        str_Project_Name = self.str_Project_Name__Current
        str_Project_UID = str(self.int_Project_UID)
        str_Project_Species_Name = self.str_Project_Species_Name
        '''
        ------------------------------------------
        Get Batch Scenario data from Current Batch Scenario File
        ------------------------------------------
        '''
        ''' Read BATCH SCENARIO file '''
        obj_Config = object_SSConfigBatchScenario()
        obj_Config = self.func_Read_Config_File(str_Batch_Scenario__Relative_Path_And_File, obj_Config, True)
        ''' Get the data from the config_parser_Config '''
        self.func_Get_Config_Data__BATCH_SCENARIO(obj_Config)
               
        str_Scenario_Name = self.str_Scenario_Name__Current
        str_Scenario_UID = str(self.int_Batch_Scenario_UID__Current)

        str_Scenario_path = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str_Scenario_UID
        #str_Sampling_Strategy_path = self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID
        #str_Sampling_Strategy_Run_Simulation_Output_Base_Path = os__path.join(self.str_BackEnd_Working_Base_Path, str_Scenario_path, str_Sampling_Strategy_path)
        str_Sampling_Strategy_Run_Simulation_Output_Base_Path = os__path.join(self.str_BackEnd_Working_Base_Path, str_Scenario_path)
        
        '''
        ------------------------------------------
        Create new SAMPLING_STRATEGY File
        ------------------------------------------
        '''
        bool_Success = self.func_Create_FRESH_SAMPLING_STRATEGY_File(str_Config_File_Relative_Path_And_Name__Sampling_Strategy, str_Datetime_Stamp_New_Sampling_Strategy_UID, str_Project_Name, str_Project_UID, str_Project_Species_Name, str_Batch_Scenario__Relative_Path_And_File, str_Scenario_Name, str_Scenario_UID, str_Sampling_Strategy_Run_Simulation_Output_Base_Path, str_Sampling_Strategy_Name)
        if bool_Success:
            self.str_Sampling_Strategy_Path_And_File__Current = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name__Sampling_Strategy)
        pass
        '''
        ------------------------------------------
        UPDATE BATCH_SCENARIO file with new SAMPLING_STRATEGY
        ------------------------------------------
        '''       
        obj_Config =self.obj_Config_Batch_Scenario

        ''' <<<<<<< SECTION: Scenario_Sampling_Strategy_File_List '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Scenario_Sampling_Strategy_File_List
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Scenario_Sampling_Strategy_File + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID
        value_Option = str_Config_File_Relative_Path_And_Name__Sampling_Strategy
        ''' Update the OPTION '''
        bool_Success, obj_Config = self.func_Update_Config_File(str_Batch_Scenario__Relative_Path_And_File, obj_Config, str_Section, str_Option, value_Option, True)

        ''' <<<<<<< SECTION: Scenario_Sampling_Strategy_Name_List '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Scenario_Sampling_Strategy_Name_List
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Scenario_Sampling_Strategy_Name + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID
        value_Option = str_Sampling_Strategy_Name
        ''' Update the OPTION '''
        bool_Success, obj_Config = self.func_Update_Config_File(str_Batch_Scenario__Relative_Path_And_File, obj_Config, str_Section, str_Option, value_Option, True)
                                      
        return bool_Success

    def func_Create_New_Cloned_SAMPLING_STRATEGY(self, str_Project__Relative_Path_And_File, str_Batch_Scenario__Relative_Path_And_File, str_Sampling_Strategy_To_Clone_Relative_Path_File, str_Sampling_Strategy_Name):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        ''' Get UID for the new project '''
        str_Datetime_Stamp_New_Sampling_Strategy_UID = self.func_Get_New_PROJECT_UID()
        
        '''
        ------------------------------------------
        Create new filenames
        ------------------------------------------
        '''
        str_Batch_Scenario_Relative_Path, _ = os__path.split(str_Batch_Scenario__Relative_Path_And_File)
        str_Sampling_Strategy_Relative_Path = os__path.join(str_Batch_Scenario_Relative_Path, self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID)
        ''' Sampling Strategy '''
        str_Path = str_Sampling_Strategy_Relative_Path
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Sampling_Strategy
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Sampling_Strategy = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID, os__extsep, str_Extension]))        

        '''
        ------------------------------------------
        Get Project Details from Current Project File
        ------------------------------------------
        '''
        ''' Read PROJECT file '''
        obj_Config = object_SSConfigProject()
        obj_Config = self.func_Read_Config_File(str_Project__Relative_Path_And_File, obj_Config, True)
        self.func_Get_Config_Data__PROJECT(obj_Config)
        
        str_Project_Name = self.str_Project_Name__Current
        str_Project_UID = str(self.int_Project_UID)
        str_Project_Species_Name = self.str_Project_Species_Name
        '''
        ------------------------------------------
        Get Batch Scenario data from Current Batch Scenario File
        ------------------------------------------
        '''
        obj_Config = object_SSConfigBatchScenario()
        obj_Config = self.func_Read_Config_File(str_Batch_Scenario__Relative_Path_And_File, obj_Config, True)
        self.func_Get_Config_Data__BATCH_SCENARIO(obj_Config)
    
        str_Scenario_Name = self.str_Scenario_Name__Current
        str_Scenario_UID = str(self.int_Batch_Scenario_UID__Current)

        '''
        ------------------------------------------
        Create new SAMPLING STRATEGY File
        ------------------------------------------
        '''
        self.func_Create_FRESH_BATCH_Cloned_SAMPLING_STRATEGY_File(str_Sampling_Strategy_To_Clone_Relative_Path_File, str_Config_File_Relative_Path_And_Name__Sampling_Strategy, str_Sampling_Strategy_Name, str_Datetime_Stamp_New_Sampling_Strategy_UID)
        
        '''
        ------------------------------------------
        UPDATE BATCH_SCENARIO file with new SAMPLING_STRATEGY
        ------------------------------------------
        '''       
        obj_Config =self.obj_Config_Batch_Scenario

        ''' <<<<<<< SECTION: Scenario_Sampling_Strategy_File_List '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Scenario_Sampling_Strategy_File_List
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Scenario_Sampling_Strategy_File + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID
        value_Option = str_Config_File_Relative_Path_And_Name__Sampling_Strategy
        ''' Update the OPTION '''
        bool_Success, obj_Config = self.func_Update_Config_File(str_Batch_Scenario__Relative_Path_And_File, obj_Config, str_Section, str_Option, value_Option, True)
                                
        ''' <<<<<<< SECTION: Scenario_Sampling_Strategy_Name_List '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Scenario_Sampling_Strategy_Name_List
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Scenario_Sampling_Strategy_Name + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID
        value_Option = str_Sampling_Strategy_Name
        ''' Update the OPTION '''
        bool_Success, obj_Config = self.func_Update_Config_File(str_Batch_Scenario__Relative_Path_And_File, obj_Config, str_Section, str_Option, value_Option, True)
                                
        return bool_Success
 
    def func_Create_New_PROJECT_and_SCENARIO(self, str_Project_Name, str_Project_Species_Name, str_Scenario_Name):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        ''' Get UID for the new project '''
        str_Datetime_Stamp_New_Project_UID = self.func_Get_New_PROJECT_UID()
        str_Project_UID = str_Datetime_Stamp_New_Project_UID
        
        ''' Specify new folders '''
        str_Project_Relative_Path__New = self.str_Settings_Run_Project_Folder_Prefix__Default_Value + '_' + str_Datetime_Stamp_New_Project_UID
        str_Batch_Scenario_Relative_Path__New = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str_Datetime_Stamp_New_Project_UID
        
        '''
        ------------------------------------------
        Create new filenames
        ------------------------------------------
        '''
        ''' Project '''
        str_Path = str_Project_Relative_Path__New
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Project
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Project = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Project_UID, os__extsep, str_Extension]))        
                                                     
        ''' Batch scenario '''
        str_Path = os__path.join(str_Project_Relative_Path__New, str_Batch_Scenario_Relative_Path__New)
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Batch_Scenario
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Batch_Scenario = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Project_UID, os__extsep, str_Extension]))        
        
        
        ''' Batch settings '''
        str_Path = os__path.join(str_Project_Relative_Path__New, str_Batch_Scenario_Relative_Path__New)
        str_Base_Filename = globalsSSFE.App_File.static_str__App_File_Prefix__Batch_Settings
        str_Extension = self.str_Settings_Run_File_Extension_Config_File__Default_Value
        str_Config_File_Relative_Path_And_Name__Batch_Settings = os__path.join(str_Path, ''.join([str_Base_Filename + '_' + str_Datetime_Stamp_New_Project_UID, os__extsep, str_Extension]))        

        str_Scenario_path = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(str_Datetime_Stamp_New_Project_UID)
        ''' For new Scenarios always prime with the default work path '''
        self.str_BackEnd_Working_Base_Path = self.str_Settings_Run_BackEnd_Working_Base_Path__Default_Value
        str_Scenario_Run_Simulation_Output_Base_Path = os__path.join(self.str_BackEnd_Working_Base_Path, str_Scenario_path)

        '''
        ------------------------------------------
        Create new BATCH SCENARIOS Files
        ------------------------------------------
        '''
        self.func_Create_FRESH_BATCH_SCENARIO_Files(str_Project_UID, str_Datetime_Stamp_New_Project_UID, str_Config_File_Relative_Path_And_Name__Batch_Scenario, str_Config_File_Relative_Path_And_Name__Batch_Settings, str_Project_Name, str_Project_Species_Name, str_Scenario_Name,str_Scenario_Run_Simulation_Output_Base_Path)

        '''
        ------------------------------------------
        Create new Project File
        ------------------------------------------
        '''
        self.func_Create_New_PROJECT_File(str_Datetime_Stamp_New_Project_UID, str_Config_File_Relative_Path_And_Name__Project, str_Project_Name, str_Project_Species_Name, str_Config_File_Relative_Path_And_Name__Batch_Scenario, str_Scenario_Name)
        
        
        return True
    
    def func_Create_New_PROJECT_File(self, str_Datetime_Stamp_New_Project_UID, str_Config_File_Relative_Path_And_Name__Project, str_Project_Name, str_Project_Species_Name, str_Config_File_Relative_Path_And_Name__Batch_Scenario, str_Scenario_Name):        

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        '''
        ------------------------------------------
        Create new Project File
        ------------------------------------------
        '''
        obj_SSConfig = object_SSConfigProject()
        dict_Section_Key_Option_Value_Tuple = OrderedDict()
        
        ''' >>>>>>>>> Project_Details '''
        str_Section = obj_SSConfig.static_str_Section__Project_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Project_Name
        value_Option = str_Project_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Project_UID
        value_Option = str_Datetime_Stamp_New_Project_UID
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Project_Species_Name
        value_Option = str_Project_Species_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        
        ''' >>>>>>>>> Scenario_File_List '''
        str_Section = obj_SSConfig.static_str_Section__Scenario_File_List
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Scenario_File + '_' + str_Datetime_Stamp_New_Project_UID
        value_Option = str_Config_File_Relative_Path_And_Name__Batch_Scenario
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        ''' >>>>>>>>> Scenario_Name_List '''
        str_Section = obj_SSConfig.static_str_Section__Scenario_Name_List
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Scenario_Name + '_' + str_Datetime_Stamp_New_Project_UID
        value_Option = str_Scenario_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        '''
        ---------------------------------
        Create the config file from the dict values 
        ---------------------------------
        '''
        with SSConfigOperation() as obj_ConfigOp:
            str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name__Project)
            strUniqueRunID = 'GUI'
            str_INI_UID_DateTime_Stamp = str_Datetime_Stamp_New_Project_UID
            bool_Success = obj_ConfigOp.func_Create_FRESH_Config_File(strUniqueRunID, str_INI_UID_DateTime_Stamp, str_Config_File_FULL_Path_And_Name, dict_Section_Key_Option_Value_Tuple, obj_SSConfig)
        pass        
        ''' Read the new Project to initialise the global config_parser_Config '''
        #self.func_Read_Config_File__PROJECT(str_Config_File_Path_And_Name__Project)
        
        '''
        ------------------------------------------
        UPDATE projects file with new project
        ------------------------------------------
        ''' 
        bool_Success = False
        
        obj_Config = self.obj_Config_Projects
        
        ''' <<<<<<< SECTION: Project_File_List '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Project_File_List
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Project_File + '_' + str_Datetime_Stamp_New_Project_UID
        value_Option = str_Config_File_Relative_Path_And_Name__Project
        ''' Update the OPTION '''
        bool_Success, obj_Config = self.func_Update_Config_File(self.str_Application_Projects_Path_And_File, obj_Config, str_Section, str_Option, value_Option, True)

        ''' <<<<<<< SECTION: Project_Name_List '''
        ''' Specify SECTION to UPDATE '''
        str_Section = obj_Config.static_str_Section__Project_Name_List
        ''' Specify OPTION to UPDATE '''
        str_Option = obj_Config.static_str_Option__Project_Name + '_' + str_Datetime_Stamp_New_Project_UID
        value_Option = str_Project_Name
        ''' Update the OPTION '''
        bool_Success, obj_Config = self.func_Update_Config_File(self.str_Application_Projects_Path_And_File, obj_Config, str_Section, str_Option, value_Option, True)
        
        if bool_Success:
            self.func_Initialise_PROJECT_Widgets_With_Data(self.str_Application_Projects_Path_And_File)
        pass       
     
        return True
    
    def func_Create_FRESH_SAMPLING_STRATEGY_File(self, str_Config_File_Relative_Path_And_Name__Sampling_Strategy, str_Datetime_Stamp_New_Sampling_Strategy_UID, str_Project_Name, str_Project_UID, str_Project_Species_Name, str_Config_File_Relative_Path_And_Name__Batch_Scenario, str_Scenario_Name, str_Scenario_UID, str_Sampling_Strategy_Run_Simulation_Output_Base_Path, str_Sampling_Strategy_Name):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        '''
        ------------------------------------------
        Create fresh SAMPLING STRATEGY File
        ------------------------------------------
        '''
        obj_SSConfig = object_SSConfigSamplingStrategy()
        dict_Section_Key_Option_Value_Tuple = OrderedDict()
        
        ''' >>>>>>>>> Project_Details '''
        str_Section = obj_SSConfig.static_str_Section__Scenario_Project_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Scenario_Project_Name
        value_Option = str_Project_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Scenario_Project_UID
        value_Option = str_Project_UID
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Scenario_Project_UID
        value_Option = str_Project_UID
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Scenario_Project_Species_Name
        value_Option = str_Project_Species_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        
        ''' >>>>>>>>> Scenario_Details '''
        str_Section = obj_SSConfig.static_str_Section__Scenario_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Scenario_Name
        value_Option = str_Scenario_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Scenario_UID
        value_Option = str_Scenario_UID
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
                
        ''' >>>>>>>>> Batch_Scenario '''
        str_Section = obj_SSConfig.static_str_Section__Sampling_Strategy_Batch_Scenario
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Scenario_File
        value_Option = str_Config_File_Relative_Path_And_Name__Batch_Scenario
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
                
        ''' >>>>>>>>> Sampling_Strategy_Details '''
        str_Section = obj_SSConfig.static_str_Section__Sampling_Strategy_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Name
        value_Option = str_Sampling_Strategy_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_UID
        value_Option = str_Datetime_Stamp_New_Sampling_Strategy_UID
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 

        
        ''' >>>>>>>>> Sampling_Strategy_Run_Details '''
        str_Section = obj_SSConfig.static_str_Section__Sampling_Strategy_Run_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Run_Ne_Estimator_External_Process_Version
        value_Option = self.str_Sampling_Strategy_Run_Settings_Ne_Estimator_External_Process_Version__Default_Value
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Run_Simulation_Working_Base_Path
        #value_Option = os__path.split(os__path.split(str_Sampling_Strategy_Run_Simulation_Output_Base_Path)[0])[0]
        value_Option = os__path.split(str_Sampling_Strategy_Run_Simulation_Output_Base_Path)[0]
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Run_Simulation_Output_Base_Path
        value_Option = str_Sampling_Strategy_Run_Simulation_Output_Base_Path
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds
        value_Option = self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Run_Time_Max_Seconds__Default_Value
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count
        value_Option = self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Repeat_FAILED_Max_Count__Default_Value
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed
        value_Option = self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed__Default_Value
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed
        value_Option = self.int_Sampling_Strategy_Run_Settings_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed__Default_Value
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS
        value_Option = str(self.dict_Sampling_Strategy_Run_Settings_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS__Default_Value).replace('{','').replace('}','').replace("'", "").replace(' ', '')
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS
        value_Option = str(self.dict_Sampling_Strategy_Run_Settings_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS__Default_Value).replace('{','').replace('}','').replace("'", "").replace(' ', '')
        if not (value_Option == ''):
            list_tup_Option_Value.append((str_Option, value_Option))
        pass
    
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 

        ''' >>>>>>>>> LDNe_Details '''
        str_Section = obj_SSConfig.static_str_Section__Sampling_Strategy_LDNe_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
        value_Option = self.float_Settings_Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep__Default_Value
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 

        
        '''
        ---------------------------------
        Create the config file from the dict values 
        ---------------------------------
        '''
        with SSConfigOperation() as obj_ConfigOp:
            str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name__Sampling_Strategy)
            strUniqueRunID = 'GUI'
            str_INI_UID_DateTime_Stamp = str_Datetime_Stamp_New_Sampling_Strategy_UID
            bool_Success = obj_ConfigOp.func_Create_FRESH_Config_File(strUniqueRunID, str_INI_UID_DateTime_Stamp, str_Config_File_FULL_Path_And_Name, dict_Section_Key_Option_Value_Tuple, obj_SSConfig)
            if not bool_Success:
                return False
            pass
        pass        
        

        return bool_Success

    def func_Create_FRESH_BATCH_Cloned_SAMPLING_STRATEGY_File(self, *args):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        str_Sampling_Strategy_To_Clone_Relative_Path_File, str_Config_File_Relative_Path_And_Name__Sampling_Strategy, str_Sampling_Strategy_Name, str_Datetime_Stamp_New_Sampling_Strategy_UID = args
        
        '''
        ------------------------------------------
        Read SAMPLING STRATEGY File to clone
        ------------------------------------------
        '''
        ''' Read SAMPLING STRATEGY file '''
        obj_Config = object_SSConfigSamplingStrategy()
        obj_Config = self.func_Read_Config_File(str_Sampling_Strategy_To_Clone_Relative_Path_File, obj_Config, True)
        
        ''' Read the Batch Settings file using the Path and Filename from Batch Scenario '''
        config_parser_Config = obj_Config.config_parser_Config
        if config_parser_Config != None:
            bool_Success = True
        pass        

        if bool_Success:

            '''
            ------------------------------------------
            Clone new SAMPLING_STRATEGY File
            ------------------------------------------
            '''

            ''' >>>>>>>>> Sampling_Strategy_Details '''
            str_Section = obj_Config.static_str_Section__Sampling_Strategy_Details
            
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Name
            value_Option = str_Sampling_Strategy_Name                  
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)

            str_Option = obj_Config.static_str_Option__Sampling_Strategy_UID
            value_Option = str_Datetime_Stamp_New_Sampling_Strategy_UID                  
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)

            ''' >>>>>>>>> Sampling_Strategy_Run_Details '''
            str_Scenario_path = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current)
            str_Sampling_Strategy_Run_Simulation_Output_Base_Path = os__path.join(self.str_BackEnd_Working_Base_Path, str_Scenario_path)

            str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details
            
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Simulation_Working_Base_Path
            value_Option = self.str_BackEnd_Working_Base_Path       
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)

            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Simulation_Output_Base_Path
            value_Option = str_Sampling_Strategy_Run_Simulation_Output_Base_Path                  
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
            
            ''' >>>>>>>>> LDNe_Details '''
            str_Section = obj_Config.static_str_Section__Sampling_Strategy_LDNe_Details
    
            str_Option = obj_Config.static_str_Option__Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep
            if self.bool_float_Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep__FOUND:
                value_Option = self.float_Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep 
            else:
                value_Option = self.float_Settings_Sampling_Strategy_LDNe_FULL_Estimates__Percentage_Of_Loci_To_Keep__Default_Value
            pass
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
            
            '''
            ---------------------------------------------------
            Remove unwanted SECTIONS & OPTIONS from config
            ---------------------------------------------------
            '''
            
            ''' >>>>>>>>> Sampling_Strategy_Last_Run_Details '''
            str_Section = obj_Config.static_str_Section__Sampling_Strategy_Last_Run_Details
            obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)

            '''
            -------------------------------------
            Write cloned config file
            -------------------------------------
            '''
            str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name__Sampling_Strategy)
            bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, str_Config_File_FULL_Path_And_Name)
        pass
    
        return True

    def func_Create_FRESH_BATCH_SCENARIO_Files(self, str_Project_UID, str_Datetime_Stamp_New_Project_UID, str_Config_File_Relative_Path_And_Name__Batch_Scenario, str_Config_File_Relative_Path_And_Name__Batch_Settings, str_Project_Name, str_Project_Species_Name, str_Scenario_Name, str_Scenario_Run_Simulation_Output_Base_Path):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        '''
        ------------------------------------------
        Create new Batch Scenario File
        ------------------------------------------
        '''
        obj_SSConfig = object_SSConfigBatchScenario()
        dict_Section_Key_Option_Value_Tuple = OrderedDict()
        
        ''' >>>>>>>>> Project_Details '''
        str_Section = obj_SSConfig.static_str_Section__Scenario_Project_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Scenario_Project_Name
        value_Option = str_Project_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Scenario_Project_UID
        value_Option = str_Project_UID
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Scenario_Project_Species_Name
        value_Option = str_Project_Species_Name
        list_tup_Option_Value.append((str_Option, value_Option))
                
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        
        ''' >>>>>>>>> Scenario_Details '''
        str_Section = obj_SSConfig.static_str_Section__Scenario_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Scenario_Name
        value_Option = str_Scenario_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Scenario_UID
        value_Option = str_Datetime_Stamp_New_Project_UID
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        ''' >>>>>>>>> Batch_Settings '''
        str_Section = obj_SSConfig.static_str_Section__Scenario_Batch_Settings
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Scenario_Batch_Settings_File
        value_Option = str_Config_File_Relative_Path_And_Name__Batch_Settings
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        ''' >>>>>>>>> Scenario_Run_Details '''
        str_Section = obj_SSConfig.static_str_Section__Scenario_Run_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Scenario_Run_Simulation_Working_Base_Path
        value_Option, _ = os__path.split(str_Scenario_Run_Simulation_Output_Base_Path)
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Scenario_Run_Simulation_Output_Base_Path
        value_Option = str_Scenario_Run_Simulation_Output_Base_Path
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        '''
        ---------------------------------
        Create the config file from the dict values 
        ---------------------------------
        '''
        with SSConfigOperation() as obj_ConfigOp:
            str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name__Batch_Scenario)
            strUniqueRunID = 'GUI'
            str_INI_UID_DateTime_Stamp = str_Datetime_Stamp_New_Project_UID
            bool_Success = obj_ConfigOp.func_Create_FRESH_Config_File(strUniqueRunID, str_INI_UID_DateTime_Stamp, str_Config_File_FULL_Path_And_Name, dict_Section_Key_Option_Value_Tuple, obj_SSConfig)
        pass
        '''
        ------------------------------------------
        Create new Batch Settings File
        ------------------------------------------
        '''
        obj_SSConfig = object_SSConfigBatchSettings()
        dict_Section_Key_Option_Value_Tuple = OrderedDict()
        
        ''' >>>>>>>>> Project_Details '''
        str_Section = obj_SSConfig.static_str_Section__Batch_Setting_Project_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Batch_Setting_Details__Project_Name
        value_Option = str_Project_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Batch_Setting_Details__Project_UID
        value_Option = str_Project_UID
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Batch_Setting_Details__Project_Species_Name
        value_Option = str_Project_Species_Name
        list_tup_Option_Value.append((str_Option, value_Option))
                
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        
        ''' >>>>>>>>> Batch_Setting_Details '''
        str_Section = obj_SSConfig.static_str_Section__Batch_Setting_Details
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Batch_Setting_Details__Scenario_Name
        value_Option = str_Scenario_Name
        list_tup_Option_Value.append((str_Option, value_Option))
        
        str_Option = obj_SSConfig.static_str_Option__Batch_Setting_Details__Scenario_UID
        value_Option = str_Datetime_Stamp_New_Project_UID
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        ''' >>>>>>>>> Batch_Scenario '''
        str_Section = obj_SSConfig.static_str_Section__Batch_Setting_Batch_Scenario
        list_tup_Option_Value = []

        str_Option = obj_SSConfig.static_str_Option__Batch_Setting_Scenario_File
        value_Option = str_Config_File_Relative_Path_And_Name__Batch_Scenario
        list_tup_Option_Value.append((str_Option, value_Option))
        
        dict_Section_Key_Option_Value_Tuple[str_Section] = list_tup_Option_Value 
        
        '''
        ---------------------------------
        Create the config file from the dict values 
        ---------------------------------
        '''
        with SSConfigOperation() as obj_ConfigOp:
            str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name__Batch_Settings)
            strUniqueRunID = 'GUI'
            str_INI_UID_DateTime_Stamp = str_Datetime_Stamp_New_Project_UID
            bool_Success = obj_ConfigOp.func_Create_FRESH_Config_File(strUniqueRunID, str_INI_UID_DateTime_Stamp, str_Config_File_FULL_Path_And_Name, dict_Section_Key_Option_Value_Tuple, obj_SSConfig)
        pass        

        return True
        
    def func_Create_FRESH_BATCH_Cloned_SCENARIO_Files(self, str_Project_UID, str_Datetime_Stamp_New_Scenario_UID, str_Config_File_Relative_Path_And_Name__Batch_Scenario, str_Config_File_Relative_Path_And_Name__Batch_Settings, str_Project_Name, str_Project_Species_Name, str_Scenario__Relative_Path_And_File__To_Clone, str_Scenario_Name):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        bool_Success = False
        '''
        ------------------------------------------
        Read Batch Scenario File to clone
        ------------------------------------------
        '''
        
        ''' Read the Batch Scenario file '''
        obj_Config_BS = object_SSConfigBatchScenario()
        obj_Config_BS = self.func_Read_Config_File(str_Scenario__Relative_Path_And_File__To_Clone, obj_Config_BS, True)
        ''' Check if successfull '''
        bool_Success = False
        if obj_Config_BS.config_parser_Config != None:
            bool_Success = True
        pass        

    
        '''NOTE: Need to get the Sampling Strategy filenames (if they exist) from Batch Scenario '''
        if bool_Success:
            list_Sampling_Strategy_Files, _ = self.func_Get_Config_File_List_Of_SAMPLING_STRATEGIES_from_BATCH_SCENARIO(obj_Config_BS)
        pass

        '''NOTE: Need to get the batch settings filename from Batch Scenario BEFORE obj_Config_BS is overwritten'''
        if obj_Config_BS.config_parser_Config != None:
            str_Section = obj_Config_BS.static_str_Section__Scenario_Batch_Settings
            str_Option = obj_Config_BS.static_str_Option__Scenario_Batch_Settings_File
            str_Batch_Settings_File_Relative_Path_And_Name = obj_Config_BS.func_Read_Config_File_OPTION(str_Section, str_Option, value_Type='')
        pass
        
        if bool_Success:

            '''
            ------------------------------------------
            Clone new Batch Scenario File
            ------------------------------------------
            '''
                
            ''' >>>>>>>>> Project_Details '''
            str_Section = obj_Config_BS.static_str_Section__Scenario_Project_Details
            
            str_Option = obj_Config_BS.static_str_Option__Scenario_Project_Name
            value_Option = str_Project_Name                  
            obj_Config_BS.config_parser_Config = obj_Config_BS.func_Set_Values_in_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section, str_Option, value_Option)

            str_Option = obj_Config_BS.static_str_Option__Scenario_Project_UID
            value_Option = str_Project_UID                  
            obj_Config_BS.config_parser_Config = obj_Config_BS.func_Set_Values_in_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section, str_Option, value_Option)

            str_Option = obj_Config_BS.static_str_Option__Scenario_Project_Species_Name
            value_Option = str_Project_Species_Name                  
            obj_Config_BS.config_parser_Config = obj_Config_BS.func_Set_Values_in_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section, str_Option, value_Option)

            ''' >>>>>>>>> Scenario_Details '''
            str_Section = obj_Config_BS.static_str_Section__Scenario_Details
            
            str_Option = obj_Config_BS.static_str_Option__Scenario_Name
            value_Option = str_Scenario_Name                  
            obj_Config_BS.config_parser_Config = obj_Config_BS.func_Set_Values_in_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section, str_Option, value_Option)

            str_Option = obj_Config_BS.static_str_Option__Scenario_UID
            value_Option = str_Datetime_Stamp_New_Scenario_UID                  
            obj_Config_BS.config_parser_Config = obj_Config_BS.func_Set_Values_in_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section, str_Option, value_Option)

            ''' >>>>>>>>> Batch_Settings '''
            str_Section = obj_Config_BS.static_str_Section__Scenario_Batch_Settings
            
            str_Option = obj_Config_BS.static_str_Option__Scenario_Batch_Settings_File
            value_Option = str_Config_File_Relative_Path_And_Name__Batch_Settings                  
            obj_Config_BS.config_parser_Config = obj_Config_BS.func_Set_Values_in_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section, str_Option, value_Option)


            ''' >>>>>>>>> Scenario_Run_Details '''
            str_Scenario_path = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(str_Datetime_Stamp_New_Scenario_UID)
            str_Scenario_Run_Simulation_Output_Base_Path = os__path.join(self.str_BackEnd_Working_Base_Path, str_Scenario_path)
            
            str_Section = obj_Config_BS.static_str_Section__Scenario_Run_Details
            
            str_Option = obj_Config_BS.static_str_Option__Scenario_Run_Simulation_Working_Base_Path
            value_Option = self.str_BackEnd_Working_Base_Path                  
            obj_Config_BS.config_parser_Config = obj_Config_BS.func_Set_Values_in_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section, str_Option, value_Option)
            
            str_Option = obj_Config_BS.static_str_Option__Scenario_Run_Simulation_Output_Base_Path
            value_Option = str_Scenario_Run_Simulation_Output_Base_Path                  
            obj_Config_BS.config_parser_Config = obj_Config_BS.func_Set_Values_in_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section, str_Option, value_Option)


            '''
            ---------------------------------------------------
            Remove unwanted SECTIONS & OPTIONS from config
            ---------------------------------------------------
            '''
            
            ''' >>>>>>>>> Scenario_Sampling_Strategy_File_List '''
            str_Section = obj_Config_BS.static_str_Section__Scenario_Sampling_Strategy_File_List
            obj_Config_BS.func_Remove_SECTION_From_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section)

            ''' >>>>>>>>> Scenario_Sampling_Strategy_Name_List '''
            str_Section = obj_Config_BS.static_str_Section__Scenario_Sampling_Strategy_Name_List
            obj_Config_BS.func_Remove_SECTION_From_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section)

            '''
            -------------------------------------
            DONT Write cloned BATCH_SCENARIO config file until end
            -------------------------------------
            '''

        pass
    
        bool_Success = False
        '''
        ------------------------------------------
        Read Batch Scenario File to clone
        ------------------------------------------
        '''
        ''' Read the Batch Settings file '''
        obj_Config = object_SSConfigBatchSettings()
        obj_Config = self.func_Read_Config_File(str_Batch_Settings_File_Relative_Path_And_Name, obj_Config, True)
        #obj_Config = self.func_Read_Config_File(str_Batch_Settings_File_Path_And_Name, obj_Config)
        config_parser_Config = obj_Config.config_parser_Config
        ''' Check if successfull '''
        bool_Success = False
        if config_parser_Config != None:
            bool_Success = True
        pass       
            
        if bool_Success:
            bool_Success = False                
            '''
            ------------------------------------------
            Clone new Batch Settings File
            ------------------------------------------
            '''

            ''' >>>>>>>>> Project_Details '''
            str_Section = obj_Config.static_str_Section__Batch_Setting_Project_Details
            
            str_Option = obj_Config.static_str_Option__Batch_Setting_Details__Project_Name
            value_Option = str_Project_Name                  
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)

            str_Option = obj_Config.static_str_Option__Batch_Setting_Details__Project_UID
            value_Option = str_Project_UID                  
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)

            str_Option = obj_Config.static_str_Option__Batch_Setting_Details__Project_Species_Name
            value_Option = str_Project_Species_Name                  
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)

            ''' >>>>>>>>> Scenario_Details '''
            str_Section = obj_Config.static_str_Section__Batch_Setting_Details
            
            str_Option = obj_Config.static_str_Option__Batch_Setting_Details__Scenario_Name
            value_Option = str_Scenario_Name                  
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)

            str_Option = obj_Config.static_str_Option__Batch_Setting_Details__Scenario_UID
            value_Option = str_Datetime_Stamp_New_Scenario_UID                  
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)

            ''' >>>>>>>>> Batch_Settings '''
            str_Section = obj_Config.static_str_Section__Batch_Setting_Batch_Scenario
            
            str_Option = obj_Config.static_str_Option__Batch_Setting_Scenario_File
            value_Option = str_Config_File_Relative_Path_And_Name__Batch_Scenario                  
            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)

            '''
            ---------------------------------------------------
            Remove unwanted SECTIONS & OPTIONS from config
            ---------------------------------------------------
            '''
            
            ''' >>>>>>>>> Batch_Setting_Last_Batch_Scenario_Run_Details '''
            str_Section = obj_Config.static_str_Section__Batch_Setting_Last_Batch_Scenario_Run_Details
            obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)
            
            ''' >>>>>>>>> Batch_Setting_Last_Sampling_Strategy_Run_Details '''
            str_Section = obj_Config.static_str_Section__Batch_Setting_Last_Sampling_Strategy_Run_Details
            obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)

            '''
            -------------------------------------
            Write cloned config file
            -------------------------------------
            '''
            str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name__Batch_Settings)
            bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, str_Config_File_FULL_Path_And_Name)
        pass            

        '''
        ------------------------------------------
        Read Sampling Strategy Files to clone
        ------------------------------------------
        '''
        if bool_Success:
            bool_Success = False
            if len(list_Sampling_Strategy_Files) > 0:
                for str_Sampling_Strategy_File_Relative_Path_And_Name__To_Clone in list_Sampling_Strategy_Files:
                    ''' Read the Sampling Strategy file '''
                    obj_Config = object_SSConfigSamplingStrategy()
                    str_File_Relative_Path_And_Name__To_Clone = str_Sampling_Strategy_File_Relative_Path_And_Name__To_Clone
                    obj_Config = self.func_Read_Config_File(str_File_Relative_Path_And_Name__To_Clone, obj_Config, True)
                    config_parser_Config = obj_Config.config_parser_Config
                    ''' Check if successfull '''
                    bool_Success = False
                    if config_parser_Config != None:
                        bool_Success = True
                    pass 
                                
                    if bool_Success:
                        bool_Success = False

                        ''' Get UID for the new Sampling Strategy '''
                        ''' Ensure UID is different with timer '''
                        time__sleep(1) 
                        str_Datetime_Stamp_New_Sampling_Strategy_UID = self.func_Get_New_PROJECT_UID()
                        
                        str_Batch_Scenario_Relative_Path, _ = os__path.split(str_Config_File_Relative_Path_And_Name__Batch_Scenario)
                        str_Sampling_Strategy_Relative_Path = os__path.join(str_Batch_Scenario_Relative_Path, self.str_Settings_Run_Sampling_Strategy_Folder_Prefix__Default_Value + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID)
                        str_Sampling_Strategy_File_Name = globalsSSFE.App_File.static_str__App_File_Prefix__Sampling_Strategy + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID + os__extsep + self.str_Settings_Run_File_Extension_Config_File__Default_Value
                        str_Config_File_Relative_Path_And_Name__Sampling_Strategy = os__path.join(str_Sampling_Strategy_Relative_Path, str_Sampling_Strategy_File_Name)
                        
                        '''
                        ------------------------------------------
                        Clone new Batch Scenario File
                        ------------------------------------------
                        '''
                            
                        ''' >>>>>>>>> Project_Details '''
                        str_Section = obj_Config.static_str_Section__Scenario_Project_Details
                        
                        str_Option = obj_Config.static_str_Option__Scenario_Project_Name
                        value_Option = str_Project_Name                  
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
            
                        str_Option = obj_Config.static_str_Option__Scenario_Project_UID
                        value_Option = str_Project_UID                  
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
            
                        str_Option = obj_Config.static_str_Option__Scenario_Project_Species_Name
                        value_Option = str_Project_Species_Name                  
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
            
                        ''' >>>>>>>>> Scenario_Details '''
                        str_Section = obj_Config.static_str_Section__Scenario_Details
                        
                        str_Option = obj_Config.static_str_Option__Scenario_Name
                        value_Option = str_Scenario_Name                  
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
            
                        str_Option = obj_Config.static_str_Option__Scenario_UID
                        value_Option = str_Datetime_Stamp_New_Scenario_UID                  
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)

                        ''' >>>>>>>>> Batch_Scenario '''
                        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Batch_Scenario
                        
                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Scenario_File
                        value_Option = str_Config_File_Relative_Path_And_Name__Batch_Scenario                  
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
                        
                        ''' >>>>>>>>> Sampling_Strategy_Details '''
                        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Details
                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Name
                        value_Option = globalsSSFE.Name.static_str__Name__Sampling_Strategy + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
             
                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_UID
                        value_Option = str_Datetime_Stamp_New_Sampling_Strategy_UID                  
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
            
            
                        ''' >>>>>>>>> Sampling_Strategy_Run_Details '''
                        str_Scenario_path = self.str_Settings_Run_Batch_Scenario_Folder_Prefix__Default_Value + '_' + str(self.int_Batch_Scenario_UID__Current)
                        str_Sampling_Strategy_Run_Simulation_Output_Base_Path = os__path.join(self.str_BackEnd_Working_Base_Path, str_Scenario_path)

                        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Run_Details

                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Ne_Estimator_External_Process_Version
                        value_Option = self.str_Sampling_Strategy_Run_Ne_Estimator_External_Process_Version
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
                                                        
                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Simulation_Working_Base_Path
                        value_Option = self.str_BackEnd_Working_Base_Path                  
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
                        
                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_Simulation_Output_Base_Path
                        value_Option = str_Scenario_Run_Simulation_Output_Base_Path                  
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
        
                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds
                        value_Option = self.int_Sampling_Strategy_Run_LDNe_External_Process_Run_Time_Max_Seconds
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
                        
                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count
                        value_Option = self.int_Sampling_Strategy_Run_LDNe_External_Process_Repeat_FAILED_Max_Count
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
            
                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed
                        value_Option = self.int_Sampling_Strategy_Run_LDNe_External_Process_Number_Of_Concurrent_Processes_Allowed
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
            
                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed
                        value_Option = self.int_Sampling_Strategy_Run_LDNe_External_Process_Zombie_Found_Serially_Count_Allowed
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
   
                        str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS
                        value_Option = str(self.dict_Sampling_Strategy_Run_LDNe_Accuracy_Line_Sampling_Plan_Dict__PLAN_CODE__REPS).replace('{','').replace('}','').replace("'", "").replace(' ', '')
                        config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
                        
                        if self.dict_Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS != {}:
                            str_Option = obj_Config.static_str_Option__Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS
                            value_Option = str(self.dict_Sampling_Strategy_Run_LDNe_Other_Sampling_Plans_CSV_Dict__PLAN_CODE__REPS).replace('{','').replace('}','').replace("'", "").replace(' ', '')
                            config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(config_parser_Config, str_Section, str_Option, value_Option)
                        pass
                    
                        '''
                        ---------------------------------------------------
                        Remove unwanted SECTIONS & OPTIONS from config
                        ---------------------------------------------------
                        '''
                        
                        ''' >>>>>>>>> Sampling_Strategy_Last_Run_Details '''
                        str_Section = obj_Config.static_str_Section__Sampling_Strategy_Last_Run_Details
                        obj_Config.func_Remove_SECTION_From_Config_File_Section(obj_Config.config_parser_Config, str_Section)

                        '''
                        -------------------------------------
                        Write cloned SAMPLIING_STRATEGY config file
                        -------------------------------------
                        '''
                        str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name__Sampling_Strategy)
                        bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, str_Config_File_FULL_Path_And_Name)
                        #bool_Success = obj_Config.func_Write_Config_File(config_parser_Config, str_Config_File_Path_And_Name__Sampling_Strategy)
                            

                        ''' Update the Batch Scenario with the list of Sampling Strategy files '''
                        '''
                        ------------------------------------------
                        Add SAMPLING_STRATEGIES to BATCH_SCENARIO file 
                        ------------------------------------------
                        '''  
                        str_Section = obj_Config_BS.static_str_Section__Scenario_Sampling_Strategy_File_List
                        str_Option = obj_Config_BS.static_str_Option__Scenario_Sampling_Strategy_File + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID
                        value_Option = str_Config_File_Relative_Path_And_Name__Sampling_Strategy

                        obj_Config_BS.config_parser_Config = obj_Config_BS.func_Set_Values_in_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section, str_Option, value_Option)                 

                        str_Section = obj_Config_BS.static_str_Section__Scenario_Sampling_Strategy_Name_List
                        str_Option = obj_Config_BS.static_str_Option__Scenario_Sampling_Strategy_Name + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID
                        value_Option = globalsSSFE.Name.static_str__Name__Sampling_Strategy + '_' + str_Datetime_Stamp_New_Sampling_Strategy_UID      

                        obj_Config_BS.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(obj_Config_BS.config_parser_Config, str_Section, str_Option, value_Option)                 
                    
                    pass  
                pass
            pass
        
            '''
            -------------------------------------
            Write cloned BATCH_SCENARIO config file
            -------------------------------------
            '''
            str_Config_File_FULL_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Relative_Path_And_Name__Batch_Scenario)
            bool_Success = obj_Config_BS.func_Write_Config_File(obj_Config_BS.config_parser_Config, str_Config_File_FULL_Path_And_Name)       
        pass
      
        return bool_Success

        
    def func_Update_Config_File(self, str_Config_File_Path_And_Name, obj_Config, str_Section, str_Option, value_Option, bool_Config_File_And_Path_Is_Relative=False):        

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False

        if bool_Config_File_And_Path_Is_Relative:
            str_Config_File_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Path_And_Name)
        pass
            
        if obj_Config == None:
            str_Message_Text = 'obj_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False, obj_Config 
        pass
            
        if obj_Config.config_parser_Config == None:
            str_Message_Text = 'obj_Config.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False, obj_Config 
        pass
        
        '''
        ------------------------------------------
        UPDATE Config file
        ------------------------------------------
        '''       
        obj_Config.config_parser_Config = obj_Config.func_Set_Values_in_Config_File_Section(obj_Config.config_parser_Config, str_Section, str_Option, value_Option)
        
        bool_Success = obj_Config.func_Write_Config_File(obj_Config.config_parser_Config, str_Config_File_Path_And_Name)

        return bool_Success, obj_Config


    def func_Get_Current_Config_Value(self, obj_Config, str_Section, str_Option, value_Type):
        
        #obj_Config = self.obj_Config_Settings
        
        if obj_Config != None:
            config_parser_Config = obj_Config.config_parser_Config
        
            if config_parser_Config != None:
                value_Option = obj_Config.func_Read_Config_File_OPTION(str_Section, str_Option, value_Type)
            else:
                str_Message_Text = 'config_parser_Config = None'
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            pass
        else:
            str_Message_Text = 'obj_Config != None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
        pass
    
        return value_Option
    
    def func_Get_Current_Config_Name__PROJECT(self):
        
        if self.obj_Config_Project.config_parser_Config != None:
            str_Section = self.obj_Config_Project.static_str_Section__Project_Details
            str_Option = self.obj_Config_Project.static_str_Option__Project_Name
            str_Project_Name = self.obj_Config_Project.func_Read_Config_File_OPTION(str_Section, str_Option, value_Type='')
        pass
        
        return str_Project_Name

    def func_Get_Current_Config_Name__BATCH_SCENARIO(self):
        
        if self.obj_Config_Batch_Scenario.config_parser_Config != None:
            str_Section = self.obj_Config_Batch_Scenario.static_str_Section__Scenario_Details
            str_Option = self.obj_Config_Batch_Scenario.static_str_Option__Scenario_Name
            str_Scenario_Name = self.obj_Config_Batch_Scenario.func_Read_Config_File_OPTION(str_Section, str_Option, value_Type='')
        pass
        
        return str_Scenario_Name

    def func_Get_Config_File_List_Of_PROJECT_from_PROJECTS(self, obj_Config_Projects):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = obj_Config_Projects
        
        if obj_Config == None:
            str_Message_Text = 'self.obj_Config_Project = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False  
        pass         
    
        config_parser_Config = obj_Config.config_parser_Config
    
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Project.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass    

        ''' <<<<<<< SECTION: Project_File_List '''
        list_Files = []
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Project_File_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' read all items under this SECTION '''
            dict_Option = OrderedDict(obj_Config.config_parser_Config.items(str_Section))
            list_Files = [value_str_File for key_Option, value_str_File in dict_Option.items()]
        pass    

        ''' <<<<<<< SECTION: Project_Name_List '''
        list_Names = []
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Project_Name_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' read all items under this SECTION '''
            dict_Option = OrderedDict(obj_Config.config_parser_Config.items(str_Section))
            list_Names = [value_str_Name for key_Option, value_str_Name in dict_Option.items()]
        pass    
        
        return list_Files, list_Names

    def func_Get_Config_File_List_Of_SCENARIOS_from_PROJECT(self, obj_Config_Project):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = obj_Config_Project
        
        if obj_Config == None:
            str_Message_Text = 'obj_Config_Project = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False  
        pass         
    
        config_parser_Config = obj_Config.config_parser_Config
    
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Project.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass    

        ''' <<<<<<< SECTION: Scenario_File_List '''
        list_Files = []
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Scenario_File_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' read all items under this SECTION '''
            dict_Option = OrderedDict(obj_Config.config_parser_Config.items(str_Section))
            list_Files = [value_str_File for key_Option, value_str_File in dict_Option.items()]
        pass    

        ''' <<<<<<< SECTION: Scenario_Name_List '''
        list_Names = []
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Scenario_Name_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' read all items under this SECTION '''
            dict_Option = OrderedDict(obj_Config.config_parser_Config.items(str_Section))
            list_Names = [value_str_Name for key_Option, value_str_Name in dict_Option.items()]
        pass    
        
        return list_Files, list_Names

    def func_Get_Config_File_List_Of_SAMPLING_STRATEGIES_from_BATCH_SCENARIO(self, obj_Config_Batch_Scenario):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        obj_Config = obj_Config_Batch_Scenario
        
        if obj_Config == None:
            str_Message_Text = 'obj_Config_Batch_Scenario = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False  
        pass         
    
        config_parser_Config = obj_Config.config_parser_Config
    
        if config_parser_Config == None:
            str_Message_Text = 'obj_Config_Batch_Scenario.config_parser_Config = None'
            int_Stack_Trace_Level = 2
            self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            return False
        pass    

        ''' <<<<<<< SECTION: Scenario_Sampling_Strategy_File_List '''
        list_Files = []
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Scenario_Sampling_Strategy_File_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' read all items under this SECTION '''
            dict_Option = OrderedDict(obj_Config.config_parser_Config.items(str_Section))
            list_Files = [value_str_File for key_Option, value_str_File in dict_Option.items()]
        pass    

        ''' <<<<<<< SECTION: Scenario_Sampling_Strategy_File_List '''
        list_Names = []
        ''' Specify SECTION to get '''
        str_Section = obj_Config.static_str_Section__Scenario_Sampling_Strategy_Name_List
        ''' Check if SECTION exists in config file '''
        bool_Section_Exists = obj_Config.func_Check_If_Config_File_SECTION_Exists(config_parser_Config, str_Section)
        '''Its OK if the SECTION does not exist, however if the SECTION exists, read the option '''
        if bool_Section_Exists:
            ''' read all items under this SECTION '''
            dict_Option = OrderedDict(obj_Config.config_parser_Config.items(str_Section))
            list_Names = [value_str_Name for key_Option, value_str_Name in dict_Option.items()]
        pass    
        
        return list_Files, list_Names


    def func_Read_Config_File(self, str_Config_File_Path_And_Name, obj_Config, bool_Config_File_And_Path_Is_Relative=False):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        if bool_Config_File_And_Path_Is_Relative:
            str_Config_File_Path_And_Name = os__path.join(self.str_Application_Projects_Path, str_Config_File_Path_And_Name)
        pass

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, 'Read file: ' + str(str_Config_File_Path_And_Name))
        #DEBUG_OFF
                
        with SSConfigOperation(None) as obj_ConfigOp:
            with FileHandler() as obj_FileHandler:
                if obj_FileHandler.fileExists(str_Config_File_Path_And_Name):
                    obj_Config = obj_ConfigOp.func_Read_Any_Config_File(str_Config_File_Path_And_Name, obj_Config)
                    if obj_Config.config_parser_Config == None:
                        str_Message_Text = 'obj_Config.config_parser_Config = None'
                        int_Stack_Trace_Level = 2
                        self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                    pass
                else:
                    str_Message_Text = 'Non-existant config file: ' + str_Config_File_Path_And_Name
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
                pass
            pass
        pass
        return obj_Config

    def func_Write_Shell_Script_File(self, str_File_Path_And_Name, str_Text):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        fileHandle = None
        
        with FileHandler() as obj_FileHandler:
            fileHandle = obj_FileHandler.fileOpen(str_File_Path_And_Name, 'write')
            
            if fileHandle != None:
                bool_Success = True
                
                fileHandle.write(str_Text)
                fileHandle.close()
            else:
                str_Message_Text = 'File could not be create or opened for write: ' + str_File_Path_And_Name
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            pass               
        pass

        if bool_Success:
            ''' Double check file is in place '''
            if obj_FileHandler.fileExists(str_File_Path_And_Name):
                bool_Success = True
            else:
                str_Message_Text = 'File does not exist: ' + str_File_Path_And_Name
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text)
            pass
        pass
    
        return bool_Success

    def func_Create_Backend_Local_Copy_Of_Required_Files(self, str_Path__Origin, str_Path__Destination, str_File_Name__Copy_Pattern, bool_Delete_Files=False):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
                
        bool_Success = False
        
        ''' Copy files to backend working folder '''
        with FileHandler() as obj_FileOp:
        
            ''' Check that ORIGIN path exists '''
            bool_Success = obj_FileOp.method_Path_Exists(str_Path__Origin)
            if not bool_Success:
                str_Message_Text = 'Origin copy path does not exist: ' + str_Path__Origin + '; str_Path__Destination: ' + str_Path__Destination + '; str_File_Name__Copy_Pattern: ' + str_File_Name__Copy_Pattern
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                return False                
            pass
        
            ''' If so, Check if destination exists, and if not create it ''' 
            bool_Success = obj_FileOp.method_Path_Exists(str_Path__Destination)
            if not bool_Success:       
                bool_Success = obj_FileOp.method_Create_Path(str_Path__Destination)
                if not bool_Success:
                    str_Message_Text = 'Destination copy path does not exist and could not be created: ' + str_Path__Origin + '; str_Path__Destination: ' + str_Path__Destination + '; str_File_Name__Copy_Pattern: ' + str_File_Name__Copy_Pattern
                    int_Stack_Trace_Level = 2
                    self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                    return False      
                pass
            else:
                ''' Path exists, exiting files will be overwritten'''
                if bool_Delete_Files:
                    str_File_Delete_Pattern = os__path.join(str_Path__Destination, str_File_Name__Copy_Pattern)
                    bool_Success = obj_FileOp.methodDelete_MultipleFilesByWildcard(str_File_Delete_Pattern)
                    
                    if not bool_Success:
                        str_Message_Text = 'File wildcard delete failed: ' + str_File_Delete_Pattern
                        int_Stack_Trace_Level = 2
                        self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                        return False  
                    pass
                pass
            pass
        
            ''' Copy files '''
            if bool_Success:
                bool_Success = False
                bool_Success = obj_FileOp.method_Copy_Files_By_Pattern(str_Path__Origin, str_Path__Destination, str_File_Name__Copy_Pattern)
            else:
                str_Message_Text = 'File copy failed: ' + str_Path__Origin + '; str_Path__Destination: ' + str_Path__Destination + '; str_File_Name__Copy_Pattern: ' + str_File_Name__Copy_Pattern
                int_Stack_Trace_Level = 2
                self.func_Error_Handler__Caught_Exceptions(int_Stack_Trace_Level, str_Message_Text) 
                return False                 
            pass
        pass

        return bool_Success                  


    def func_Zip(self, src, dst):

        #DEBUG_ON
        self.func_Debug_Logging(False, 2, '')
        #DEBUG_OFF
        
        zf = zipfile.ZipFile("%s.zip" % (dst), "w", zipfile.ZIP_DEFLATED)
        abs_src = os.path.abspath(src)
        for dirname, subdirs, files in os.walk(src):
            for filename in files:
                absname = os.path.abspath(os.path.join(dirname, filename))
                arcname = absname[len(abs_src) + 1:]
                print('zipping %s as %s' % (os.path.join(dirname, filename),
                                            arcname))
                zf.write(absname, arcname)
        zf.close()
        
        print ('finished')
        
        return True    

    '''
    -------------------------------------------------------------------------------
        Messages & Logging
    -------------------------------------------------------------------------------
    '''           

    def func_Debug_Logging(self, bool_Events, int_Stack_Trace_Level, str_Message_Text):

        #if self.bool_Settings_Run_FrontEnd_DEBUG_Logging__Default_Value:
        if self.bool_App_Arg_Debug_Logging:
            with dcb_Debug_Location() as obj_DebugLoc:
                str_Message_Location = obj_DebugLoc.Get_Debug_Location(bool_Short=True, int_Stack_Trace_Level_Override=int_Stack_Trace_Level)
            pass
#             str_Message = str_Message_Location + ' ; ' + str_Message_Text
#             if bool_Events:
#                 sys.stdout.flush()
#                 self.obj_Log_Debug_Events.debug(str_Message)
#             else:
#                 sys.stdout.flush()
#                 self.obj_Log_Debug_Display.debug(str_Message)
#             pass
            if bool_Events:
                ''' So events can be filtered out of the log '''
                str_Message = 'EVENT ' + str_Message_Location + ' ; ' + str_Message_Text
            else:
                str_Message = str_Message_Location + ' ; ' + str_Message_Text

            pass
        
            sys.stdout.flush()
            self.obj_Log_Debug_Display.debug(str_Message)        
        pass
    
        return True
    
    def func_Error_Handler__Caught_Exceptions(self, int_Stack_Trace_Level, str_Message_Text, bool_Log_Trace=True, int_Display_Trace_Levels=0):

        ''' Cleanup '''
        if self.t1 != None:
            self.t1.cancel()
            self.int_Run_Status_Error_Flag__Current == globalsDCBGen.Run_Status.static_str_Run_Status__FAILED_CAUGHT            
        pass
        
        with dcb_Debug_Location() as obj_DebugLoc:
            str_Message_Location = obj_DebugLoc.Get_Debug_Location(bool_Short=True, int_Stack_Trace_Level_Override=int_Stack_Trace_Level)
        pass
        str_Message_Prefix = '!!UNEXP_ERR!!'
        str_Message = str_Message_Location + ' ; ' + str_Message_Prefix + ' ; ' + str_Message_Text
        sys.stdout.flush()
        if bool_Log_Trace:
            stack = traceback.extract_stack()
            stack_List = traceback.format_list(stack)
            if int_Display_Trace_Levels == 0:
                ''' Display all '''
                pass
            else:
                stack = stack[:int_Display_Trace_Levels]
            pass
            str_Stack = '\n'.join(traceback.format_list(stack))
            self.obj_Log_Default_Display.error(str_Message + '\n' + str_Stack)
            if self.bool_App_Arg_Debug_Logging:
                self.obj_Log_Debug_Display.error(str_Message + '\n' + str_Stack)
            pass
        else:
            self.obj_Log_Default_Display.error(str_Message)
            if self.bool_App_Arg_Debug_Logging:
                self.obj_Log_Debug_Display.error(str_Message)
            pass            
        pass
        
        ''' Format into a message '''    
        str_MessageBox_Text = 'Snap! An unexpected error has been encountered:' + '\n\n' + str_Message_Text + '\n\n ERROR' + str_Message_Location + '\n\n' + "Sorry but the program will have to be terminated."
        ''' Display the MessageBox '''
        QtGui.QMessageBox.critical(self, 'Unexpected Error', str_MessageBox_Text, QtGui.QMessageBox.Abort, QtGui.QMessageBox.Abort)

        ''' End the application as gracefully as possible'''
        self.close()
        QtGui.QApplication.quit()
        
        ''' Close the loggers to prevent the file handles being left open '''
        if self.obj_Log_Default_Display is not None:
            self.obj_Log_Default_Display.handlers = []
        pass      
        if self.obj_Log_Debug_Display is not None:
            self.obj_Log_Debug_Display.handlers = []
        pass 
            
        sys.exit()
        return True
    
    def func_Error_Handler__UNCaught_Exceptions(self, exc_type, exc_value, exc_traceback):

        ''' Cleanup '''
        if self.t1 != None:
            self.t1.cancel()
            self.int_Run_Status_Error_Flag__Current == globalsDCBGen.Run_Status.static_str_Run_Status__FAILED_UNCAUGHT
        pass

        str_Exec_Type = str(exc_type)
        str_Exec_Value = str(exc_value)
        str_Message_Prefix = '!!UNHAN_ERR!!'
        str_Message_Text = 'Uncaught exception'
        str_Message__Log = str_Message_Prefix + ' ; ' + str_Message_Text
        
        ''' Get the very last frame which contains the error '''
        traceback_Obj = exc_traceback
        if traceback_Obj != None:
            while True:
                if traceback_Obj.tb_next == None:
                    break
                else:
                    traceback_Obj = traceback_Obj.tb_next
                pass
            pass

            ''' Get the error frame '''
            frame = traceback_Obj.tb_frame
    
            ''' Get the error info '''
            str_Origin_LineNo = str(frame.f_lineno)
            str_Origin_Func = str(frame.f_code.co_name)
            str_Origin_Class_PathAndFileName = str(frame.f_code.co_filename)
            str_Origin_Class_Path, str_Origin_Class_FileName = os__path.split(str_Origin_Class_PathAndFileName)
            str_Location = str_Origin_Class_FileName + '.' + str_Origin_Func + '; ' + 'line: ' + str_Origin_LineNo
            
            str_Message__MsgBox = str_Message_Prefix + ' ; ' + str_Message_Text + '\n\nError: ' + str_Exec_Value + '\nLine:\t' + str_Origin_LineNo + '\nType:\t' + str_Exec_Type + '\nFunc:\t' + str_Origin_Func + '\nFile:\t' +  str_Origin_Class_FileName 
    
            ''' Format into a message '''
            str_MessageBox_Text = 'Bugger! An uncaught exception error has occurred:' + '\n\n' + str_Message__MsgBox + '\n\n' + "Sorry but the program will have to be terminated."
            ''' Display the MessageBox '''
            QtGui.QMessageBox.critical(self, str_Message_Text, str_MessageBox_Text, QtGui.QMessageBox.Abort, QtGui.QMessageBox.Abort)
        else:
             
            str_Message__MsgBox = str_Message_Prefix + ' ; ' + str_Message_Text + '\nType:\t' + str_Exec_Type + '\n\nError: ' + str_Exec_Value
            
            ''' Format into a message '''
            str_MessageBox_Text = 'Bugger! An uncaught exception error has occurred:' + '\n\n' + str_Message__MsgBox + '\n\n' + "Sorry but the program will have to be terminated."
            ''' Display the MessageBox '''
            QtGui.QMessageBox.critical(self, str_Message_Text, str_MessageBox_Text, QtGui.QMessageBox.Abort, QtGui.QMessageBox.Abort)
        pass

        sys.stdout.flush()
        self.obj_Log_Default_Display.error(str_Message__Log, exc_info=(exc_type, exc_value, exc_traceback))
        if self.bool_App_Arg_Debug_Logging:
            self.obj_Log_Debug_Display.error(str_Message__Log, exc_info=(exc_type, exc_value, exc_traceback))
        pass     
        
        ''' End the application as gracefully as possible'''
        self.close()
        QtGui.QApplication.quit()
        
        ''' Close the loggers to prevent the file handles being left open '''
        if self.obj_Log_Default_Display is not None:
            self.obj_Log_Default_Display.handlers = []
        pass      
        if self.obj_Log_Debug_Display is not None:
            self.obj_Log_Debug_Display.handlers = []
        pass 
            
        sys.exit()
        
        return True

    '''
    -------------------------------------------------------------------------------
        Dialogs
    -------------------------------------------------------------------------------
    '''    
    def func_Open_File_Dialog(self, str_Title, str_Start_Path, str_File_Type_Hint):
        
        ''' File Open Dialog '''
        str_Path_And_File_Name = QtGui.QFileDialog.getOpenFileName(self, str_Title, str_Start_Path, str_File_Type_Hint)

        ''' Alternative dialog '''
        #self.fileDialog = QtGui.QFileDialog(self)
        #self.fileDialog.show()   
             
        return str_Path_And_File_Name

    def func_Select_Path_Dialog(self, str_Title, str_Start_Path):
        
        bool_Cancelled = False
        str_Path = ''
        
        ''' File Open Dialog '''
        str_Path = QtGui.QFileDialog.getExistingDirectory(self, str_Title, str_Start_Path, QtGui.QFileDialog.ShowDirsOnly)

        if not str_Path:
            bool_Cancelled = True
            str_Path = str_Start_Path
        pass
             
        return bool_Cancelled, str_Path

    '''
    --------------------------------------------------------------------------------------------------------
    # <<<<<<<<<<<<<<<<<< CLASS FINALIZATION
    --------------------------------------------------------------------------------------------------------
    '''       
    def __exit__(self):
        
        pass
        